name: Generate & Publish Combined Code File

on:
  # æ‰‹å‹•å®Ÿè¡Œã‚’å¯èƒ½ã«ã™ã‚‹
  workflow_dispatch:

# ğŸ’¡ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å…¨ä½“ã§ä½¿ç”¨ã™ã‚‹ç’°å¢ƒå¤‰æ•°
env:
  # å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«å
  OUTPUT_FILENAME: combined.txt
  # å‡ºåŠ›å…ˆãƒ–ãƒ©ãƒ³ãƒå
  TARGET_BRANCH: combine-code
  # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ‹¡å¼µå­
  TARGET_EXTENSIONS: .cpp,.h,.hpp,.vcxproj,.vcxproj.filters
  # é™¤å¤–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
  EXCLUDE_DIRS: Resources,Novice,Adapter,DirectXTex,imgui

jobs:
  publish:
    runs-on: ubuntu-latest
    
    # ğŸ’¡ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã¸ã®ãƒ—ãƒƒã‚·ãƒ¥ã«å¿…è¦ãªæ›¸ãè¾¼ã¿æ¨©é™ã‚’ä»˜ä¸
    permissions:
      contents: write 

    steps:
      - name: Checkout master (Shallow depth)
        # çµåˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§shallow cloneï¼‰
        uses: actions/checkout@v4 

      # 1. ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰çµåˆãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆ
      - name: Generate Code Summary
        id: generate
        shell: python
        run: |
          import os
          import hashlib
          
          # --- ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ã®è¨­å®šèª­ã¿è¾¼ã¿ ---
          target_extensions = tuple(os.environ['TARGET_EXTENSIONS'].split(','))
          exclude_dirs = set(os.environ['EXCLUDE_DIRS'].split(','))
          output_file = os.environ['OUTPUT_FILENAME']
          root_dir = '.'
          # å›ºå®šã§é™¤å¤–ã™ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’è¿½åŠ 
          exclude_dirs.update({'.git', '.github', '.vs', 'build', 'out'})
          # -----------------------------------

          def is_excluded(dir_name):
              return dir_name in exclude_dirs

          # --- ãƒ•ã‚¡ã‚¤ãƒ«ãƒ„ãƒªãƒ¼ç”Ÿæˆé–¢æ•° ---
          def generate_tree(dir_path, prefix=''):
              tree = []
              # ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®é …ç›®ã‚’æº–å‚™
              items = sorted([f for f in os.listdir(dir_path) if f != output_file and f not in exclude_dirs])

              pointers = [('â”œâ”€â”€ ', 'â””â”€â”€ ') if i != len(items) - 1 else ('â””â”€â”€ ', '    ') for i in range(len(items))]

              for i, item in enumerate(items):
                  full_path = os.path.join(dir_path, item)
                  pointer = pointers[i]
                  
                  if os.path.isdir(full_path):
                      # é™¤å¤–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¯ãƒ„ãƒªãƒ¼ã«ã‚‚å«ã‚ãªã„
                      if not is_excluded(item):
                          tree.append(f"{prefix}{pointer[0]}{item}/")
                          tree.extend(generate_tree(full_path, prefix + pointer[1]))
                  else:
                      # å¯¾è±¡ã®æ‹¡å¼µå­ã‚’æŒã¤ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ãƒ„ãƒªãƒ¼ã«å«ã‚ã‚‹
                      if item.endswith(target_extensions):
                          tree.append(f"{prefix}{pointer[0]}{item}")
              return tree

          # --- ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã®å‡¦ç†é–¢æ•° ---
          def process_directory(current_path, outfile):
              try:
                  items = sorted(os.listdir(current_path))
              except OSError:
                  return

              for item in items:
                  full_path = os.path.join(current_path, item)
                  
                  if os.path.isdir(full_path):
                      if not is_excluded(item):
                          process_directory(full_path, outfile)
                  else:
                      if item.endswith(target_extensions):
                          rel_path = os.path.relpath(full_path, root_dir)
                          
                          outfile.write(f"\n{'='*60}\n")
                          outfile.write(f"File Path: {rel_path}\n")
                          outfile.write(f"{'='*60}\n")
                          
                          try:
                              with open(full_path, 'r', encoding='utf-8', errors='replace') as f:
                                  outfile.write(f.read())
                          except Exception as e:
                              outfile.write(f"[Error reading file: {e}]\n")
                          
                          outfile.write("\n")

          # --- ãƒ¡ã‚¤ãƒ³å‡¦ç† ---
          print(f"Generating {output_file}...")
          with open(output_file, 'w', encoding='utf-8') as outfile:
              
              # 1. ãƒ•ã‚¡ã‚¤ãƒ«ãƒ„ãƒªãƒ¼ã‚’æ›¸ãè¾¼ã‚€
              outfile.write("### ğŸŒ³ Codebase File Tree (Excluding ignored directories)\n\n")
              
              tree_output = generate_tree(root_dir)
              if tree_output:
                  outfile.write("\n".join(tree_output))
              else:
                  outfile.write("No files matching the target extensions found.\n")
              
              outfile.write("\n" + "="*80 + "\n\n")

              # 2. ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’çµåˆã™ã‚‹
              process_directory(root_dir, outfile)
          print("Done.")

          # ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å‡ºåŠ›ã—ã€æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã§åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹
          with open(output_file, 'rb') as f:
              file_hash = hashlib.sha256(f.read()).hexdigest()
          
          print(f"::set-output name=file_hash::{file_hash}")
          print(f"::set-output name=output_file::{output_file}")


      # 1.5. æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ãƒã‚§ãƒƒã‚¯ã¨ã‚¹ã‚­ãƒƒãƒ—
      - name: Check for Content Changes and Skip Push
        id: check_changes
        # ä¾å­˜é–¢ä¿‚ã¨ã—ã¦ sha256sum ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€Linuxç’°å¢ƒã§å®Ÿè¡Œ
        run: |
          OUTPUT_FILENAME="${{ steps.generate.outputs.output_file }}"
          CURRENT_HASH="${{ steps.generate.outputs.file_hash }}"
          TARGET_BRANCH="${{ env.TARGET_BRANCH }}"
          
          # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ã€å¿…ãšã‚³ãƒŸãƒƒãƒˆã—ã€ã‚¹ã‚­ãƒƒãƒ—ã—ãªã„
          if ! git ls-remote --heads origin "$TARGET_BRANCH" | grep "$TARGET_BRANCH"; then
            echo "Target branch does not exist. Must commit."
            echo "::set-output name=skip_commit::false"
            exit 0
          fi
          
          # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã‚’ãƒ•ã‚§ãƒƒãƒ
          git fetch origin "$TARGET_BRANCH"
          
          # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã®æœ€æ–°ã‚³ãƒŸãƒƒãƒˆã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’å–å¾—
          # ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„å ´åˆã¯ç©ºã®ãƒãƒƒã‚·ãƒ¥å€¤ã¨ãªã‚‹ (|| echo "")
          EXISTING_HASH=$(git show origin/"$TARGET_BRANCH":"$OUTPUT_FILENAME" | sha256sum | awk '{print $1}' || echo "")
          
          echo "Current file hash: $CURRENT_HASH"
          echo "Existing file hash: $EXISTING_HASH"
          
          if [ "$CURRENT_HASH" = "$EXISTING_HASH" ]; then
            echo "âœ… Content unchanged. Skipping commit and push."
            echo "::set-output name=skip_commit::true"
          else
            echo "ğŸ”„ Content changed. Proceeding with commit."
            echo "::set-output name=skip_commit::false"
          fi

      # 2. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¨ã‚³ãƒŸãƒƒãƒˆ
      # ğŸ’¡ å¤‰æ›´ãŒãªã„å ´åˆã¯ã“ã®ã‚¹ãƒ†ãƒƒãƒ—å…¨ä½“ã‚’ã‚¹ã‚­ãƒƒãƒ—
      - name: Setup Target Branch and Commit (Hybrid Logic)
        if: steps.check_changes.outputs.skip_commit == 'false'
        run: |
          TARGET_BRANCH="${{ env.TARGET_BRANCH }}"
          OUTPUT_FILENAME="${{ steps.generate.outputs.output_file }}"
          
          # 1. ç”Ÿæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸€æ™‚çš„ã«ä¿å­˜ (ãƒ–ãƒ©ãƒ³ãƒåˆ‡ã‚Šæ›¿ãˆã«å‚™ãˆã‚‹)
          cp "$OUTPUT_FILENAME" /tmp/"$OUTPUT_FILENAME"
          
          # 2. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯ã¨åˆ‡ã‚Šæ›¿ãˆ
          BRANCH_EXISTS=$(git ls-remote --heads origin "$TARGET_BRANCH" | wc -l)

          if [ "$BRANCH_EXISTS" -ne 0 ]; then
            # --- A. ãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã™ã‚‹å ´åˆ (åŠ¹ç‡çš„ãªæ›´æ–°) ---
            echo "Target branch '$TARGET_BRANCH' exists. Checking out."
            git fetch origin "$TARGET_BRANCH"
            # æ—¢å­˜ãƒ–ãƒ©ãƒ³ãƒã‚’ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆã™ã‚‹å‰ã«ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã—è¡çªå›é¿
            if [ -f "$OUTPUT_FILENAME" ]; then
              rm "$OUTPUT_FILENAME"
            fi
            git checkout "$TARGET_BRANCH"
          else
            # --- B. ãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã—ãªã„å ´åˆ (ã‚¯ãƒªãƒ¼ãƒ³ãªåˆå›ä½œæˆ) ---
            echo "Target branch '$TARGET_BRANCH' does not exist. Creating from initial commit."
            
            # å…¨å±¥æ­´ã‚’å–å¾— (fetch-depth: 0 ç›¸å½“)
            echo "Fetching full history..."
            git fetch --unshallow || git fetch origin master --depth=0
            
            INITIAL_COMMIT_ID=$(git rev-list --max-parents=0 HEAD)
            echo "Initial Commit ID: $INITIAL_COMMIT_ID"
            
            # åˆæœŸã‚³ãƒŸãƒƒãƒˆã‹ã‚‰æ–°ã—ã„ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆã—ã€ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
            git checkout -b "$TARGET_BRANCH" "$INITIAL_COMMIT_ID"
            
            # åˆæœŸã‚³ãƒŸãƒƒãƒˆã‹ã‚‰åˆ†å²ã—ãŸãŸã‚ã€ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            git rm -rf . || true
          fi
          
          # 3. å…±é€šå‡¦ç†: ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒã—ã¦ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°
          cp /tmp/"$OUTPUT_FILENAME" .
          git add "$OUTPUT_FILENAME"
          
          # 4. ã‚³ãƒŸãƒƒãƒˆã¨ãƒ—ãƒƒã‚·ãƒ¥
          git config user.name github-actions[bot]
          git config user.email 41898282+github-actions[bot]@users.noreply.github.com
          
          # masterã®æœ€æ–°SHAã‚’ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å«ã‚ã‚‹
          git commit -m "Auto: Update summary for AI review (${{ github.sha }})"
          
          # å¼·åˆ¶ãƒ—ãƒƒã‚·ãƒ¥ã§ãƒªãƒ¢ãƒ¼ãƒˆãƒ–ãƒ©ãƒ³ãƒã‚’æ›´æ–°/ä½œæˆ
          git push -u origin "$TARGET_BRANCH" --force
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}