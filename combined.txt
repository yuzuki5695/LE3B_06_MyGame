### ðŸŒ³ Codebase File Tree (Excluding ignored directories)

â””â”€â”€ project/
    â”œâ”€â”€ MyGame.vcxproj
    â”œâ”€â”€ MyGame.vcxproj.filters
    â”œâ”€â”€ Tools/
    â””â”€â”€ â””â”€â”€ AssetGenerator/
    â””â”€â”€     â”œâ”€â”€ AssetGenerator.vcxproj
    â””â”€â”€     â”œâ”€â”€ AssetGenerator.vcxproj.filters
    â””â”€â”€     â”œâ”€â”€ engine/
    â””â”€â”€     â””â”€â”€ â”œâ”€â”€ math/
    â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AssetType.h
    â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LoadResourceID.h
    â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ResourceEntry.h
    â””â”€â”€     â””â”€â”€ â””â”€â”€ â””â”€â”€ ResourceID.h
    â””â”€â”€     â””â”€â”€ â””â”€â”€ src/
    â””â”€â”€     â””â”€â”€     â”œâ”€â”€ FileSearcher.cpp
    â””â”€â”€     â””â”€â”€     â”œâ”€â”€ FileSearcher.h
    â””â”€â”€     â””â”€â”€     â”œâ”€â”€ ManifestExporter.cpp
    â””â”€â”€     â””â”€â”€     â”œâ”€â”€ ManifestExporter.h
    â””â”€â”€     â””â”€â”€     â”œâ”€â”€ ResourceCodeGenerator.cpp
    â””â”€â”€     â””â”€â”€     â”œâ”€â”€ ResourceCodeGenerator.h
    â””â”€â”€     â””â”€â”€     â”œâ”€â”€ ResourceIdGenerator.cpp
    â””â”€â”€     â””â”€â”€     â””â”€â”€ ResourceIdGenerator.h
    â””â”€â”€     â””â”€â”€ main.cpp
    â”œâ”€â”€ application/
    â””â”€â”€ â”œâ”€â”€ bullet/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseBullet.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BulletManager.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BulletManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyBullet.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyBullet.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PlayerBullet.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ PlayerBullet.h
    â””â”€â”€ â”œâ”€â”€ camera/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameClearCamera.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameClearCamera.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameOverCamera.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameOverCamera.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GamePlayCamera.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GamePlayCamera.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SceneCameraBase.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TitleCamera.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ TitleCamera.h
    â””â”€â”€ â”œâ”€â”€ character/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseCharacter.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CharacterManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ CharacterManager.h
    â””â”€â”€ â”œâ”€â”€ enemy/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Enemy.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Enemy.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemySpawner.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ EnemySpawner.h
    â””â”€â”€ â”œâ”€â”€ event/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EventManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ EventManager.h
    â””â”€â”€ â”œâ”€â”€ fade/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FadeManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ FadeManager.h
    â””â”€â”€ â”œâ”€â”€ loader/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CharacterLoader.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CharacterLoader.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CurveJsonLoader.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CurveJsonLoader.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyLoader.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ EnemyLoader.h
    â””â”€â”€ â”œâ”€â”€ particle/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseEmitter.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DefaultParticleEmitter.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DefaultParticleEmitter.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FollowEmitter.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameClearparticle.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameClearparticle.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameOverparticle.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameOverparticle.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GamePlayparticle.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GamePlayparticle.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Titleparticle.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Titleparticle.h
    â””â”€â”€ â”œâ”€â”€ pause/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Pausemenu.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Pausemenu.h
    â””â”€â”€ â”œâ”€â”€ player/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Player.h
    â””â”€â”€ â”œâ”€â”€ resource/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FileSearcher.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FileSearcher.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ManifestExporter.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ ManifestExporter.h
    â””â”€â”€ â”œâ”€â”€ scene/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameClearScene.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameClearScene.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameOverScene.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameOverScene.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GamePlayScene.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GamePlayScene.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TitleScene.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ TitleScene.h
    â””â”€â”€ â””â”€â”€ stage/
    â””â”€â”€     â”œâ”€â”€ StageManager.cpp
    â””â”€â”€     â””â”€â”€ StageManager.h
    â”œâ”€â”€ engine/
    â””â”€â”€ â”œâ”€â”€ 2d/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SpriteCommon.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ SpriteCommon.h
    â””â”€â”€ â”œâ”€â”€ 3d/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelCommon.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelCommon.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3d.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3d.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3dCommon.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3dCommon.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Particle/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleCommon.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleCommon.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleEmitter.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleEmitter.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleManager.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleModel.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ ParticleModel.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Skybox.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Skybox.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SkyboxCommon.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ SkyboxCommon.h
    â””â”€â”€ â”œâ”€â”€ audio/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SoundLoader.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SoundLoader.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SoundPlayer.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ SoundPlayer.h
    â””â”€â”€ â”œâ”€â”€ base/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CopylmageCommon.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CopylmageCommon.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DescriptorUtils.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DescriptorUtils.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FPSController.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FPSController.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FenceManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FenceManager.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ShaderCompiler.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ShaderCompiler.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SwapChainManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SwapChainManager.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ViewportManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ ViewportManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Framework.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Framework.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ImGuiManager.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ImGuiManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Utility/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Logger.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Logger.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StringUtility.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ StringUtility.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ViewManager/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DsvManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DsvManager.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RtvManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RtvManager.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SrvManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ SrvManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ WinApp.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ WinApp.h
    â””â”€â”€ â”œâ”€â”€ camera/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraManager.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraTransform.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ CameraTypes.h
    â””â”€â”€ â”œâ”€â”€ io/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Controller.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Controller.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Input.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Input.h
    â””â”€â”€ â”œâ”€â”€ math/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collision/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collision.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collision.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ OBB.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Easing/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Easing.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Easing.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Light/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectionalLight.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PointLight.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ SpotLight.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MathUtil.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MathUtil.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix3x3.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix4x4.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ TransformationMatrix.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MatrixVector.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MatrixVector.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Material.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MaterialDate.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelDate.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Vertex.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleData/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ InstanceData.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Particle.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleGroup.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleRandomData.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RandomParameter.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Velocity.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PrimitiveGenerator.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PrimitiveGenerator.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Quaternion.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ Vector/
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Transform.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Vector2.h
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Vector3.h
    â””â”€â”€ â””â”€â”€     â””â”€â”€ Vector4.h
    â””â”€â”€ â”œâ”€â”€ resource/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ D3DResourceLeakChecker.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ D3DResourceLeakChecker.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelManager.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelManager.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ResourceFactory.cpp
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ResourceFactory.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ResourceObject.h
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TextureManager.cpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€ TextureManager.h
    â””â”€â”€ â””â”€â”€ scene/
    â””â”€â”€     â”œâ”€â”€ AbstractSceneFactory.h
    â””â”€â”€     â”œâ”€â”€ BaseScene.cpp
    â””â”€â”€     â”œâ”€â”€ BaseScene.h
    â””â”€â”€     â”œâ”€â”€ MyGame.cpp
    â””â”€â”€     â”œâ”€â”€ MyGame.h
    â””â”€â”€     â”œâ”€â”€ SceneFactory.cpp
    â””â”€â”€     â”œâ”€â”€ SceneFactory.h
    â””â”€â”€     â”œâ”€â”€ SceneManager.cpp
    â””â”€â”€     â””â”€â”€ SceneManager.h
    â”œâ”€â”€ externals/
    â””â”€â”€ â”œâ”€â”€ assimp/
    â””â”€â”€ â””â”€â”€ â”œâ”€â”€ include/
    â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ assimp/
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ AssertHandler.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Base64.hpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BaseImporter.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Bitmap.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ BlobIOSystem.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ByteSwapper.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ColladaMetaData.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Compiler/
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ poppack1.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ pstdint.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ pushpack1.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ CreateAnimMesh.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ DefaultIOStream.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ DefaultIOSystem.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ DefaultLogger.hpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Exceptional.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Exporter.hpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GenericProperty.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GltfMaterial.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Hash.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ IOStream.hpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ IOStreamBuffer.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ IOSystem.hpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Importer.hpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ LineSplitter.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ LogAux.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ LogStream.hpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Logger.hpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ MathFunctions.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ MemoryIOWrapper.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ NullLogger.hpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ObjMaterial.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ParsingUtils.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Profiler.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ProgressHandler.hpp
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ RemoveComments.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SGSpatialSort.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SceneCombiner.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SkeletonMeshBuilder.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SmallVector.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SmoothingGroups.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SpatialSort.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ StandardShapes.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ StreamReader.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ StreamWriter.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ StringComparison.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ StringUtils.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Subdivision.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TinyFormatter.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Vertex.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ XMLTools.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ XmlParser.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ZipArchiveIOSystem.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ aabb.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ai_assert.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ anim.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ camera.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ cexport.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ cfileio.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ cimport.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ color4.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ commonMetaData.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ config.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ defs.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ fast_atof.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ importerdesc.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ light.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ material.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ matrix3x3.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ matrix4x4.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ mesh.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ metadata.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ pbrmaterial.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ port/
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ AndroidJNI/
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€     â”œâ”€â”€ AndroidJNIIOSystem.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€     â””â”€â”€ BundledAssetIOSystem.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ postprocess.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ qnan.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ quaternion.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ scene.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ texture.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ types.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ vector2.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ vector3.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ version.h
    â””â”€â”€ â””â”€â”€ â””â”€â”€ lib/
    â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Debug/
    â””â”€â”€ â””â”€â”€     â””â”€â”€ Release/
    â””â”€â”€ â””â”€â”€ nlohmann/
    â””â”€â”€     â””â”€â”€ json.hpp
    â””â”€â”€ main.cpp
================================================================================


============================================================
File Path: project/MyGame.vcxproj
============================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4a4dc1f5-7c46-444e-98e4-c58c3fb34d6b}</ProjectGuid>
    <RootNamespace>MyGame</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <IncludePath>$(SolutionDir)DirectXTex;$(SolutionDir)imgui;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <IncludePath>$(SolutionDir)DirectXTex;$(SolutionDir)imgui;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;USE_IMGUI;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\audio;$(ProjectDir)engine\base;$(ProjectDir)engine\io;$(ProjectDir)engine\math;$(ProjectDir)engine\scene;$(ProjectDir)engine\3d\Particle;$(ProjectDir)engine\camera;$(ProjectDir)engine\base\DirectXCommon;$(ProjectDir)engine\base\Utility;$(ProjectDir)engine\base\ViewManager;$(ProjectDir)engine\math\Light;$(ProjectDir)engine\math\Matrix;$(ProjectDir)engine\math\Model;$(ProjectDir)engine\math\Vector;$(ProjectDir)engine\resource;$(ProjectDir)externals\nlohmann;$(ProjectDir)application\scene;$(ProjectDir)application\character;$(ProjectDir)application\player;$(ProjectDir)application\bullet;$(ProjectDir)application\loader;$(ProjectDir)application\camera;$(ProjectDir)application\enemy;$(ProjectDir)externals\assimp\include;$(ProjectDir)engine\math\collision;$(ProjectDir)application\collision;$(ProjectDir)application\fade;$(ProjectDir)application\event;$(ProjectDir)application\stage;$(ProjectDir)engine\math\Easing;$(ProjectDir)application\particle;$(ProjectDir)engine\math\ParticleData;$(ProjectDir)application\resource;$(ProjectDir)application\pause</AdditionalIncludeDirectories>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(ProjectDir)externals\assimp\lib\Debug;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>assimp-vc143-mtd.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <AdditionalOptions>/ignore:4049,4048 %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll"
copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"</Command>
    </PostBuildEvent>
    <PreBuildEvent>
      <Command>"$(SolutionDir)..\generated\outputs\$(Configuration)\AssetGenerator.exe" "$(ProjectDir)."

</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\audio;$(ProjectDir)engine\base;$(ProjectDir)engine\io;$(ProjectDir)engine\math;$(ProjectDir)engine\scene;$(ProjectDir)engine\3d\Particle;$(ProjectDir)engine\camera;$(ProjectDir)engine\base\DirectXCommon;$(ProjectDir)engine\base\Utility;$(ProjectDir)engine\base\ViewManager;$(ProjectDir)engine\math\Light;$(ProjectDir)engine\math\Matrix;$(ProjectDir)engine\math\Model;$(ProjectDir)engine\math\Vector;$(ProjectDir)engine\resource;$(ProjectDir)externals\nlohmann;$(ProjectDir)application\scene;$(ProjectDir)application\character;$(ProjectDir)application\player;$(ProjectDir)application\bullet;$(ProjectDir)application\loader;$(ProjectDir)application\camera;$(ProjectDir)application\enemy;$(ProjectDir)externals\assimp\include;$(ProjectDir)engine\math\collision;$(ProjectDir)application\collision;$(ProjectDir)application\fade;$(ProjectDir)application\event;$(ProjectDir)application\stage;$(ProjectDir)engine\math\Easing;$(ProjectDir)application\particle;$(ProjectDir)engine\math\ParticleData;$(ProjectDir)application\resource;$(ProjectDir)application\pause</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(ProjectDir)externals\assimp\lib\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>assimp-vc143-mt.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <AdditionalOptions>/ignore:4020 %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll"
copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"</Command>
    </PostBuildEvent>
    <PreBuildEvent>
      <Command>"$(SolutionDir)..\generated\outputs\$(Configuration)\AssetGenerator.exe" "$(ProjectDir)."
</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="application\bullet\BulletManager.cpp" />
    <ClCompile Include="application\bullet\EnemyBullet.cpp" />
    <ClCompile Include="application\bullet\PlayerBullet.cpp" />
    <ClCompile Include="application\camera\GameClearCamera.cpp" />
    <ClCompile Include="application\camera\GameOverCamera.cpp" />
    <ClCompile Include="application\camera\GamePlayCamera.cpp" />
    <ClCompile Include="application\character\CharacterManager.cpp" />
    <ClCompile Include="application\enemy\Enemy.cpp" />
    <ClCompile Include="application\enemy\EnemySpawner.cpp" />
    <ClCompile Include="application\fade\FadeManager.cpp" />
    <ClCompile Include="application\loader\CharacterLoader.cpp" />
    <ClCompile Include="application\loader\CurveJsonLoader.cpp" />
    <ClCompile Include="application\loader\EnemyLoader.cpp" />
    <ClCompile Include="application\particle\DefaultParticleEmitter.cpp" />
    <ClCompile Include="application\particle\GameClearparticle.cpp" />
    <ClCompile Include="application\particle\GameOverparticle.cpp" />
    <ClCompile Include="application\particle\GamePlayparticle.cpp" />
    <ClCompile Include="application\particle\Titleparticle.cpp" />
    <ClCompile Include="application\pause\Pausemenu.cpp" />
    <ClCompile Include="application\player\Player.cpp" />
    <ClCompile Include="application\resource\FileSearcher.cpp" />
    <ClCompile Include="application\resource\ManifestExporter.cpp" />
    <ClCompile Include="application\scene\GameOverScene.cpp" />
    <ClCompile Include="application\scene\GamePlayScene.cpp" />
    <ClCompile Include="application\scene\TitleScene.cpp" />
    <ClCompile Include="engine\math\Collision\Collision.cpp" />
    <ClCompile Include="engine\math\Easing\Easing.cpp" />
    <ClCompile Include="engine\3d\Skybox.cpp" />
    <ClCompile Include="engine\3d\SkyboxCommon.cpp" />
    <ClCompile Include="engine\base\ViewManager\DsvManager.cpp" />
    <ClCompile Include="engine\base\ViewManager\RtvManager.cpp" />
    <ClCompile Include="engine\io\Controller.cpp" />
    <ClCompile Include="engine\base\DirectXCommon\DescriptorUtils.cpp" />
    <ClCompile Include="engine\base\CopylmageCommon.cpp" />
    <ClCompile Include="engine\base\DirectXCommon\ShaderCompiler.cpp" />
    <ClCompile Include="engine\camera\CameraManager.cpp" />
    <ClCompile Include="engine\3d\Particle\ParticleCommon.cpp" />
    <ClCompile Include="engine\3d\Particle\ParticleEmitter.cpp" />
    <ClCompile Include="engine\3d\Particle\ParticleManager.cpp" />
    <ClCompile Include="engine\3d\Particle\ParticleModel.cpp" />
    <ClCompile Include="engine\audio\SoundLoader.cpp" />
    <ClCompile Include="engine\audio\SoundPlayer.cpp" />
    <ClCompile Include="engine\camera\Camera.cpp" />
    <ClCompile Include="engine\math\MathUtil.cpp" />
    <ClCompile Include="engine\resource\D3DResourceLeakChecker.cpp" />
    <ClCompile Include="engine\base\DirectXCommon\DirectXCommon.cpp" />
    <ClCompile Include="engine\base\Framework.cpp" />
    <ClCompile Include="engine\base\ImGuiManager.cpp" />
    <ClCompile Include="engine\io\Input.cpp" />
    <ClCompile Include="engine\base\Utility\Logger.cpp" />
    <ClCompile Include="engine\math\PrimitiveGenerator.cpp" />
    <ClCompile Include="engine\scene\BaseScene.cpp" />
    <ClCompile Include="engine\scene\SceneFactory.cpp" />
    <ClCompile Include="application\scene\GameClearScene.cpp" />
    <ClCompile Include="engine\base\DirectXCommon\FenceManager.cpp" />
    <ClCompile Include="engine\base\DirectXCommon\FPSController.cpp" />
    <ClCompile Include="application\event\EventManager.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="engine\math\MatrixVector.cpp" />
    <ClCompile Include="engine\3d\Model.cpp" />
    <ClCompile Include="engine\3d\ModelCommon.cpp" />
    <ClCompile Include="engine\resource\ModelManager.cpp" />
    <ClCompile Include="engine\3d\Object3d.cpp" />
    <ClCompile Include="engine\3d\Object3dCommon.cpp" />
    <ClCompile Include="engine\2d\Sprite.cpp" />
    <ClCompile Include="engine\2d\SpriteCommon.cpp" />
    <ClCompile Include="engine\base\Utility\StringUtility.cpp" />
    <ClCompile Include="engine\resource\TextureManager.cpp" />
    <ClCompile Include="engine\base\WinApp.cpp" />
    <ClCompile Include="engine\base\ViewManager\SrvManager.cpp" />
    <ClCompile Include="engine\scene\MyGame.cpp" />
    <ClCompile Include="engine\scene\SceneManager.cpp" />
    <ClCompile Include="engine\resource\ResourceFactory.cpp" />
    <ClCompile Include="engine\base\DirectXCommon\ViewportManager.cpp" />
    <ClCompile Include="engine\base\DirectXCommon\SwapChainManager.cpp" />
    <ClCompile Include="application\stage\StageManager.cpp" />
    <ClCompile Include="application\camera\TitleCamera.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="application\bullet\BaseBullet.h" />
    <ClInclude Include="application\bullet\BulletManager.h" />
    <ClInclude Include="application\bullet\EnemyBullet.h" />
    <ClInclude Include="application\bullet\PlayerBullet.h" />
    <ClInclude Include="application\camera\GameClearCamera.h" />
    <ClInclude Include="application\camera\GameOverCamera.h" />
    <ClInclude Include="application\camera\GamePlayCamera.h" />
    <ClInclude Include="application\camera\SceneCameraBase.h" />
    <ClInclude Include="application\character\BaseCharacter.h" />
    <ClInclude Include="application\character\CharacterManager.h" />
    <ClInclude Include="application\enemy\Enemy.h" />
    <ClInclude Include="application\enemy\EnemySpawner.h" />
    <ClInclude Include="application\fade\FadeManager.h" />
    <ClInclude Include="application\loader\CharacterLoader.h" />
    <ClInclude Include="application\loader\CurveJsonLoader.h" />
    <ClInclude Include="application\loader\EnemyLoader.h" />
    <ClInclude Include="application\particle\BaseEmitter.h" />
    <ClInclude Include="application\particle\DefaultParticleEmitter.h" />
    <ClInclude Include="application\particle\FollowEmitter.h" />
    <ClInclude Include="application\particle\GameClearparticle.h" />
    <ClInclude Include="application\particle\GameOverparticle.h" />
    <ClInclude Include="application\particle\GamePlayparticle.h" />
    <ClInclude Include="application\particle\Titleparticle.h" />
    <ClInclude Include="application\pause\Pausemenu.h" />
    <ClInclude Include="application\player\Player.h" />
    <ClInclude Include="application\resource\FileSearcher.h" />
    <ClInclude Include="application\resource\ManifestExporter.h" />
    <ClInclude Include="application\scene\GameOverScene.h" />
    <ClInclude Include="engine\math\Collision\Collision.h" />
    <ClInclude Include="engine\math\Collision\OBB.h" />
    <ClInclude Include="engine\math\Easing\Easing.h" />
    <ClInclude Include="engine\camera\CameraTransform.h" />
    <ClInclude Include="engine\camera\CameraTypes.h" />
    <ClInclude Include="engine\3d\Skybox.h" />
    <ClInclude Include="engine\3d\SkyboxCommon.h" />
    <ClInclude Include="engine\base\ViewManager\DsvManager.h" />
    <ClInclude Include="engine\base\ViewManager\RtvManager.h" />
    <ClInclude Include="engine\io\Controller.h" />
    <ClInclude Include="engine\base\DirectXCommon\DescriptorUtils.h" />
    <ClInclude Include="engine\base\CopylmageCommon.h" />
    <ClInclude Include="engine\base\DirectXCommon\ShaderCompiler.h" />
    <ClInclude Include="engine\camera\CameraManager.h" />
    <ClInclude Include="engine\3d\Particle\ParticleCommon.h" />
    <ClInclude Include="engine\3d\Particle\ParticleEmitter.h" />
    <ClInclude Include="engine\3d\Particle\ParticleManager.h" />
    <ClInclude Include="engine\3d\Particle\ParticleModel.h" />
    <ClInclude Include="engine\audio\SoundLoader.h" />
    <ClInclude Include="engine\audio\SoundPlayer.h" />
    <ClInclude Include="engine\camera\Camera.h" />
    <ClInclude Include="engine\math\Light\DirectionalLight.h" />
    <ClInclude Include="engine\math\Light\PointLight.h" />
    <ClInclude Include="engine\math\Light\SpotLight.h" />
    <ClInclude Include="engine\math\MathUtil.h" />
    <ClInclude Include="engine\math\Matrix\Matrix3x3.h" />
    <ClInclude Include="engine\math\Matrix\Matrix4x4.h" />
    <ClInclude Include="engine\math\Matrix\TransformationMatrix.h" />
    <ClInclude Include="engine\math\Model\Material.h" />
    <ClInclude Include="engine\math\Model\MaterialDate.h" />
    <ClInclude Include="engine\math\Model\ModelDate.h" />
    <ClInclude Include="engine\math\Model\Vertex.h" />
    <ClInclude Include="engine\math\ParticleData\InstanceData.h" />
    <ClInclude Include="engine\math\ParticleData\Particle.h" />
    <ClInclude Include="engine\math\ParticleData\ParticleGroup.h" />
    <ClInclude Include="engine\math\ParticleData\ParticleRandomData.h" />
    <ClInclude Include="engine\math\ParticleData\RandomParameter.h" />
    <ClInclude Include="engine\math\ParticleData\Velocity.h" />
    <ClInclude Include="engine\math\Quaternion.h" />
    <ClInclude Include="engine\math\Vector\Transform.h" />
    <ClInclude Include="engine\math\Vector\Vector2.h" />
    <ClInclude Include="engine\math\Vector\Vector3.h" />
    <ClInclude Include="engine\math\Vector\Vector4.h" />
    <ClInclude Include="engine\resource\D3DResourceLeakChecker.h" />
    <ClInclude Include="engine\base\DirectXCommon\DirectXCommon.h" />
    <ClInclude Include="engine\base\Framework.h" />
    <ClInclude Include="engine\base\ImGuiManager.h" />
    <ClInclude Include="engine\io\Input.h" />
    <ClInclude Include="engine\base\Utility\Logger.h" />
    <ClInclude Include="engine\math\MatrixVector.h" />
    <ClInclude Include="engine\3d\Model.h" />
    <ClInclude Include="engine\3d\ModelCommon.h" />
    <ClInclude Include="engine\resource\ModelManager.h" />
    <ClInclude Include="engine\3d\Object3d.h" />
    <ClInclude Include="engine\3d\Object3dCommon.h" />
    <ClInclude Include="engine\resource\ResourceObject.h" />
    <ClInclude Include="engine\2d\Sprite.h" />
    <ClInclude Include="engine\2d\SpriteCommon.h" />
    <ClInclude Include="engine\base\Utility\StringUtility.h" />
    <ClInclude Include="engine\resource\TextureManager.h" />
    <ClInclude Include="engine\math\PrimitiveGenerator.h" />
    <ClInclude Include="engine\base\WinApp.h" />
    <ClInclude Include="engine\base\ViewManager\SrvManager.h" />
    <ClInclude Include="engine\scene\AbstractSceneFactory.h" />
    <ClInclude Include="engine\scene\BaseScene.h" />
    <ClInclude Include="application\scene\GamePlayScene.h" />
    <ClInclude Include="engine\scene\MyGame.h" />
    <ClInclude Include="engine\scene\SceneFactory.h" />
    <ClInclude Include="application\scene\TitleScene.h" />
    <ClInclude Include="engine\scene\SceneManager.h" />
    <ClInclude Include="application\scene\GameClearScene.h" />
    <ClInclude Include="engine\resource\ResourceFactory.h" />
    <ClInclude Include="engine\base\DirectXCommon\FenceManager.h" />
    <ClInclude Include="engine\base\DirectXCommon\ViewportManager.h" />
    <ClInclude Include="engine\base\DirectXCommon\FPSController.h" />
    <ClInclude Include="engine\base\DirectXCommon\SwapChainManager.h" />
    <ClInclude Include="application\camera\GameCamera.h" />
    <ClInclude Include="application\event\EventManager.h" />
    <ClInclude Include="application\stage\StageManager.h" />
    <ClInclude Include="application\camera\TitleCamera.h" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="externals\DirectXTex\DirectXTex_Desktop_2022_Win10.vcxproj">
      <Project>{371b9fa9-4c90-4ac6-a123-aced756d6c77}</Project>
    </ProjectReference>
    <ProjectReference Include="externals\imgui\imgui.vcxproj">
      <Project>{12ce02d8-a771-4844-aacc-f20bf9af9aea}</Project>
    </ProjectReference>
    <ProjectReference Include="Tools\AssetGenerator\AssetGenerator.vcxproj">
      <Project>{b309d80a-b650-41b2-a3a8-c6afc14bc2db}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\levels\bezier.json" />
    <None Include="Resources\levels\untitled.json" />
    <None Include="Resources\shaders\Fullscreen\Fullscreen.hlsli" />
    <None Include="Resources\shaders\Object3d\Object3d.hlsli" />
    <None Include="Resources\shaders\Particle\Particle.hlsli" />
    <None Include="Resources\shaders\Skybox\Skybox.hlsli" />
    <None Include="Resources\shaders\Sprite\Sprite.hlsli" />
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resources\shaders\Fullscreen\BoxFilter.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\Fullscreen.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\Fullscreen.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\GaussianFilter.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\LuminancsBasedOutline.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\RadialBlur.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\Random.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\Vignette.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Object3d\Object3d.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Object3d\Object3d.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Particle\Particle.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Particle\Particle.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Skybox\Skybox.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Skybox\Skybox.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Sprite\Sprite.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Sprite\Sprite.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

============================================================
File Path: project/MyGame.vcxproj.filters
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine">
      <UniqueIdentifier>{e5bb12bd-eb6c-4539-8614-50e10be7f71c}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\2d">
      <UniqueIdentifier>{87dbf081-2f7b-4eab-8c81-08ea214b5ba0}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d">
      <UniqueIdentifier>{e4f54486-87d7-4c08-acbf-10af73162a20}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\audio">
      <UniqueIdentifier>{c5faab06-77d5-44a2-a700-36b635bf587a}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\io">
      <UniqueIdentifier>{849c0a72-3185-4493-85f4-cbfc3ab982a5}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math">
      <UniqueIdentifier>{148871ea-cfec-4a44-ad07-e82a90916544}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene">
      <UniqueIdentifier>{d700f57f-629f-4663-b0c5-9fed45d48a34}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base">
      <UniqueIdentifier>{184d90e8-56f6-4da2-a158-9577d0e8c868}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine">
      <UniqueIdentifier>{737dfbbb-a9b0-492a-8809-350bd6bd331b}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\2d">
      <UniqueIdentifier>{2eee3025-5ed7-4f2f-a553-663f32452e5e}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d">
      <UniqueIdentifier>{f57245cc-06c0-4856-9025-f7310549b45f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\audio">
      <UniqueIdentifier>{db8600b6-b9d4-46b5-ba34-247bbbbfc1c0}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\io">
      <UniqueIdentifier>{f1c4ee9f-6e8e-430d-a0ca-7a684e31282c}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base">
      <UniqueIdentifier>{4fdfa224-e6d7-4d32-a12f-d6becbb084ad}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene">
      <UniqueIdentifier>{960523b3-dc50-4e8f-86ea-9fcec9aaa013}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math">
      <UniqueIdentifier>{28340a47-7d72-4339-9ddf-7feeea023b28}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application">
      <UniqueIdentifier>{e2eeeae6-7bff-48ec-904c-1bb0da6123a8}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d\Particle">
      <UniqueIdentifier>{f11d837f-785c-46f4-8d38-d2db12fb12e4}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d\Particle">
      <UniqueIdentifier>{6a681e0b-b31b-47fd-bd3d-6861765745c8}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders">
      <UniqueIdentifier>{0de7fefb-2e6d-4ca7-b098-464774bb7c1b}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\scene">
      <UniqueIdentifier>{792431d0-54be-4105-831e-7121fc68efe6}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\camera">
      <UniqueIdentifier>{3b2bd65f-cf04-450a-8757-252635abbb16}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\camera">
      <UniqueIdentifier>{059690a8-734e-4cad-a2bb-9a414ca8fc96}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Fullscreen">
      <UniqueIdentifier>{419fc8b7-8d78-408b-87aa-4f00c7411722}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Object3d">
      <UniqueIdentifier>{967d8d1a-e665-4339-a427-69f3677d040b}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Particle">
      <UniqueIdentifier>{da9a8be8-8b79-44d5-ad2e-bb1e3b8a95bf}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Skybox">
      <UniqueIdentifier>{58e09b7b-5b5a-4eae-8de9-218cb52b007a}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Sprite">
      <UniqueIdentifier>{f7712655-1155-484d-8058-4ee95a16f0af}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\ViewManager">
      <UniqueIdentifier>{bdba6ee3-ac54-4ce6-bbdd-7970e376e45a}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\Utility">
      <UniqueIdentifier>{8e33345e-5a44-4927-a1ae-28fa0b2998a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon">
      <UniqueIdentifier>{941116ce-1a37-4eda-b488-cde40d6909f7}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource">
      <UniqueIdentifier>{aa126d1c-d076-4dc5-9995-7d217c2d8e3a}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\Utility">
      <UniqueIdentifier>{959b4794-2a7c-4e7d-9f24-be5df888e02f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\ViewManager">
      <UniqueIdentifier>{c3078c87-a168-474e-90ed-134b67d9c0df}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon">
      <UniqueIdentifier>{8c15bfd4-5c05-46ae-9dc2-b16cb2ea4795}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource">
      <UniqueIdentifier>{75b8f15d-9509-4d2a-9929-73b792609711}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Light">
      <UniqueIdentifier>{72c878a0-46ae-46b1-850c-b98866920993}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Matrix">
      <UniqueIdentifier>{8fae8f0b-6440-44fa-ae95-9916e7827649}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Model">
      <UniqueIdentifier>{debaee5f-585e-40d7-9014-0afc1300cc73}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Vector">
      <UniqueIdentifier>{e13f2e36-4292-41c9-b7c0-9808517079de}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\player">
      <UniqueIdentifier>{a7eab18e-630a-472c-afe5-35bace2ee948}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\character">
      <UniqueIdentifier>{2a9f0528-9f22-4368-a9d5-57d0c9e90e83}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\loader">
      <UniqueIdentifier>{737ec024-93f3-4b94-94b0-39ecb63a733d}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera">
      <UniqueIdentifier>{2c45c29c-d0c3-4ba3-83cc-fde300d51295}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\bullet">
      <UniqueIdentifier>{43779993-e4ed-4cb3-86e8-2e2a8fc165da}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\enemy">
      <UniqueIdentifier>{4b99df62-1041-4fee-a5fd-1decbabccbe3}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\fade">
      <UniqueIdentifier>{6de3d2ff-57ef-4f70-81ac-7a699de0dd44}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\collision">
      <UniqueIdentifier>{5f01e14b-13b2-42aa-ae79-9affb9303730}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\event">
      <UniqueIdentifier>{560a6f91-295f-44f1-b0b7-b2aa1307c46e}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\collision">
      <UniqueIdentifier>{c7d8663d-47b8-4017-9149-5c426a1193a4}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\stage">
      <UniqueIdentifier>{956b23a1-c000-4af9-816b-d60f4377254e}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Easing">
      <UniqueIdentifier>{dd67d91e-27df-46e4-b34a-c55c296e5fd1}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Easing">
      <UniqueIdentifier>{97eaff47-422d-4b71-86af-e4d42b61b8d3}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle">
      <UniqueIdentifier>{0d377709-ece8-4a7d-9b05-29fc250084e0}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\ParticleData">
      <UniqueIdentifier>{ab309e3a-ec4e-44c9-8978-c114a46308b8}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\collision">
      <UniqueIdentifier>{f4077ff3-9d86-403e-9ef0-1bebb837b1f8}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\resource">
      <UniqueIdentifier>{07a86f35-75fe-4831-bfb6-13aa414b3d2f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\pause">
      <UniqueIdentifier>{c5781d8c-054f-48a2-8959-008b1c5e936f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application">
      <UniqueIdentifier>{8879c179-8943-4fc5-a19e-f0b38a474781}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\scene">
      <UniqueIdentifier>{274efcee-0964-497f-a839-b32ab88eb2cf}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\character">
      <UniqueIdentifier>{88d1f61c-35e7-4b87-8d52-a0fe6ed451ec}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\player">
      <UniqueIdentifier>{2a7546ab-cebe-44d3-a852-a35e4e04e782}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\loader">
      <UniqueIdentifier>{4fd94a91-62be-4991-98c1-9fe49ec67cec}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera">
      <UniqueIdentifier>{225bec48-4135-4122-8a6e-3b5d8149494c}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\bullet">
      <UniqueIdentifier>{91330ba0-b2ca-4345-9fa7-f3775f10d4e6}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\enemy">
      <UniqueIdentifier>{8ca6f24a-1c20-4541-8f80-30ba17e68e7f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\fade">
      <UniqueIdentifier>{fca0a5c4-0cca-4f32-9665-08aef2b11991}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\collision">
      <UniqueIdentifier>{2b551131-8003-4282-b5ca-995d168aec00}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\event">
      <UniqueIdentifier>{2e44f535-1b69-4651-b91a-3c6c9d1fef4a}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\stage">
      <UniqueIdentifier>{1d514fa6-6226-4b6e-ad61-846cfd2e44bb}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle">
      <UniqueIdentifier>{3264e2f4-9fdc-482b-ad88-dcef28660e8d}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\resource">
      <UniqueIdentifier>{479ca9b3-2dfa-4bfe-a30d-0bc400cf9199}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\pause">
      <UniqueIdentifier>{5f0ad7e7-d543-4f5d-9f5a-2e8ac0dc99ba}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\Sprite.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\SpriteCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\io\Input.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\io</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\WinApp.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\MatrixVector.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Object3d.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Object3dCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\ModelCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Model.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\ImGuiManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base</Filter>
    </ClCompile>
    <ClCompile Include="engine\audio\SoundLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\audio</Filter>
    </ClCompile>
    <ClCompile Include="engine\audio\SoundPlayer.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\audio</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\MyGame.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\Framework.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\BaseScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\SceneManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene</Filter>
    </ClCompile>
    <ClCompile Include="engine\scene\SceneFactory.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Particle\ParticleCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d\Particle</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Particle\ParticleEmitter.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d\Particle</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Particle\ParticleManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d\Particle</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Particle\ParticleModel.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d\Particle</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\PrimitiveGenerator.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math</Filter>
    </ClCompile>
    <ClCompile Include="application\scene\GamePlayScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\scene</Filter>
    </ClCompile>
    <ClCompile Include="application\scene\TitleScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\scene</Filter>
    </ClCompile>
    <ClCompile Include="engine\camera\CameraManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\camera\Camera.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\CopylmageCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base</Filter>
    </ClCompile>
    <ClCompile Include="application\scene\GameClearScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\scene</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\SkyboxCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Skybox.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\ViewManager\DsvManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\ViewManager</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\ViewManager\RtvManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\ViewManager</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\ViewManager\SrvManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\ViewManager</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\Utility\Logger.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\Utility</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\Utility\StringUtility.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\Utility</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon\FPSController.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon\DirectXCommon.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon\FenceManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon\ShaderCompiler.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon\DescriptorUtils.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon\ViewportManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon\SwapChainManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClCompile>
    <ClCompile Include="engine\resource\TextureManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource</Filter>
    </ClCompile>
    <ClCompile Include="engine\resource\ResourceFactory.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource</Filter>
    </ClCompile>
    <ClCompile Include="engine\resource\ModelManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource</Filter>
    </ClCompile>
    <ClCompile Include="engine\resource\D3DResourceLeakChecker.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource</Filter>
    </ClCompile>
    <ClCompile Include="engine\io\Controller.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\io</Filter>
    </ClCompile>
    <ClCompile Include="application\player\Player.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\player</Filter>
    </ClCompile>
    <ClCompile Include="application\loader\CurveJsonLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\loader</Filter>
    </ClCompile>
    <ClCompile Include="application\loader\CharacterLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\loader</Filter>
    </ClCompile>
    <ClCompile Include="application\bullet\BulletManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\bullet</Filter>
    </ClCompile>
    <ClCompile Include="application\bullet\PlayerBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\bullet</Filter>
    </ClCompile>
    <ClCompile Include="application\enemy\Enemy.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\enemy</Filter>
    </ClCompile>
    <ClCompile Include="application\bullet\EnemyBullet.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\bullet</Filter>
    </ClCompile>
    <ClCompile Include="application\scene\GameOverScene.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\scene</Filter>
    </ClCompile>
    <ClCompile Include="application\fade\FadeManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\fade</Filter>
    </ClCompile>
    <ClCompile Include="application\event\EventManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\event</Filter>
    </ClCompile>
    <ClCompile Include="application\character\CharacterManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\character</Filter>
    </ClCompile>
    <ClCompile Include="application\stage\StageManager.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\stage</Filter>
    </ClCompile>
    <ClCompile Include="application\camera\TitleCamera.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera</Filter>
    </ClCompile>
    <ClCompile Include="application\camera\GameOverCamera.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera</Filter>
    </ClCompile>
    <ClCompile Include="application\camera\GameClearCamera.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Easing\Easing.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Easing</Filter>
    </ClCompile>
    <ClCompile Include="application\camera\GamePlayCamera.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera</Filter>
    </ClCompile>
    <ClCompile Include="application\particle\Titleparticle.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClCompile>
    <ClCompile Include="application\particle\GamePlayparticle.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClCompile>
    <ClCompile Include="application\particle\GameClearparticle.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClCompile>
    <ClCompile Include="application\particle\GameOverparticle.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\Collision\Collision.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\collision</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\MathUtil.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math</Filter>
    </ClCompile>
    <ClCompile Include="application\particle\DefaultParticleEmitter.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClCompile>
    <ClCompile Include="application\enemy\EnemySpawner.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\enemy</Filter>
    </ClCompile>
    <ClCompile Include="application\loader\EnemyLoader.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\loader</Filter>
    </ClCompile>
    <ClCompile Include="application\resource\FileSearcher.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\resource</Filter>
    </ClCompile>
    <ClCompile Include="application\resource\ManifestExporter.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\resource</Filter>
    </ClCompile>
    <ClCompile Include="application\pause\Pausemenu.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\pause</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="engine\2d\Sprite.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\2d\SpriteCommon.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\io\Input.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\io</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\MatrixVector.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\WinApp.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Object3d.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Object3dCommon.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Model.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\ModelCommon.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\ImGuiManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\audio\SoundLoader.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\audio</Filter>
    </ClInclude>
    <ClInclude Include="engine\audio\SoundPlayer.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\audio</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\MyGame.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\Framework.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\BaseScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\SceneManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\SceneFactory.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\scene\AbstractSceneFactory.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Particle\ParticleCommon.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d\Particle</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Particle\ParticleEmitter.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d\Particle</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Particle\ParticleManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d\Particle</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Particle\ParticleModel.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d\Particle</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\PrimitiveGenerator.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math</Filter>
    </ClInclude>
    <ClInclude Include="application\scene\GamePlayScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\scene</Filter>
    </ClInclude>
    <ClInclude Include="application\scene\TitleScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\camera\Camera.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\camera\CameraManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\io\Controller.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\io</Filter>
    </ClInclude>
    <ClInclude Include="application\scene\GameClearScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Skybox.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\SkyboxCommon.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\CopylmageCommon.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon\DirectXCommon.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon\DescriptorUtils.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\ViewManager\DsvManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\ViewManager</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon\FPSController.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon\FenceManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\ViewManager\RtvManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\ViewManager</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\ViewManager\SrvManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\ViewManager</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon\ViewportManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon\SwapChainManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\Utility\StringUtility.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\Utility</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\Utility\Logger.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\Utility</Filter>
    </ClInclude>
    <ClInclude Include="engine\resource\D3DResourceLeakChecker.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource</Filter>
    </ClInclude>
    <ClInclude Include="engine\resource\ResourceFactory.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource</Filter>
    </ClInclude>
    <ClInclude Include="engine\resource\ResourceObject.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource</Filter>
    </ClInclude>
    <ClInclude Include="engine\resource\TextureManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource</Filter>
    </ClInclude>
    <ClInclude Include="engine\resource\ModelManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\resource</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Light\DirectionalLight.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Light</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Light\PointLight.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Light</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Light\SpotLight.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Light</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon\ShaderCompiler.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\base\DirectXCommon</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Matrix\Matrix4x4.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Matrix</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Matrix\Matrix3x3.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Matrix</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Matrix\TransformationMatrix.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Matrix</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Model\ModelDate.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Model</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Model\MaterialDate.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Model</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Model\Material.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Model</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Model\Vertex.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Model</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector\Vector4.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Vector</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector\Vector3.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Vector</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector\Vector2.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Vector</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Vector\Transform.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Vector</Filter>
    </ClInclude>
    <ClInclude Include="application\character\BaseCharacter.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\character</Filter>
    </ClInclude>
    <ClInclude Include="application\player\Player.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\player</Filter>
    </ClInclude>
    <ClInclude Include="application\loader\CurveJsonLoader.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\loader</Filter>
    </ClInclude>
    <ClInclude Include="application\camera\GameCamera.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera</Filter>
    </ClInclude>
    <ClInclude Include="application\loader\CharacterLoader.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\loader</Filter>
    </ClInclude>
    <ClInclude Include="application\bullet\BaseBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\bullet</Filter>
    </ClInclude>
    <ClInclude Include="application\bullet\BulletManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\bullet</Filter>
    </ClInclude>
    <ClInclude Include="application\bullet\PlayerBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\bullet</Filter>
    </ClInclude>
    <ClInclude Include="application\scene\GameOverScene.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\scene</Filter>
    </ClInclude>
    <ClInclude Include="application\character\CharacterManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\character</Filter>
    </ClInclude>
    <ClInclude Include="application\enemy\Enemy.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\enemy</Filter>
    </ClInclude>
    <ClInclude Include="application\bullet\EnemyBullet.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\bullet</Filter>
    </ClInclude>
    <ClInclude Include="application\fade\FadeManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\fade</Filter>
    </ClInclude>
    <ClInclude Include="application\event\EventManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\event</Filter>
    </ClInclude>
    <ClInclude Include="application\stage\StageManager.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\stage</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Quaternion.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math</Filter>
    </ClInclude>
    <ClInclude Include="engine\camera\CameraTypes.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\camera\CameraTransform.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\camera</Filter>
    </ClInclude>
    <ClInclude Include="application\camera\TitleCamera.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera</Filter>
    </ClInclude>
    <ClInclude Include="application\camera\GameOverCamera.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera</Filter>
    </ClInclude>
    <ClInclude Include="application\camera\SceneCameraBase.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera</Filter>
    </ClInclude>
    <ClInclude Include="application\camera\GameClearCamera.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Easing\Easing.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\Easing</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\ParticleData\InstanceData.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\ParticleData</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\ParticleData\Particle.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\ParticleData</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\ParticleData\ParticleGroup.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\ParticleData</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\ParticleData\ParticleRandomData.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\ParticleData</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\ParticleData\RandomParameter.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\ParticleData</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\ParticleData\Velocity.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\ParticleData</Filter>
    </ClInclude>
    <ClInclude Include="application\particle\BaseEmitter.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClInclude>
    <ClInclude Include="application\particle\FollowEmitter.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClInclude>
    <ClInclude Include="application\particle\Titleparticle.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClInclude>
    <ClInclude Include="application\particle\GamePlayparticle.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClInclude>
    <ClInclude Include="application\particle\GameClearparticle.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClInclude>
    <ClInclude Include="application\particle\GameOverparticle.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Collision\OBB.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\collision</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\Collision\Collision.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math\collision</Filter>
    </ClInclude>
    <ClInclude Include="application\camera\GamePlayCamera.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\camera</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\MathUtil.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\engine\math</Filter>
    </ClInclude>
    <ClInclude Include="application\particle\DefaultParticleEmitter.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\particle</Filter>
    </ClInclude>
    <ClInclude Include="application\enemy\EnemySpawner.h">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\application\enemy</Filter>
    </ClInclude>
    <ClInclude Include="application\resource\ManifestExporter.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\resource</Filter>
    </ClInclude>
    <ClInclude Include="application\resource\FileSearcher.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\resource</Filter>
    </ClInclude>
    <ClInclude Include="application\loader\EnemyLoader.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\loader</Filter>
    </ClInclude>
    <ClInclude Include="application\pause\Pausemenu.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\application\pause</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resources\shaders\Sprite\Sprite.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Sprite</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Sprite\Sprite.VS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Sprite</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\BoxFilter.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Fullscreen</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\Fullscreen.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Fullscreen</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\Fullscreen.VS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Fullscreen</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\GaussianFilter.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Fullscreen</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\LuminancsBasedOutline.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Fullscreen</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\RadialBlur.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Fullscreen</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\Random.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Fullscreen</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Fullscreen\Vignette.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Fullscreen</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Skybox\Skybox.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Skybox</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Skybox\Skybox.VS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Skybox</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Particle\Particle.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Particle</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Particle\Particle.VS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Particle</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Object3d\Object3d.PS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Object3d</Filter>
    </FxCompile>
    <FxCompile Include="Resources\shaders\Object3d\Object3d.VS.hlsl">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Object3d</Filter>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Resources\shaders\Sprite\Sprite.hlsli">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Sprite</Filter>
    </None>
    <None Include="Resources\shaders\Fullscreen\Fullscreen.hlsli">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Fullscreen</Filter>
    </None>
    <None Include="Resources\shaders\Skybox\Skybox.hlsli">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Skybox</Filter>
    </None>
    <None Include="Resources\shaders\Particle\Particle.hlsli">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Particle</Filter>
    </None>
    <None Include="Resources\shaders\Object3d\Object3d.hlsli">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\shaders\Object3d</Filter>
    </None>
    <None Include="Resources\levels\bezier.json">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
    <None Include="Resources\levels\untitled.json">
      <Filter>ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </None>
  </ItemGroup>
</Project>

============================================================
File Path: project/Tools/AssetGenerator/AssetGenerator.vcxproj
============================================================
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b309d80a-b650-41b2-a3a8-c6afc14bc2db}</ProjectGuid>
    <RootNamespace>AssetGenerator</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <TreatWarningAsError>true</TreatWarningAsError>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir)engine\src;$(ProjectDir)engine\math;$(ProjectDir)..\..\externals\nlohmann;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
      <AdditionalOptions>/ignore:4049,4048 %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir)engine\src;$(ProjectDir)engine\math;$(ProjectDir)..\..\externals\nlohmann;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="engine\src\FileSearcher.cpp" />
    <ClCompile Include="engine\src\ManifestExporter.cpp" />
    <ClCompile Include="engine\src\ResourceCodeGenerator.cpp" />
    <ClCompile Include="engine\src\ResourceIdGenerator.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="engine\math\AssetType.h" />
    <ClInclude Include="engine\math\LoadResourceID.h" />
    <ClInclude Include="engine\math\ResourceEntry.h" />
    <ClInclude Include="engine\math\ResourceID.h" />
    <ClInclude Include="engine\src\FileSearcher.h" />
    <ClInclude Include="engine\src\ManifestExporter.h" />
    <ClInclude Include="engine\src\ResourceCodeGenerator.h" />
    <ClInclude Include="engine\src\ResourceIdGenerator.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

============================================================
File Path: project/Tools/AssetGenerator/AssetGenerator.vcxproj.filters
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="ãƒªã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\math">
      <UniqueIdentifier>{096b1cc1-869c-4c29-a284-64f9c87fdab6}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\math">
      <UniqueIdentifier>{98ba7bee-f60b-4677-9458-1d163c0dce99}</UniqueIdentifier>
    </Filter>
    <Filter Include="ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\src">
      <UniqueIdentifier>{57a01277-271b-4252-a698-7a17c7025440}</UniqueIdentifier>
    </Filter>
    <Filter Include="ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\src">
      <UniqueIdentifier>{1abe0527-9375-43b4-9357-5a03cbbc1766}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="engine\src\ResourceIdGenerator.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\src</Filter>
    </ClCompile>
    <ClCompile Include="engine\src\ResourceCodeGenerator.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\src</Filter>
    </ClCompile>
    <ClCompile Include="engine\src\ManifestExporter.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\src</Filter>
    </ClCompile>
    <ClCompile Include="engine\src\FileSearcher.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«\src</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp">
      <Filter>ã‚½ãƒ¼ã‚¹ ãƒ•ã‚¡ã‚¤ãƒ«</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="engine\src\ResourceCodeGenerator.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\src</Filter>
    </ClInclude>
    <ClInclude Include="engine\src\ManifestExporter.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\src</Filter>
    </ClInclude>
    <ClInclude Include="engine\src\FileSearcher.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\src</Filter>
    </ClInclude>
    <ClInclude Include="engine\src\ResourceIdGenerator.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\src</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\ResourceID.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\LoadResourceID.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\AssetType.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\ResourceEntry.h">
      <Filter>ãƒ˜ãƒƒãƒ€ãƒ¼ ãƒ•ã‚¡ã‚¤ãƒ«\math</Filter>
    </ClInclude>
  </ItemGroup>
</Project>

============================================================
File Path: project/Tools/AssetGenerator/engine/math/AssetType.h
============================================================
#pragma once

/// <summary>
/// ãƒªã‚½ãƒ¼ã‚¹ã®ç¨®é¡žã‚’è¡¨ã™åˆ—æŒ™ä½“
/// </summary>
enum class AssetType {
    Texture,   // ãƒ†ã‚¯ã‚¹ãƒãƒ£
    Model,     // 3Dãƒ¢ãƒ‡ãƒ«
    Audio,     // éŸ³æº
    Unknown    // éžå¯¾å¿œæ‹¡å¼µå­
};

============================================================
File Path: project/Tools/AssetGenerator/engine/math/LoadResourceID.h
============================================================
#pragma once

namespace LoadResourceID {

    namespace texture {
        constexpr const char* Arrow = "Textures/Ui/Arrow.png";
        constexpr const char* Command01 = "Textures/Ui/command_01.png";
        constexpr const char* Command02 = "Textures/Ui/command_02.png";
        constexpr const char* Command11 = "Textures/Ui/command_11.png";
        constexpr const char* Command12 = "Textures/Ui/command_12.png";
        constexpr const char* Pausemenupanel = "Textures/Ui/PauseMenuPanel.png";
        constexpr const char* Poseicon = "Textures/Ui/Poseicon.png";
        constexpr const char* PoseiconRed = "Textures/Ui/Poseicon_red.png";
        constexpr const char* Title = "Textures/Ui/Title.png";
        constexpr const char* Ui02 = "Textures/Ui/UI_02.png";
    }

    namespace model {
        constexpr const char* Player = "Models/Character/Player/Player.obj";
    }

    namespace audio {
    }

} // namespace LoadResourceID


============================================================
File Path: project/Tools/AssetGenerator/engine/math/ResourceEntry.h
============================================================
#pragma once
#include <string>

/// <summary>
/// å„ã‚¢ã‚»ãƒƒãƒˆã®æƒ…å ±ã‚’ä¿æŒã™ã‚‹æ§‹é€ ä½“
/// </summary>
struct ResourceEntry {
    std::string name;    //!< ã‚¢ã‚»ãƒƒãƒˆã®è«–ç†åï¼ˆä¾‹: player_idleï¼‰
    std::string model;   //!< ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
    std::string texture; //!< ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
    std::string audio;   //!< éŸ³æºãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
};

============================================================
File Path: project/Tools/AssetGenerator/engine/math/ResourceID.h
============================================================
#pragma once
#include <string>

enum class ResourceType {
    Texture,
    Model,
    Audio
};

struct ResourceId {
    ResourceType type;   // Texture / Model / Audio
    std::string  name;   // enemybullet / alarm01
    std::string  path;   // Bullet/EnemyBullet.obj
};


============================================================
File Path: project/Tools/AssetGenerator/engine/src/FileSearcher.cpp
============================================================
#include"FileSearcher.h"
#include <filesystem>

std::vector<std::string> FileSearcher::GetAllFiles(const std::vector<std::string>& excludeDirs) {
    std::vector<std::string> files;
    // ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä»¥ä¸‹ã‚’å†å¸°çš„ã«èµ°æŸ»
    for (const auto& entry : std::filesystem::recursive_directory_iterator(root_)) {
        // ãƒ•ã‚¡ã‚¤ãƒ«ä»¥å¤–ï¼ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç­‰ï¼‰ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (!entry.is_regular_file()) { continue; }

        // ãƒ•ãƒ«ãƒ‘ã‚¹æ–‡å­—åˆ—ã‚’å–å¾—
        std::string pathStr = entry.path().string();
        // é™¤å¤–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«è©²å½“ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        bool skip = false;
        for (const auto& ex : excludeDirs) {
            // ãƒ‘ã‚¹æ–‡å­—åˆ—ã«é™¤å¤–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåãŒå«ã¾ã‚Œã¦ã„ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
            if (pathStr.find(ex) != std::string::npos) {
                skip = true;
                break;
            }
        }
        // é™¤å¤–å¯¾è±¡ã§ãªã‘ã‚Œã°ã€root ã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ã‚’è¿½åŠ 
        if (!skip) {
            files.push_back(std::filesystem::relative(entry.path(), root_).string());
        }
    }
    // æ¤œç´¢çµæžœã‚’è¿”ã™
    return files;
}

============================================================
File Path: project/Tools/AssetGenerator/engine/src/FileSearcher.h
============================================================
#pragma once
#include <string>
#include <vector>

/// <summary>
/// æŒ‡å®šã—ãŸãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ä»¥ä¸‹ã‚’å†å¸°çš„ã«èµ°æŸ»ã—ã€
/// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ä¸€è¦§ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹
/// </summary>
class FileSearcher {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    /// <param name="root">
    /// æ¤œç´¢ã®èµ·ç‚¹ã¨ãªã‚‹ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ï¼ˆä¾‹: "Resources"ï¼‰
    /// </param>
    explicit FileSearcher(const std::string& root) : root_(root) {}
    /// <summary>
    /// ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ä»¥ä¸‹ã‚’å†å¸°çš„ã«ã‚¹ã‚­ãƒ£ãƒ³ã—ã€
    /// é™¤å¤–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’è€ƒæ…®ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’è¿”ã™
    /// </summary>
    /// <param name="excludeDirs">
    /// é™¤å¤–ã—ãŸã„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã®ãƒªã‚¹ãƒˆ
    /// ï¼ˆä¾‹: ".git", "Temp", "EditorTemp" ãªã©ï¼‰
    /// </param>
    /// <returns>
    /// root ã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ã§æ§‹æˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ä¸€è¦§
    /// </returns>
    std::vector<std::string> GetAllFiles(const std::vector<std::string>& excludeDirs);

private:
    // æ¤œç´¢ã®åŸºæº–ã¨ãªã‚‹ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
    std::string root_;
};

============================================================
File Path: project/Tools/AssetGenerator/engine/src/ManifestExporter.cpp
============================================================
#include"ManifestExporter.h"
#include <fstream>
#include <unordered_map>
#include <json.hpp>

///=====================================================
/// Export
///-----------------------------------------------------
/// fileList ã‚’èµ°æŸ»ã—ã€
/// åŒä¸€ Group / Name ã® Asset ã‚’çµ±åˆã—ãªãŒã‚‰ JSON ã‚’æ§‹ç¯‰ã™ã‚‹
///
/// å‡ºåŠ›å½¢å¼:
/// {
///   "Bullet": {
///     "enemybullet": {
///       "model": "...",
///       "texture": "..."
///     }
///   }
/// }
///=====================================================

void ManifestExporter::Export(const std::string& outputPath, const std::vector<std::string>& fileList) { 
    // å‡ºåŠ›ç”¨å¤‰æ•° 
    nlohmann::json manifest;

   for (const auto& file : fileList) {
        // ãƒ‘ã‚¹æ­£è¦åŒ–
        std::string normalized = NormalizePath(file);

        // æ‹¡å¼µå­å–å¾—
        std::string ext = std::filesystem::path(normalized).extension().string();

        // AssetType åˆ¤å®š
        AssetType type = GetAssetType(ext);
        if (type == AssetType::Unknown) continue;

        // Groupï¼ˆæœ€ä¸Šä½ãƒ•ã‚©ãƒ«ãƒ€ï¼‰
        std::string group = GetGroup(normalized);

        // Asset è«–ç†åï¼ˆæ‹¡å¼µå­ç„¡ã—. åŒåã®model/texture/audio ã‚’1ã¤ã«æŸã­ã‚‹ãŸã‚ã«ä½¿ç”¨
        std::string name = CreateId(normalized, type);

        // JSONã‚­ãƒ¼åï¼ˆmodel / texture / audioï¼‰
        std::string typeKey = ToString(type);

        // åŒä¸€ Group/Name ã®ä¸­ã« model/texture/audioã‚’çµ±åˆã—ã¦æ ¼ç´ã™ã‚‹
        manifest[group][name][typeKey] = normalized;
    }
    // å·®åˆ†ãŒã‚ã‚‹å ´åˆã®ã¿ä¿å­˜ã—ç„¡é§„ãªãƒ•ã‚¡ã‚¤ãƒ«æ›´æ–°ã‚’é˜²ã
    SaveIfChanged(outputPath, manifest.dump(4));
}

void ManifestExporter::SaveIfChanged(const std::string& path, const std::string& content) {
    // æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    std::ifstream ifs(path, std::ios::binary);
    if (ifs) {
        std::string existing((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
        // å†…å®¹ãŒåŒä¸€ãªã‚‰æ›¸ãè¾¼ã¿ã‚’ã‚¹ã‚­ãƒƒãƒ—
        if (existing == content) {
            return;
        }
    }

    // å·®åˆ†ãŒã‚ã‚‹å ´åˆã®ã¿ä¸Šæ›¸ãä¿å­˜
    std::ofstream ofs(path, std::ios::binary | std::ios::trunc);
    ofs << content;
}

std::string ManifestExporter::CreateId(std::string path, AssetType type) {
    std::filesystem::path p(path);
    // æ‹¡å¼µå­ã‚’é™¤ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–å¾—
    std::string id = p.stem().string();
    // å°æ–‡å­—åŒ–ï¼ˆã‚­ãƒ¼ã®æºã‚Œé˜²æ­¢ï¼‰ _model / _texture ã¯ä»˜ã‘ãªã„
    std::transform(id.begin(), id.end(), id.begin(), ::tolower);
    return id;
}


std::string ManifestExporter::NormalizePath(std::string path) {
    std::replace(path.begin(), path.end(), '\\', '/');
    return path;
}

std::string ManifestExporter::GetGroup(const std::string& path) {
    std::filesystem::path p(path);

    if (p.has_parent_path()) {
        return p.begin()->string();
    }
    // ãƒ•ã‚©ãƒ«ãƒ€ã‚’æŒãŸãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    return "Common";
}


AssetType ManifestExporter::GetAssetType(const std::string& ext) {
    std::string lowerExt = ext;

    // æ‹¡å¼µå­ã‚’å°æ–‡å­—åŒ–
    std::transform(lowerExt.begin(), lowerExt.end(), lowerExt.begin(), ::tolower);
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£
    if (lowerExt == ".png" || lowerExt == ".jpg" || lowerExt == ".jpeg" || lowerExt == ".tga" || lowerExt == ".dds") return AssetType::Texture;
    // ãƒ¢ãƒ‡ãƒ«
    if (lowerExt == ".fbx" || lowerExt == ".obj" || lowerExt == ".gltf" || lowerExt == ".glb") return AssetType::Model;
    // éŸ³æº
    if (lowerExt == ".wav" || lowerExt == ".mp3" || lowerExt == ".ogg") return AssetType::Audio;

    return AssetType::Unknown;
}

std::string ManifestExporter::ToString(AssetType type) {
    switch (type) {
    case AssetType::Texture: return "texture";
    case AssetType::Model:   return "model";
    case AssetType::Audio:   return "audio";
    default: return "";
    }
}


============================================================
File Path: project/Tools/AssetGenerator/engine/src/ManifestExporter.h
============================================================
#pragma once
#include <vector>
#include <string>
#include <AssetType.h>

/// <summary>
/// ManifestExporter
/// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ä¸€è¦§ã‹ã‚‰ Asset Manifest(JSON) ã‚’ç”Ÿæˆã™ã‚‹ã‚¯ãƒ©ã‚¹
/// </summary>
class ManifestExporter {
private: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// æ‹¡å¼µå­ã‹ã‚‰ AssetType ã‚’åˆ¤å®šã™ã‚‹
    /// æœªå¯¾å¿œã®æ‹¡å¼µå­ã¯ Unknown ã‚’è¿”ã™
    /// </summary>
    AssetType GetAssetType(const std::string& ext);
    /// <summary>
    /// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰ Asset ã®è«–ç†åã‚’ç”Ÿæˆã™ã‚‹
    /// æ‹¡å¼µå­ã‚’é™¤ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’å°æ–‡å­—åŒ–ã—ãŸã‚‚ã®ã‚’ä½¿ç”¨
    /// </summary>
    std::string CreateId(std::string path, AssetType type);
    /// <summary>
    /// AssetType ã‚’ JSON ã®ã‚­ãƒ¼æ–‡å­—åˆ—ã¸å¤‰æ›ã™ã‚‹
    /// </summary>
    std::string ToString(AssetType type); 
    /// <summary>
    /// ãƒ‘ã‚¹ã®æœ€ä¸Šä½ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ Group åã¨ã—ã¦å–å¾—ã™ã‚‹
    /// ä¾‹: "Bullet/EnemyBullet.obj" â†’ "Bullet"
    /// </summary>
    std::string GetGroup(const std::string& path);
    /// <summary>
    /// ãƒ‘ã‚¹åŒºåˆ‡ã‚Šã‚’ '/' ã«æ­£è¦åŒ–ã™ã‚‹
    /// Windows / Unix æ··åœ¨å¯¾ç­–ç”¨ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    /// </summary>
    static std::string NormalizePath(std::string path);
    /// <summary>
    /// æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã¨å†…å®¹ã‚’æ¯”è¼ƒã—,å·®åˆ†ãŒã‚ã‚‹å ´åˆã®ã¿ä¸Šæ›¸ãä¿å­˜ã™ã‚‹
    /// </summary>
    void SaveIfChanged(const std::string& path, const std::string& content); 
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›å‡¦ç†
    /// ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’å—ã‘å–ã£ã¦JSONåŒ–å‡ºåŠ›ã€‚å†…å®¹ã«å·®åˆ†ãŒã‚ã‚‹å ´åˆã®ã¿ãƒ•ã‚¡ã‚¤ãƒ«ã¸æ›¸ãå‡ºã™ 
    /// </summary> 
    void Export(const std::string& outputPath, const std::vector<std::string>& fileList);
};

============================================================
File Path: project/Tools/AssetGenerator/engine/src/ResourceCodeGenerator.cpp
============================================================
#include "ResourceCodeGenerator.h"
#include <fstream>
#include <sstream>
#include <regex>
#include <iostream>
#include <set>

std::map<std::string, std::string> ResourceCodeGenerator::ParseExistingHeader(const std::string& filePath) {
    std::map<std::string, std::string> existingData;
    std::ifstream ifs(filePath);
    if (!ifs) return existingData;

    std::string line;
    // æ­£è¦è¡¨ç¾ã‚’ä¿®æ­£: "= "path"" ã®éƒ¨åˆ†ã‚’éžã‚­ãƒ£ãƒ—ãƒãƒ£ã‚°ãƒ«ãƒ¼ãƒ— (?:...)? ã«ã—ã¦ã€ã‚ã£ã¦ã‚‚ãªãã¦ã‚‚ãƒžãƒƒãƒã•ã›ã‚‹
    // 1: å¤‰æ•°å (\w+), 2: ãƒ‘ã‚¹ ([^"]+)
    std::regex re(R"(constexpr const char\*\s+(\w+)(?:\s*=\s*\"([^\"]+)\")?\s*;)");
    std::smatch match;

    while (std::getline(ifs, line)) {
        if (std::regex_search(line, match, re)) {
            std::string varName = match[1].str();
            std::string path = match[2].matched ? match[2].str() : "__UNDEFINED__";

            // ãƒ‘ã‚¹ã‚’ã‚­ãƒ¼ã«ã—ã¦å¤‰æ•°åã‚’ä¿å­˜ï¼ˆãƒ‘ã‚¹ä¸æ˜Žã®å ´åˆã¯ __UNDEFINED__ ã‚’ã‚­ãƒ¼ã«ã™ã‚‹ï¼‰
            // ãŸã ã—ã€åŒã˜ãƒ‘ã‚¹ãŒè¤‡æ•°ã‚ã‚‹ã¨ä¸Šæ›¸ãã•ã‚Œã‚‹ãŸã‚ã€æ‰‹å‹•å®šç¾©ãŒå¤šã„å ´åˆã¯æ³¨æ„
            existingData[path] = varName;
        }
    }
    return existingData;
}

void ResourceCodeGenerator::GenerateHeader(const std::string& outputPath, const std::vector<ResourceEntry>& entries) {
    // 1. æ—¢å­˜ã®å®šç¾©ã‚’èª­ã¿è¾¼ã‚€
    auto existingData = ParseExistingHeader(outputPath);

    // æ—¢å­˜ã® {å¤‰æ•°å : å…ƒã®ãƒ‘ã‚¹} ã®é€†å¼•ããƒžãƒƒãƒ—ã‚’ä½œæˆ
    std::map<std::string, std::string> nameToPath;
    for (auto const& [path, name] : existingData) {
        nameToPath[name] = path;
    }

    std::stringstream ss;
    ss << "#pragma once\n\n";
    ss << "namespace LoadResourceID {\n\n";

    // ã©ã®ã‚°ãƒ«ãƒ¼ãƒ—ã§ã‚‚å‡ºåŠ›ã•ã‚Œãªã‹ã£ãŸæ—¢å­˜å¤‰æ•°åã‚’è¿½è·¡
    std::set<std::string> allUsedNames;

    auto writeGroup = [&](const std::string& groupName, auto filterFunc) {
        ss << "    namespace " << groupName << " {\n";
        std::set<std::string> usedInThisGroup;

        // A. ç¾å­˜ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã«åŸºã¥ãç”Ÿæˆ
        for (const auto& e : entries) {
            std::string currentPath = filterFunc(e);
            if (currentPath.empty()) continue;

            // æ•´ç†ç”¨ãƒ•ã‚£ãƒ«ã‚¿
            if (currentPath.find("Textures") == std::string::npos &&
                currentPath.find("Models") == std::string::npos) {
                continue;
            }

            std::string varName;
            if (existingData.count(currentPath)) {
                varName = existingData[currentPath];
            } else {
                varName = ToUpperCamel(e.name);
            }

            ss << "        constexpr const char* " << varName << " = \"" << currentPath << "\";\n";
            usedInThisGroup.insert(varName);
            allUsedNames.insert(varName);
        }

        // B. æ‰‹å‹•è¿½åŠ ã•ã‚ŒãŸå¤‰æ•°ã‚„ã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ¶ˆãˆãŸå¤‰æ•°ã® nullptr å‡ºåŠ›
        for (auto const& [name, path] : nameToPath) {
            // ã™ã§ã«ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã§å‡ºåŠ›æ¸ˆã¿ãªã‚‰é£›ã°ã™
            if (usedInThisGroup.count(name)) continue;

            // 1. ãƒ‘ã‚¹ãŒç‰¹å®šã®ãƒ•ã‚©ãƒ«ãƒ€ã‚’å«ã‚€å ´åˆã€ãã®ã‚°ãƒ«ãƒ¼ãƒ—ã§ nullptr å‡ºåŠ›
            // 2. ãƒ‘ã‚¹ãŒ "__UNDEFINED__" (æ‰‹å‹•ã§ Title2; ã¨æ›¸ã„ãŸ) ã®å ´åˆã€
            //    ã¨ã‚Šã‚ãˆãš texture namespace ãªã©ã§æœ€åˆã«è¦‹ã¤ã‘ãŸæ™‚ã«å‡ºã™ã€
            //    ã¾ãŸã¯ namespace åˆ¤å®šã‚’ç°¡æ˜“åŒ–ã—ã¦å‡ºåŠ›
            bool isTargetGroup = false;
            if (path == "__UNDEFINED__") {
                // æ‰‹å‹•å®šç¾©ã®å ´åˆã€å¤‰æ•°åã®ãƒ’ãƒ³ãƒˆï¼ˆ"Title"ãŒå«ã¾ã‚Œã‚‹ãªã‚‰textureãªã©ï¼‰
                // ã¾ãŸã¯å…ƒã® namespace ã®å ´æ‰€ã‚’ç‰¹å®šã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ãŒå¿…è¦ã§ã™ãŒã€
                // ä»Šå›žã¯ã€Œæœ€åˆã«ãƒžãƒƒãƒã—ãŸã‚°ãƒ«ãƒ¼ãƒ—ã€ã§å‡ºã™ç°¡æ˜“ä»•æ§˜ã«ã—ã¾ã™
                if (groupName == "texture") isTargetGroup = true;
            } else if (ContainsFolder(path, groupName)) {
                isTargetGroup = true;
            }

            if (isTargetGroup && allUsedNames.find(name) == allUsedNames.end()) {
                ss << "        constexpr const char* " << name << " = nullptr; // // [Error: File not found or name mismatch] \n";
                allUsedNames.insert(name);
            }
        }
        ss << "    }\n\n";
        };

    // 1. Textureã‚°ãƒ«ãƒ¼ãƒ—: ãƒ‘ã‚¹ã« "Textures" ãŒå«ã¾ã‚Œã‚‹å ´åˆã®ã¿åæ˜ 
    writeGroup("texture", [](const ResourceEntry& e) {
        if (!e.texture.empty() && e.texture.find("Textures") != std::string::npos) {
            return e.texture;
        }
        return std::string("");
        });

    // 2. Modelã‚°ãƒ«ãƒ¼ãƒ—: ãƒ‘ã‚¹ã« "Models" ãŒå«ã¾ã‚Œã‚‹å ´åˆã®ã¿åæ˜ 
    writeGroup("model", [](const ResourceEntry& e) {
        if (!e.model.empty() && e.model.find("Models") != std::string::npos) {
            return e.model;
        }
        return std::string("");
        });

    // 3. Audioã‚°ãƒ«ãƒ¼ãƒ—: åŸºæœ¬çš„ã«ãã®ã¾ã¾åæ˜ 
    writeGroup("audio", [](const ResourceEntry& e) {
        return e.audio;
        });

    ss << "} // namespace LoadResourceID\n";

    // --- ä¿å­˜å‡¦ç†ï¼ˆå¤‰æ›´ãªã—ï¼‰ ---
    std::string newContent = ss.str();
    if (IsContentChanged(outputPath, newContent)) {
        std::ofstream ofs(outputPath);
        ofs << newContent;
        // å·®åˆ†ãŒã‚ã‚‹ãªã‚‰ã€æ–°ã—ã„å†…å®¹ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸Šæ›¸ãä¿å­˜
        std::cout << "[Update] Header file updated." << std::endl;
    } else {
        // å†…å®¹ãŒåŒã˜ãªã‚‰ã€æ›¸ãè¾¼ã¿ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆæ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿æŒï¼‰
        std::cout << "[Skip] No changes detected." << std::endl;
    }
}

bool ResourceCodeGenerator::IsContentChanged(const std::string& filePath, const std::string& newContent) {
    std::ifstream ifs(filePath);
    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã„ï¼ˆå­˜åœ¨ã—ãªã„ï¼‰å ´åˆã¯ã€æ–°è¦ä½œæˆãŒå¿…è¦ãªãŸã‚ã€Œå¤‰æ›´ã‚ã‚Šã€ã¨ã¿ãªã™
    if (!ifs) return true;

    std::stringstream oldContent;
    oldContent << ifs.rdbuf();
    return oldContent.str() != newContent;
}

std::string ResourceCodeGenerator::ToUpperCamel(const std::string& name) {
    std::string res;
    bool nextUpper = true; // æœ€åˆã®æ–‡å­—ã‚„åŒºåˆ‡ã‚Šå¾Œã®æ–‡å­—ã‚’å¤§æ–‡å­—ã«ã™ã‚‹ãƒ•ãƒ©ã‚°
    for (char c : name) {
        // åŒºåˆ‡ã‚Šæ–‡å­—ï¼ˆã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã€ã‚¹ãƒšãƒ¼ã‚¹ã€ãƒã‚¤ãƒ•ãƒ³ï¼‰ã‚’æ¤œå‡º
        if (c == '_' || c == ' ' || c == '-') {
            nextUpper = true;
            continue;
        }
        if (nextUpper) {
            // å¤§æ–‡å­—ã«å¤‰æ›ã—ã¦è¿½åŠ 
            res += (char)toupper(static_cast<unsigned char>(c));
            nextUpper = false;
        } else {
            // å°æ–‡å­—ã«å¤‰æ›ã—ã¦è¿½åŠ 
            res += (char)tolower(static_cast<unsigned char>(c));
        }
    }
    return res;
}

============================================================
File Path: project/Tools/AssetGenerator/engine/src/ResourceCodeGenerator.h
============================================================
#pragma once
#include <string>
#include <vector>
#include <map>
#include <ResourceIdGenerator.h>

/// <summary>
/// ãƒªã‚½ãƒ¼ã‚¹å®šç¾©ã‚³ãƒ¼ãƒ‰ï¼ˆC++ãƒ˜ãƒƒãƒ€ãƒ¼ï¼‰ã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹ã‚¯ãƒ©ã‚¹ã€‚
/// æ—¢å­˜ã®å®šç¾©ã‚’è§£æžã—ã€å®šæ•°åã®ä¸€è²«æ€§ã‚’ä¿ã¡ã¤ã¤æœ€æ–°ã®çŠ¶æ…‹ã«æ›´æ–°ã™ã‚‹ã€‚
/// </summary>
class ResourceCodeGenerator {
public:
    /// <summary>
    /// ãƒªã‚½ãƒ¼ã‚¹ã‚¨ãƒ³ãƒˆãƒªã®ãƒªã‚¹ãƒˆã‹ã‚‰ C++ ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã™ã‚‹
    /// </summary>
    /// <param name="outputPath">å‡ºåŠ›ã™ã‚‹ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
    /// <param name="entries">ResourceIdGeneratorã«ã‚ˆã£ã¦è§£æžã•ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹æƒ…å ±ãƒªã‚¹ãƒˆ</param>
    void GenerateHeader(
        const std::string& outputPath,
        const std::vector<ResourceEntry>& entries
    );
    /// <summary>
    /// æ–‡å­—åˆ—ã‚’ã‚¢ãƒƒãƒ‘ãƒ¼ã‚­ãƒ£ãƒ¡ãƒ«ã‚±ãƒ¼ã‚¹ã«å¤‰æ›ã™ã‚‹ï¼ˆä¾‹: "enemy_bullet" -> "EnemyBullet"ï¼‰
    /// </summary>
    /// <param name="name">å¤‰æ›å…ƒã®æ–‡å­—åˆ—</param>
    /// <returns>å¤‰æ›å¾Œã®æ–‡å­—åˆ—</returns>
    std::string ToUpperCamel(const std::string& name);
    /// <summary>
    /// æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¹ã®ä¸­ã«ç‰¹å®šã®ãƒ•ã‚©ãƒ«ãƒ€åãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹åˆ¤å®šã™ã‚‹
    /// </summary>
    /// <param name="path">å¯¾è±¡ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    /// <param name="folder">æ¤œç´¢ã™ã‚‹ãƒ•ã‚©ãƒ«ãƒ€å</param>
    /// <returns>å«ã¾ã‚Œã¦ã„ã‚Œã° true</returns>
    static bool ContainsFolder(const std::string& path, const std::string& folder) {
        return path.find(folder + "/") != std::string::npos;
    };
    /// <summary>
    /// æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¹ãŒç‰¹å®šã®ãƒ•ã‚©ãƒ«ãƒ€ç›´ä¸‹ï¼ˆã¾ãŸã¯é…ä¸‹ï¼‰ã«ã‚ã‚‹ã‹åˆ¤å®šã™ã‚‹
    /// </summary>
    bool IsUnderFolder(const std::string& path, const std::string& folder) {
        return path.find(folder + "/") != std::string::npos;
    };
private:
    /// <summary>
    /// æ—¢å­˜ã®ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€å®šç¾©æ¸ˆã¿ã®å¤‰æ•°åã¨ãƒ‘ã‚¹ã®å¯¾å¿œè¡¨ã‚’ä½œæˆã™ã‚‹
    /// </summary>
    /// <param name="filePath">æ—¢å­˜ã®ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ‘ã‚¹</param>
    /// <returns>ãƒ‘ã‚¹ã‚’ã‚­ãƒ¼ã€å¤‰æ•°åã‚’å€¤ã¨ã—ãŸãƒžãƒƒãƒ—</returns>
    std::map<std::string, std::string> ParseExistingHeader(const std::string& filePath);
    /// <summary>
    /// æ–°ã—ãç”Ÿæˆã—ãŸå†…å®¹ãŒç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã¨ç•°ãªã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹
    /// </summary>
    /// <param name="filePath">æ¯”è¼ƒå¯¾è±¡ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    /// <param name="newContent">æ–°ã—ãç”Ÿæˆã—ãŸã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—</param>
    /// <returns>å¤‰æ›´ãŒã‚ã‚Œã° trueã€åŒã˜ã§ã‚ã‚Œã° false</returns>
    bool IsContentChanged(const std::string& filePath, const std::string& newContent);
};

============================================================
File Path: project/Tools/AssetGenerator/engine/src/ResourceIdGenerator.cpp
============================================================
#include "ResourceIdGenerator.h"
#include <fstream>

using json = nlohmann::json;

bool ResourceIdGenerator::LoadFromJson(const std::string& jsonPath) {
    std::ifstream ifs(jsonPath);
    if (!ifs) return false;

    json manifest;
    try {
        ifs >> manifest;
    } catch (const json::parse_error) {
        // ãƒ‘ãƒ¼ã‚¹å¤±æ•—æ™‚ã¯ false ã‚’è¿”ã™
        return false;
    }

    // JSON ã®æ§‹é€ ã‚’èµ°æŸ» (Group -> AssetName -> Data)
    for (auto& [groupName, assets] : manifest.items()) {
        for (auto& [assetName, assetData] : assets.items()) {

            ResourceEntry entry;
            entry.name = assetName;
            // model ã‚­ãƒ¼ãŒå­˜åœ¨ã™ã‚Œã°ãƒ‘ã‚¹ã‚’æ ¼ç´
            if (assetData.contains("model"))
                entry.model = assetData["model"].get<std::string>();
            // texture ã‚­ãƒ¼ãŒå­˜åœ¨ã™ã‚Œã°ãƒ‘ã‚¹ã‚’æ ¼ç´
            if (assetData.contains("texture"))
                entry.texture = assetData["texture"].get<std::string>();
            // audio ã‚­ãƒ¼ãŒå­˜åœ¨ã™ã‚Œã°ãƒ‘ã‚¹ã‚’æ ¼ç´
            if (assetData.contains("audio"))
                entry.audio = assetData["audio"].get<std::string>();

            resourceids_.push_back(entry);
        }
    }
    return true;
}

ResourceType ResourceIdGenerator::ToResourceType(const std::string& key) {
    // æ–‡å­—åˆ—è­˜åˆ¥å­ã‹ã‚‰å†…éƒ¨åž‹ã® ResourceType ã¸å¤‰æ›ã‚’è¡Œã†
    if (key == "texture") return ResourceType::Texture;
    if (key == "model")   return ResourceType::Model;
    if (key == "audio")   return ResourceType::Audio;

    // æƒ³å®šå¤–ã®ã‚­ãƒ¼ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ä¾‹å¤–ã‚’æŠ•ã’ã‚‹
    throw std::runtime_error("Unknown resource type encountered: " + key);
}

============================================================
File Path: project/Tools/AssetGenerator/engine/src/ResourceIdGenerator.h
============================================================
#pragma once
#include <vector>
#include <json.hpp>
#include <ResourceId.h>
#include <ResourceEntry.h>

/// <summary>
/// Manifest.json ã‚’è§£æžã—ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã§åˆ©ç”¨ã—ã‚„ã™ã„ ResourceEntry ã®ãƒªã‚¹ãƒˆã«å¤‰æ›ã™ã‚‹ã‚¯ãƒ©ã‚¹
/// </summary>
class ResourceIdGenerator {
public:
    /// <summary>
    /// Manifest.json ã‚’èª­ã¿è¾¼ã‚“ã§ ResourceEntry ã®ä¸€è¦§ã‚’æ§‹ç¯‰ã™ã‚‹
    /// </summary>
    /// <param name="jsonPath">èª­ã¿è¾¼ã‚€ JSON ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
    /// <returns>èª­ã¿è¾¼ã¿ã¨è§£æžã«æˆåŠŸã™ã‚Œã° true</returns>
    bool LoadFromJson(const std::string& jsonPath);
    /// <summary>
    /// è§£æžæ¸ˆã¿ã®ãƒªã‚½ãƒ¼ã‚¹ã‚¨ãƒ³ãƒˆãƒªãƒªã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹
    /// </summary>
    /// <returns>ResourceEntry ã®ãƒ™ã‚¯ã‚¿ã¸ã®å®šæ•°å‚ç…§</returns>
    const std::vector<ResourceEntry>& GetResources() const { return resourceids_; }
private:
    /// <summary>
    /// JSON å†…ã®ã‚­ãƒ¼æ–‡å­—åˆ—ã‚’ ResourceType åˆ—æŒ™åž‹ã«å¤‰æ›ã™ã‚‹
    /// </summary>
    /// <param name="key">"texture", "model", "audio" ãªã©ã®æ–‡å­—åˆ—</param>
    /// <returns>å¯¾å¿œã™ã‚‹ ResourceType</returns>
    ResourceType ToResourceType(const std::string& key);
private:
    // è§£æžã•ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹æƒ…å ±ã®æ ¼ç´ç”¨ãƒªã‚¹ãƒˆ
    std::vector<ResourceEntry> resourceids_;
};

============================================================
File Path: project/Tools/AssetGenerator/main.cpp
============================================================
#include <iostream>
#include <filesystem>
#include <FileSearcher.h>
#include <ManifestExporter.h>
#include <ResourceIdGenerator.h>
#include <ResourceCodeGenerator.h>

namespace fs = std::filesystem;

int main(int argc, char* argv[]) {
    // æ—¥æœ¬èªžãƒ‘ã‚¹å¯¾å¿œ
    std::locale::global(std::locale("japanese"));

    // 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆãƒ‘ã‚¹ã®æ±ºå®š
    // å¼•æ•°ãŒãªã„å ´åˆã¯å®Ÿè¡Œç’°å¢ƒã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ã‚’ä½¿ç”¨
    std::string pathStr = (argc > 1) ? argv[1] : "../../";

    // Windowsã®æœ«å°¾å¼•ç”¨ç¬¦ãƒã‚°å¯¾ç­– ---
    if (!pathStr.empty() && pathStr.back() == '\"') {
        pathStr.pop_back(); // æ··å…¥ã—ãŸ " ã‚’å‰Šé™¤
    }
    // æœ«å°¾ãŒ \. ã§çµ‚ã‚ã‚‹ã‚ˆã†ã«æŒ‡å®šã•ã‚ŒãŸå ´åˆã®å¯¾ç­–
    if (!pathStr.empty() && pathStr.back() == '.') {
        pathStr.pop_back();
    }
    // ------------------------------------------
    fs::path projectRoot = fs::absolute(pathStr); // çµ¶å¯¾ãƒ‘ã‚¹ã«å¤‰æ›ã—ã¦å®‰å®šã•ã›ã‚‹
    // 2. å…¥å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ»ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®å®šç¾©
    fs::path resourceDir = projectRoot / "Resources";
    fs::path jsonPath = resourceDir / "Manifest.json";

    fs::path headerDir = projectRoot / "Tools/AssetGenerator/engine/math";
    fs::path headerPath = headerDir / "LoadResourceID.h";

    // å‡ºåŠ›å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®è‡ªå‹•ä½œæˆ
    if (!fs::exists(headerDir)) {
        fs::create_directories(headerDir);
    }

    try {
        std::cout << "--- Asset Generator Start ---" << std::endl;

        // â‘  ãƒªã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œç´¢
        // Manifest.json è‡ªä½“ã¯æ¤œç´¢å¯¾è±¡ã‹ã‚‰é™¤å¤–ã™ã‚‹
        FileSearcher searcher(resourceDir.string());
        std::vector<std::string> exclude = { ".git", ".vs", "Manifest.json" };
        auto files = searcher.GetAllFiles(exclude);

        // â‘¡ ã‚¢ã‚»ãƒƒãƒˆç›®éŒ² (Manifest.json) ã®æ›¸ãå‡ºã—
        // å¤‰æ›´ãŒãªã„å ´åˆã¯ãƒ•ã‚¡ã‚¤ãƒ«æ›´æ–°ï¼ˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—å¤‰æ›´ï¼‰ã‚’è¡Œã‚ãªã„
        ManifestExporter exporter;
        exporter.Export(jsonPath.string(), files);
        std::cout << "[Success] JSON created at: " << jsonPath << std::endl;

        // â‘¢ JSONã®è§£æžã¨C++å®šæ•°å®šç¾©ãƒ˜ãƒƒãƒ€ãƒ¼ã®è‡ªå‹•ç”Ÿæˆ
        ResourceIdGenerator idGen;
        if (idGen.LoadFromJson(jsonPath.string())) {
            ResourceCodeGenerator codeGen;
            codeGen.GenerateHeader(headerPath.string(), idGen.GetResources());
            std::cout << "[Success] Header created at: " << headerPath << std::endl;
        }
    }
    catch (const std::exception& e) {
        std::cerr << "[Error] " << e.what() << std::endl;
        return 1;
    }
    return 0;
}

============================================================
File Path: project/application/bullet/BaseBullet.h
============================================================
#pragma once
#include <Vector3.h>
#include <memory>

// ãƒ˜ãƒƒãƒ€ãƒ¼ã®é‡è¤‡ã‚’é˜²ãå‰æ–¹å®£è¨€
class Object3d;

/// <summary>
/// å¼¾ã®åŸºåº•ã‚¯ãƒ©ã‚¹ï¼ˆæŠ½è±¡ã‚¯ãƒ©ã‚¹ï¼‰
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ãƒ»æ•µå¼¾ã®å…±é€šã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®šç¾©ã™ã‚‹ã€‚
/// å„æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã¯ Initialize / Update / Draw ãªã©ã‚’å®Ÿè£…ã™ã‚‹ã€‚
/// </summary>
class BaseBullet {
public:// ãƒ¡ãƒ³ãƒé–¢æ•° 
	/// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary> 
	virtual ~BaseBullet() = default;
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
	virtual void Initialize() = 0;
	virtual void Initialize(const Vector3& startPos, const Vector3& targetPos, float speed) {};
    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
	virtual void Finalize() = 0;
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
	virtual void Update() = 0;
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
	virtual void Draw() = 0;

    // ===============================================
    // å…±é€šå±žæ€§ã®ã‚¢ã‚¯ã‚»ãƒƒã‚µ
    // ===============================================

    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’å–å¾—
    /// </summary>
    /// <returns>å¼¾ãŒæœ‰åŠ¹ãªã‚‰ true</returns>
    bool IsActive() const { return active_; }

    /// <summary>
    /// å¼¾ã‚’éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã«ã™ã‚‹ï¼ˆå‰Šé™¤å¯¾è±¡ã«ã™ã‚‹ï¼‰
    /// </summary>
    void SetInactive() { active_ = false; }

protected: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ãƒ•ãƒ©ã‚°
    /// true = æœ‰åŠ¹ï¼ˆæç”»ãƒ»æ›´æ–°å¯¾è±¡ï¼‰
    /// false = ç„¡åŠ¹ï¼ˆå‰Šé™¤ï¼‰
    /// </summary>
    bool active_ = true;
};

============================================================
File Path: project/application/bullet/BulletManager.cpp
============================================================
#include "BulletManager.h"

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
BulletManager* BulletManager::instance = nullptr;

///====================================================
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
///====================================================
BulletManager* BulletManager::GetInstance() {	
    // ã¾ã ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒç”Ÿæˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°ä½œæˆ
    if (instance == nullptr) {
		instance = new BulletManager;
	}
	return instance;
}

///====================================================
/// çµ‚äº†å‡¦ç†
///====================================================
void BulletManager::Finalize() {
    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å‰Šé™¤ã—ã¦nullptrã«æˆ»ã™
    delete instance;
	instance = nullptr;   
    // å„å¼¾ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
    playerBullets_.clear();
    enemyBullets_.clear();
}

///====================================================
/// æ›´æ–°å‡¦ç†
/// ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®å¼¾ã‚’æ›´æ–°ã™ã‚‹ã€‚
///====================================================
void BulletManager::Update() {
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ã®æ›´æ–°
    for (std::unique_ptr<PlayerBullet>& bullet : playerBullets_) {
        if (bullet->IsActive()) {
            bullet->Update();
        }
    }

    // æ•µå¼¾ã®æ›´æ–°
    for (std::unique_ptr<EnemyBullet>& bullet : enemyBullets_) {
        if (bullet->IsActive()) {
            bullet->Update();
        }
    }

    // ç„¡åŠ¹åŒ–ã•ã‚ŒãŸå¼¾ã¯å‰Šé™¤ã•ã‚Œã‚‹
    std::erase_if(playerBullets_, [](const std::unique_ptr<PlayerBullet>& b) {
        return !b->IsActive();
        });
    std::erase_if(enemyBullets_, [](const std::unique_ptr<EnemyBullet>& b) {
        return !b->IsActive();
        });
}

///====================================================
/// æç”»å‡¦ç†
/// ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®å¼¾ã‚’æç”»ã™ã‚‹ã€‚
/// ç„¡åŠ¹ï¼ˆéžã‚¢ã‚¯ãƒ†ã‚£ãƒ–ï¼‰ãªå¼¾ã¯æç”»å¯¾è±¡å¤–ã¨ãªã‚‹ã€‚
///====================================================
void BulletManager::Draw() {
    // --- ç„¡åŠ¹åŒ–ã•ã‚ŒãŸå¼¾ã‚’å‰Šé™¤ --- //
    for (std::unique_ptr<PlayerBullet>& bullet : playerBullets_) {
        if (bullet->IsActive()) {
            bullet->Draw();
        }
    }

    for (std::unique_ptr<EnemyBullet>& bullet : enemyBullets_) {
        if (bullet->IsActive()) {
            bullet->Draw();
        }
    }
}

///====================================================
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ã®è¿½åŠ ç™»éŒ²
///====================================================
void BulletManager::AddPlayerBullet(std::unique_ptr<PlayerBullet> bullet) {
    playerBullets_.push_back(std::move(bullet));
}

///====================================================
/// æ•µå¼¾ã®è¿½åŠ ç™»éŒ²
///====================================================
void BulletManager::AddEnemyBullet(std::unique_ptr<EnemyBullet> bullet) {
    enemyBullets_.push_back(std::move(bullet));
}

///====================================================
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ã®å‚ç…§ã‚’è¿”ã™
///====================================================
const std::vector<std::unique_ptr<PlayerBullet>>& BulletManager::GetPlayerBullets() const {
    return playerBullets_;
}

///====================================================
/// æ•µå¼¾ã®å‚ç…§ã‚’è¿”ã™
///====================================================
const std::vector<std::unique_ptr<EnemyBullet>>& BulletManager::GetEnemyBullets() const {
    return enemyBullets_;
}

============================================================
File Path: project/application/bullet/BulletManager.h
============================================================
#pragma once
#include "BaseBullet.h"
#include <vector>
#include <memory>
#include<PlayerBullet.h>
#include<EnemyBullet.h>

/// <summary>
/// å„å¼¾ã®æ›´æ–°ãƒ»æç”»ã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
/// å„ã‚·ãƒ¼ãƒ³ã§ç™ºå°„ã•ã‚ŒãŸå¼¾ã‚’è¿½åŠ ,ä¿æŒã™ã‚‹
/// å¼¾ã®ç”Ÿæˆã¯ AddPlayerBullet / AddEnemyBullet çµŒç”±ã§è¡Œã†
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã¨ã—ã¦å…¨ä½“ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
/// </summary>
class BulletManager {
private: // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    static BulletManager* instance;
    // ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’é˜²ã
    BulletManager(BulletManager&) = delete;
    BulletManager& operator=(BulletManager&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•° 
    BulletManager() = default;
    ~BulletManager() = default;
    // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
    static BulletManager* GetInstance();
    /// <summary>
    /// çµ‚äº†å‡¦ç† 
    /// </summary> 
    void Finalize();
    /// <summary>
    /// æ›´æ–°å‡¦ç† 
    /// </summary>
    void Update();
    /// <summary>
    /// æç”»å‡¦ç† 
    /// </summary>
    void Draw();
    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã‚’ç™»éŒ²
    /// å¤–éƒ¨ã‹ã‚‰ç”Ÿæˆã•ã‚ŒãŸå¼¾ã‚’BulletManagerã«ç™»éŒ²ã™ã‚‹ã€‚
    /// ç™»éŒ²ã•ã‚ŒãŸå¼¾ã¯Updateã‚„Drawå‡¦ç†ã§ç®¡ç†ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
    /// </summary>
    void AddPlayerBullet(std::unique_ptr<PlayerBullet> bullet);
    /// <summary>
    /// æ•µã®å¼¾ã‚’ç™»éŒ²
    /// å¤–éƒ¨ã‹ã‚‰ç”Ÿæˆã•ã‚ŒãŸå¼¾ã‚’BulletManagerã«ç™»éŒ²ã™ã‚‹ã€‚
    /// ç™»éŒ²ã•ã‚ŒãŸå¼¾ã¯Updateã‚„Drawå‡¦ç†ã§ç®¡ç†ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
    /// </summary>
    void AddEnemyBullet(std::unique_ptr<EnemyBullet> bullet);
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    // å¼¾ã®ãƒªã‚¹ãƒˆ
    std::vector<std::unique_ptr<PlayerBullet>> playerBullets_; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    std::vector<std::unique_ptr<EnemyBullet>> enemyBullets_;   // æ•µ
public: // ã‚¢ã‚¯ã‚»ãƒƒã‚µï¼ˆGetter / Setterï¼‰   
    // å¼¾ã®ãƒªã‚¹ãƒˆã‚’å¤–éƒ¨ã‹ã‚‰èª­ã¿å–ã‚‹
    const std::vector<std::unique_ptr<PlayerBullet>>& GetPlayerBullets() const; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    const std::vector<std::unique_ptr<EnemyBullet>>& GetEnemyBullets() const;   // æ•µ
};

============================================================
File Path: project/application/bullet/EnemyBullet.cpp
============================================================
#include "EnemyBullet.h"
#include "ModelManager.h"
#include <MatrixVector.h>
#include <Object3d.h>

using namespace MatrixVector;

///====================================================
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///====================================================
EnemyBullet::EnemyBullet(){}

///====================================================
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼‰
///====================================================
EnemyBullet::~EnemyBullet() { Finalize(); }

///====================================================
/// çµ‚äº†å‡¦ç†
///====================================================
void EnemyBullet::Finalize() {
    if (object_) {
        object_.reset(); // ãƒ¡ãƒ¢ãƒªé–‹æ”¾
    }
}

//====================================================
/// åˆæœŸåŒ–å‡¦ç†ï¼ˆå…±é€šï¼‰
/// â€»ä»Šå›žã¯æœªä½¿ç”¨ã€ç¶™æ‰¿å…ˆã‚„å…±é€šåˆæœŸåŒ–ç”¨ã«æ®‹ã—ã¦ã‚ã‚‹
///====================================================
void EnemyBullet::Initialize() {}

///====================================================
/// åˆæœŸåŒ–å‡¦ç†ï¼ˆç™ºå°„è¨­å®šä»˜ãï¼‰
/// <param name="startPos">å¼¾ã®ç™ºå°„ä½ç½®ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰</param>
/// <param name="targetPos">å¼¾ãŒç‹™ã†ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®åº§æ¨™ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰</param>
/// <param name="speed">å¼¾ã®ç§»å‹•é€Ÿåº¦</param>
///====================================================
void EnemyBullet::Initialize(const Vector3& startPos, const Vector3& targetPos, float speed) {
    // å¼¾ã®åˆæœŸä½ç½®ã‚’è¨­å®š
    transform_.translate = startPos;
    // å¼¾ã®å¤§ãã•ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ã‚’è¨­å®š
    transform_.scale = { 0.5f,0.5f,0.5f };
    // ãƒ¢ãƒ‡ãƒ«æœªç”Ÿæˆã®å ´åˆã¯ãƒ­ãƒ¼ãƒ‰ãƒ»ç”Ÿæˆã™ã‚‹
    if (!object_) {
        // ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        ModelManager::GetInstance()->LoadModel("EnemyBullet.obj");
        // å¼¾ç”¨ã®3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ
        object_ = Object3d::Create(
            "EnemyBullet.obj",
            transform_
        );
        // ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®š
        object_->SetScale({ 0.5f, 0.5f, 0.5f });
    }
    // ç™ºå°„æ–¹å‘ã®è¨ˆç®—ï¼šã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’æ­£è¦åŒ–ã—ã¦å‘ãã‚’æ±‚ã‚ã‚‹
    Vector3 dir = Normalize(targetPos - startPos);
    // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆæ–¹å‘ Ã— é€Ÿåº¦ï¼‰
    velocity_ = dir * speed;
    // å¼¾ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã«ã™ã‚‹ï¼ˆUpdateå¯¾è±¡ã«ã™ã‚‹ï¼‰
    active_ = true; 
    // å¼¾ã®å¯¿å‘½ç®¡ç†ç”¨ã‚¿ã‚¤ãƒžãƒ¼åˆæœŸåŒ–
    time_ = 0;
    Maxtime_ = 500;
}
///====================================================
/// åˆæœŸåŒ–å‡¦ç†ï¼ˆç™ºå°„è¨­å®šä»˜ãï¼‰
/// <param name="startPos">å¼¾ã®ç™ºå°„ä½ç½®</param>
/// <param name="targetPos">ç‹™ã†ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ä½ç½®</param>
/// <param name="speed">å¼¾ã®é€Ÿåº¦</param>
///====================================================
void EnemyBullet::Initialize(const Vector3& startPos, const Vector3& targetPos, const Vector3& cameraForward, float speed) {
    // åˆæœŸä½ç½®ã‚’è¨­å®š
    transform_.translate = startPos;
    // å¼¾ã®å¤§ãã•ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ã‚’è¨­å®š  
    transform_.scale = { 0.5f, 0.5f, 0.5f };
    // ãƒ¢ãƒ‡ãƒ«ãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã‘ã‚Œã°ãƒ­ãƒ¼ãƒ‰ï¼†ç”Ÿæˆ
    if (!object_) {
        // ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        ModelManager::GetInstance()->LoadModel("Bullet/EnemyBullet.obj");
        // å¼¾ç”¨ã®3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆï¼ˆTransformæƒ…å ±ã‚’æ¸¡ã™ï¼‰
        object_ = Object3d::Create("Bullet/EnemyBullet.obj", transform_);
        // ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®š
        object_->SetScale({ 0.5f, 0.5f, 0.5f });
    }

    // --- ã‚«ãƒ¡ãƒ©å‰æ–¹å‘ã«åŸºã¥ãä¿®æ­£ ---
    // å®Œå…¨ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ–¹å‘ã¸é£›ã°ã™
    // å¼¾ã®å‘ãè¨ˆç®—
    Vector3 forward = Normalize(targetPos - startPos); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ–¹å‘ã‚’ã‚«ãƒ¡ãƒ©ã®å‰æ–¹å‘ã«ã€Œå¯„ã›ã‚‹ã€
    float yaw   = std::atan2(forward.x, forward.z);
    float pitch = -std::asin(forward.y);
    transform_.rotate = { pitch, yaw + DirectX::XM_PI, 0.0f };
    // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆæ–¹å‘ Ã— é€Ÿåº¦ï¼‰
    velocity_ = forward * speed;
    // å¼¾ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã«ã™ã‚‹ï¼ˆUpdateå¯¾è±¡ã«ã™ã‚‹ï¼‰
    active_ = true;
    // å¼¾ã®å¯¿å‘½ç®¡ç†ç”¨ã‚¿ã‚¤ãƒžãƒ¼åˆæœŸåŒ–
    time_ = 0;
    Maxtime_ = 1000;
}

///====================================================
/// æ›´æ–°å‡¦ç†
///====================================================
void EnemyBullet::Update() {
    // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’åŠ ãˆã‚‹
    transform_.translate = transform_.translate + velocity_;
    // åº§æ¨™ã‚’æ›´æ–°
    object_->SetTranslate(transform_.translate);
    object_->SetRotate(transform_.rotate);
    object_->SetScale(transform_.scale);
    // æ›´æ–°å‡¦ç†
    object_->Update();
    // æ™‚é–“çµŒéŽã‚«ã‚¦ãƒ³ãƒˆï¼ˆå¯¿å‘½åˆ¶å¾¡ï¼‰
    if (time_ < Maxtime_) {
        time_++;
    } else {
        // ä¸€å®šæ™‚é–“çµŒéŽå¾Œã¯éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ï¼ˆå‰Šé™¤å¯¾è±¡ï¼‰
        time_ = 0;
        active_ = false;
    }
}

///====================================================
/// æç”»å‡¦ç†
///====================================================
void EnemyBullet::Draw() {       
	object_->Draw();
}

///====================================================
/// å½“ãŸã‚Šåˆ¤å®šç”¨OBBã®å–å¾—
///====================================================
OBB EnemyBullet::GetOBB() const {
    OBB obb;

    // ä¸­å¿ƒã¯ç¾åœ¨ã®ä½ç½®
    obb.center = transform_.translate;

    // ã‚µã‚¤ã‚ºï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ã®åŠåˆ†ã‚’ãƒãƒ¼ãƒ•ã‚µã‚¤ã‚ºã«ã™ã‚‹
    obb.halfSize = { transform_.scale.x };

    // è»¸ã¯XYZã®å˜ä½ãƒ™ã‚¯ãƒˆãƒ«
    obb.axis[0] = {1, 0, 0}; // Xè»¸
    obb.axis[1] = {0, 1, 0}; // Yè»¸
    obb.axis[2] = {0, 0, 1}; // Zè»¸

    return obb;
}

============================================================
File Path: project/application/bullet/EnemyBullet.h
============================================================
#pragma once
#include <BaseBullet.h>
#include <Transform.h>
#include <BaseCharacter.h>
#include<OBB.h>

// ãƒ˜ãƒƒãƒ€ãƒ¼ã®é‡è¤‡ã‚’é˜²ãå‰æ–¹å®£è¨€
class Object3d;

/// <summary>
/// æ•µã®å¼¾ã‚¯ãƒ©ã‚¹
/// BaseBulletã‚’ç¶™æ‰¿
/// æ•µã®å¼¾ã®ç”Ÿæˆãƒ»ç§»å‹•ãƒ»æç”»ãƒ»è¡çªåˆ¤å®šã‚’ç®¡ç†ã™ã‚‹
/// </summary>
class EnemyBullet : public BaseBullet {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// ãƒ¡ãƒ³ãƒå¤‰æ•°ã®åˆæœŸåŒ–ãªã©ã‚’è¡Œã†
    /// </summary>
    EnemyBullet();
    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// ãƒªã‚½ãƒ¼ã‚¹ã®è§£æ”¾å‡¦ç†ã‚’è¡Œã†
    /// </summary>
    ~EnemyBullet() override;    
    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// ãƒ¡ãƒ¢ãƒªè§£æ”¾ãªã©ã®å¾Œå‡¦ç†ã‚’è¡Œã†
    /// </summary>
    void Finalize() override;
    /// <summary>
    /// å¼¾ã®åˆæœŸåŒ–ï¼ˆå…±é€šå‡¦ç†ï¼‰
    /// ãƒ¢ãƒ‡ãƒ«ã‚„åŸºæœ¬è¨­å®šã®ãƒ­ãƒ¼ãƒ‰ãªã©ã‚’è¡Œã†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// å¼¾ã®åˆæœŸåŒ–ï¼ˆç™ºå°„ä½ç½®ãƒ»ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‚’æŒ‡å®šï¼‰
    /// </summary>
    /// <param name="startPos">ç™ºå°„ä½ç½®ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰</param>
    /// <param name="targetPos">ç‹™ã†ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ä½ç½®ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰</param>
    /// <param name="speed">å¼¾ã®é€Ÿåº¦</param>
    void Initialize(const Vector3& startPos, const Vector3& targetPos, float speed) override;
  
        
    void Initialize(const Vector3& startPos, const Vector3& targetPos, const Vector3& cameraForward, float speed);

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// ç§»å‹•ãƒ»å¯¿å‘½ç®¡ç†ãƒ»è¡çªåˆ¤å®šãªã©ã‚’è¡Œã†
    /// </summary>
    void Update() override;
    /// <summary>
    /// æç”»å‡¦ç†
    /// å¼¾ãƒ¢ãƒ‡ãƒ«ã‚’3Dç©ºé–“ã«æç”»ã™ã‚‹
    /// </summary>
    void Draw() override;
    /// <summary>
    /// å¼¾ã®å½“ãŸã‚Šåˆ¤å®šæƒ…å ±ï¼ˆOBBï¼‰ã‚’å–å¾—ã™ã‚‹
    /// </summary>
    /// <returns>å¼¾ã®OBBï¼ˆå›žè»¢ä»˜ãå½“ãŸã‚Šåˆ¤å®šï¼‰</returns>
    OBB GetOBB() const;
private:    // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    std::unique_ptr<Object3d> object_;
    // ä½ç½®ãƒ»å›žè»¢ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ± 
    Transform transform_;
	// æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
    Vector3 direction_;
	// é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
    Vector3 velocity_;
	// ç¾åœ¨ã®ç”Ÿå­˜æ™‚é–“
    int time_;
	// æœ€å¤§ç”Ÿå­˜æ™‚é–“
    int Maxtime_;
public:  // ã‚¢ã‚¯ã‚»ãƒƒã‚µï¼ˆGetter / Setterï¼‰    
    /// Transformã‚’å–å¾—
    Transform GetTransform() const { return transform_; }
    /// ç¾åœ¨ä½ç½®ã‚’å–å¾—
    Vector3 GetTranslate() const { return transform_.translate; }
    /// ã‚µã‚¤ã‚ºã‚’å–å¾—
    Vector3 GetScale() const { return transform_.scale; }  

    /// Transformã‚’è¨­å®š
    void SetTranslate(const Transform& transform) {  transform_ = transform; } 
    /// ç¾åœ¨ä½ç½®ã‚’è¨­å®š
    void SetTranslate(const Vector3& translate) { transform_.translate = translate; } 
    /// ã‚µã‚¤ã‚ºã‚’è¨­å®š
    void SetScale(const Vector3& scale) { transform_.scale = scale; }
};


============================================================
File Path: project/application/bullet/PlayerBullet.cpp
============================================================
#include "PlayerBullet.h"
#include <Object3d.h>
#include <ModelManager.h>
#include <MatrixVector.h>

using namespace MatrixVector;

///====================================================
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///====================================================
PlayerBullet::PlayerBullet() {}

///====================================================
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///====================================================
PlayerBullet::~PlayerBullet() {
    Finalize();  // ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
}

///====================================================
/// çµ‚äº†å‡¦ç†ï¼ˆãƒªã‚½ãƒ¼ã‚¹è§£æ”¾ï¼‰
///====================================================
void PlayerBullet::Finalize() {
	if (object_) {
		object_.reset(); // ãƒ¡ãƒ¢ãƒªé–‹æ”¾
	}
}

///====================================================
/// åˆæœŸåŒ–å‡¦ç†ï¼ˆå…±é€šï¼‰
/// â€»ä»Šå›žã¯æœªä½¿ç”¨ã€ç¶™æ‰¿å…ˆã‚„å…±é€šåˆæœŸåŒ–ç”¨ã«æ®‹ã—ã¦ã‚ã‚‹
///====================================================
void PlayerBullet::Initialize() {}
void PlayerBullet::Initialize(const Vector3& startPos, const Vector3& targetPos, float speed) {
    // åˆæœŸä½ç½®ã‚’è¨­å®š
    transform_.translate = startPos;
    // å¼¾ã®å¤§ãã•ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ã‚’è¨­å®š  
    transform_.scale = { 0.5f, 0.5f, 0.5f };
    // ãƒ¢ãƒ‡ãƒ«ãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã‘ã‚Œã°ãƒ­ãƒ¼ãƒ‰ï¼†ç”Ÿæˆ
    if (!object_) {
        // ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        ModelManager::GetInstance()->LoadModel("Bullet/PlayerBullet.obj");
        // å¼¾ç”¨ã®3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆï¼ˆTransformæƒ…å ±ã‚’æ¸¡ã™ï¼‰
        object_ = Object3d::Create(
            "Bullet/PlayerBullet.obj",
            transform_
        );
        // ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®š
        object_->SetScale({ 0.5f, 0.5f, 0.5f });
    }
    // ç™ºå°„æ–¹å‘ã®è¨ˆç®—ï¼šã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’æ­£è¦åŒ–ã—ã¦å‘ãã‚’æ±‚ã‚ã‚‹
    Vector3 dir = Normalize(targetPos - startPos);
    // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆæ–¹å‘ Ã— é€Ÿåº¦ï¼‰
    velocity_ = dir * speed;
    // å¼¾ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã«ã™ã‚‹ï¼ˆUpdateå¯¾è±¡ã«ã™ã‚‹ï¼‰
    active_ = true;
    // å¼¾ã®å¯¿å‘½ç®¡ç†ç”¨ã‚¿ã‚¤ãƒžãƒ¼åˆæœŸåŒ–
    time_ = 0;
    Maxtime_ = 1000;
}

///====================================================
/// åˆæœŸåŒ–å‡¦ç†ï¼ˆç™ºå°„è¨­å®šä»˜ãï¼‰
/// <param name="startPos">å¼¾ã®ç™ºå°„ä½ç½®</param>
/// <param name="targetPos">ç‹™ã†ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ä½ç½®</param>
/// <param name="speed">å¼¾ã®é€Ÿåº¦</param>
///====================================================
void PlayerBullet::Initialize(const Vector3& startPos, const Vector3& targetPos,const Vector3& cameraForward, float speed) {
    // åˆæœŸä½ç½®ã‚’è¨­å®š
    transform_.translate = startPos;
    // å¼¾ã®å¤§ãã•ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ï¼‰ã‚’è¨­å®š  
    transform_.scale = { 0.5f, 0.5f, 0.5f };
    // ãƒ¢ãƒ‡ãƒ«ãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã‘ã‚Œã°ãƒ­ãƒ¼ãƒ‰ï¼†ç”Ÿæˆ
    if (!object_) {
        // ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        ModelManager::GetInstance()->LoadModel("Bullet/PlayerBullet.obj");
        // å¼¾ç”¨ã®3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆï¼ˆTransformæƒ…å ±ã‚’æ¸¡ã™ï¼‰
        object_ = Object3d::Create("Bullet/PlayerBullet.obj", transform_);
        // ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®š
        object_->SetScale({ 0.5f, 0.5f, 0.5f });
    }
  
    // --- ã‚«ãƒ¡ãƒ©å‰æ–¹å‘ã«åŸºã¥ãä¿®æ­£ ---
    // å®Œå…¨ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ–¹å‘ã¸é£›ã°ã™
    Vector3 dir = Normalize(targetPos - startPos);

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ–¹å‘ã‚’ã‚«ãƒ¡ãƒ©ã®å‰æ–¹å‘ã«ã€Œå¯„ã›ã‚‹ã€
    float yaw = std::atan2(dir.x, dir.z);
    float pitch = -std::asin(dir.y);
    transform_.rotate = { pitch, yaw, 0.0f };
    // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆæ–¹å‘ Ã— é€Ÿåº¦ï¼‰
    velocity_ = dir * speed;
    // å¼¾ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã«ã™ã‚‹ï¼ˆUpdateå¯¾è±¡ã«ã™ã‚‹ï¼‰
    active_ = true;
    // å¼¾ã®å¯¿å‘½ç®¡ç†ç”¨ã‚¿ã‚¤ãƒžãƒ¼åˆæœŸåŒ–
    time_ = 0;
    Maxtime_ = 1000;
}

///====================================================
/// æ›´æ–°å‡¦ç†
///====================================================
void PlayerBullet::Update() {
    // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’åŠ ãˆã‚‹
    transform_.translate = transform_.translate + velocity_;
    // åº§æ¨™ã‚’æ›´æ–°
    object_->SetTranslate(transform_.translate);
    object_->SetRotate(transform_.rotate);
    object_->SetScale(transform_.scale);
    // æ›´æ–°å‡¦ç†
    object_->Update();
    // æ™‚é–“çµŒéŽã‚«ã‚¦ãƒ³ãƒˆï¼ˆå¯¿å‘½åˆ¶å¾¡ï¼‰
    if (time_ < Maxtime_) {
        time_++;
    } else {
        // ä¸€å®šæ™‚é–“çµŒéŽå¾Œã¯éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ï¼ˆå‰Šé™¤å¯¾è±¡ï¼‰
        time_ = 0;
        active_ = false;
    }
}

///====================================================
/// æç”»å‡¦ç†
///====================================================
void PlayerBullet::Draw() {
    object_->Draw();
}

///====================================================
/// å½“ãŸã‚Šåˆ¤å®šç”¨OBBã®å–å¾—
///====================================================
OBB PlayerBullet::GetOBB() const {
    OBB obb;

    // ä¸­å¿ƒã¯ç¾åœ¨ã®ä½ç½®
    obb.center = transform_.translate;

    // ã‚µã‚¤ã‚ºï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ï¼‰
    obb.halfSize = { transform_.scale};

    // è»¸ã¯XYZã®å˜ä½ãƒ™ã‚¯ãƒˆãƒ«
    obb.axis[0] = { 1,0,0 }; // Xè»¸
    obb.axis[1] = { 0,1,0 }; // Yè»¸
    obb.axis[2] = { 0,0,1 }; // Zè»¸

    return obb;
}

============================================================
File Path: project/application/bullet/PlayerBullet.h
============================================================
#pragma once
#include <BaseBullet.h>
#include <Transform.h>
#include <BaseCharacter.h>
#include<OBB.h>

// ãƒ˜ãƒƒãƒ€ãƒ¼ã®é‡è¤‡ã‚’é˜²ãå‰æ–¹å®£è¨€
class Object3d;

/// <summary>
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã‚¯ãƒ©ã‚¹
/// BaseBulletã‚’ç¶™æ‰¿
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã®ç”Ÿæˆãƒ»ç§»å‹•ãƒ»æç”»ãƒ»è¡çªåˆ¤å®šã‚’ç®¡ç†ã™ã‚‹
/// </summary>
class PlayerBullet : public BaseBullet {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// ãƒ¡ãƒ³ãƒå¤‰æ•°ã®åˆæœŸåŒ–ãªã©ã‚’è¡Œã†
    /// </summary>
    PlayerBullet();
    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// ãƒªã‚½ãƒ¼ã‚¹ã®è§£æ”¾å‡¦ç†ã‚’è¡Œã†
    /// </summary>
    ~PlayerBullet() override;
    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// ãƒ¡ãƒ¢ãƒªè§£æ”¾ãªã©ã®å¾Œå‡¦ç†ã‚’è¡Œã†
    /// </summary>
    void Finalize() override;
    /// <summary>
    /// å¼¾ã®åˆæœŸåŒ–ï¼ˆå…±é€šå‡¦ç†ï¼‰
    /// ãƒ¢ãƒ‡ãƒ«ã‚„åŸºæœ¬è¨­å®šã®ãƒ­ãƒ¼ãƒ‰ãªã©ã‚’è¡Œã†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// å¼¾ã®åˆæœŸåŒ–ï¼ˆç™ºå°„ä½ç½®ãƒ»ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‚’æŒ‡å®šï¼‰
    /// </summary>
    /// <param name="startPos">ç™ºå°„ä½ç½®ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰</param>
    /// <param name="targetPos">ç‹™ã†ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ä½ç½®ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰</param>
    /// <param name="speed">å¼¾ã®é€Ÿåº¦</param>
    void Initialize(const Vector3& startPos, const Vector3& targetPos,float speed) override;

    void Initialize(const Vector3& startPos, const Vector3& targetPos, const Vector3& cameraForward, float speed);

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// ç§»å‹•ãƒ»å¯¿å‘½ç®¡ç†ãƒ»è¡çªåˆ¤å®šãªã©ã‚’è¡Œã†
    /// </summary>
    void Update() override;
    /// <summary>
    /// æç”»å‡¦ç†
    /// å¼¾ãƒ¢ãƒ‡ãƒ«ã‚’3Dç©ºé–“ã«æç”»ã™ã‚‹
    /// </summary>
    void Draw() override;
    /// <summary>
    /// å¼¾ã®å½“ãŸã‚Šåˆ¤å®šæƒ…å ±ï¼ˆOBBï¼‰ã‚’å–å¾—ã™ã‚‹
    /// </summary>
    /// <returns>å¼¾ã®OBBï¼ˆå›žè»¢ä»˜ãå½“ãŸã‚Šåˆ¤å®šï¼‰</returns>
    OBB GetOBB() const;
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    std::unique_ptr<Object3d> object_;	   
    // ä½ç½®ãƒ»å›žè»¢ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ± 
    Transform transform_;
	// æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
    Vector3 direction_;
	// é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
    Vector3 velocity_;
	// ç¾åœ¨ã®ç”Ÿå­˜æ™‚é–“
    int time_;
   	// æœ€å¤§ç”Ÿå­˜æ™‚é–“
    int Maxtime_;


public: // ã‚¢ã‚¯ã‚»ãƒƒã‚µï¼ˆGetter / Setterï¼‰
	/// Transformã‚’å–å¾—
    Transform GetTransform() const { return transform_; }
    /// ç¾åœ¨ä½ç½®ã‚’å–å¾—
    Vector3 GetTranslate() const { return transform_.translate ; }
    /// ã‚µã‚¤ã‚ºã‚’å–å¾—
    Vector3 GetScale() const { return transform_.scale; }


    /// Transformã‚’è¨­å®š
    void SetTranslate(const Transform& transform) {  transform_ = transform; } 
    /// ç¾åœ¨ä½ç½®ã‚’è¨­å®š
    void SetTranslate(const Vector3& translate) {  transform_.translate = translate; } 
    /// ã‚µã‚¤ã‚ºã‚’è¨­å®š
    void SetScale(const Vector3& scale) { transform_.scale = scale; }
};

============================================================
File Path: project/application/camera/GameClearCamera.cpp
============================================================
#include "GameClearCamera.h"
#include <CameraManager.h>
#include <MatrixVector.h>

using namespace MatrixVector;

void GameClearCamera::Initialize() {
    // ã‚«ãƒ¡ãƒ©ã®å€¤ã®åˆæœŸåŒ–
    transform_ = { { 0.0f,0.0f,0.0f },{ 0.0f, 0.0f, 0.0f} };


}

void GameClearCamera::Update() {
    // ã‚«ãƒ¡ãƒ©ä½ç½®ã¯å›ºå®š 
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã¿ã«é©å¿œ
    if (CameraManager::GetInstance()->GetMode() == CameraMode::Default) {
        Vector3 camPos = transform_.translate;
        Vector3 targetPos = target_->GetWorldPosition();
        Vector3 dir = targetPos - camPos;

        // æ­£è¦åŒ–ï¼ˆã‚¼ãƒ­å‰²å¯¾ç­–ï¼‰
        if (Length(dir) > 0.0001f) {
            dir = Normalize(dir);

            // --- ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ–¹å‘ã¸å›žè»¢ã‚’è¨­å®š ---
            float yaw = atan2f(dir.x, dir.z);
            float pitch = -asinf(dir.y);

            transform_.rotate = { pitch, yaw, 0.0f };
        }
    }
}

void GameClearCamera::AddSubCamera(const CameraTransform& trans) {
    // æ–°ã—ã„ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
    std::unique_ptr<Camera> cam = std::make_unique<Camera>();

    // æ¸¡ã•ã‚ŒãŸCameraTransformã‚’å…ƒã«ã€ä½ç½®ã¨è§’åº¦ã‚’è¨­å®š
    cam->SetTranslate(trans.translate);
    cam->SetRotate(trans.rotate);

    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ãƒªã‚¹ãƒˆã¸è¿½åŠ ï¼ˆunique_ptrã®æ‰€æœ‰æ¨©ã‚’ç§»å‹•
    subcameras_.push_back(std::move(cam));
}

void GameClearCamera::AddSubCameras(const std::vector<CameraTransform>& transforms) {
    for (const CameraTransform& trans : transforms) {
        // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚’è¤‡æ•°ç™»éŒ²ã™ã‚‹
        AddSubCamera(trans);
    }
}

============================================================
File Path: project/application/camera/GameClearCamera.h
============================================================
#pragma once
#include<SceneCameraBase.h>
#include <Object3d.h>

// ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢å°‚ç”¨ã‚«ãƒ¡ãƒ©
class GameClearCamera : public SceneCameraBase {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary> 
    void Update() override;
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®è¿½åŠ 
    void AddSubCamera(const CameraTransform& trans) override;
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®è¿½åŠ ï¼ˆè¤‡æ•°ç™»éŒ²ã«å¯¾å¿œï¼‰
    void AddSubCameras(const std::vector<CameraTransform>& transforms) override;

    // --- è¿½å¾“å¯¾è±¡ã‚’è¨­å®š ---
    void SetTarget(Object3d* target) { target_ = target; }

    void MoveCameraX(float ease) {
        float startX = 0.0f;
        float endX = 8.0f;

        transform_.translate.x = startX + (endX - startX) * ease;
    }
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
   
    // è¿½å¾“å¯¾è±¡
    Object3d* target_ = nullptr;

    float followDistance_ = -20.0f; // å¾Œã‚ã‹ã‚‰è¦‹ã‚‹è·é›¢ï¼ˆèª¿æ•´å¯ï¼‰

};

============================================================
File Path: project/application/camera/GameOverCamera.cpp
============================================================
#include "GameOverCamera.h"

void GameOverCamera::Initialize() {
    // ã‚«ãƒ¡ãƒ©ã®å€¤ã®åˆæœŸåŒ–
    transform_ = { { 0.0f,0.0f,0.0f },{ 0.0f, 0.0f, 0.0f} };
}

void GameOverCamera::Update(){}

void GameOverCamera::AddSubCamera(const CameraTransform& trans) {
    // æ–°ã—ã„ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
    std::unique_ptr<Camera> cam = std::make_unique<Camera>();

    // æ¸¡ã•ã‚ŒãŸCameraTransformã‚’å…ƒã«ã€ä½ç½®ã¨è§’åº¦ã‚’è¨­å®š
    cam->SetTranslate(trans.translate);
    cam->SetRotate(trans.rotate);

    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ãƒªã‚¹ãƒˆã¸è¿½åŠ ï¼ˆunique_ptrã®æ‰€æœ‰æ¨©ã‚’ç§»å‹•
    subcameras_.push_back(std::move(cam));
}

void GameOverCamera::AddSubCameras(const std::vector<CameraTransform>& transforms) {
    for (const CameraTransform& trans : transforms) {
        // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚’è¤‡æ•°ç™»éŒ²ã™ã‚‹
        AddSubCamera(trans);
    }
}

============================================================
File Path: project/application/camera/GameOverCamera.h
============================================================
#pragma once
#include<SceneCameraBase.h>

// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å°‚ç”¨ã‚«ãƒ¡ãƒ©
class GameOverCamera : public SceneCameraBase {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary> 
    void Update() override;

    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®è¿½åŠ 
    void AddSubCamera(const CameraTransform& trans) override;
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®è¿½åŠ ï¼ˆè¤‡æ•°ç™»éŒ²ã«å¯¾å¿œï¼‰
    void AddSubCameras(const std::vector<CameraTransform>& transforms) override;
};

============================================================
File Path: project/application/camera/GamePlayCamera.cpp
============================================================
#include "GamePlayCamera.h"
#include<MatrixVector.h>
#include<algorithm> 
#include<CameraManager.h>
#include<MathUtil.h>

using namespace MathUtil;
using namespace MatrixVector;

///====================================================
/// åˆæœŸåŒ–å‡¦ç†
///====================================================
void GamePlayCamera::Initialize() {
    Jsondata = new CurveJsonLoader();
    bezierPoints = Jsondata->LoadBezierFromJSON("Resources/levels/bezier.json");
    // ã‚«ãƒ¡ãƒ©ã®åˆæœŸè¨­å®š
    //mode_ = ViewType::Main;

    speed = 0.3f;        // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ãŸã‚Šç§»å‹•è·é›¢
    movefige = true;
    currentSegment = 0;

    // åˆæœŸä½ç½®ã‚’æœ€åˆã®åˆ¶å¾¡ç‚¹ã«åˆã‚ã›ã‚‹
    bezierPos_ = bezierPoints[0].controlPoint;
    prevForward = { 0, 0, 1 }; // åˆæœŸå‘ã
    // ãƒ¡ã‚¤ãƒ³
    transform_ = { bezierPos_,LookAtRotation(prevForward) };
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ç™»éŒ² 
    std::vector<CameraTransform> subCams = { { {2, 0, 50}, {0, 0, 0} } };
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚’è¿½åŠ 
    AddSubCameras(subCams);

    // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ã¯è¿½å¾“ãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹
    CameraManager::GetInstance()->SetMode(CameraMode::Follow);

    followInitialized_ = false;
    subOffset_ = { 5.5f,-1.0f,15.0f };

    railInfo_.totalLength = 0.0f;
    railInfo_.segmentLengths.clear();

    for (size_t i = 0; i + 1 < bezierPoints.size(); ++i) {
        float len = Length(
            bezierPoints[i + 1].controlPoint -
            bezierPoints[i].controlPoint
        );
        railInfo_.segmentLengths.push_back(len);
        railInfo_.totalLength += len;
    }

    currentRailLength_ = 0.0f;
    prevPos_ = bezierPos_;
}

///====================================================
/// æ›´æ–°å‡¦ç†ï¼ˆè¤‡æ•°åˆ¶å¾¡ç‚¹å¯¾å¿œï¼‹å‘ãè£œé–“ï¼‰
///====================================================
void GamePlayCamera::Update() {
    if (bezierPoints.size() < 3) return;
    // ç¯„å›²ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€å¾Œã¾ã§è¡Œã£ãŸã‚‰åœæ­¢ï¼‰
    if (currentSegment >= bezierPoints.size() - 1) {
        // æœ€å¾Œã¾ã§è¡Œã£ãŸã‚‰åœæ­¢ã™ã‚‹å ´åˆï¼š
        movefige = false;
        return;
    }

    if (CameraManager::GetInstance()->GetMode() == CameraMode::Transition) {
//        UpdateTransition();

        CameraManager::GetInstance()->SetTypeview(ViewCameraType::Sub);


    } else if (CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Main && CameraManager::GetInstance()->GetMode() == CameraMode::Follow) {
        if (CheckAndResumeMovement())
            UpdateBezierMovement();
        transform_.translate = bezierPos_;
        UpdateCameraRotation();
    } else if (CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Sub) {     // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®å‡¦ç†
        UpdateSubCameraFollow();
    }


}

bool GamePlayCamera::CheckAndResumeMovement() {
    if (!movefige) {
        // å†é–‹æ¡ä»¶ï¼šç¾åœ¨ã¨æ¬¡ã®åˆ¶å¾¡ç‚¹ãŒã€Œé€šéŽè¨±å¯æ¸ˆã¿ã€
        if (bezierPoints[currentSegment].passed && bezierPoints[currentSegment].passed) {
            movefige = true;
            return true;
        } else {
            return false; // è¨±å¯ãŒå‡ºã‚‹ã¾ã§åœæ­¢
        }
    }
    return true; // é€šå¸¸é€²è¡ŒOK
}


void GamePlayCamera::UpdateBezierMovement() {
    // ç¾åœ¨ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ start / end
    const Vector3& start = bezierPoints[currentSegment].controlPoint;
    const Vector3& end = bezierPoints[currentSegment + 1].controlPoint;
    Vector3 oldPos = bezierPos_;

    // --- ç›´ç·šãƒ¢ãƒ¼ãƒ‰ï¼ˆstart â†’ point_01ï¼‰ ---
    if (currentSegment == 0) {
        Vector3 dir = end - bezierPos_;
        float dist = Length(dir);


        if (dist <= speed) {
            bezierPos_ = end;
            bezierPoints[currentSegment].passed = true;
            currentSegment++;
        } else {
            bezierPos_ += Normalize(dir) * speed; // ãƒ™ã‚¯ãƒˆãƒ«ç›´é€²
            currentRailLength_ += Length(Normalize(dir) * speed); // â˜…è¿½åŠ 
        }
        return;
    }

    // --- è£œå®Œãƒ¢ãƒ¼ãƒ‰ï¼ˆãã‚Œä»¥é™ï¼‰ ---
    // ç¾åœ¨ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆé•·ã‚’å–å¾—ï¼ˆCatmull-Romè£œé–“ã‚’è·é›¢åŸºæº–ã§é€²ã‚ã‚‹ãŸã‚ï¼‰
    Vector3 p0 = (currentSegment > 0) ? bezierPoints[currentSegment - 1].controlPoint : start;
    Vector3 p1 = start;
    Vector3 p2 = end;
    Vector3 p3 = (currentSegment + 2 < bezierPoints.size()) ? bezierPoints[currentSegment + 2].controlPoint : end;
  
    // ç°¡æ˜“çš„ã«ã‚»ã‚°ãƒ¡ãƒ³ãƒˆé•·ã‚’ã€Œç›´ç·šè·é›¢ã€ã§è¿‘ä¼¼
    float segmentLength = Length(p2 - p1);
    if (segmentLength < 0.0001f) segmentLength = 0.0001f;

    // t ã®å¢—åˆ†ã‚’è·é›¢åŸºæº–ã§è¨ˆç®—
    float deltaT = speed / segmentLength;
    t_ += deltaT;

    if (t_ >= 1.0f) {
        t_ = 0.0f;
        currentSegment++;
        bezierPos_ = end;

        if (currentSegment >= bezierPoints.size() - 1) {
            movefige = false;
            return;
        }
    } else {
        // Catmull-Rom è£œé–“
        bezierPos_ = CatmullRom(p0, p1, p2, p3, t_);
    }
    // ç§»å‹•è·é›¢ã‚’ç´¯ç©
    currentRailLength_ += Length(bezierPos_ - oldPos);
    prevPos_ = bezierPos_;
}

void GamePlayCamera::UpdateCameraRotation() {
    // === å‘ãè£œé–“ï¼ˆæ”¹è‰¯ç‰ˆï¼‰ ===
    Vector3 targetForward;

    if (currentSegment < bezierPoints.size() - 1) {
        // æ¬¡ã®åˆ¶å¾¡ç‚¹ã¨ã•ã‚‰ã«æ¬¡ã®åˆ¶å¾¡ç‚¹ã‚’ä½¿ã£ã¦ã€æ»‘ã‚‰ã‹ãªæŽ¥ç·šæ–¹å‘ã‚’æ±‚ã‚ã‚‹
        Vector3 next = bezierPoints[currentSegment + 1].controlPoint;
        Vector3 next2 = (currentSegment + 2 < bezierPoints.size()) ?
            bezierPoints[currentSegment + 2].controlPoint : next;

        // ç¾åœ¨â†’æ¬¡ã®æ–¹å‘ã‚’0.7ã€æ¬¡â†’æ¬¡ã®æ¬¡ã®æ–¹å‘ã‚’0.3æ··ãœã‚‹ï¼ˆæ›²ãŒã‚Šã‚’ç·©ã‚„ã‹ã«ï¼‰
        targetForward = Normalize((next - bezierPos_) * 0.7f + (next2 - next) * 0.3f);
    } else {
        targetForward = prevForward;
    }

    // å‰å›žã®forwardã¨ä»Šå›žã®forwardã®è§’åº¦å·®ã‚’è¨ˆç®—
    float dot = std::clamp(Dot(prevForward, targetForward), -1.0f, 1.0f);
    float angle = acosf(dot);

    // æ›²ãŒã‚‹è§’åº¦ãŒå¤§ãã„ã»ã©è£œé–“ã‚’é€Ÿãã€å°ã•ã„ã»ã©ã‚†ã£ãã‚Š
    float smooth = std::clamp(angle * 0.1f, 0.02f, 0.15f);

    // çƒé¢ç·šå½¢è£œé–“ï¼ˆSlerpï¼‰ã§å‘ãã‚’æ»‘ã‚‰ã‹ã«è£œé–“
    Vector3 newForward = Slerp(prevForward, targetForward, smooth);
    newForward = Normalize(newForward);

    prevForward = newForward;

    // ---------- forward æ›´æ–° ----------
    forward_ = newForward;

    // ---------- right / up ã‚’æ›´æ–° ----------
    // ä¸–ç•Œã®ä¸Šæ–¹å‘ï¼ˆYè»¸ï¼‰
    Vector3 worldUp = { 0,1,0 };

    // right = forward Ã— worldUp
    right_ = Normalize(Cross(worldUp, forward_));

    // up = right Ã— forwardï¼ˆç›´äº¤åŒ–ï¼‰
    up_ = Normalize(Cross(forward_, right_));
 
    // ã‚«ãƒ¡ãƒ©ã® transform.rotate æ›´æ–°
    transform_.rotate = LookAtRotation(forward_);
}

Vector3 GamePlayCamera::CatmullRom(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector3& p3, float t) {
    float t2 = t * t;
    float t3 = t2 * t;

    return 0.5f * (
        (2.0f * p1) +
        (-p0 + p2) * t +
        (2.0f*p0 - 5.0f*p1 + 4.0f*p2 - p3) * t2 +
        (-p0 + 3.0f*p1 - 3.0f*p2 + p3) * t3
    );
}

void GamePlayCamera::AddSubCamera(const CameraTransform& trans) {
    // æ–°ã—ã„ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
    std::unique_ptr<Camera> cam = std::make_unique<Camera>();

    // æ¸¡ã•ã‚ŒãŸCameraTransformã‚’å…ƒã«ã€ä½ç½®ã¨è§’åº¦ã‚’è¨­å®š
    cam->SetTranslate(trans.translate);
    cam->SetRotate(trans.rotate);

    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ãƒªã‚¹ãƒˆã¸è¿½åŠ 
    subcameras_.push_back(std::move(cam)); // æ‰€æœ‰æ¨©ã‚’ç§»å‹•
}

void GamePlayCamera::AddSubCameras(const std::vector<CameraTransform>& transforms) {
    for (const CameraTransform& trans : transforms) {
        // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚’è¤‡æ•°ç™»éŒ²ã™ã‚‹
        AddSubCamera(trans);
    }
}

void GamePlayCamera::UpdateTransition() {
    auto* cm = CameraManager::GetInstance();

    Camera* mainCam = cm->GetMainCamera();
    Camera* subCam = cm->GetActiveCamera();

    if (!mainCam || !subCam || !followTarget_) return;

    // åˆå›žã ã‘åˆæœŸä½ç½®ã‚’ä¿å­˜
    if (!isTransitioning_) {
        isTransitioning_ = true;

        mainStartPos_ = mainCam->GetTranslate();
        mainStartRot_ = mainCam->GetRotate();

        subStartPos_ = subCam->GetTranslate();

        Vector3 targetPos = followTarget_->GetWorldPosition();

        mainTargetPos_ = targetPos + subOffset_;
        subTargetPos_ = targetPos + subOffset_;

        transitionTimer_ = 0.0f;
    }

    transitionTimer_ += 1.0f / 60.0f;
    float t = transitionTimer_ / transitionDuration_;
    if (t > 1.0f) t = 1.0f;

    // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°
    float easeT = t * t * (3.0f - 2.0f * t);

    // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©è£œé–“
    Vector3 mainPos = mainStartPos_ * (1 - easeT) + mainTargetPos_ * easeT;
    mainCam->SetTranslate(mainPos);

    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚‚â€œå°‘ã—é…ã‚Œã¦â€è¿½å¾“
    float followEase = 0.1f;
    Vector3 subNow = subCam->GetTranslate();
    Vector3 subPos = subNow + (subTargetPos_ - subNow) * followEase;
    subCam->SetTranslate(subPos);

    // å‘ãæ›´æ–°
    Vector3 dir = Normalize(mainTargetPos_ - mainPos);
    float yaw = atan2f(dir.x, dir.z);
    float pitch = -asinf(dir.y);
    mainCam->SetRotate({ pitch, yaw, 0.0f });

    // å®Œäº†å‡¦ç†
    if (t >= 1.0f) {
        cm->SetTypeview(ViewCameraType::Sub);
        cm->SetCameraMode(CameraMode::Default);
        isTransitioning_ = false;
    }
}


void GamePlayCamera::UpdateSubCameraFollow() {
    if (!followTarget_) return;

    Camera* subCam = CameraManager::GetInstance()->GetActiveCamera();
    if (!subCam) return;

    Vector3 targetPos = followTarget_->GetWorldPosition();
    Vector3 desiredPos = targetPos + subOffset_;

    // â€» è¿½å¾“ã‚‚ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°åŒ–
    float ease = 0.15f;
    Vector3 nowPos = subCam->GetTranslate();
    Vector3 newPos = nowPos + (desiredPos - nowPos) * ease;
    subCam->SetTranslate(newPos);

    Vector3 dir = targetPos - newPos;
    if (Length(dir) > 0.0001f) {
        dir = Normalize(dir);
        float yaw = atan2f(dir.x, dir.z);
        float pitch = -asinf(dir.y);
        subCam->SetRotate({ pitch, yaw, 0.0f });
    }
}
float GamePlayCamera::GetRailProgressRate() const {
    if (railInfo_.totalLength <= 0.0001f) return 0.0f;
    return std::clamp(currentRailLength_ / railInfo_.totalLength, 0.0f, 1.0f);
}

============================================================
File Path: project/application/camera/GamePlayCamera.h
============================================================
#pragma once
#include <Vector3.h>
#include <CurveJsonLoader.h>
#include<Quaternion.h>
#include <Object3d.h>
#include<SceneCameraBase.h>

struct RailInfo {
    float totalLength = 0.0f;
    std::vector<float> segmentLengths;
};

///====================================================
/// GamePlayCameraã‚¯ãƒ©ã‚¹
/// <summary>
/// ãƒ™ã‚¸ã‚§æ›²ç·šã‚’ã‚‚ã¨ã«ã‚«ãƒ¡ãƒ©ã‚’è‡ªå‹•ç§»å‹•ã•ã›ã‚‹ã‚¯ãƒ©ã‚¹
/// ã‚«ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ï¼ˆåˆ¶å¾¡ç‚¹ï¼‰ã¯JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€
/// </summary>
///====================================================
class GamePlayCamera : public SceneCameraBase {
public:
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize();
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();

    //Quaternion ForwardToQuaternion(const Vector3& forward);

    // ç§»å‹•åœæ­¢ãƒ»å†é–‹ã®ç¢ºèª
    bool CheckAndResumeMovement();
    void UpdateBezierMovement();
    void UpdateCameraRotation();

    //void SwitchView(ViewType  targetType); // â† ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆã‚’é–‹å§‹ã™ã‚‹
    // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ç§»å‹•
    void UpdateTransition();

    // ViewType GetCurrentView() const { return mode_; }

   //  void SetCurrentView(ViewType view) { mode_ = view; }

    void UpdateSubCameraFollow(const Vector3& targetPos, const Vector3& offset);

    Vector3 CatmullRom(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector3& p3, float t);

    Camera* GetActiveCamera();

    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®è¿½åŠ 
    void AddSubCamera(const CameraTransform& trans) override;
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®è¿½åŠ ï¼ˆè¤‡æ•°ç™»éŒ²ã«å¯¾å¿œï¼‰
    void AddSubCameras(const std::vector<CameraTransform>& transforms) override;

    //void StartCameraTransition(ViewCameraType targetType, const std::string& subName);

    void UpdateSubCameraFollow();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    CurveJsonLoader* Jsondata = nullptr;         // ãƒ™ã‚¸ã‚§åˆ¶å¾¡ç‚¹ã‚’èª­ã¿è¾¼ã‚€ãƒ­ãƒ¼ãƒ€ãƒ¼

    Vector3 bezierPos_;                          // ç¾åœ¨ã®ãƒ™ã‚¸ã‚§æ›²ç·šä¸Šã®ä½ç½®
    std::vector<BezierPoint> bezierPoints;       // ç§»å‹•ã«ä½¿ã†åˆ¶å¾¡ç‚¹ãƒ‡ãƒ¼ã‚¿
    bool movefige;                               // ãƒ™ã‚¸ã‚§æ›²ç·šã«æ²¿ã£ã¦ç§»å‹•ã™ã‚‹ãƒ•ãƒ©ã‚°      	
    float speed;                             // ç§»å‹•é€Ÿåº¦
    Vector3 prevForward = { 0,0,1 };        // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®å‘ããƒ™ã‚¯ãƒˆãƒ«ï¼ˆå›žè»¢è£œé–“ç”¨ï¼‰        
    int currentSegment = 0; // ãƒ¬ãƒ¼ãƒ«ä¸Šã®ç¾åœ¨ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    float t_ = 0.0f;

    Vector3 forward_ = { 0,0,1 };
    Vector3 up_ = { 0,1,0 };
    Vector3 right_ = { 1,0,0 };

    bool followInitialized_;

    float transitionTimer_ = 0.0f;
    float transitionDuration_ = 0.25f;

    Vector3 startPos_;
    Vector3 startRot_;
    Vector3 endPos_;
    Vector3 endRot_;

    std::string transitionSubCameraName_;



    Object3d* followTarget_ = nullptr; // è¿½å¾“å¯¾è±¡ 
    Vector3 subOffset_ = { 0, 5, -10 }; // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆä½ç½®


    bool isMovingToTarget_ = false;

    Vector3 moveStartPos_;
    Vector3 moveTargetPos_;

    Vector3 rotStart_;
    Vector3 rotTarget_;

    float moveTimer_ = 0.0f;
    float moveDuration_ = 1.0f;  // ä½•ç§’ã§ç§»å‹•ã™ã‚‹ã‹

    bool transitionStarted_ = false;

    bool isTransitioning_ = false;

    Vector3 mainStartPos_;
    Vector3 mainTargetPos_;

    Vector3 subStartPos_;
    Vector3 subTargetPos_;

    Vector3 mainStartRot_;
    Vector3 mainTargetRot_;


    RailInfo railInfo_;
    float currentRailLength_ = 0.0f;
    Vector3 prevPos_;
public: // ã‚¢ã‚¯ã‚»ãƒƒã‚µï¼ˆGetter / Setterï¼‰
    // getter 
    bool Getmovefige() { return movefige; }
    Vector3 GetbezierPos() { return bezierPos_; }
    // setter
    void Setmovefige(bool value) { movefige = value; }
    void SetbezierPos(Vector3 pos) { bezierPos_ = pos; }
    // BezierPoint ã®å–å¾—
    std::vector<BezierPoint>& GetBezierPoints() { return bezierPoints; }
    // ã™ã¹ã¦ã® passed ã‚’ ON/OFF
    void SetAllPassed(bool flag) { for (auto& point : bezierPoints) { point.passed = flag; } }
    // ä¸€åº¦é€šéŽã—ãŸæ‰±ã„ã«ã™ã‚‹ï¼ˆã™ã¹ã¦ trueï¼‰
    void MarkAllAsPassed() { for (auto& point : bezierPoints) { if (!point.passed) point.passed = true; } }


    Vector3 GetBezierPos() const {
        return bezierPos_;
    }

    Vector3 GetForward() const {
        return forward_; // UpdateCameraRotation() å†…ã§æ›´æ–°æ¸ˆã¿
    }

    Vector3 GetUp() const {
        return up_;      // ã“ã‚Œã‚‚ã‚«ãƒ¡ãƒ©æ›´æ–°ã§æ±‚ã‚ã¦ãŠã
    }

    Vector3 GetRight() const {
        return right_;
    }

    // è¿½å¾“ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨­å®š
    void SetFollowTarget(Object3d* target) {
        followTarget_ = target;
    }

    float GetRailProgressRate() const;

    float GetTotalRailLength() const { return railInfo_.totalLength; }
    float GetCurrentRailLength() const { return currentRailLength_; }

};

============================================================
File Path: project/application/camera/SceneCameraBase.h
============================================================
#pragma once
#include <CameraTransform.h>
#include <Camera.h>
#include <vector>
#include <memory>

// ã‚·ãƒ¼ãƒ³ã”ã¨ã®ã‚«ãƒ¡ãƒ©åŸºåº•ã‚¯ãƒ©ã‚¹
class SceneCameraBase {
public:  
    virtual ~SceneCameraBase() = default;

    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†ï¼ˆã‚·ãƒ¼ãƒ³ã”ã¨ã«ç•°ãªã‚‹ã®ã§ç´”ç²‹ä»®æƒ³ï¼‰
    /// </summary>
    virtual void Initialize() = 0;

    /// <summary>
    /// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ ã®æ›´æ–°å‡¦ç†
    /// </summary>
    virtual void Update() = 0;

    /// ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ© Transform ã®å–å¾—
    const CameraTransform& GetMainTransform() const { return transform_; }
    /// ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©Rotateã®è¨­å®š
    void SetMainRotate(const Vector3& trans) { transform_.rotate = trans; }
    /// ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©Translateã®è¨­å®š
    void SetMainTranslate(const Vector3& trans) { transform_.translate = trans; }
    /// ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®è¿½åŠ 
    virtual void AddSubCamera(const CameraTransform& trans) {} 
    /// ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®è¿½åŠ ï¼ˆè¤‡æ•°ç™»éŒ²ã«å¯¾å¿œï¼‰
    virtual void AddSubCameras(const std::vector<CameraTransform>& transforms) {} 
    /// ã‚µãƒ–ã‚«ãƒ¡ãƒ©ç”Ÿæˆï¼ˆCameraManager ã«æ‰€æœ‰æ¨©ã‚’æ¸¡ã™ï¼‰
    virtual std::vector<std::unique_ptr<Camera>> MoveSubCameras() { return std::move(subcameras_); }

protected:
    CameraTransform transform_;                       // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ç”¨ã®ä½ç½®ãƒ»å›žè»¢
    std::vector<std::unique_ptr<Camera>> subcameras_; // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ç¾¤(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç©º)
};

============================================================
File Path: project/application/camera/TitleCamera.cpp
============================================================
#include "TitleCamera.h"
#include <CameraManager.h>
#include <MatrixVector.h>
#include <Easing.h>

using namespace Easing;
using namespace MatrixVector;

void TitleCamera::Initialize() {
    // ã‚«ãƒ¡ãƒ©ã®å€¤ã®åˆæœŸåŒ–
    transform_ = { { 0.0f,0.0f,0.0f },{ 0.0f, 0.0f, 0.0f} };
    std::vector<CameraTransform> subCams = {
     { {0, 10, -50}, {0, 0, 0} },
     { {5, 15, -60}, {0, 30, 0} },
    };
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚’è¿½åŠ 
    AddSubCameras(subCams);
}

void TitleCamera::Update() {
    switch (state_) {
    case TitleCameraState::IntroMove:
        UpdateIntroMove();
        break;

    case TitleCameraState::Default:
        if (CameraManager::GetInstance()->GetMode() == CameraMode::Follow) {
            UpdateLookAt();
        }
        break;
    }
}

void TitleCamera::UpdateIntroMove() {
    moveTimer_ += 1.0f / 60.0f; // deltaTime ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ã†

    float t = std::clamp(moveTimer_ / moveDuration_, 0.0f, 1.0f);
    float easedT = EaseOutQuad(t);

    transform_.translate = Lerp(startPos_, endPos_, easedT);

    // Follow ä¸­ã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¦‹ã‚‹
    UpdateLookAt();

    if (t >= 1.0f) {
        // çµ‚äº†å‡¦ç†
        transform_.translate = endPos_;
        state_ = TitleCameraState::Default;

        CameraManager::GetInstance()->SetCameraMode(CameraMode::Default);
    }
}

void TitleCamera::UpdateLookAt() {
    if (!target_) return;

    Vector3 camPos = transform_.translate;
    Vector3 targetPos = target_->GetWorldPosition();
    Vector3 dir = targetPos - camPos;

    if (Length(dir) > 0.0001f) {
        dir = Normalize(dir);
        float yaw = atan2f(dir.x, dir.z);
        float pitch = -asinf(dir.y);
        transform_.rotate = { pitch, yaw, 0.0f };
    }
}


void TitleCamera::AddSubCamera(const CameraTransform& trans) {
    // æ–°ã—ã„ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
    std::unique_ptr<Camera> cam = std::make_unique<Camera>();

    // æ¸¡ã•ã‚ŒãŸCameraTransformã‚’å…ƒã«ã€ä½ç½®ã¨è§’åº¦ã‚’è¨­å®š
    cam->SetTranslate(trans.translate);
    cam->SetRotate(trans.rotate);

    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ãƒªã‚¹ãƒˆã¸è¿½åŠ 
    subcameras_.push_back(std::move(cam)); // æ‰€æœ‰æ¨©ã‚’ç§»å‹•
}

void TitleCamera::AddSubCameras(const std::vector<CameraTransform>& transforms) {
    for (const CameraTransform& trans : transforms) {
        // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚’è¤‡æ•°ç™»éŒ²ã™ã‚‹
        AddSubCamera(trans);
    }
}

============================================================
File Path: project/application/camera/TitleCamera.h
============================================================
#pragma once
#include<SceneCameraBase.h>
#include <Object3d.h>

enum class TitleCameraState {
    IntroMove,
    Default
};

// ã‚¿ã‚¤ãƒˆãƒ«å°‚ç”¨ã‚«ãƒ¡ãƒ©
class TitleCamera : public SceneCameraBase {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary> 
    void Update() override;

    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®è¿½åŠ 
    void AddSubCamera(const CameraTransform& trans) override;
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®è¿½åŠ ï¼ˆè¤‡æ•°ç™»éŒ²ã«å¯¾å¿œï¼‰
    void AddSubCameras(const std::vector<CameraTransform>& transforms) override;

    // --- è¿½å¾“å¯¾è±¡ã‚’è¨­å®š ---
    void SetTarget(Object3d* target) { target_ = target; }


    void UpdateIntroMove();
    void UpdateLookAt();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•° 
    // è¿½å¾“å¯¾è±¡
    Object3d* target_ = nullptr;
    float followDistance_ = -20.0f; // å¾Œã‚ã‹ã‚‰è¦‹ã‚‹è·é›¢ï¼ˆèª¿æ•´å¯ï¼‰

    TitleCameraState state_ = TitleCameraState::IntroMove;

    Vector3 startPos_ = { -30.0f, 10.0f, 0.0f };
    Vector3 endPos_ = { 30.0f, -3.0f,  20.0f };

    float moveTimer_ = 0.0f;
    float moveDuration_ = 2.0f; // ç§’ï¼ˆ60fpsãªã‚‰120ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
    float lookAtEaseSpeed_ = 5.0f;   // è¿½å¾“é€Ÿåº¦ï¼ˆå¤§ãã„ã»ã©é€Ÿã„ï¼‰
    float targetPitch_ = 0.0f;       // ç›®æ¨™Xå›žè»¢
};

============================================================
File Path: project/application/character/BaseCharacter.h
============================================================
#pragma once
#include <memory>
#include <Object3d.h>

/// <summary>
/// ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®åŸºåº•ã‚¯ãƒ©ã‚¹
/// åˆæœŸåŒ–ãƒ»æ›´æ–°ãƒ»æç”»ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’å®šç¾©
/// </summary>
class BaseCharacter {
public:
    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary> 
    virtual ~BaseCharacter() = default;
    /// <summary> 
    /// åˆæœŸåŒ–å‡¦ç† 
    /// </summary>
    virtual void Initialize() = 0;
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    virtual void Update() = 0;
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    virtual void Draw() = 0;
};

============================================================
File Path: project/application/character/CharacterManager.cpp
============================================================
#include "CharacterManager.h"
#include <Player.h>

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
std::unique_ptr<CharacterManager> CharacterManager::instance = nullptr;

///====================================================
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
///====================================================
CharacterManager* CharacterManager::GetInstance() {
    if (!instance) {
        instance = std::make_unique<CharacterManager>();
    }
    return instance.get();
}

///====================================================
/// çµ‚äº†å‡¦ç†
///====================================================
void CharacterManager::Finalize() {
    instance.reset();  // `delete` ä¸è¦
}
///====================================================
/// åˆæœŸåŒ–å‡¦ç†
///====================================================
void CharacterManager::Initialize() {
    for (auto& Character : characters_) Character->Initialize();
}
///====================================================
/// æ›´æ–°å‡¦ç†
///====================================================
void CharacterManager::Update() {
    for (auto& Character : characters_) Character->Update();
}
///====================================================
/// æç”»å‡¦ç†
///====================================================
void CharacterManager::Draw() {
    for (auto& Character : characters_) Character->Draw();
}
///====================================================
/// ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼è¿½åŠ å‡¦ç†
///====================================================
void CharacterManager::AddCharacter(std::unique_ptr<BaseCharacter> character) {
    // Playerã‹ã©ã†ã‹ã‚’å‹•çš„ã‚­ãƒ£ã‚¹ãƒˆã§ãƒã‚§ãƒƒã‚¯
    if (Player* player = dynamic_cast<Player*>(character.get())) {
        player_ = player;
    }
    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒªã‚¹ãƒˆã«ç™»éŒ²
    characters_.push_back(std::move(character));
}


============================================================
File Path: project/application/character/CharacterManager.h
============================================================
#pragma once
#include <vector>
#include <BaseCharacter.h>

// ãƒ˜ãƒƒãƒ€ãƒ¼ã®é‡è¤‡ã‚’é˜²ãå‰æ–¹å®£è¨€
class Player;

///====================================================
/// CharacterManager
/// ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ»æ•µãªã©ï¼‰ã‚’ä¸€æ‹¬ç®¡ç†ã™ã‚‹ãƒžãƒãƒ¼ã‚¸ãƒ£ã‚¯ãƒ©ã‚¹ã€‚
///====================================================
class CharacterManager {
private:
	static std::unique_ptr<CharacterManager> instance;

	CharacterManager(CharacterManager&) = delete;
	CharacterManager& operator=(CharacterManager&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	CharacterManager() = default;
	~CharacterManager() = default;
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static CharacterManager* GetInstance();
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize();	
	/// <summary>
	/// æ›´æ–°æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»æ›´æ–°
	/// </summary>
	void Draw(); 
	/// <summary>
    /// ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®è¿½åŠ ç™»éŒ² (ç¾çŠ¶ãƒ—ãƒ¬ã‚¤ãƒ¤â€•ç”¨)
    /// </summary> 
	void AddCharacter(std::unique_ptr<BaseCharacter> character);
private:// ãƒ¡ãƒ³ãƒå¤‰æ•°
	std::vector<std::unique_ptr<BaseCharacter>> characters_; 	// ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç™»éŒ²
	Player* player_ = nullptr;								    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
public: // ã‚¢ã‚¯ã‚»ãƒƒã‚µï¼ˆGetter / Setterï¼‰
	// getter

	/// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å–å¾—
    /// </summary>
	Player* GetPlayer() const {
		assert(player_ != nullptr && "Player has not been registered!");
		return player_;
	}
};


============================================================
File Path: project/application/enemy/Enemy.cpp
============================================================
#include "Enemy.h"
#include <MatrixVector.h>
//#include<EnemyBullet.h>
#include <BulletManager.h>
#include <Player.h>
#include <algorithm> 
#include <ModelManager.h>
#include <CameraManager.h>
#include <Easing.h>

using namespace Easing;
using namespace MatrixVector;

///====================================================
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///====================================================
Enemy::~Enemy() {}

///====================================================
/// åˆæœŸåŒ–å‡¦ç†
///====================================================
void Enemy::Initialize() {
    ModelManager::GetInstance()->LoadModel("Gameplay/Model/Enemy/Enemy.obj");     
    // ä¹±æ•°ã‚¨ãƒ³ã‚¸ãƒ³ã‚’åˆæœŸåŒ–
    std::random_device rd;// ä¹±æ•°ç”Ÿæˆå™¨
    randomEngine = std::mt19937(rd());
    // åˆæœŸåº§æ¨™ã‚’ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆ
    std::uniform_real_distribution<float> distX(-12.0f, 12.0f);
    std::uniform_real_distribution<float> distY(0.0f, 1.0f);
    std::uniform_real_distribution<float> distZ(50.0f, 100.0f);
    // Transformè¨­å®š
    Vector3 xyz = { distX(randomEngine), distY(randomEngine),distZ(randomEngine) };
    // å¼¾ã®ç™ºå°„é–“éš”ã‚’ãƒ©ãƒ³ãƒ€ãƒ è¨­å®šï¼ˆ2ã€œ7ç§’ï¼‰
    transform_ = { { 1.0f, 1.0f, 1.0f }, { 0.0f, 0.0f, 0.0f },xyz };
    object = Object3d::Create("Gameplay/Model/Enemy/Enemy.obj", transform_);
    object->SetScale({ 1.0f, 1.0f, 1.0f }); // å®‰å®šã—ãŸã‚µã‚¤ã‚ºã‚’æ˜Žç¤º
    bulletIntervalDist_ = std::uniform_real_distribution<float>(0.2f, 3.0f); // ç™ºå°„é–“éš”ã‚’æ±ºå®šã™ã‚‹åˆ†å¸ƒ
    bulletInterval_ = bulletIntervalDist_(randomEngine); // æœ€åˆã®é–“éš”ã‚’æ±ºå®š
    // ç§»å‹•æ–¹å‘ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«è¨­å®š
    std::uniform_int_distribution<int> typeDist(0, 2);
    int type = typeDist(randomEngine);
    moveType_ = static_cast<MoveType>(type);
    moveDirDist_ = std::uniform_real_distribution<float>(-1.5f, 1.5f);
    moveDirection_ = Vector3{ moveDirDist_(randomEngine),moveDirDist_(randomEngine),moveDirDist_(randomEngine) };
}

///====================================================
/// æ›´æ–°å‡¦ç†
///====================================================
void Enemy::Update() {
    switch (state_) {
    case State::Spawn:
        UpdateSpawn();
        break;
    case State::Active:
        UpdateActive();
        break;
    case State::Dying:
        UpdateDying();
        break;
    case State::Dead:
        return;
    }
    

    // ä½ç½®ã‚’objectã‹ã‚‰å–å¾—ã—ã¦åŒæœŸã™ã‚‹
    transform_.translate = object->GetTranslate(); // â† è¿½åŠ 

    // ç¾åœ¨ã®åº§æ¨™ã‚’åŒæœŸ
    object->SetTranslate(transform_.translate);
    object->Update();
}
///====================================================
/// æç”»å‡¦ç†
///====================================================
void Enemy::Draw() {   
    object->Draw();
}
///====================================================
/// å¼¾ã®ç™ºå°„å‡¦ç†
///====================================================
void Enemy::AttachBullet(const Vector3& playerPos) {
    bulletTimer_ += 1.0f / 60.0f; // æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ çµŒéŽæ™‚é–“ã‚’åŠ ç®—ï¼ˆ60fpså‰æï¼‰
    // 30ç§’çµŒéŽã—ãŸã‚‰ç™ºå°„å¯èƒ½ã«ã™ã‚‹
    if (bulletTimer_ >= bulletInterval_) {
        canShoot_ = true;
        bulletTimer_ = 0.0f; // ã‚¿ã‚¤ãƒžãƒ¼ãƒªã‚»ãƒƒãƒˆ
    }

    // å¼¾ãŒæ’ƒã¦ã‚‹ã‹ç¢ºèª
    if (!canShoot_) return;

    // å¼¾ã®åˆæœŸä½ç½®ï¼šæ•µã®å‰æ–¹æ–¹å‘ï¼ˆæ•µå‘ãã«å°‘ã—å‰é€²ï¼‰
    Vector3 forward = Normalize(moveDirection_); // æ•µã®é€²è¡Œæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
    Vector3 bulletStartPos = transform_.translate + forward * 1.0f;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç‹™ã†
    Vector3 targetPos = playerPos;
    Vector3 dir = targetPos - bulletStartPos; // å¼¾ã‹ã‚‰ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ã¸ã®ãƒ™ã‚¯ãƒˆãƒ«

    // ã‚«ãƒ¡ãƒ©æƒ…å ±
    GamePlayCamera* gameCam = CameraManager::GetInstance()->GetGameplayCamera();
    Vector3 shootDir;
    if (gameCam) {
        Vector3 camForward = gameCam->GetForward();
        Vector3 camRight   = gameCam->GetRight();
        Vector3 camUp      = gameCam->GetUp();

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’ã‚«ãƒ¡ãƒ©åŸºæº–ã«å¤‰æ›
        float localX = Dot(dir, camRight);
        float localY = Dot(dir, camUp);
        float localZ = Dot(dir, camForward);

        Vector3 localDir = { localX, localY, localZ };

        // å¿…è¦ã«å¿œã˜ã¦Yè»¸ã ã‘è£œæ­£ã™ã‚‹ãªã‚‰ localY ã‚’èª¿æ•´
        // localY = 0.0f; // æ°´å¹³å°„å‡ºã®å ´åˆ

        // å†ã³ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ç³»ã«å¤‰æ›
        shootDir = Normalize(camRight * localDir.x + camUp * localDir.y + camForward * localDir.z);
    } else {
        shootDir = Normalize(dir);
    }

     // å¼¾ç”Ÿæˆ
    std::unique_ptr<EnemyBullet> bullet = std::make_unique<EnemyBullet>();
    bullet->Initialize(
        bulletStartPos,
        bulletStartPos + shootDir * 10.0f,
        shootDir,
        0.8f
    );

    BulletManager::GetInstance()->AddEnemyBullet(std::move(bullet));
    bulletInterval_ = bulletIntervalDist_(randomEngine);
    canShoot_ = false;
}
///====================================================
/// OBBï¼ˆå½“ãŸã‚Šåˆ¤å®šç”¨ï¼‰ã‚’å–å¾—
///====================================================
OBB Enemy::GetOBB() const {
    OBB obb;
    // ä¸­å¿ƒåº§æ¨™
    obb.center = transform_.translate;
    // ãƒãƒ¼ãƒ•ã‚µã‚¤ã‚ºï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ã®åŠåˆ†ï¼‰
    obb.halfSize = {
        transform_.scale.x / 1.0f, 
        transform_.scale.y / 1.0f, 
        transform_.scale.z / 1.0f
    };
    // å›žè»¢è¡Œåˆ—ï¼ˆXYZé †ã§å›žè»¢ã‚’åˆæˆï¼‰
    Matrix4x4 rotX = MakeRotateXMatrix(transform_.rotate.x);
    Matrix4x4 rotY = MakeRotateYMatrix(transform_.rotate.y);
    Matrix4x4 rotZ = MakeRotateZMatrix(transform_.rotate.z);
    // Zâ†’Xâ†’Y ã®é †ã«æŽ›ã‘ã‚‹ã“ã¨ã§ã€XYZå›žè»¢ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ç©ºé–“å›žè»¢ï¼‰ã‚’å†ç¾
    Matrix4x4 rotMat = Multiply(Multiply(rotZ, rotX), rotY);
    // ãƒ­ãƒ¼ã‚«ãƒ«è»¸ï¼ˆX, Y, Zï¼‰ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰ç©ºé–“ã¸å›žè»¢é©ç”¨
    obb.axis[0] = Normalize(Multiply4x4x3(rotMat, Vector3{ 1, 0, 0 })); // Xè»¸
    obb.axis[1] = Normalize(Multiply4x4x3(rotMat, Vector3{ 0, 1, 0 })); // Yè»¸
    obb.axis[2] = Normalize(Multiply4x4x3(rotMat, Vector3{ 0, 0, 1 })); // Zè»¸
    return obb;
}

void Enemy::Spawn(const Vector3& pos, MoveType moveType) {
    // ===== çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆï¼ˆSetnewTranslate ç”±æ¥ï¼‰=====
    isDead_ = false;
    isDying_ = false;
    deathTimer_ = 0.0f;
    canShoot_ = false;
    bulletTimer_ = 0.0f;

    moveType_ = moveType;

    spawnBaseZ_ = pos.z;
    bulletInterval_ = bulletIntervalDist_(randomEngine);

    // ===== Spawn ã‚¹ãƒ†ãƒ¼ãƒˆé–‹å§‹ =====
    state_ = State::Spawn;
    spawnTimer_ = 0.0f;

    spawnTargetPos_ = pos;
    spawnStartPos_ = pos + Vector3{ 0, 0, 10.0f };

    // å‡ºç¾é–‹å§‹çŠ¶æ…‹
    transform_.translate = spawnStartPos_;
    transform_.scale = { 0.0f, 0.0f, 0.0f };
    transform_.rotate = { 0.0f, 0.0f, 0.0f };

    // Object3d å´ã«ã‚‚å³åæ˜ ï¼ˆ1ãƒ•ãƒ¬é…å»¶é˜²æ­¢ï¼‰
    object->SetTranslate(transform_.translate);
    object->SetScale(transform_.scale);
    object->SetRotate(transform_.rotate);
}

void Enemy::UpdateSpawn() {
    spawnTimer_ += 1.0f /60.0f;
    float t = std::min(spawnTimer_ / spawnDuration_, 1.0f);

    // ä½ç½®ã¯æ™®é€šã«
    transform_.translate = Lerp(spawnStartPos_, spawnTargetPos_, t);

    // ã‚¹ã‚±ãƒ¼ãƒ«ã¯ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆ
    float s = EaseOutBack(t);

    transform_.scale = {
        s,
        s,
        s
    };
    object->SetScale(transform_.scale);

    if (t >= 0.6) {

    }

    if (t >= 1.0f) {
        transform_.scale = { 1,1,1 }; // å¿µã®ãŸã‚åŽæŸ
        state_ = State::Active;
    }
}

void Enemy::OnHit() {
    // ã™ã§ã«æ­»ã«ã‹ã‘ or æ­»äº¡æ¸ˆã¿ãªã‚‰ç„¡è¦–
    if (state_ == State::Dying || state_ == State::Dead) {
        return;
    }

    state_ = State::Dying;
    isDying_ = true;
    deathTimer_ = 0.0f;
}
void Enemy::UpdateActive() {
    if (player_) {
        AttachBullet(player_->GetPosition());
    }
    switch (moveType_) {
    case MoveType::Vertical:
        transform_.translate.y += moveDirection_.y * moveSpeed_;
        object->SetTranslate(transform_.translate);
        break;
    case MoveType::Horizontal:
        transform_.translate.x += moveDirection_.x * moveSpeed_;
        object->SetTranslate(transform_.translate);
        break;
    case MoveType::Diagonal: {
        moveDirection_ = Normalize(moveDirection_); // æ–œã‚ã®å ´åˆã¯æ­£è¦åŒ–
        transform_.translate.x += moveDirection_.x * moveSpeed_;
        transform_.translate.y += moveDirection_.y * moveSpeed_;
        object->SetTranslate(transform_.translate);
        break;
    case MoveType::None:
        break;
    }
    }
}
void Enemy::UpdateDying() {
    // æ­»äº¡åˆ¤å®šä¸­ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ç¸®å°ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
    if (isDying_) {
        deathTimer_ += 1.0f / 120.0f; // 60FPSå‰æ
        float t = (std::min)(deathTimer_ / deathDuration_, 1.0f);
        Vector3 scale = { 1.0f - t,1.0f - t ,1.0f - t };

        object->SetScale(scale);


        // ãƒ©ãƒ³ãƒ€ãƒ å›žè»¢ï¼ˆæ¯Žãƒ•ãƒ¬ãƒ¼ãƒ å°‘ã—ãšã¤å¤‰åŒ–ï¼‰
        std::uniform_real_distribution<float> rotDist(-5.0f, 5.0f); // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ãŸã‚Šã®å›žè»¢é‡ï¼ˆåº¦ï¼‰
        Vector3 currentRot = object->GetRotate(); // Object3då´ã«GetRotateãŒå¿…è¦
        currentRot.x += rotDist(randomEngine);
        currentRot.y += rotDist(randomEngine);
        currentRot.z += rotDist(randomEngine);
        object->SetRotate(currentRot);

        // ãƒ©ãƒ³ãƒ€ãƒ ç§»å‹•ï¼ˆå¹ã£é£›ã¶æ¼”å‡ºï¼‰
        std::uniform_real_distribution<float> moveDist(-0.2f, 0.2f); // x,yæ–¹å‘
        std::uniform_real_distribution<float> moveZDist(0.1f, 0.3f);  // zæ–¹å‘ã¯å¿…ãšå‰æ–¹ã¸
        Vector3 currentPos = object->GetTranslate();
        currentPos.x += moveDist(randomEngine);
        currentPos.y += moveDist(randomEngine);
        currentPos.z += moveZDist(randomEngine); // zã¯æ­£æ–¹å‘
        object->SetTranslate(currentPos);
         
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ—©ã‚ã«ç™ºå‹•
        if (!hasTriggeredParticle_ && t >= 0.5f) { // 30%çµŒéŽã—ãŸã‚‰ç™ºå‹•
            hasTriggeredParticle_ = true;
            // æ­»äº¡æ™‚ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å‘¼ã¶
            if (onDeathCallback) {
                onDeathCallback(currentPos);
            }
        }
        if (t >= 1.0f) {
            isDead_ = true; // ã‚¹ã‚±ãƒ¼ãƒ«ãŒ0ã«ãªã£ãŸã®ã§å‰Šé™¤è¨±å¯
            SetActive(false);
        }
    }
}

============================================================
File Path: project/application/enemy/Enemy.h
============================================================
#pragma once
#include <Vector3.h>
#include<random>
#include<Transform.h>
#include<BaseCharacter.h>
#include<Sprite.h>
#include<OBB.h>

// ãƒ˜ãƒƒãƒ€ãƒ¼ã®é‡è¤‡ã‚’é˜²ãå‰æ–¹å®£è¨€
class Player;

/// <summary>
/// æ•µã®ç§»å‹•ã‚¿ã‚¤ãƒ—ã‚’å®šç¾©ã™ã‚‹åˆ—æŒ™ä½“
/// </summary>
enum class MoveType {
    None,       // ç§»å‹•ã—ãªã„
    Vertical,   // ç¸¦æ–¹å‘ã«ç§»å‹•
    Horizontal,  // æ¨ªæ–¹å‘ã«ç§»å‹•
    Diagonal
};


/// <summary>
/// æ•µã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¯ãƒ©ã‚¹
/// </summary>
class Enemy : public BaseCharacter {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    enum class State {
        Spawn,   // å‡ºç¾æ¼”å‡ºä¸­
        Active,  // é€šå¸¸è¡Œå‹•
        Dying,   // æ­»äº¡æ¼”å‡º
        Dead
    };

    /// <summary>
    /// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
	~Enemy() override;
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
	void Initialize() override;	    
	/// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
	void Update() override;	    
	/// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
	void Draw() override;		
    /// <summary>
    /// å¼¾ã®ç™ºå°„å‡¦ç†
    /// </summary>
    /// <param name="playerPos">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨åº§æ¨™</param>
	void AttachBullet(const Vector3& playerPos);
    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’è¨­å®šã™ã‚‹
    /// </summary>
	void SetPlayer(Player* player) { player_ = player; }	    
	/// <summary>
    /// æ•µãŒæ­»ã‚“ã åˆ¤å®šã¸ç§»è¡Œ
    /// </summary>
	void SetInactive() {
        if (!isDying_) {
            isDying_ = true;
            deathTimer_ = 0.0f;
            iscollar_ = true;   // ç‚¹æ»…ãƒ»ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã‚‚æ›´æ–°å¯èƒ½
            isActive_ = true; // æ­»äº¡æ¼”å‡ºä¸­ã‚‚æ›´æ–°ãƒ»æç”»å¯èƒ½ã«ã™ã‚‹
        }
	}
    /// <summary>
    /// ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’å–å¾—
    /// </summary>
    bool IsActive() const { return isActive_; }
    /// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š
    /// </summary>
    void SetActive(bool active) { isActive_ = active; }
    /// <summary>
    /// å¼·åˆ¶çš„ã«æ•µã‚’å‰Šé™¤ï¼ˆéžã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–ï¼‰
    /// </summary>
    void Kill() { isActive_ = false; }
    /// <summary>
    /// æ­»äº¡åˆ¤å®šã‚’å–å¾—
    /// </summary>
    bool IsDead() const { return isDead_; }
    /// <summary>
    /// æ•µã®OBBï¼ˆå½“ãŸã‚Šåˆ¤å®šï¼‰ã‚’å–å¾—
    /// </summary>
    OBB GetOBB() const;

    void Spawn(const Vector3& pos, MoveType moveType);
    void UpdateSpawn();
    void OnHit();   // â† ã“ã‚Œã‚’è¿½åŠ 
    void UpdateActive();
    void UpdateDying();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒã‚¤ãƒ³ã‚¿
    Player* player_; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	Transform transform_; //ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®transform
	std::unique_ptr<Object3d> object;// æ•µãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
    float radius_ = 1.0f;                    // å½“ãŸã‚Šåˆ¤å®šåŠå¾„
    float spawnBaseZ_ = 0.0f;                // å‡ºç¾Zä½ç½®ã®åŸºæº–  
    //====================================================
    // ãƒ©ãƒ³ãƒ€ãƒ æŒ™å‹•é–¢é€£
    //====================================================
    std::mt19937 randomEngine;               // ä¹±æ•°ç”Ÿæˆå™¨
    std::uniform_real_distribution<float> moveDirDist_; // ç§»å‹•æ–¹å‘ï¼ˆ-1.0ã€œ1.0ï¼‰
    Vector3 moveDirection_;                  // ç¾åœ¨ã®ç§»å‹•æ–¹å‘
    float moveSpeed_ = 0.1f;                 // ç§»å‹•é€Ÿåº¦
    MoveType moveType_;                      // ç§»å‹•ã‚¿ã‚¤ãƒ—
    //====================================================
    // å¼¾ç™ºå°„é–¢é€£
    //====================================================
    float bulletTimer_ = 0.0f;               // çµŒéŽæ™‚é–“ï¼ˆç™ºå°„é–“éš”æ¸¬å®šï¼‰
    float bulletInterval_ = 5.0f;            // ç™ºå°„é–“éš”ï¼ˆç§’ï¼‰
    std::uniform_real_distribution<float> bulletIntervalDist_; // ç™ºå°„é–“éš”ã®ãƒ©ãƒ³ãƒ€ãƒ åˆ†å¸ƒ
    bool canShoot_ = true;                   // å¼¾ã‚’æ’ƒã¦ã‚‹çŠ¶æ…‹ã‹ã©ã†ã‹
    //====================================================
    // æ­»äº¡ãƒ»çŠ¶æ…‹ç®¡ç†
    //====================================================
    bool isDying_ = false;                   // æ­»äº¡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆä¸­ã‹ã©ã†ã‹
    float deathTimer_ = 0.0f;                // æ­»äº¡çµŒéŽæ™‚é–“
    const float deathDuration_ = 0.4f;       // æ­»äº¡ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“ï¼ˆç§’ï¼‰
    bool isActive_ = false;                  // æœ‰åŠ¹ã‹ã©ã†ã‹
    bool isDead_ = false;                    // å®Œå…¨ã«å‰Šé™¤æ¸ˆã¿ã‹ã©ã†ã‹


        
    bool iscollar_ = false;                  // æœ‰åŠ¹ã‹ã©ã†ã‹
    
    float t;

    // çŠ¶æ…‹é·ç§»
    State state_ = State::Dead;


    // Spawnæ¼”å‡ºç”¨
    float spawnTimer_ = 0.0f;
    float spawnDuration_ = 1.0f; // 1ç§’æ¼”å‡º
    Vector3 spawnStartPos_;
    Vector3 spawnTargetPos_;
    bool hasTriggeredParticle_ = false;
public:   // ã‚¢ã‚¯ã‚»ãƒƒã‚µï¼ˆGetter / Setterï¼‰
	   
    std::function<void(const Vector3&)> onDeathCallback;

    float GetSpawnBaseZ() const { return spawnBaseZ_; }
     
	// Transformã®positionã‚’è¿”ã™getter
	Vector3 GetPosition() const {
		return transform_.translate;
	}

};

============================================================
File Path: project/application/enemy/EnemySpawner.cpp
============================================================
#include"EnemySpawner.h"
#include <MatrixVector.h>

using namespace MatrixVector;

void EnemySpawner::Initialize(Player* player, CameraManager* cameraManager, std::vector<std::unique_ptr<Enemy>>* enemies) {
    player_ = player;
    cameraManager_ = cameraManager;
    enemies_ = enemies;

    // Loader ã‚’ç”Ÿæˆ
    levelLoader_ = std::make_unique<EnemyLoader>();

    // ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    levelData = levelLoader_->LoadFile("Enemy");


    for (const auto& e : levelData->enemies) {
        EnemySpawnTrigger trigger;
        trigger.Position = e.translation;
        trigger.spawnCount = 5;
        trigger.hasSpawned = false;

        trigger.moveType =
            (e.enemyType == 1) ? MoveType::None :
            (e.enemyType == 2) ? MoveType::None :
            MoveType::None;

        spawnTriggers_.push_back(trigger);
    }
}

void EnemySpawner::Update() {
    // å›ºå®šä½ç½®ã§ã®å‡ºç¾
    EnemySpawn();

    // ãƒ©ãƒ³ãƒ€ãƒ å‡ºç¾
    std::uniform_real_distribution<float> time(3.0f, 8.0f);    
    randomSpawnTimer_ += 1.0f / 60.0f;
    if (randomSpawnTimer_ >= nextRandomSpawnTime_) {
        std::uniform_int_distribution<int> distCount(2, 5);
        int spawnCount = distCount(randomEngine);
        SpawnRandomEnemy(spawnCount);

        nextRandomSpawnTime_ = time(randomEngine); // æ¬¡ã®å‡ºç¾é–“éš”
        randomSpawnTimer_ = 0.0f;
    }
}

void EnemySpawner::EnemySpawn() {
    Vector3 playerPos = player_->GetPosition();
    GamePlayCamera* gameCam = cameraManager_->GetGameplayCamera();
    if (!gameCam) return;

    Vector3 forward = gameCam->GetForward();
    Vector3 right = Normalize(Cross({0,1,0}, forward));
    Vector3 up = Normalize(Cross(forward, right));
    
    // ä¹±æ•°ç”Ÿæˆå™¨
    std::random_device rd;
    std::mt19937 rng(rd());
    std::uniform_int_distribution<int> patternDist(0, 2); // 0:V, 1:ZigZag, 2:ReverseStep


    for (size_t i = 0; i < spawnTriggers_.size(); ++i) {
        auto& trigger = spawnTriggers_[i];

        float distanceForward =
            Dot((trigger.Position - playerPos), forward);
        

        if (!trigger.hasSpawned &&
            distanceForward >= 0.0f &&
            distanceForward < 10.0f) {

            // ãƒ©ãƒ³ãƒ€ãƒ ã«å‡ºç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸æŠž
            int selectedPattern = patternDist(rng);

            switch (selectedPattern) {
            case 0:
                SpawnVFormation(trigger);
                break;
            case 1:
                SpawnZigZagFormation(trigger);
                break;
            case 2:
                SpawnReverseStepFormation(trigger);
                break;
            }


            trigger.hasSpawned = true;
        }
    }
}

///====================================================
/// æ•µå‡ºç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šVå­—ãƒ•ã‚©ãƒ¼ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå§¿å‹¢å¯¾å¿œï¼‰
///====================================================
void EnemySpawner::SpawnVFormation(const EnemySpawnTrigger& trigger) {
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ»ã‚«ãƒ¡ãƒ©æƒ…å ±ã‚’å–å¾—
    Vector3 playerPos = player_->GetPosition();
    GamePlayCamera* gameCam = CameraManager::GetInstance()->GetGameplayCamera(); 
    if (!gameCam) return;

    Vector3 forward = Normalize(gameCam->GetForward());
    Vector3 right   = Normalize(Cross({ 0,1,0 }, forward));
    Vector3 up      = Normalize(Cross(forward, right));

    // æ•µé…ç½®è¨­å®š
    int activated = 0;

    const float forwardDist = 60.0f;  // å‰æ–¹è·é›¢
    const float baseY = 1.0f;
    const float stepX = 3.0f;
    const float stepY = -2.0f;

    for (auto& enemy : *enemies_) {
        if (!enemy->IsActive()) {
            float x = 0.0f;
            float y = 0.0f;

            switch (activated) {
            case 0: x =  0.0f; y =  0.0f; break;               // ä¸­å¤®
            case 1: x = -stepX; y = stepY; break;              // å·¦ä¸Š
            case 2: x =  stepX; y = stepY; break;              // å³ä¸Š
            case 3: x = -stepX * 2; y = stepY * 2; break;      // å·¦ä¸‹
            case 4: x =  stepX * 2; y = stepY * 2; break;      // å³ä¸‹
            default:
                x = (activated - 2) * stepX;
                y = stepY * 3;
                break;
            }

            Vector3 spawnPos =
                playerPos +
                forward * forwardDist +
                right * x +
                up * (baseY + y);

            enemy->Spawn(spawnPos, trigger.moveType);
            enemy->SetActive(true);

            ++activated;
            if (activated >= trigger.spawnCount) break;
        }
    }
}



///====================================================
/// æ•µå‡ºç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šã‚¸ã‚°ã‚¶ã‚°ãƒ•ã‚©ãƒ¼ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
///====================================================
void EnemySpawner::SpawnZigZagFormation(const EnemySpawnTrigger& trigger) {
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ»ã‚«ãƒ¡ãƒ©æƒ…å ±ã‚’å–å¾—
    Vector3 playerPos = player_->GetPosition();
    GamePlayCamera* gameCam = CameraManager::GetInstance()->GetGameplayCamera();
    if (!gameCam) return;

    Vector3 forward = Normalize(gameCam->GetForward());
    Vector3 right = Normalize(Cross({ 0,1,0 }, forward));
    Vector3 up = Normalize(Cross(forward, right));

    // æ•µé…ç½®è¨­å®š
    int activated = 0;
    const int numEnemies = 5;
    const float forwardDist = 50.0f;
    const float baseY = 5.0f;

    const float xOffsets[5] = { -1.5f,  1.5f,  0.0f, -1.5f,  1.5f };
    const float yOffsets[5] = { 2.0f,  2.0f,  0.0f, -2.0f, -2.0f };

    for (auto& enemy : *enemies_) {
        if (!enemy->IsActive() && activated < numEnemies) {
            float x = xOffsets[activated];
            float y = yOffsets[activated];

            Vector3 spawnPos =
                playerPos +
                forward * forwardDist +
                right * x +
                up * (baseY + y);

            enemy->Spawn(spawnPos, trigger.moveType);
            enemy->SetActive(true);
            ++activated;
        }
    }
}

///====================================================
/// æ•µå‡ºç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼šé€†ã‚¹ãƒ†ãƒƒãƒ—ãƒ•ã‚©ãƒ¼ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå§¿å‹¢å¯¾å¿œï¼‰
///====================================================
void EnemySpawner::SpawnReverseStepFormation(const EnemySpawnTrigger& trigger) {
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ»ã‚«ãƒ¡ãƒ©æƒ…å ±ã‚’å–å¾—
    Vector3 playerPos = player_->GetPosition();
    GamePlayCamera* gameCam = CameraManager::GetInstance()->GetGameplayCamera();
    if (!gameCam) return;

    Vector3 forward = Normalize(gameCam->GetForward());
    Vector3 right = Normalize(Cross({ 0,1,0 }, forward));
    Vector3 up = Normalize(Cross(forward, right));

    // æ•µé…ç½®è¨­å®š
    int activated = 0;
    const float baseY = 5.0f;
    const float forwardBase = 80.0f;
    const float stepX = 1.5f;
    const float stepY = -1.2f;
    const float stepZ = 5.0f;

    for (auto& enemy : *enemies_) {
        if (!enemy->IsActive()) {
            Vector3 spawnPos =
                playerPos +
                forward * (forwardBase - stepZ * activated) +
                right * -(stepX * activated) +
                up * (baseY + stepY * activated);

            enemy->Spawn(spawnPos, trigger.moveType);
            enemy->SetActive(true);

            ++activated;
            if (activated >= trigger.spawnCount) break;
        }
    }
}

void EnemySpawner::SpawnRandomEnemy(int count) {
    // ã‚«ãƒ¡ãƒ©å–å¾—
    GamePlayCamera* gameCam = cameraManager_->GetGameplayCamera();
    if (!gameCam) return;

    Vector3 camPos = gameCam->GetMainTransform().translate;
    Vector3 forward = Normalize(gameCam->GetForward());
    Vector3 right   = Normalize(Cross({0,1,0}, forward));
    Vector3 up      = Normalize(Cross(forward, right));
    
    // ä¹±æ•°ã‚¨ãƒ³ã‚¸ãƒ³ã‚’åˆæœŸåŒ–
    std::random_device rd;// ä¹±æ•°ç”Ÿæˆå™¨
    randomEngine = std::mt19937(rd());

    std::uniform_real_distribution<float> distX(-15.0f, 15.0f);
    std::uniform_real_distribution<float> disty(-4.0f, 8.0f);
    std::uniform_real_distribution<float> distz(80.0f, 250.0f);

    int activated = 0;
    for (auto& enemy : *enemies_) {
        if (!enemy->IsActive() && activated < count) { // 1ä½“ãšã¤å‡ºã™å ´åˆ
            // ãƒ©ãƒ³ãƒ€ãƒ åº§æ¨™ç”Ÿæˆ
            float randX = distX(randomEngine); // æ¨ªå¹…ã®ç¯„å›²
            float randY = disty(randomEngine);  // é«˜ã•
            float randZ = distz(randomEngine); // å¥¥è¡Œã

            Vector3 spawnPos = camPos + forward * randZ + right * randX + up * randY;
            
            // ãƒ©ãƒ³ãƒ€ãƒ ç§»å‹•ã‚’æœ‰åŠ¹ã«
            std::uniform_int_distribution<int> typeDist(0, 3); // 0:None,1:Vertical,2:Horizontal
            MoveType moveType = static_cast<MoveType>(typeDist(randomEngine));

            enemy->Spawn(spawnPos, moveType);
            enemy->SetActive(true);

            ++activated;
        }
    }
}

============================================================
File Path: project/application/enemy/EnemySpawner.h
============================================================
#pragma once
#include <Player.h>
#include <CameraManager.h>
#include <Enemy.h>
#include<EnemyLoader.h>

/// <summary>
/// æ•µã®å‡ºç¾æ¡ä»¶ï¼ˆãƒˆãƒªã‚¬ãƒ¼ï¼‰ã‚’å®šç¾©ã™ã‚‹æ§‹é€ ä½“
/// </summary>
struct EnemySpawnTrigger {
    Vector3 Position;   // å‡ºç¾ä½ç½®
    int spawnCount;     // åŒæ™‚ã«å‡ºç¾ã•ã›ã‚‹æ•°
    bool hasSpawned;    // ã™ã§ã«å‡ºç¾æ¸ˆã¿ã‹ã©ã†ã‹
    MoveType moveType;  // æ•µã®ç§»å‹•ã‚¿ã‚¤ãƒ—
};

class EnemySpawner {
public:
    void Initialize(Player* player, CameraManager* camera, std::vector<std::unique_ptr<Enemy>>* enemies);

    void Update();

private:
    void EnemySpawn();
    void SpawnRandomEnemy(int count);

    void SpawnVFormation(const EnemySpawnTrigger& trigger);
    void SpawnReverseStepFormation(const EnemySpawnTrigger& trigger);
    void SpawnZigZagFormation(const EnemySpawnTrigger& trigger);

private:
    Player* player_ = nullptr;
    CameraManager* cameraManager_ = nullptr;
    std::vector<std::unique_ptr<Enemy>>* enemies_ = nullptr;
    std::vector<EnemySpawnTrigger> spawnTriggers_;
        
       
    // =========================
    // ãƒ©ãƒ³ãƒ€ãƒ å‡ºç¾ç”¨
    // =========================
    float randomSpawnTimer_ = 0.0f;           // çµŒéŽæ™‚é–“
    float nextRandomSpawnTime_ = 2.0f;        // æ¬¡ã«å‡ºç¾ã•ã›ã‚‹ã¾ã§ã®æ™‚é–“ï¼ˆç§’ï¼‰
    std::mt19937 randomEngine;               // ä¹±æ•°ç”Ÿæˆå™¨

    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ­ãƒ¼ãƒ€ãƒ¼
    std::unique_ptr<EnemyLoader> levelLoader_ = nullptr;
    // ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
    LevelEnemyData* levelData = nullptr;
};

============================================================
File Path: project/application/event/EventManager.cpp
============================================================
#include "EventManager.h"
#include <MatrixVector.h>
#include<TextureManager.h>
#include <ModelManager.h>
#include <CameraManager.h>
#include<Input.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI

using namespace MatrixVector;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
EventManager* EventManager::instance = nullptr;

///====================================================
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
///====================================================
EventManager* EventManager::GetInstance() {
    // ã¾ã ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒç”Ÿæˆã•ã‚Œã¦ã„ãªã‘ã‚Œã°ä½œæˆ
    if (instance == nullptr) {
        instance = new EventManager;
    }
    return instance;
}

///====================================================
/// çµ‚äº†å‡¦ç†
///====================================================
void EventManager::Finalize() {
    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å‰Šé™¤ã—ã¦nullptrã«æˆ»ã™
    delete instance;
	instance = nullptr;   
}

///====================================================
/// åˆæœŸåŒ–å‡¦ç†
///====================================================
void EventManager::Initialize(const std::string& stateName) {
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ­ãƒ¼ãƒ‰
    TextureManager::GetInstance()->LoadTexture("Event/Black.png");
    TextureManager::GetInstance()->LoadTexture("Event/Startevent_01.png");
    TextureManager::GetInstance()->LoadTexture("Event/Startevent_02.png");
    TextureManager::GetInstance()->LoadTexture("Event/mission.png");
    TextureManager::GetInstance()->LoadTexture("Event/start.png");
    // å—ã‘å–ã£ãŸæ–‡å­—åˆ—ã‚’å°æ–‡å­—ã«å¤‰æ›ã—ã¦æ¯”è¼ƒï¼ˆå¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„ãŸã‚ï¼‰
    std::string lower = stateName;
    std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);

    // æ–‡å­—åˆ—ã«ã‚ˆã£ã¦stateã‚’è¨­å®š
    if (lower == "none") {
        state_ = EventState::None;

    } else if (lower == "gamestart") {
        // ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¤ãƒ™ãƒ³ãƒˆã®åˆæœŸåŒ–
        state_ = EventState::GameStart;
        // åˆæœŸåŒ–
        sprite_ = Sprite::Create("Event/Black.png", Vector2{ 0.0f, 300.0f }, 0.0f, Vector2{ 1280.0f,150.0f });
        sprite_->SetColor(Vector4{ 1.0f, 1.0f, 1.0f, 0.0f });
        alpha_ = 0.0f;
        // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚µã‚¤ã‚º
        size_ = { 1280.0f, 75.0f }; // ç”»é¢å¹…1280ã€é«˜ã•åŠåˆ†ãšã¤ãã‚‰ã„ã‚’æƒ³å®š
        // å·¦ã‹ã‚‰å³ã«å‹•ãã‚¹ãƒ—ãƒ©ã‚¤ãƒˆï¼ˆä¸Šå´ï¼‰
        topSprite_ = Sprite::Create("Event/Startevent_02.png", Vector2{ -1280.0f, 300.0f }, 0.0f, size_);
        topSprite_->SetTextureSize(Vector2{ 1280.0f,75.0f });
        // å³ã‹ã‚‰å·¦ã«é–‰ã˜ã‚‹ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆï¼ˆä¸‹å´ï¼‰
        bottomSprite_ = Sprite::Create("Event/Startevent_01.png", Vector2{ 1280.0f, 375.0f }, 0.0f, size_);
        bottomSprite_->SetTextureSize(Vector2{ 1280.0f,75.0f });
        closeSpeed_ = 17.0f; 
        // UIã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
        missionsize_ = { 300.0f,200.0f };
        mission_ = Sprite::Create("Event/mission.png", Vector2{ 500.0f, 265.0f }, 0.0f, missionsize_);
        missionalpha_ = 0.0f;
        mission_->SetColor(Vector4{ 1.0f, 1.0f, 1.0f, missionalpha_ });
        mission_->SetTextureSize(Vector2{ 300.0f,200.0f });

        // å„ç¨®åˆæœŸåŒ–
        timefige_ = false;
        topPos_ = { 0.0f,0.0f };
        bottomPos_ = { 0.0f,0.0f }; 
        isActive_ = true;
        isFinished_ = false;
    }
}

///====================================================
/// æ›´æ–°å‡¦ç†
///====================================================
void EventManager::Update() {
    if (state_ == EventState::None) {
        // ã‚¤ãƒ™ãƒ³ãƒˆãŒãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
        return;
    } else if (state_ == EventState::GameStart) {
        // å„ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°
        sprite_->Update();
        topSprite_->Update();
        bottomSprite_->Update();
        mission_->Update();
        // æ¼”å‡ºãƒ•ã‚§ãƒ¼ã‚ºã”ã¨ã«å‡¦ç†ã‚’åˆ†å²
        switch (phase_) {
            // ------------------------------
        // ãƒ•ã‚§ãƒ¼ã‚º1ï¼šé»’èƒŒæ™¯ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
        // ------------------------------
        case EventPhase::Phase1:
            alpha_ += 0.01f;  // å°‘ã—ãšã¤æ˜Žã‚‹ãã™ã‚‹
            sprite_->SetColor({ 1.0f, 1.0f, 1.0f, alpha_ }); // è‰²ï¼ˆRGBAï¼‰ã‚’æ›´æ–°

            if (alpha_ >= 0.7f) {
                alpha_ = 0.7f;
                phase_ = EventPhase::Phase2;
            }
            break;            
        // ------------------------------
        // ãƒ•ã‚§ãƒ¼ã‚º2ï¼šä¸Šä¸‹ã®ãƒãƒ¼ãŒä¸­å¤®ã¸é–‰ã˜ã‚‹
        // ------------------------------
        case EventPhase::Phase2:
            // ä¸Šå´ã®ç§»å‹•
            topPos_ = topSprite_->GetPosition();
            if (topPos_.x < 200.0f) { // å·¦ä¸Šåº§æ¨™ã‚’è»¸ã¨ã—ã¦ç›®çš„ã®å€¤ã®é”ã™ã‚‹ã¾ã§å³ã¸ç§»å‹•
                topPos_.x += closeSpeed_;
                if (topPos_.x > 0.0f) topPos_.x = 0.0f; // ã¯ã¿å‡ºã—é˜²æ­¢
            }

            // ä¸‹å´ã®ç§»å‹•
            bottomPos_ = bottomSprite_->GetPosition();
            if (bottomPos_.x > 0.0f) { // å·¦ä¸Šåº§æ¨™ã‚’è»¸ã¨ã—ã¦ç›®çš„ã®å€¤ã®é”ã™ã‚‹ã¾ã§å·¦ã¸ç§»å‹•
                bottomPos_.x -= closeSpeed_;
                if (bottomPos_.x < 0.0f) bottomPos_.x = 0.0f; // ã¯ã¿å‡ºã—é˜²æ­¢
            }

            // åæ˜ 
            topSprite_->SetPosition(topPos_);
            bottomSprite_->SetPosition(bottomPos_);

            // ä¸¡æ–¹ã¨ã‚‚ä¸­å¤®ã«åˆ°é”ã—ãŸã‚‰æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºã¸
            if (topPos_.x == 0.0f && bottomPos_.x == 0.0f) {
                phase_ = EventPhase::Phase3;
            }

            break;
        // ------------------------------
        // ãƒ•ã‚§ãƒ¼ã‚º3ï¼šMISSIONæ–‡å­—ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
        // ------------------------------
        case EventPhase::Phase3:
            missionalpha_ += 0.05f;  // å°‘ã—ãšã¤æ˜Žã‚‹ãã™ã‚‹

            if (missionalpha_ >= 1.0f) {
                missionalpha_ = 1.0f;
                timefige_ = true;
                phase_ = EventPhase::Phase4;
            }

            mission_->SetColor({ 1.0f, 1.0f, 1.0f, missionalpha_ }); // è‰²ï¼ˆRGBAï¼‰ã‚’æ›´æ–°
            break;
        // ------------------------------
        // ãƒ•ã‚§ãƒ¼ã‚º4ï¼šMISSIONè¡¨ç¤ºç¶­æŒ â†’ ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ â†’ â€œSTARTâ€è¡¨ç¤º
        // ------------------------------
        case EventPhase::Phase4:
            // æ˜Žã‚‹ããªã£ã¦ã‹ã‚‰æ™‚é–“ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            missionTimer_ += 1.0f / 60.0f; // 60fpsæ›ç®—ï¼ˆæ¯Žãƒ•ãƒ¬ãƒ¼ãƒ ç´„0.016ç§’ï¼‰
            if (missionTimer_ >= 1.0f && timefige_) {
                // 5ç§’çµŒéŽã—ãŸã‚‰ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹
                missionalpha_ -= 0.05f;
            }

            // æ¶ˆãˆåˆ‡ã£ãŸã‚‰æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºã¸
            if (missionalpha_ <= 0.0f) {
                missionalpha_ = 1.0f;
                timefige_ = false;
                mission_->SetTexture("Event/start.png");
                phase_ = EventPhase::End;
            }
            mission_->SetColor({ 1.0f, 1.0f, 1.0f, missionalpha_ }); // è‰²ï¼ˆRGBAï¼‰ã‚’æ›´æ–°
            break;
        // ------------------------------
        // ãƒ•ã‚§ãƒ¼ã‚ºEndï¼šãƒãƒ¼ãŒå¤–ã¸é–‹ã„ã¦çµ‚äº†
        // ------------------------------
        case EventPhase::End:
            // ä¸Šå´ã®ç§»å‹•
            if (topPos_.x < 1280.0f) { // ã•ã‚‰ã«spriteã®å¤§ãã•åˆ†ç§»å‹•
                topPos_.x += closeSpeed_;
                if (topPos_.x > 1280.0f) topPos_.x = 1280.0f;
            }
            // ä¸‹å´ã®ç§»å‹•
            if (bottomPos_.x > -1280.0f) { // ã•ã‚‰ã«spriteã®å¤§ãã•åˆ†ç§»å‹•
                bottomPos_.x -= closeSpeed_;
                if (bottomPos_.x < -1280.0f) bottomPos_.x = -1280.0f;
            }
            // ä¸¡æ–¹ãŒå®Œå…¨ã«å¤–ã«å‡ºãŸã‚‰ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†
            if (topPos_.x >= 1280.0f && bottomPos_.x <= -1280.0f) {
                missionalpha_ -= 0.05f;
                if (missionalpha_ <= 0.7f)
                    alpha_ -= 0.05f;
                if (alpha_ <= 0.0f && missionalpha_ <= 0.0f) {
                    state_ = EventState::None;
                    Reset();
                }
            }

            // åæ˜ 
            topSprite_->SetPosition(topPos_);
            bottomSprite_->SetPosition(bottomPos_);
            sprite_->SetColor({ 1.0f, 1.0f, 1.0f, alpha_ });
            mission_->SetColor({ 1.0f, 1.0f, 1.0f, missionalpha_ });
            break;
        }
    }
}
	
///====================================================
/// æç”»å‡¦ç†(3D)
///====================================================
void  EventManager::Drawo3Dbject(){
    if (state_ == EventState::None) {

    } else if (state_ == EventState::GameStart) {

    }
}

///====================================================
/// æç”»å‡¦ç†(2D)
///====================================================
void  EventManager::Draw2DSprite(){
    if (state_ == EventState::None) {

    } else if (state_ == EventState::GameStart) {
        sprite_->Draw();
        topSprite_->Draw();
        bottomSprite_->Draw();
        mission_->Draw();
    }
}

///====================================================
/// ãƒªã‚»ãƒƒãƒˆå‡¦ç†
///====================================================
void EventManager::Reset() {
    isActive_ = false;
    isFinished_ = true;
    timer_ = 0.0f;
}

///====================================================
/// ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º
///====================================================
void EventManager::DrawImGui() {
#ifdef USE_IMGUI
    ImGui::Begin("EventManager Debug");

    // ç¾åœ¨ã®ã‚¤ãƒ™ãƒ³ãƒˆçŠ¶æ…‹ã‚’è¡¨ç¤º
    const char* stateNames[] = { "None", "GameStart" };
    ImGui::Text("Current State: %s", stateNames[(int)state_]);

    // ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚ºã‚’è¡¨ç¤º
    const char* phaseNames[] = {
        "Phase1 (Start)",
        "Phase2",
        "Phase3",
        "Phase4",
        "End"
    };
    ImGui::Text("Current Phase: %s", phaseNames[(int)phase_]);

    // ä»»æ„ã§å„ç¨®å¤‰æ•°ã®å€¤ã‚‚ç¢ºèªã§ãã‚‹
    ImGui::Separator();
    ImGui::Text("Alpha: %.2f", alpha_);
    ImGui::Text("Mission Alpha: %.2f", missionalpha_);
    ImGui::Text("Mission Timer: %.2f", missionTimer_);
    ImGui::Text("Close Speed: %.2f", closeSpeed_);
//    ImGui::Checkbox("Freeze Time", &timefige_); // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒˆã‚°ãƒ«

    ImGui::End();
#endif // USE_IMGUI
}

============================================================
File Path: project/application/event/EventManager.h
============================================================
#pragma once
#include<Object3d.h>
#include<Sprite.h>
#include <vector>
#include <memory>

/// <summary>
/// ã‚¤ãƒ™ãƒ³ãƒˆã®é€²è¡Œæ®µéšŽ
/// </summary>
enum class EventPhase {
    Phase1,        // ç¬¬1æ®µéšŽï¼ˆæ¼”å‡ºé–‹å§‹)
    Phase2,        // ç¬¬2æ®µéšŽ
    Phase3,        // ç¬¬3æ®µéšŽ
    Phase4,        // ç¬¬4æ®µéšŽ
    End,           // å®Œäº† (æ¼”å‡ºçµ‚äº†)
};
/// <summary>
/// ç™ºç”Ÿã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã®ç¨®é¡ž
/// </summary>
enum EventState {
    None,                // ã‚¤ãƒ™ãƒ³ãƒˆãªã—
    GameStart,           // ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¤ãƒ™ãƒ³ãƒˆ
};

/// <summary>
/// å„æ¼”å‡ºã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
/// </summary>
class EventManager  {
private: // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    static EventManager* instance;
    // ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’é˜²ã
    EventManager(EventManager&) = delete;
    EventManager& operator=(EventManager&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•° 
    EventManager() = default;
    ~EventManager() = default;
    // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
    static EventManager* GetInstance();
    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize();
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
	void Initialize(const std::string& stateName);
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
	void Update();
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    /// <summary>
    /// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»
    /// </summary>
    void Drawo3Dbject();
    /// <summary>
    /// 2Dã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æç”»
    /// </summary>
    void Draw2DSprite();
    /// <summary>
    /// ImGuiã«ã‚ˆã‚‹ãƒ‡ãƒãƒƒã‚°æç”»
    /// </summary>
    void DrawImGui();

    /// <summary>
    /// ã‚¤ãƒ™ãƒ³ãƒˆçŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void Reset();
private:    // ãƒ¡ãƒ³ãƒå¤‰æ•°
    EventState state_ = EventState::None;      // ã‚¤ãƒ™ãƒ³ãƒˆã®ç¨®é¡ž
    float timer_ = 0.0f;                       // çµŒéŽæ™‚é–“
    EventPhase phase_ = EventPhase::Phase1;    // ã‚¤ãƒ™ãƒ³ãƒˆã”ã¨ã®æ¼”å‡ºãƒ•ã‚§ãƒ¼ã‚º
    // 2Dã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
    std::unique_ptr<Sprite> sprite_ = nullptr;
    float alpha_ = 0.0f;                        // ä¸é€æ˜Žåº¦ 
    // ä¸Šä¸‹ã‹ã‚‰é–‰ã˜ã‚‹æ¼”å‡ºç”¨ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ  
    std::unique_ptr<Sprite> topSprite_ = nullptr;
    std::unique_ptr<Sprite> bottomSprite_ = nullptr;
    Vector2 topPos_;                          // ä¸Šã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åº§æ¨™
    Vector2 bottomPos_;                       // ä¸‹ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åº§æ¨™
    Vector2 size_;                            // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ã‚µã‚¤ã‚º
    float closeSpeed_ = 0.0f;                 // ã‚¹ãƒ©ã‚¤ãƒ‰é€Ÿåº¦
    // æ–‡å­—æ¼”å‡ºã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
    std::unique_ptr<Sprite> mission_ = nullptr;
    Vector2 missionsize_;                     // æ–‡å­—ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚µã‚¤ã‚º
    float missionalpha_ = 0.0f;               // é€æ˜Žåº¦
    float missionTimer_ = 0.0f;               // çµŒéŽæ™‚é–“
    bool timefige_ = false;                   // æ™‚é–“åˆ¶å¾¡ãƒ•ãƒ©ã‚°ï¼Ÿ
    bool isActive_ = false;                   // ã‚¤ãƒ™ãƒ³ãƒˆå®Ÿè¡Œä¸­ãƒ•ãƒ©ã‚°
    bool isFinished_ = false;                 // ã‚¤ãƒ™ãƒ³ãƒˆå®Œäº†ãƒ•ãƒ©ã‚°
public:
    bool IsActive() const { return isActive_; }
    bool IsFinished() const { return isFinished_; }
};

============================================================
File Path: project/application/fade/FadeManager.cpp
============================================================
#include "FadeManager.h"
#include <TextureManager.h>
#define NOMINMAX
#include <Windows.h>
#ifdef min
#undef min
#endif
#ifdef max
#undef max
#endif
#include <algorithm>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
std::unique_ptr<FadeManager> FadeManager::instance = nullptr;

///====================================================
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
///====================================================
FadeManager* FadeManager::GetInstance() {
    if (!instance) {
        instance = std::make_unique<FadeManager>();
    }
    return instance.get();
}
///====================================================
/// çµ‚äº†å‡¦ç†
///====================================================
void FadeManager::Finalize() {
    instance.reset();  // `delete` ä¸è¦
}
///====================================================
/// åˆæœŸåŒ–å‡¦ç†
///====================================================
void FadeManager::Initialize() {
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿
    TextureManager::GetInstance()->LoadTexture("fade/Black.png");
    TextureManager::GetInstance()->LoadTexture("fade/white.png");
    // ãƒ•ã‚§ãƒ¼ãƒ‰ç”¨ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
    sprite_ = Sprite::Create("fade/Black.png", Vector2{ 0.0f, 0.0f }, 0.0f, Vector2{ 1280.0f,720.0f });
    sprite_->SetColor({ 1.0f, 1.0f, 1.0f, 0.0f }); // é€æ˜Žã‚¹ã‚¿ãƒ¼ãƒˆ         

    // å„ç¨®åˆæœŸå€¤
    timer_ = 0.0f;
    duration_ = 1.0f;
    alpha_ = 0.0f;
    fadeStart_ = false;
    fadeEnd_ = false;
    t_ = 0.0f;

    // ç”»é¢ã‚’æ ¼å­çŠ¶ã«é»’ä¸¸ã§åŸ‹ã‚ã‚‹
    const int cols = 10;
    const int rows = 6;
    const float spacingX = 1280.0f / cols;
    const float spacingY = 720.0f / rows; 
    const float maxDelay = 0.7f; // æœ€å¤§é…å»¶æ™‚é–“ï¼ˆç§’ï¼‰   
    Vector2 center = { 1280.0f / 2, 720.0f / 2 }; // ç”»é¢ä¸­å¿ƒ
    shapes_.clear(); 
    for (int y = 0; y < rows; ++y) {
        for (int x = 0; x < cols; ++x) {
            FadeShape shape;
            shape.position = { (x + 0.5f) * spacingX, (y + 0.5f) * spacingY };
            shape.size = { spacingX, spacingY };
            shape.scale = 0.0f;

            shape.sprite = Sprite::Create("fade/white.png", shape.position, 0.0f, shape.size);
            shape.sprite->SetAnchorPoint({ 0.5f, 0.5f });
            shape.sprite->SetColor({ 0, 0, 0, 0 });

            // ä¸­å¿ƒã‹ã‚‰ã®è·é›¢ã«å¿œã˜ã¦delayè¨­å®š
            float dx = shape.position.x - center.x;
            float dy = shape.position.y - center.y;
            float dist = std::sqrt(dx * dx + dy * dy);
            float maxDist = std::sqrt(center.x * center.x + center.y * center.y);
            shape.delay = (dist / maxDist) * maxDelay;
            shape.rotation = 0.0f;
            shape.rotationSpeed = (rand() % 2 == 0 ? 1 : -1) * (0.02f + (rand() % 100 / 5000.0f));
            shapes_.push_back(std::move(shape));
        }
    }
}
/// =========================================================
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
/// =========================================================
void FadeManager::StartFadeIn(float duration, FadeStyle style) {
    fadeType_ = FadeType::FadeIn;
    fadeStyle_ = style;
    duration_ = duration;
    duration_ = std::max(duration, 0.001f);
    t_ = 0.0f; 
    timer_ = 0.0f;
    alpha_ = 0.0f;
    fadeStart_ = true;
    fadeEnd_ = false;
    isFading_ = true;
}
/// =========================================================
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹
/// =========================================================
void FadeManager::StartFadeOut(float duration, FadeStyle style) {
    fadeType_ = FadeType::FadeOut;
    fadeStyle_ = style;
    duration_ = duration;
    duration_ = std::max(duration, 0.001f);
    t_ = 0.0f;
    timer_ = 0.0f;
    alpha_ = 0.0f;
    fadeStart_ = true;
    fadeEnd_ = false;
    isFading_ = true;
}
/// =========================================================
/// æ›´æ–°å‡¦ç†
/// =========================================================
void FadeManager::Update() {
    if (!isFading_) return;

    // çµŒéŽæ™‚é–“ã‚’é€²ã‚ã‚‹ï¼ˆ60FPSå‰æï¼‰
    const float deltaTime = 1.0f / 60.0f;
    timer_ += deltaTime;

    // çµŒéŽå‰²åˆã‚’æ±‚ã‚ã‚‹
    t_ = std::clamp(timer_ / duration_, 0.0f, 1.0f);
        
    // ã‚¹ã‚¿ã‚¤ãƒ«åˆ¥å‡¦ç†
    switch (fadeStyle_) {
    case FadeStyle::Normal: UpdateNormalFade(); break;
    case FadeStyle::SilhouetteSlide: UpdateSilhouetteSlideFade(); break;
    case FadeStyle::SilhouetteExplode: UpdateSilhouetteExplodeFade(); break;   
    }

    // ãƒ•ã‚§ãƒ¼ãƒ‰å®Œäº†åˆ¤å®š
    if (t_ >= 1.0f) {
        // ãƒ•ãƒ©ã‚°ãƒªã‚»ãƒƒãƒˆ
        isFading_ = false;
        fadeEnd_ = true;
    }
}
/// =========================================================
///  é€šå¸¸ãƒ•ã‚§ãƒ¼ãƒ‰ã®æ›´æ–°å‡¦ç†
/// =========================================================
void FadeManager::UpdateNormalFade() {
    if (fadeType_ == FadeType::FadeOut) {
        // é€æ˜Ž â†’ é»’
        alpha_ = t_;
    } else if (fadeType_ == FadeType::FadeIn) {
        // é»’ â†’ é€æ˜Ž
        alpha_ = 1.0f - t_;
    }
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã«åæ˜ 
    sprite_->SetColor({ 0.0f, 0.0f, 0.0f, alpha_ });
    sprite_->Update();
}
/// =========================================================
/// ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ•ã‚§ãƒ¼ãƒ‰ã®æ›´æ–°å‡¦ç†
/// =========================================================
void FadeManager::UpdateSilhouetteSlideFade() {
    const float maxScale = 1.0f;
    auto easeOutQuad = [](float t) { return 1 - (1 - t) * (1 - t); };

    for (auto& s : shapes_) {
        float localT = std::clamp((t_ - s.delay) / (1.0f - s.delay), 0.0f, 1.0f);
        float easedT = easeOutQuad(localT);

        float scale, alpha;
        if (fadeType_ == FadeType::FadeOut) {
            scale = easedT * maxScale;
            alpha = easedT;
        } else {
            scale = maxScale - easedT * maxScale;
            alpha = 1.0f - easedT;
        }

        s.scale = scale;
        s.sprite->SetSize(s.size * s.scale);
        s.sprite->SetColor({ 0,0,0,alpha });
        s.sprite->Update();
    }
}
// =========================================================
// çˆ†ç™ºãƒ•ã‚§ãƒ¼ãƒ‰ã®æ›´æ–°å‡¦ç†
// =========================================================
void FadeManager::UpdateSilhouetteExplodeFade() {
    const Vector2 center = { 1280.0f / 2, 720.0f / 2 };

    // å¼¾ã‘ã‚‹ã‚ˆã†ãªã‚¤ãƒ¼ã‚¸ãƒ³ã‚°
    auto easeOutElastic = [](float t) {
        const float c4 = (2 * 3.141592f) / 3;
        return (t == 0.0f) ? 0.0f :
            (t == 1.0f) ? 1.0f :
            powf(2.0f, -10.0f * t) * sinf((t * 10.0f - 0.75f) * c4) + 1.0f;
        };

    for (auto& s : shapes_) {
        float localT = std::clamp((t_ - s.delay) / (1.0f - s.delay), 0.0f, 1.0f);
        float easedT = easeOutElastic(localT);

        float scale = 1.0f;
        float alpha = 1.0f;
        Vector2 pos = s.position;
        Vector2 dir = { pos.x - center.x, pos.y - center.y };
        float len = std::sqrt(dir.x * dir.x + dir.y * dir.y);
        if (len > 0.0f) { dir.x /= len; dir.y /= len; }

        Vector4 color = { 0, 0, 0, 1 }; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé»’

        // ===============================================
        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå‡¦ç†ï¼ˆä¸­å¿ƒã«æˆ»ã‚‹ï¼‰
        // ===============================================
        if (fadeType_ == FadeType::FadeOut) {

            float spread = (1.0f - easedT) * 150.0f;
            Vector2 movedPos = { pos.x + dir.x * spread, pos.y + dir.y * spread };
            s.sprite->SetPosition(movedPos);

            scale = 1.0f - (1.0f - easedT) * 0.2f;
            alpha = easedT;
            color = { 0, 0, 0, alpha };
        }

        // ===============================================
        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å‡¦ç†ï¼ˆé»’â†’ç™½â†’çˆ†ç™ºç§»å‹•ï¼‰
        // ===============================================
        else {
            // 0ã€œ0.3ï¼šé»’â†’ç™½ã¸ï¼ˆé™æ­¢ï¼‰
            if (localT < 0.3f) {
                float colorT = localT / 0.3f; // 0â†’1
                color = {
                    colorT, colorT, colorT, 1.0f // é»’â†’ç™½
                };
                s.sprite->SetPosition(pos);  // å‹•ã‹ãªã„
                scale = 1.0f;
                alpha = 1.0f;
            }
            // 0.3ã€œ1.0ï¼šç™½â†’é»’ã«æˆ»ã‚ŠãªãŒã‚‰çˆ†ç™ºçš„ã«ç§»å‹•
            else {
                float moveT = (localT - 0.3f) / 0.7f; // 0ã€œ1ã¸æ­£è¦åŒ–
                float easedMoveT = easeOutElastic(moveT);

                // æ‹¡æ•£è·é›¢ï¼ˆçˆ†ç™ºï¼‰
                float spread = easedMoveT * 150.0f;
                Vector2 movedPos = { pos.x + dir.x * spread, pos.y + dir.y * spread };

                s.rotation += s.rotationSpeed * easedMoveT;
                s.sprite->SetRotation(s.rotation);
                s.sprite->SetPosition(movedPos);

                // ã‚¹ã‚±ãƒ¼ãƒ«ãƒ»ã‚¢ãƒ«ãƒ•ã‚¡å¤‰åŒ–
                scale = 1.0f + easedMoveT * 0.3f;

                // å®Œå…¨ã«é€æ˜Žã¾ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                alpha = std::clamp(1.0f - easedMoveT, 0.0f, 1.0f);


                // ç™½ã®ã¾ã¾å›ºå®š
                color = { 1.0f, 1.0f, 1.0f, alpha };
            }
        }

        // ===============================================
        // å…±é€šé©ç”¨
        // ===============================================
        s.scale = scale;
        s.sprite->SetSize(s.size * s.scale);
        s.sprite->SetColor(color);
        s.sprite->Update();
    }
}
/// =========================================================
/// æç”»å‡¦ç†
/// =========================================================
void FadeManager::Draw() {
    switch (fadeStyle_) {
    case FadeStyle::Normal:
        sprite_->Draw();
        break;
    case FadeStyle::SilhouetteSlide:
        for (auto& s : shapes_) {
            s.sprite->Draw();
        };
        break;
    case FadeStyle::SilhouetteExplode:
        for (auto& s : shapes_) {
            s.sprite->Draw();
        };
        break;
    }
}
/// =========================================================
/// ImGuiãƒ‡ãƒãƒƒã‚°æç”»ï¼ˆã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆï¼‰
/// =========================================================
void FadeManager::DrawImGui() {
#ifdef _DEBUG
    //ImGui::Begin("Fade Manager");

    //ImGui::Text("Fade Type: %s",
    //    fadeType_ == FadeType::FadeIn ? "FadeIn" :
    //    fadeType_ == FadeType::FadeOut ? "FadeOut" : "None");

    //ImGui::SliderFloat("Alpha", &alpha_, 0.0f, 1.0f);
    //ImGui::SliderFloat("Duration", &duration_, 0.1f, 5.0f);

    //if (ImGui::Button("Start Fade Out")) {
    //    StartFadeOut(duration_);
    //}
    //if (ImGui::Button("Start Fade In")) {
    //    StartFadeIn(duration_);
    //}

    //ImGui::Separator();
    //if (sprite_) {
    //    sprite_->DrawImGui();  // ðŸ‘ˆ Sprite ã® ImGui åˆ¶å¾¡ã‚‚å‘¼ã¶
    //}

    //ImGui::End();
#endif
}

============================================================
File Path: project/application/fade/FadeManager.h
============================================================
#pragma once
#include <memory>
#include <DirectXCommon.h>
#include <SrvManager.h>
#include <CopylmageCommon.h>
#include <SpriteCommon.h>
#include <Sprite.h>

/// <summary>
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã®ç¨®é¡ž
/// </summary>
enum class FadeType {
    None,    // é€šå¸¸
	FadeIn,  // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	FadeOut, // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
};
/// <summary>
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã®æ¼”å‡ºã‚¹ã‚¿ã‚¤ãƒ«
/// </summary>
enum class FadeStyle {
    Normal,   // å…¨ç”»é¢ãƒ•ã‚§ãƒ¼ãƒ‰
    SilhouetteExplode,    // ä¸­å¿ƒã‹ã‚‰å¤–ã«é£›ã³æ•£ã£ã¦æ¶ˆãˆã‚‹ãƒ•ã‚§ãƒ¼ãƒ‰
    SilhouetteSlide,      // å·¦â†’å³ã«æ¶ˆãˆã‚‹ã€å³â†’å·¦ã«ç¾ã‚Œã‚‹ï¼ˆç·šçŠ¶ãƒ•ã‚§ãƒ¼ãƒ‰ï¼‰
};
/// <summary>
/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã«ã‚ˆã‚‹ãƒ•ã‚§ãƒ¼ãƒ‰æ¼”å‡º
/// </summary>
struct FadeShape {
    std::unique_ptr<Sprite> sprite;
    Vector2 position;
    Vector2 size;
    float scale;
    float delay;   // ã“ã®ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆãŒæ‹¡å¤§ã‚’å§‹ã‚ã‚‹ã¾ã§ã®é…å»¶æ™‚é–“
    float rotation;        // ç¾åœ¨ã®å›žè»¢è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
    float rotationSpeed;   // å›žè»¢é€Ÿåº¦ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰
};
/// <summary>
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚’ç®¡ç†ã™ã‚‹ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹
/// </summary>
class FadeManager {
private:
	static std::unique_ptr<FadeManager> instance;

	FadeManager(FadeManager&) = delete;
	FadeManager& operator=(FadeManager&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	FadeManager() = default;
	~FadeManager() = default;
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static FadeManager* GetInstance();		
    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize();
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize();
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw();  
    /// <summary>
    /// ImGuiãƒ‡ãƒãƒƒã‚°æç”»
    /// </summary> 
    void DrawImGui();
 private:
	/// <summary>
    /// é€šå¸¸ãƒ•ã‚§ãƒ¼ãƒ‰ã®æ›´æ–°
    /// </summary>
    void UpdateNormalFade();     // é€šå¸¸ãƒ•ã‚§ãƒ¼ãƒ‰
    /// <summary>
    /// ã‚¹ãƒ©ã‚¤ãƒ‰ãƒ•ã‚§ãƒ¼ãƒ‰ã®æ›´æ–°
    // </summary>
    void UpdateSilhouetteExplodeFade();
    /// <summary>
    /// çˆ†ç™ºãƒ•ã‚§ãƒ¼ãƒ‰ã®æ›´æ–°
    /// </summary>
    void UpdateSilhouetteSlideFade();
 public:
   /// <summary>
   /// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
   /// </summary>
   void StartFadeIn(float duration, FadeStyle style);
   /// <summary>
   /// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹
   /// </summary>
   void StartFadeOut(float duration, FadeStyle style);
private:
    std::unique_ptr<Sprite> sprite_;  // ãƒ•ã‚§ãƒ¼ãƒ‰ç”¨ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
    FadeType fadeType_;               // ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ãƒ‰ç¨®åˆ¥
    FadeStyle fadeStyle_ = FadeStyle::Normal; // ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«
    float timer_;                     // çµŒéŽæ™‚é–“
    float duration_;                  // ãƒ•ã‚§ãƒ¼ãƒ‰æ™‚é–“
    float alpha_;                     // é€æ˜Žåº¦
    bool isFading_;                   // ãƒ•ã‚§ãƒ¼ãƒ‰ä¸­ãƒ•ãƒ©ã‚°
    bool fadeStart_;                  // é–‹å§‹çž¬é–“ãƒ•ãƒ©ã‚°
    bool fadeEnd_;                    // å®Œäº†çž¬é–“ãƒ•ãƒ©ã‚°
    float t_;                         // 0ã€œ1ã§é€²è¡Œåº¦ã‚’è¡¨ã™è£œé–“å€¤
    std::vector<FadeShape> shapes_;   // ãƒ•ã‚§ãƒ¼ãƒ‰æ¼”å‡ºã‚¹ãƒ—ãƒ©ã‚¤ãƒˆç¾¤

public:
    // getter
    FadeType GetFadeType() const { return fadeType_; }
    bool IsFadeStart() const { return fadeStart_; }
    bool IsFadeEnd() const { return fadeEnd_; }    
    bool IsFading() const { return isFading_; }
};

============================================================
File Path: project/application/loader/CharacterLoader.cpp
============================================================
#include "CharacterLoader.h"
#include<json.hpp>
#include <fstream>
#include <ModelManager.h>

const std::string CharacterLoader::kDefaultBaseDirectory = "Resources/levels/";
const std::string CharacterLoader::kExtension = ".json";

LevelData* CharacterLoader::LoadFile(const std::string& fileName) {
	
	// é€£çµã—ã¦ãƒ•ãƒ«ãƒ‘ã‚¹ã‚’å¾—ã‚‹
	const std::string fullpath = kDefaultBaseDirectory + fileName + kExtension;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ 
	std::ifstream file;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	file.open(fullpath);
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³å¤±æ•—ã‚’ãƒã‚§ãƒƒã‚¯
	if (file.fail()) {
		assert(0);
	}

	// JSONæ–‡å­—åˆ—ã‹ã‚‰è§£å‡ã—ãŸãƒ‡ãƒ¼ã‚¿
	nlohmann::json deserialized;
	
	// è§£å‡
	file >> deserialized;

	// æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
	assert(deserialized.is_object());
	assert(deserialized.contains("name"));
	assert(deserialized["name"].is_string());

	// "name"ã‚’æ–‡å­—åˆ—ã¨ã—ã¦
	std::string name = deserialized["name"].get<std::string>();
	// æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
	assert(name.compare("scene") == 0);

	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	levelData = new LevelData();
	
    // å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å†å¸°å‡¦ç†ã‚’å‘¼ã³å‡ºã™
    for (const auto& objectJson : deserialized["objects"]) {
        LoadObjectsRecursive(objectJson, *levelData);
    }

	return levelData;
}

void CharacterLoader::LoadObjectsRecursive(const nlohmann::json& objectJson, LevelData& levelData) {
    assert(objectJson.contains("type"));
    
    bool isDisabled = objectJson.contains("disabled") && objectJson["disabled"].get<bool>();

    if (!isDisabled) {
        // ç¨®åˆ¥ã‚’å–å¾—
        std::string type = objectJson["type"].get<std::string>();

        // ç¨®é¡žã”ã¨ã®å‡¦ç†

        // MESH
        if (type == "MESH") {
            // è¦ç´ è¿½åŠ 
            levelData.objects.emplace_back(LevelData::ObjectData{});
            // ä»Šè¿½åŠ ã—ãŸè¦ç´ ã®å‚ç…§ã‚’å¾—ã‚‹
            LevelData::ObjectData& objectData = levelData.objects.back();

            if (objectJson.contains("file_name")) {
                // file_name ã‚’å–å¾—ï¼ˆä¾‹: "uvChecker"ï¼‰
                objectData.fileName = objectJson["file_name"];

                //// .obj ã‚’ä»˜ã‘ãŸãƒ‘ã‚¹ã§ãƒ­ãƒ¼ãƒ‰ï¼ˆä¾‹: "uvChecker.obj"ï¼‰
                //std::string modelPath = objectData.fileName + ".obj";
                //ModelManager::GetInstance()->LoadModel(modelPath);
            }


            // ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
            const auto& transform = objectJson["transform"];
            // å¹³è¡Œç§»å‹•
            objectData.translation.x = (float)transform["translation"][0];
            objectData.translation.y = (float)transform["translation"][2];
            objectData.translation.z = (float)transform["translation"][1];
            // å›žè»¢è§’
            objectData.rotation.x = -(float)transform["rotation"][0];
            objectData.rotation.y = -(float)transform["rotation"][2];
            objectData.rotation.z = -(float)transform["rotation"][1];
            // ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
            objectData.scaling.x = (float)transform["scaling"][0];
            objectData.scaling.y = (float)transform["scaling"][2];
            objectData.scaling.z = (float)transform["scaling"][1];
        } else if (type.compare("PlayerSpawn") == 0) {                        // è‡ªã‚­ãƒ£ãƒ©ç™ºç”Ÿãƒã‚¤ãƒ³ãƒˆ
            // playersã«è¦ç´ ã‚’1ã¤è¿½åŠ ã™ã‚‹
            levelData.players.emplace_back(PlayerSpawnData{});
            PlayerSpawnData& playerData = levelData.players.back();
            // ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
            const auto& transform = objectJson["transform"];
            // å¹³è¡Œç§»å‹•ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€
            playerData.translation.x = (float)transform["translation"][0];
            playerData.translation.y = (float)transform["translation"][2]; // Yã¨Zå…¥ã‚Œæ›¿ãˆ
            playerData.translation.z = (float)transform["translation"][1];
            // å›žè»¢è§’ã®æ•°å€¤ã‚’ãƒ©ã‚¸ã‚¢ãƒ³ã§æ›¸ãè¾¼ã‚€
            playerData.rotation.x = -(float)transform["rotation"][0];
            playerData.rotation.y = -(float)transform["rotation"][2];
            playerData.rotation.z = -(float)transform["rotation"][1];
        } else if (type.compare("EnemySpawn") == 0) {                        // è‡ªã‚­ãƒ£ãƒ©ç™ºç”Ÿãƒã‚¤ãƒ³ãƒˆ
            // playersã«è¦ç´ ã‚’1ã¤è¿½åŠ ã™ã‚‹
            levelData.enemies.emplace_back(EnemySpawnData{});
            EnemySpawnData& enemyData = levelData.enemies.back();
            // ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
            const auto& transform = objectJson["transform"];
            // å¹³è¡Œç§»å‹•ã®æ•°å€¤ã‚’æ›¸ãè¾¼ã‚€
            enemyData.translation.x = (float)transform["translation"][0];
            enemyData.translation.y = (float)transform["translation"][2]; // Yã¨Zå…¥ã‚Œæ›¿ãˆ
            enemyData.translation.z = (float)transform["translation"][1];
            // å›žè»¢è§’ã®æ•°å€¤ã‚’ãƒ©ã‚¸ã‚¢ãƒ³ã§æ›¸ãè¾¼ã‚€
            enemyData.rotation.x = -(float)transform["rotation"][0];
            enemyData.rotation.y = -(float)transform["rotation"][2];
            enemyData.rotation.z = -(float)transform["rotation"][1];
			// ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–å¾—
			enemyData.fileName = objectJson["file_name"].get<std::string>();
        }
    }

    // å­ãƒŽãƒ¼ãƒ‰ãŒã‚ã‚Œã°å†å¸°å‘¼ã³å‡ºã—
    if (objectJson.contains("children") && objectJson["children"].is_array()) {
        for (const auto& childJson : objectJson["children"]) {
            LoadObjectsRecursive(childJson, levelData);
        }
    }
}

============================================================
File Path: project/application/loader/CharacterLoader.h
============================================================
#pragma once
#include<string>
#include <vector>
#include <Vector3.h>
#include<json.hpp>

// è‡ªã‚­ãƒ£ãƒ©ã®ç”Ÿæˆãƒ‡ãƒ¼ã‚¿
struct PlayerSpawnData {	
	// ä½ç½®ç§»å‹•
	Vector3 translation;
	// å›žè»¢è§’
	Vector3 rotation;
};	

struct EnemySpawnData {
	// ãƒ•ã‚¡ã‚¤ãƒ«å
	std::string fileName;
	// å¹³è¡Œç§»å‹•
	Vector3 translation;
	// å›žè»¢è§’
	Vector3 rotation;
};

// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿
struct LevelData {
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ1å€‹åˆ†ã®ãƒ‡ãƒ¼ã‚¿
	struct ObjectData {
		// ãƒ•ã‚¡ã‚¤ãƒ«å
		std::string fileName;
		Vector3 translation;
		Vector3 rotation;
		Vector3 scaling;
	};
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚³ãƒ³ãƒ†ãƒŠ
	std::vector<ObjectData> objects;
	// è‡ªã‚­ãƒ£ãƒ©é…åˆ—
	std::vector<PlayerSpawnData> players;	
	// è‡ªã‚­ãƒ£ãƒ©é…åˆ—
	std::vector<EnemySpawnData> enemies;
};

class CharacterLoader
{
public:// ãƒ¡ãƒ³ãƒé–¢æ•°			
    static const std::string kDefaultBaseDirectory;
    static const std::string kExtension;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	LevelData* LoadFile(const std::string& fileName);
	// ãƒ¢ãƒ‡ãƒ«ã®æƒ…å ±ã‚’å‡ºåŠ›	
	void LoadObjectsRecursive(const nlohmann::json& objectsJson, LevelData& levelData);

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	LevelData* levelData = nullptr;
};

============================================================
File Path: project/application/loader/CurveJsonLoader.cpp
============================================================
#include "CurveJsonLoader.h"
#include <json.hpp>
#include <fstream>
#include <stdexcept>

using json = nlohmann::json;

std::vector<BezierPoint> CurveJsonLoader::LoadBezierFromJSON(const std::string& filePath) {
    std::vector<BezierPoint> points;

    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
    std::ifstream file(filePath);
    if (!file.is_open()) {
        throw std::runtime_error("JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ");
    }

    // JSONãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
    json j;
    file >> j;

    // object_namesé…åˆ—ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    if (!j.contains("object_names") || !j["object_names"].is_array()) {
        throw std::runtime_error("object_names ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
    }

    // å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåï¼ˆã‚«ãƒ¼ãƒ–åï¼‰ã”ã¨ã«ãƒ«ãƒ¼ãƒ—
    for (const auto& name : j["object_names"]) {
        const std::string curveName = name.get<std::string>();

        // ã‚«ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
        if (!j.contains(curveName) || !j[curveName].is_array() || j[curveName].empty()) {
            continue;
        }

        // ã‚¹ãƒ—ãƒ©ã‚¤ãƒ³ã”ã¨ã«å‡¦ç†
        for (const auto& spline : j[curveName]) {
            for (const auto& pointData : spline) {
                // control_point ã®ã¿å­˜åœ¨ã™ã‚‹å ´åˆã«å¯¾å¿œ
                BezierPoint pt;

                if (pointData.contains("control_point") && pointData["control_point"].is_array()) {
                    pt.controlPoint = {
                        pointData["control_point"][0].get<float>(),
                        pointData["control_point"][1].get<float>(),
                        pointData["control_point"][2].get<float>()
                    };
                }

                // handle_left / handle_right ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯èª­ã¿è¾¼ã‚€
                if (pointData.contains("handle_left") && pointData["handle_left"].is_array()) {
                    pt.handleLeft = {
                        pointData["handle_left"][0].get<float>(),
                        pointData["handle_left"][1].get<float>(),
                        pointData["handle_left"][2].get<float>()
                    };
                }

                if (pointData.contains("handle_right") && pointData["handle_right"].is_array()) {
                    pt.handleRight = {
                        pointData["handle_right"][0].get<float>(),
                        pointData["handle_right"][1].get<float>(),
                        pointData["handle_right"][2].get<float>()
                    };
                }
                points.push_back(pt);
            }
        }
    }

    return points;
}


============================================================
File Path: project/application/loader/CurveJsonLoader.h
============================================================
#pragma once
#include <string>
#include <Vector3.h>
#include<vector>

/// <summary>
/// ãƒ™ã‚¸ã‚§æ›²ç·šã®1ç‚¹åˆ†ã®åˆ¶å¾¡æƒ…å ±ã‚’ä¿æŒã™ã‚‹æ§‹é€ ä½“
/// </summary>
struct BezierPoint {
    Vector3 handleLeft;
    Vector3 controlPoint;
    Vector3 handleRight;
    bool passed = true;  // â† ã“ã®åˆ¶å¾¡ç‚¹ã‚’é€šéŽã—ãŸã‹
};

/// <summary>
/// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ™ã‚¸ã‚§æ›²ç·šåˆ¶å¾¡ç‚¹ã‚’èª­ã¿è¾¼ã‚€ã‚¯ãƒ©ã‚¹
/// </summary>
class CurveJsonLoader {
public:
    /// <summary>
    /// æŒ‡å®šã—ãŸãƒ‘ã‚¹ã®JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€ãƒ™ã‚¸ã‚§åˆ¶å¾¡ç‚¹ãƒªã‚¹ãƒˆã‚’è¿”ã™
    /// </summary>
    /// <param name="filePath">JSONãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
    /// <returns>BezierPointã®é…åˆ—</returns>s
    std::vector<BezierPoint> LoadBezierFromJSON(const std::string& filePath);
};

============================================================
File Path: project/application/loader/EnemyLoader.cpp
============================================================
#include "EnemyLoader.h"
#include<json.hpp>
#include <fstream>
#include <ModelManager.h>

const std::string EnemyLoader::kDefaultBaseDirectory = "Resources/levels/";
const std::string EnemyLoader::kExtension = ".json";

LevelEnemyData* EnemyLoader::LoadFile(const std::string& fileName) {
	
	// é€£çµã—ã¦ãƒ•ãƒ«ãƒ‘ã‚¹ã‚’å¾—ã‚‹
	const std::string fullpath = kDefaultBaseDirectory + fileName + kExtension;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ 
	std::ifstream file;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	file.open(fullpath);
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³å¤±æ•—ã‚’ãƒã‚§ãƒƒã‚¯s
	if (file.fail()) {
		assert(0);
	}

	// JSONæ–‡å­—åˆ—ã‹ã‚‰è§£å‡ã—ãŸãƒ‡ãƒ¼ã‚¿
	nlohmann::json deserialized;
	
	// è§£å‡
	file >> deserialized;

	// æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
	assert(deserialized.is_object());
	assert(deserialized.contains("name"));
	assert(deserialized["name"].is_string());

	// "name"ã‚’æ–‡å­—åˆ—ã¨ã—ã¦
	std::string name = deserialized["name"].get<std::string>();
	// æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
	assert(name.compare("scene") == 0);

	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	levelData = new LevelEnemyData();
	
    // å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦å†å¸°å‡¦ç†ã‚’å‘¼ã³å‡ºã™
    for (const auto& objectJson : deserialized["objects"]) {
        LoadObjectsRecursive(objectJson, *levelData);
    }

	return levelData;
}

void EnemyLoader::LoadObjectsRecursive(const nlohmann::json& objectJson, LevelEnemyData& levelData) {
    assert(objectJson.contains("type"));

    bool isDisabled = objectJson.contains("disabled") && objectJson["disabled"].get<bool>();

    if (isDisabled) return;

    // ç¨®åˆ¥ã‚’å–å¾—
    std::string type = objectJson["type"].get<std::string>();

    if (type == "MESH" && objectJson.contains("name")) {

        std::string name = objectJson["name"].get<std::string>();

        // ===== Enemy åˆ¤å®š =====
        if (name.rfind("Enemy_", 0) == 0) {

            EnemyData enemy{};

            enemy.name = name;
            enemy.enemyIndex = ExtractNumber(name);

            // ===== type åˆ¤å®š =====
            if (objectJson.contains("file_name")) {
                std::string fileName =
                    objectJson["file_name"].get<std::string>();
                enemy.enemyType = ExtractType(fileName);
            } else {
                enemy.enemyType = 0;
            }

            // ===== transform =====
            const auto& transform = objectJson["transform"];
            enemy.translation.x = (float)transform["translation"][0];
            enemy.translation.y = (float)transform["translation"][2];
            enemy.translation.z = (float)transform["translation"][1];

            levelData.enemies.push_back(enemy);
        }
    }

    // å­ãƒŽãƒ¼ãƒ‰ãŒã‚ã‚Œã°å†å¸°å‘¼ã³å‡ºã—
    if (objectJson.contains("children") && objectJson["children"].is_array()) {
        for (const auto& childJson : objectJson["children"]) {
            LoadObjectsRecursive(childJson, levelData);
        }
    }
}

============================================================
File Path: project/application/loader/EnemyLoader.h
============================================================
#pragma once
#include<string>
#include <vector>
#include <Vector3.h>
#include<json.hpp>

struct EnemyData {
	std::string name;     // Enemy_00
	int enemyIndex;       // 0,1,2...
	int enemyType;        // 0,1,2...
	Vector3 translation;
};

// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿
struct LevelEnemyData {
	std::vector<EnemyData> enemies;      // â˜… Enemyå°‚ç”¨
};

class EnemyLoader
{
public:// ãƒ¡ãƒ³ãƒé–¢æ•°			
    static const std::string kDefaultBaseDirectory;
    static const std::string kExtension;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	LevelEnemyData* LoadFile(const std::string& fileName);
	// ãƒ¢ãƒ‡ãƒ«ã®æƒ…å ±ã‚’å‡ºåŠ›	
	void LoadObjectsRecursive(const nlohmann::json& objectsJson, LevelEnemyData& levelData);

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	LevelEnemyData* levelData = nullptr;

public:
	int ExtractNumber(const std::string& str) {
		auto pos = str.find_last_of('_');
		if (pos == std::string::npos) return 0;
		return std::stoi(str.substr(pos + 1)); // Enemy_00 â†’ 0 
	}
	int ExtractType(const std::string& fileName) {
		if (fileName.rfind("type_", 0) != 0) {
			return 0;
		}
		return std::stoi(fileName.substr(5));// type_01 â†’ 1
	}
};

============================================================
File Path: project/application/particle/BaseEmitter.h
============================================================
#pragma once
#include<Vector3.h>
#include <string>
#include <vector>
#include<ParticleManager.h>
#include<Object3d.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI

class BaseEmitter {
public:
    //ã»ã¨ã‚“ã©ã®ãƒ¡ãƒ³ãƒå¤‰æ•°ã‚’ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚Šã€ãƒ¡ãƒ³ãƒå¤‰æ•°ã«ä»£å…¥ã™ã‚‹
    BaseEmitter(const std::string& name, const uint32_t count, const Transform& transform, const Vector4& color, float lifetime, float currentTime, const Velocity& Velocity, const RandomParameter& randomParameter)
        : name_(name), count_(count), transform_(transform), color_(color),
        frequency_(lifetime), frequencyTime_(currentTime), velocity_(Velocity),
        random_(randomParameter) {
    }

    virtual ~BaseEmitter() = default;
    virtual void Update() = 0;   // â† å‹•ä½œã”ã¨ã«é•ã†
    void Emit() {
        auto& group = ParticleManager::GetInstance()->GetGroup(name_);

        // ç¾åœ¨ç”Ÿå­˜ä¸­ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°
        uint32_t aliveCount = static_cast<uint32_t>(group.particles.size());

        // æ®‹ã‚Šç™ºç”Ÿå¯èƒ½æ•°
        uint32_t remaining = maxParticles_ > aliveCount ? maxParticles_ - aliveCount : 0;
        if (remaining == 0) return;

        // 1å›žã®ç™ºç”Ÿæ•°ã¯æ®‹ã‚Šã‚’è¶…ãˆãªã„ã‚ˆã†ã«
        uint32_t emitCount = std::min(emitPerTick_, remaining);

        ParticleManager::GetInstance()->Emit(name_, transform_, color_, emitCount, velocity_, frequency_, random_);  
    }

    void SetTarget(Object3d* obj) { target_ = obj; } // FollowEmitterç”¨ getter/setter


    // ImGui
    virtual void DrawImGuiUI() {
#ifdef USE_IMGUI
        if (ImGui::CollapsingHeader(name_.c_str())) {
            ImGui::DragInt("Count", reinterpret_cast<int*>(&count_), 1, 1, 1000);

            // Transform èª¿æ•´
            ImGui::Text("Transform");
            ImGui::DragFloat3("Translate", &transform_.translate.x, 0.01f);
            ImGui::DragFloat3("Rotate", &transform_.rotate.x, 0.1f);
            ImGui::DragFloat3("Scale", &transform_.scale.x, 0.01f);

            // Velocity èª¿æ•´
            ImGui::Text("Velocity");
            ImGui::DragFloat3("Velocity Translate", &velocity_.translate.x, 0.01f);
            ImGui::DragFloat3("Velocity Rotate", &velocity_.rotate.x, 0.01f);
            ImGui::DragFloat3("Velocity Scale", &velocity_.scale.x, 0.01f);
            // Color
            ImGui::ColorEdit4("Color", &color_.x);

            // ç™ºç”Ÿå‘¨æœŸ(Frequency)ã®èª¿æ•´
            ImGui::DragFloat("Frequency (sec)", &frequency_, 0.01f, 0.0f, 60.0f);
            // --- åˆæœŸã‚¿ã‚¤ãƒžãƒ¼å€¤ ---
            ImGui::DragFloat("Initial Elapsed Time", &frequencyTime_, 0.01f, 0.0f, 60.0f);            
            random_.DrawImGuiUI(); // RandomParameter ã® UI

            // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®UI
            random_.DrawImGuiUI();

            // é€£ç¶šç™ºç”Ÿé–¢é€£
            ImGui::Separator();
            ImGui::Text("Continuous Emission Settings");
            ImGui::DragInt("Max Particles", reinterpret_cast<int*>(&maxParticles_), 1, 1, 10000);
            ImGui::DragInt("Emit Per Tick", reinterpret_cast<int*>(&emitPerTick_), 1, 1, 100);

            // å€¤ã®åˆ¶é™ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€å¤§ < æœ€å°ã«ãªã‚‰ãªã„ã‚ˆã†ã«ï¼‰
            if (emitPerTick_ > static_cast<int>(maxParticles_)) emitPerTick_ = maxParticles_;
        }
#endif // USE_IMGUI
    }

protected:
    std::string name_;
    uint32_t count_;
    Transform transform_;
    Vector4 color_;
    float frequency_;
    float frequencyTime_;
    Velocity velocity_;
    RandomParameter random_;

    Object3d* target_ = nullptr; // â† FollowEmitterç”¨
   
    bool useGravity_ = false;

public:
    uint32_t maxParticles_ = 100;   // æœ€å¤§ç”Ÿæˆæ•°
    uint32_t emitPerTick_ = 1;      // 1å›žã®Emitã§å‡ºã™æ•°
    uint32_t currentParticles_ = 0; // ç¾åœ¨ç”Ÿæˆæ¸ˆã¿ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°

  
    void SetUseGravity(bool enable) { useGravity_ = enable; }

};

============================================================
File Path: project/application/particle/DefaultParticleEmitter.cpp
============================================================
#include "DefaultParticleEmitter.h"
#include <numbers>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI

void DefaultParticleEmitter::Update() {
    // æ™‚é–“åŠ ç®—
    timer_ += 1.0f / 60.0f;

    // ä¸€å®šæ™‚é–“çµŒéŽã—ãŸã‚‰çˆ†ç™º
    if (timer_ >= explodeDelay_ && !exploded_) {
        // ç™ºç”Ÿãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°åˆ† Emit
        for (uint32_t i = 0; i < count_; ++i) {
            Emit();
        }
        // ã‚¿ã‚¤ãƒžãƒ¼ãƒªã‚»ãƒƒãƒˆ
        timer_ = 0.0f;
        exploded_ = true;
    } 
}

bool DefaultParticleEmitter::IsDead() const {
    return frequency_ <= 0.0f;
}

============================================================
File Path: project/application/particle/DefaultParticleEmitter.h
============================================================
#pragma once
#include<BaseEmitter.h>
#include<CameraManager.h>

class DefaultParticleEmitter : public BaseEmitter {
public:
    using BaseEmitter::BaseEmitter;


    void Update() override;


    bool exploded_ = false;
    float timer_ = 0.0f;
    float explodeDelay_ = 0.4f;  // ä½•ç§’å¾Œã«çˆ†ç™ºã™ã‚‹ã‹
public:
    // ===== å¤–éƒ¨ã‹ã‚‰è¨­å®šç”¨ =====
    void SetPosition(const Vector3& pos) { transform_.translate = pos; }
    void SetLifeTime(float time) { frequency_ = time; }
    void SetEmitCount(uint32_t count) { count_ = count; }
    void SetExplodeDelay(float sec) { explodeDelay_ = sec; }
    
    bool IsDead() const;

};



============================================================
File Path: project/application/particle/FollowEmitter.h
============================================================
#pragma once
#include<BaseEmitter.h>
#include<CameraManager.h>

class FollowEmitter : public BaseEmitter {
public:
    using BaseEmitter::BaseEmitter;

        
    Vector3 offset_{ 0.0f, 0.0f, 0.0f }; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã®ç›¸å¯¾ã‚ªãƒ•ã‚»ãƒƒãƒˆ 
    // åˆæœŸåŒ–ãƒ•ãƒ©ã‚°
    bool initialized_ = false;
    float emitInterval_ = 0.06f;         // ç™ºç”Ÿé–“éš”ï¼ˆç§’ï¼‰

    void Update() override {
        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæœªè¨­å®šãªã‚‰ Emit ã—ãªã„ï¼ˆçµ¶å¯¾æ¡ä»¶ï¼‰
        if (!target_) {
            return;
        }

        // æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã¸è¿½å¾“
        transform_.translate = target_->GetTransform().translate + offset_;
        if (auto cam = CameraManager::GetInstance()->GetActiveCamera()) {
            transform_.rotate = cam->GetRotate();
        }

        // åˆæœŸåŒ–ç›´å¾Œã¯ emit ã‚’ç¦æ­¢ï¼ˆ1ãƒ•ãƒ¬ãƒ¼ãƒ ã ã‘ï¼‰
        if (!initialized_) {
            initialized_ = true;
            frequencyTime_ = 0.0f;
            return;   // â˜… Emit ã¯ã¾ã ç¦æ­¢
        }

        // ç™ºç”Ÿã‚¿ã‚¤ãƒžãƒ¼æ›´æ–°
        frequencyTime_ += 1.0f / 60.0f;

        // ç™ºç”Ÿ
        if (frequencyTime_ >= emitInterval_) {
            // Emit ç›´å‰ã« transform ã‚’ç¢ºå®š
            if (target_) {
                transform_.translate = target_->GetTransform().translate + offset_;
            }
            Emit();
            frequencyTime_ = 0.0f;
        }
    }

    void DrawImGuiUI() override {
        BaseEmitter::DrawImGuiUI(); // åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯å…±é€š UI
#ifdef USE_IMGUI
        if (ImGui::CollapsingHeader("FollowEmitter")) {
            if (target_) {
                Vector3 pos = target_->GetTransform().translate;
                ImGui::Text("Following target at %.2f, %.2f, %.2f", pos.x, pos.y, pos.z);
            } else {
                ImGui::Text("No target assigned");
            }
            // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿æ•´å¯èƒ½ã«
            ImGui::DragFloat3("Offset", &offset_.x, 0.1f); 
            // ç™ºç”Ÿé–“éš”ã‚’èª¿æ•´å¯èƒ½ã«
            ImGui::DragFloat("Emit Interval (sec)", &emitInterval_, 0.01f, 0.0f, 60.0f);
        }
#endif // USE_IMGUI
    }



    // FollowEmitter.h
    void SetOffset(const Vector3& offset) { offset_ = offset; }
    Vector3 GetOffset() const { return offset_; }

    void SetVelocity(const Velocity& v) { velocity_ = v; }
    Velocity GetVelocity() const { return velocity_; }

};

============================================================
File Path: project/application/particle/GameClearparticle.cpp
============================================================
#include "GameClearparticle.h"
#include <numbers>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI

void GameClearparticle::Initialize(Object3d* target) {
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆ
    ParticleManager::GetInstance()->CreateParticleGroup("Particles", "Particle/Particle.png", "Particle.obj", VertexType::Model);
    ParticleManager::GetInstance()->CreateParticleGroup("Particles_02", "Particle/Particle_02.png", "Particle_02.obj", VertexType::Model);

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«ãƒ©ãƒ³ãƒ€ãƒ å¤‰æ•°ã‚’çµ„ã¿è¾¼ã‚€[ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å…¨ã¦0] 
    random_
        .SetOffset({ -0.3f,0.0f,-0.1f }, { 0.3f,0.0f,0.1f })
        .SetColor(0.0f, 1.0f)
        .SetVelocity({ 0.0f,0.0f,0.0f }, { 0.0f,0.0f,0.0f });

    // ç™ºç”Ÿ
    particles_ = std::make_unique <FollowEmitter>(
        "Particles",                                                                           // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—å
        1,                                                                                     // ç™ºç”Ÿæ•°
        Transform{ { 0.05f, 0.1f, 0.3f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f } },        // ã‚µã‚¤ã‚º,å›žè»¢,ä½ç½®
        Vector4{ 1.0f,1.0f,1.0f,1.0f },                                                          // ã‚«ãƒ©ãƒ¼
        1.5f,                                                                                  //  å¯¿å‘½
        0.0f,                                                                                  // çµŒéŽæ™‚é–“ï¼ˆåŸºæœ¬ã¯0ã‹ã‚‰é–‹å§‹ï¼‰
        Velocity{ {0.0f, -0.06f, 0.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0} },                 // â† é¢¨
        random_                                                                                // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆé€Ÿåº¦ã€å›žè»¢ã€ã‚¹ã‚±ãƒ¼ãƒ«ã€è‰²ãªã©ã®ç¯„å›²ã‚’æŒ‡å®šï¼‰
    );

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    particles_->SetTarget(target);
    particles_->maxParticles_ = 200;   // æœ€å¤§200å€‹ã¾ã§
    particles_->emitPerTick_ = 2;      // 1å›žã®Updateã§2å€‹ãšã¤ç™ºç”Ÿ
    particles_->SetOffset({ -1.0f, 0.8f, 0.0f });

    // ç™ºç”Ÿ
    particles_02_ = std::make_unique <FollowEmitter>(
        "Particles_02",                                                                           // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—å
        1,                                                                                     // ç™ºç”Ÿæ•°
        Transform{ { 0.05f, 0.1f, 0.3f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f } },        // ã‚µã‚¤ã‚º,å›žè»¢,ä½ç½®
        Vector4{ 1.0f,1.0f,1.0f,1.0f },                                                          // ã‚«ãƒ©ãƒ¼
        0.8f,                                                                                  //  å¯¿å‘½
        0.0f,                                                                                  // çµŒéŽæ™‚é–“ï¼ˆåŸºæœ¬ã¯0ã‹ã‚‰é–‹å§‹ï¼‰
        Velocity{ {0.0f, -0.06f, 0.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0} },                 // â† é¢¨
        random_                                                                                // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆé€Ÿåº¦ã€å›žè»¢ã€ã‚¹ã‚±ãƒ¼ãƒ«ã€è‰²ãªã©ã®ç¯„å›²ã‚’æŒ‡å®šï¼‰
    );

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    particles_02_->SetTarget(target);
    particles_02_->maxParticles_ = 100;   // æœ€å¤§200å€‹ã¾ã§
    particles_02_->emitPerTick_ = 1;      // 1å›žã®Updateã§2å€‹ãšã¤ç™ºç”Ÿ
    particles_02_->SetOffset({ -1.0f, 0.8f, 0.0f });
}

void GameClearparticle::Update() {
    particles_->Update();
    particles_02_->Update();

#ifdef USE_IMGUI
    particles_->DrawImGuiUI();
#endif // USE_IMGUI

}

============================================================
File Path: project/application/particle/GameClearparticle.h
============================================================
#pragma once
#include <ParticleManager.h>
#include <ParticleEmitter.h>
#include<FollowEmitter.h>

// ã‚¿ã‚¤ãƒˆãƒ«å°‚ç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
class GameClearparticle {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize(Object3d* target);
    /// <summary>
    /// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ ã®æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();
        
    void SetVelocity(const Velocity& v) { if (particles_) particles_->SetVelocity(v),particles_02_->SetVelocity(v); }

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç”Ÿæˆ
    std::unique_ptr <FollowEmitter> particles_;
    // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    RandomParameter random_;
    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç”Ÿæˆ
    std::unique_ptr <FollowEmitter> particles_02_;
};

============================================================
File Path: project/application/particle/GameOverparticle.cpp
============================================================
#include "GameOverparticle.h"
#include <numbers>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI

void GameOverparticle::Initialize(const std::vector<Object3d*>& targets) {
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆ
    ParticleManager::GetInstance()->CreateParticleGroup("Particles", "Particle/Particle.png", "Particle.obj", VertexType::Model);
    ParticleManager::GetInstance()->CreateParticleGroup("Particles_02", "Particle/Particle_02.png", "Particle_02.obj", VertexType::Model);
    random_
        .SetOffset({ -0.3f,-0.01f,-0.3f }, { 0.3f,0.3f,0.3f })
        .SetColor(0.0f, 0.5f)
        .SetVelocity({ -0.02f,-0.01f,-0.02f }, { 0.02f,0.01f,0.02f })
        .SetLifetime(-0.3f,0.1f);

    for (auto* target : targets) {
        auto emitter = std::make_unique<FollowEmitter>(
            "Particles",
            1,
            Transform{{0.1f, 0.1f, 0.1f}, {0,0,0}, {0,0,0}},
            Vector4{1,1,1,1},
            1.0f,
            0.0f,
            Velocity{{0.0f, 0.06f, 0.0f},{0,0,0},{0,0,0}},
            random_
        );

        emitter->SetTarget(target);
        emitter->maxParticles_ = 500;
        emitter->emitPerTick_ = 3;
        emitter->SetOffset({0.0f, 0.0f, 0.0f});
        emitters_.push_back(std::move(emitter));
    }

    for (auto* target : targets) {
        auto emitter = std::make_unique<FollowEmitter>(
            "Particles_02",
            1,
            Transform{ {0.1f, 0.1f, 0.1f}, {0,0,0}, {0,0,0} },
            Vector4{ 1,1,1,1 },
            0.7f,
            0.0f,
            Velocity{ {0.0f, 0.06f, 0.0f},{0,0,0},{0,0,0} },
            random_
        );

        emitter->SetTarget(target);
        emitter->maxParticles_ = 250;
        emitter->emitPerTick_ = 1;
        emitter->SetOffset({ 0.0f, 0.0f, 0.0f });
        emitters2_.push_back(std::move(emitter));
    }
}

void GameOverparticle::Update() {
    for (auto& e : emitters_) {
       e->Update();
    }
    for (auto& e : emitters2_) {
       e->Update();
    }
#ifdef USE_IMGUI
    for (auto& e : emitters_) {
 //       e->DrawImGuiUI();
    }
#endif
}

void GameOverparticle::Finalize() {
    emitters_.clear();
    emitters2_.clear();
}

============================================================
File Path: project/application/particle/GameOverparticle.h
============================================================
#pragma once
#include <ParticleManager.h>
#include <ParticleEmitter.h>
#include<FollowEmitter.h>

// ã‚¿ã‚¤ãƒˆãƒ«å°‚ç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
class GameOverparticle {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize(const std::vector<Object3d*>& targets);
    /// <summary>
    /// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ ã®æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();

    void Finalize();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç”Ÿæˆ
    std::vector<std::unique_ptr<FollowEmitter>> emitters_;
    // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    RandomParameter random_;
    std::vector<std::unique_ptr<FollowEmitter>> emitters2_;
};

============================================================
File Path: project/application/particle/GamePlayparticle.cpp
============================================================
#include "GamePlayparticle.h"
#include <numbers>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI

void GamePlayparticle::Initialize(Object3d* target) {
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆ
    ParticleManager::GetInstance()->CreateParticleGroup("Particles", "Particle/Particle.png", "Particle.obj", VertexType::Model);
    ParticleManager::GetInstance()->CreateParticleGroup("Particles_02", "Particle/Particle_02.png", "Particle_02.obj", VertexType::Model);
    ParticleManager::GetInstance()->CreateParticleGroup("Firework", "Particle/Particle.png", "Particle.obj", VertexType::Model);    
    ParticleManager::GetInstance()->CreateParticleGroup("Shockwave", "Particle/Shockwave.png", "Shockwave.obj", VertexType::Model);


    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«ãƒ©ãƒ³ãƒ€ãƒ å¤‰æ•°ã‚’çµ„ã¿è¾¼ã‚€[ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å…¨ã¦0] 
    random_
        .SetOffset({ -0.3f,0.0f,-0.1f }, { 0.3f,0.0f,0.1f })
        .SetColor(0.0f, 1.0f)
        .SetVelocity({ 0.0f,0.0f,0.0f }, { 0.0f,0.0f,0.0f });

    // ç™ºç”Ÿ
    particles_ = std::make_unique <FollowEmitter>(
        "Particles",                                                                           // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—å
        1,                                                                                     // ç™ºç”Ÿæ•°
        Transform{ { 0.05f, 0.1f, 0.3f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f } },        // ã‚µã‚¤ã‚º,å›žè»¢,ä½ç½®
        Vector4{ 1.0f,1.0f,1.0f,1.0f },                                                          // ã‚«ãƒ©ãƒ¼
        0.8f,                                                                                  //  å¯¿å‘½
        0.0f,                                                                                  // çµŒéŽæ™‚é–“ï¼ˆåŸºæœ¬ã¯0ã‹ã‚‰é–‹å§‹ï¼‰
        Velocity{ {0.0f, -0.06f, -0.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0} },                 // â† é¢¨
        random_                                                                                // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆé€Ÿåº¦ã€å›žè»¢ã€ã‚¹ã‚±ãƒ¼ãƒ«ã€è‰²ãªã©ã®ç¯„å›²ã‚’æŒ‡å®šï¼‰
    );

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    particles_->SetTarget(target);
    particles_->maxParticles_ = 400;   // æœ€å¤§200å€‹ã¾ã§
    particles_->emitPerTick_ = 2;      // 1å›žã®Updateã§2å€‹ãšã¤ç™ºç”Ÿ
    particles_->SetOffset({ 0.0f, 0.3f, 0.0f });

    // ç™ºç”Ÿ
    particles_02_ = std::make_unique <FollowEmitter>(
        "Particles_02",                                                                           // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—å
        1,                                                                                     // ç™ºç”Ÿæ•°
        Transform{ { 0.05f, 0.1f, 0.3f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f } },        // ã‚µã‚¤ã‚º,å›žè»¢,ä½ç½®
        Vector4{ 1.0f,1.0f,1.0f,1.0f },                                                          // ã‚«ãƒ©ãƒ¼
        0.4f,                                                                                  //  å¯¿å‘½
        0.0f,                                                                                  // çµŒéŽæ™‚é–“ï¼ˆåŸºæœ¬ã¯0ã‹ã‚‰é–‹å§‹ï¼‰
        Velocity{ {0.0f, -0.06f, -0.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0} },                 // â† é¢¨
        random_
    );
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    particles_02_->SetTarget(target);
    particles_02_->maxParticles_ = 250;   // æœ€å¤§200å€‹ã¾ã§
    particles_02_->emitPerTick_ = 1;      // 1å›žã®Updateã§2å€‹ãšã¤ç™ºç”Ÿ
    particles_02_->SetOffset({ 0.0f, 0.3f, 0.0f });


    explosionErandom_
        .SetOffset({ 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f })
        .SetScale({ 0.06f,0.06f,0.06f }, { 0.1f, 0.1f, 0.1f })
        .SetVelocity({ -0.1f, -0.1f, -0.1f }, { 0.15f,  0.2f,  0.1f });


    shockwaveErandom_
        .SetRotate({ 0.0f,0.0f,0.0f }, { 0.0f,0.0f,360.0f }) // Zè»¸ã«ãƒ©ãƒ³ãƒ€ãƒ å›žè»¢
        .SetScale({ 0.02f,0.02f,0.02f }, { 0.1f,0.1f,0.1f }) // åˆæœŸã‚µã‚¤ã‚ºã«ãƒ©ãƒ³ãƒ€ãƒ å·® 
        .SetLifetime(0.3f, 0.5f)          // çŸ­ã„å¯¿å‘½ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
        .SetVelocity(
            Velocity{
                {0.0f,0.0f,0.0f},  // ä½ç½®ã®ç§»å‹•ã¯ãªã—
                {0.0f,0.0f,0.0f},  // å›žè»¢ãªã—
                {0.006f,0.006f,0.006f} // scale ãŒå¢—ãˆã‚‹é€Ÿåº¦
            },
            Velocity{
                {0.0f,0.0f,0.0f},
                {0.0f,0.0f,0.0f},
                {0.06f,0.06f,0.06f} // æœ€å¤§é€Ÿåº¦
            }
        );
}

void GamePlayparticle::Update() {
    particles_->Update();
    particles_02_->Update();



    // ãƒ’ãƒƒãƒˆåº§æ¨™ã‚­ãƒ¥ãƒ¼å‡¦ç†
    for (const Vector3& pos : hitPositions_) {
        // çˆ†ç™ºã‚¨ãƒŸãƒƒã‚¿ç”Ÿæˆï¼ˆæ•µãŒã‚„ã‚‰ã‚ŒãŸçž¬é–“ã ã‘ï¼‰
        auto explosion = std::make_unique<DefaultParticleEmitter>(
            "Firework", 5,
            Transform{ {0.0f,0.0f,0.0f},{0,0,0}, pos },
            Vector4{ 1,0.6f,0.2f,1 }, 0.0f, 0.0f,
            Velocity{ {0,0,0},{0,0,0},{0,0,0} }, explosionErandom_
        );
        explosion->SetLifeTime(1.0f);
        explosion->SetEmitCount(30);
        explosionEmitters_.push_back(std::move(explosion));

        auto shockwave = std::make_unique<DefaultParticleEmitter>(
            "Shockwave", 1,
            Transform{ {0,0,0},{0,0,0}, pos },
            Vector4{ 1,1,1,1 }, 0.0f, 0.0f,
            Velocity{ {0,0,0},{0,0,0},{0,0,0} }, shockwaveErandom_
        );
        shockwave->SetLifeTime(0.7f);
        shockwave->SetEmitCount(5);
        shockwaveEmitters_.push_back(std::move(shockwave));
    }
    hitPositions_.clear();

    // ã™ã¹ã¦ã®çˆ†ç™ºãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ›´æ–°
    explosionEmitters_.erase(
        std::remove_if(explosionEmitters_.begin(), explosionEmitters_.end(),
            [](auto& e) {
                e->Update();
                return e->IsDead();
            }),
        explosionEmitters_.end()
    );

    shockwaveEmitters_.erase(
        std::remove_if(shockwaveEmitters_.begin(), shockwaveEmitters_.end(),
            [](auto& e) {
                e->Update();
                return e->IsDead();
            }),
        shockwaveEmitters_.end()
    );







#ifdef USE_IMGUI
    particles_->DrawImGuiUI();
#endif // USE_IMGUI

}

============================================================
File Path: project/application/particle/GamePlayparticle.h
============================================================
#pragma once
#include <ParticleManager.h>
#include <ParticleEmitter.h>
#include<FollowEmitter.h>
#include<DefaultParticleEmitter.h>

// ã‚¿ã‚¤ãƒˆãƒ«å°‚ç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
class GamePlayparticle {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize(Object3d* target);
    /// <summary>
    /// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ ã®æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();
        // æ•µãƒ’ãƒƒãƒˆæ™‚ã«å‘¼ã¶ï¼ˆè¤‡æ•°æ•µå¯¾å¿œï¼‰
    void AddHitPosition(const Vector3& pos) { hitPositions_.push_back(pos); }


private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç”Ÿæˆ
    std::unique_ptr <FollowEmitter> particles_;
    // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    RandomParameter random_;
        // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç”Ÿæˆ
    std::unique_ptr <FollowEmitter> particles_02_;


  
    std::vector<std::unique_ptr<DefaultParticleEmitter>> explosionEmitters_;
    std::vector<std::unique_ptr<DefaultParticleEmitter>> shockwaveEmitters_;
    // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    RandomParameter shockwaveErandom_;
    RandomParameter explosionErandom_;
    float time_ = 0.0f;
    bool exploded_ = false;
      
    bool hitEnemy_ = false;      // æ•µã«å½“ãŸã£ãŸã‚‰ true
std::vector<Vector3> hitPositions_;
    bool move = false; 
public:

    void SethitEnemy_(bool hit) { hitEnemy_ = hit; }
};

============================================================
File Path: project/application/particle/Titleparticle.cpp
============================================================
#include "Titleparticle.h"
#include <numbers>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI

void Titleparticle::Initialize(Object3d* target) {
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ç”Ÿæˆ
    ParticleManager::GetInstance()->CreateParticleGroup("Particles", "Particle/Particle.png", "Particle.obj", VertexType::Model);
    ParticleManager::GetInstance()->CreateParticleGroup("Particles_02", "Particle/Particle_02.png", "Particle_02.obj", VertexType::Model);

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«ãƒ©ãƒ³ãƒ€ãƒ å¤‰æ•°ã‚’çµ„ã¿è¾¼ã‚€[ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯å…¨ã¦0] 
    random_
        .SetOffset({ 0.0f,0.0f,-0.1f }, { 0.0f,0.0f,0.1f })
        .SetColor(1.0f, 1.0f)
        .SetVelocity({ -0.13f,0.0f,0.0f }, { 0.0f,0.0f,0.0f });

    // ç™ºç”Ÿ
    particles_ = std::make_unique <FollowEmitter>(
        "Particles",                                                                           // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—å
        1,                                                                                     // ç™ºç”Ÿæ•°
        Transform{ { 0.3f, 0.1f, 0.3f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 30.0f } },        // ã‚µã‚¤ã‚º,å›žè»¢,ä½ç½®
        Vector4{ 1.0f,1.0f,1.0f,0.5f },                                                          // ã‚«ãƒ©ãƒ¼
        1.5f,                                                                                  //  å¯¿å‘½
        0.0f,                                                                                  // çµŒéŽæ™‚é–“ï¼ˆåŸºæœ¬ã¯0ã‹ã‚‰é–‹å§‹ï¼‰
        Velocity{ {-0.06f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0} },                 // â† é¢¨
        random_                                                                                // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆé€Ÿåº¦ã€å›žè»¢ã€ã‚¹ã‚±ãƒ¼ãƒ«ã€è‰²ãªã©ã®ç¯„å›²ã‚’æŒ‡å®šï¼‰
    );

    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    particles_->SetTarget(target);
    particles_->maxParticles_ = 300;   // æœ€å¤§200å€‹ã¾ã§
    particles_->emitPerTick_ = 3;      // 1å›žã®Updateã§2å€‹ãšã¤ç™ºç”Ÿ
    particles_->SetOffset({ -0.4f, 0.7f, 0.0f });

    // ç™ºç”Ÿ
    particles_02_ = std::make_unique <FollowEmitter>(
        "Particles_02",                                                                           // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—å
        1,                                                                                     // ç™ºç”Ÿæ•°
        Transform{ { 0.3f, 0.1f, 0.3f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 30.0f } },        // ã‚µã‚¤ã‚º,å›žè»¢,ä½ç½®
        Vector4{ 1.0f,1.0f,1.0f,0.5f },                                                          // ã‚«ãƒ©ãƒ¼
        0.7f,                                                                                  //  å¯¿å‘½
        0.0f,                                                                                  // çµŒéŽæ™‚é–“ï¼ˆåŸºæœ¬ã¯0ã‹ã‚‰é–‹å§‹ï¼‰
        Velocity{ {-0.06f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0} },                 // â† é¢¨
        random_                                                                                // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆé€Ÿåº¦ã€å›žè»¢ã€ã‚¹ã‚±ãƒ¼ãƒ«ã€è‰²ãªã©ã®ç¯„å›²ã‚’æŒ‡å®šï¼‰
    );
    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
    particles_02_->SetTarget(target);
    particles_02_->maxParticles_ = 100;   // æœ€å¤§200å€‹ã¾ã§
    particles_02_->emitPerTick_ = 1;      // 1å›žã®Updateã§2å€‹ãšã¤ç™ºç”Ÿ
    particles_02_->SetOffset({ -0.4f, 0.7f, 0.0f });
}

void Titleparticle::Update() {
    particles_->Update();
    particles_02_->Update();
#ifdef USE_IMGUI
    particles_->DrawImGuiUI();
#endif // USE_IMGUI

}

============================================================
File Path: project/application/particle/Titleparticle.h
============================================================
#pragma once
#include <ParticleManager.h>
#include <ParticleEmitter.h>
#include<FollowEmitter.h>
#include<DefaultParticleEmitter.h>

// ã‚¿ã‚¤ãƒˆãƒ«å°‚ç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
class Titleparticle {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize(Object3d* target);
    /// <summary>
    /// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ ã®æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç”Ÿæˆ
    std::unique_ptr <FollowEmitter> particles_;
    // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    RandomParameter random_;
    // ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç”Ÿæˆ
    std::unique_ptr <FollowEmitter> particles_02_;
};

============================================================
File Path: project/application/pause/Pausemenu.cpp
============================================================
#include "Pausemenu.h"
#include <TextureManager.h>
#include <Input.h>
#include<Easing.h>
#include <SceneManager.h>
#include <FadeManager.h>
#ifdef min
#undef min
#endif
#ifdef max
#undef max
#endif

using namespace Easing;

void Pausemenu::Initialize() {
    TextureManager::GetInstance()->LoadTexture("Textures/Ui/PauseMenuPanel.png");
    TextureManager::GetInstance()->LoadTexture("Textures/Ui/Arrow.png");
    TextureManager::GetInstance()->LoadTexture("Textures/Ui/command_01.png");
    TextureManager::GetInstance()->LoadTexture("Textures/Ui/command_02.png");
    TextureManager::GetInstance()->LoadTexture("Textures/Ui/Poseicon.png");
    TextureManager::GetInstance()->LoadTexture("Textures/Ui/command_11.png");
    TextureManager::GetInstance()->LoadTexture("Textures/Ui/command_12.png");
    TextureManager::GetInstance()->LoadTexture("Textures/Ui/Poseicon_red.png");
    command_ = PauseCommand::None;
    isActive_ = false;
    selectedIndex_ = 0;
    MAXselectedIndex_ = 2;
    frame_ = 0.0f;
    baseSize_ = { 700.0f, 400.0f }; // æœ€çµ‚çš„ãªã‚µã‚¤ã‚º 
    panelTargetPos = { 650.0f, 350.0f };
    menupanel_ = Sprite::Create("Textures/Ui/PauseMenuPanel.png", panelTargetPos, 0.0f, baseSize_);
    menupanel_->SetAnchorPoint(Vector2{ 0.5f,0.5f });
    arrow_.size = { 50.0f,50.0f };
    arrow_.sprite = Sprite::Create("Textures/Ui/Arrow.png", Vector2{ 770.0f, 350.0f }, 0.0f, arrow_.size);
    arrow_.sprite->SetAnchorPoint(Vector2{ 0.5f,0.5f });

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
    std::string textures[] = { "Textures/Ui/command_01.png", "Textures/Ui/command_02.png" };
    for (uint32_t i = 0; i < kMaxCommand; ++i) {
        commands_[i].size = { 150.0f, 50.0f };
        // Yåº§æ¨™ã‚’é–“éš”åˆ†ãšã‚‰ã—ã¦é…ç½®
        Vector2 pos = { 640.0f, kMenuTopY + (i * kMenuIntervalY) };
        if (i == 0) {
            arrow_.sprite->SetPosition({ 750.0f,pos.y });
        }
        commands_[i].sprite = Sprite::Create(textures[i], pos, 0.0f, commands_[i].size);
        commands_[i].sprite->SetAnchorPoint({ 0.5f, 0.5f });
    }
    icon_ = Sprite::Create("Textures/Ui/Poseicon.png", Vector2{ 3.0f, 3.0f }, 0.0f, Vector2{ 100.0f,100.0f });
    kStartOffestY = 800.0f;
}

void Pausemenu::Update() {
    // --- 1. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæ¼”å‡ºï¼‰ã®æ›´æ–° ---
    if (isActive_) {
        if (frame_ < kMaxFrame + 20.0f) { // å…¨ä½“ã®æ¼”å‡ºæ™‚é–“ã‚’ãƒ‡ã‚£ãƒ¬ã‚¤åˆ†å°‘ã—ä¼¸ã°ã™
            frame_ += 1.0f;
        }
    } else {
        if (frame_ > 0.0f) {
            frame_ -= 1.0f;
        } else {
            isFinished_ = true;
        }
    }

    // --- 2. å„ãƒ‘ãƒ¼ãƒ„ã®ã‚µã‚¤ã‚ºæ›´æ–°ï¼ˆæ™‚é–“å·®ã‚’ã¤ã‘ã‚‹ï¼‰ ---
    // èƒŒæ™¯ãƒ‘ãƒãƒ«ï¼šå³åº§ã«é–‹å§‹
    CalculateEaseSize(menupanel_.get(), baseSize_, frame_, kMaxFrame);
    CalculateEasePos(menupanel_.get(), panelTargetPos, kStartOffestY, frame_, kMaxFrame);

    // ã‚³ãƒžãƒ³ãƒ‰ï¼šèƒŒæ™¯ãƒ‘ãƒãƒ«ã‚ˆã‚Š 10ãƒ•ãƒ¬ãƒ¼ãƒ é…ã‚Œã¦é–‹å§‹
    float buttonFrame = std::max(0.0f, frame_ - 10.0f);
    std::string textures_green[] = { "Textures/Ui/command_11.png", "Textures/Ui/command_12.png" };
    std::string textures_red[] = { "Textures/Ui/command_01.png", "Textures/Ui/command_02.png" };
    for (uint32_t i = 0; i < kMaxCommand; ++i) {
        CalculateEaseSize(commands_[i].sprite.get(), commands_[i].size, buttonFrame, kMaxFrame);
        // --- é¸æŠžä¸­ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£å·®ã—æ›¿ãˆå‡¦ç† ---
        if (isActive_ && i == selectedIndex_) {
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹0ï¼ˆResumeï¼‰ãŒé¸æŠžã•ã‚Œã¦ã„ã‚‹æ™‚ã ã‘ command_11 ã«å·®ã—æ›¿ãˆã‚‹
            commands_[i].sprite->SetTexture(textures_green[i]);      
            commands_[i].sprite->SetColor({ 1.0f, 1.0f, 1.0f, 1.0f }); // è‰²ã«ã‚ˆã‚‹å¼·èª¿ãŒä¸è¦ãªã‚‰ç™½ã«æˆ»ã™
        } else {
            // éžé¸æŠžæ™‚ã¯å…ƒã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã«æˆ»ã™
            commands_[i].sprite->SetTexture(textures_red[i]);
            commands_[i].sprite->SetColor({ 1.0f, 1.0f, 1.0f, 1.0f });
        }
    }

    // çŸ¢å°ï¼šèƒŒæ™¯ãƒ‘ãƒãƒ«ã‚ˆã‚Š 15ãƒ•ãƒ¬ãƒ¼ãƒ é…ã‚Œã¦é–‹å§‹
    float arrowFrame = std::max(0.0f, frame_ - 10.0f);
    CalculateEaseSize(arrow_.sprite.get(), arrow_.size, arrowFrame, kMaxFrame);

    // å…¥åŠ›ã¨ä½ç½®ã®æ›´æ–°ï¼ˆå®Œå…¨ã«é–‹ããã£ã¦ã„ã‚‹æ™‚ã®ã¿æ“ä½œå¯èƒ½ï¼‰
    if (isActive_ && frame_ >= kMaxFrame) {
        UpdateSelection(); // ã‚³ãƒžãƒ³ãƒ‰é¸æŠž
        UpdateArrowPositions(); // çŸ¢å°ã®å‡¦ç†
    }
    menupanel_->Update();
    arrow_.sprite->Update();
    for (UIElement& cmd : commands_) {
        cmd.sprite->Update(); // å…¨ã¦ã®é¸æŠžè‚¢
    }
}

void Pausemenu::Draw() {

    menupanel_->Draw();
    for (UIElement& cmd : commands_) {
        cmd.sprite->Draw(); // å…¨ã¦ã®é¸æŠžè‚¢
    }
    if (isActive_ && frame_ >= kMaxFrame) {
        arrow_.sprite->Draw();
    }
}

void Pausemenu::CalculateEaseSize(Sprite* sprite, const Vector2& baseSize, float frame, float maxFrame) {
    if (!sprite) return;

    float t = std::clamp(frame / maxFrame, 0.0f, 1.0f);
    float easeT = 0.0f;

    if (t == 0.0f) {
        easeT = 0.0f;
    } else if (t == 1.0f) {
        easeT = 1.0f;
    } else {
        // easeOutBack ã®è¨ˆç®—å¼
        const float c1 = 1.70158f;
        const float c3 = c1 + 1.0f;
        easeT = 1.0f + c3 * std::pow(t - 1.0f, 3.0f) + c1 * std::pow(t - 1.0f, 2.0f);
    }

    Vector2 currentSize = { baseSize.x * easeT, baseSize.y * easeT };
    sprite->SetSize(currentSize);
}

void Pausemenu::UpdateSelection() {
    // å…¥åŠ›ã«ã‚ˆã‚‹é¸æŠžé …ç›®ã®åˆ‡ã‚Šæ›¿ãˆ
    if (Input::GetInstance()->Triggrkey(DIK_UP) || Input::GetInstance()->Triggrkey(DIK_W)) {
        selectedIndex_ = (selectedIndex_ - 1 + MAXselectedIndex_) % MAXselectedIndex_;
    }
    if (Input::GetInstance()->Triggrkey(DIK_DOWN) || Input::GetInstance()->Triggrkey(DIK_S)) {
        selectedIndex_ = (selectedIndex_ + 1) % MAXselectedIndex_;
    }
    // æ±ºå®š
    if (Input::GetInstance()->Triggrkey(DIK_RETURN)) {
        if (selectedIndex_ == 0) {
            // Resumeã‚’é¸æŠž: isActiveã‚’falseã«ã—ã¦é€†å†ç”Ÿæ¼”å‡ºã‚’é–‹å§‹ã•ã›ã‚‹
            isActive_ = false;
            command_ = PauseCommand::None; // ã¾ã ã‚²ãƒ¼ãƒ å´ã«ã¯é€šçŸ¥ã—ãªã„ï¼ˆæ¼”å‡ºã‚’å¾…ã¤ãŸã‚ï¼‰
        } else if (selectedIndex_ == 1) {
            command_ = PauseCommand::GoToTitle;
        }
    }
}
void Pausemenu::UpdateArrowPositions() {
    // ç¾åœ¨é¸ã°ã‚Œã¦ã„ã‚‹é …ç›®ã®ä½ç½®ã‚’å–å¾—
    Vector2 targetPos = commands_[selectedIndex_].sprite->GetPosition();

    // çŸ¢å°ã‚’é …ç›®ã®å·¦å´ï¼ˆã¾ãŸã¯å³å´ï¼‰ã«é…ç½®ã™ã‚‹ãŸã‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    // ä¾‹: é …ç›®ã®ä¸­å¿ƒã‹ã‚‰å·¦ã« 120ãƒ”ã‚¯ã‚»ãƒ«ãšã‚‰ã™
    float offset = 120.0f;
    arrow_.sprite->SetPosition(Vector2{ targetPos.x + offset, targetPos.y });
}

void Pausemenu::IconUpdate() {
    if (isActive_) {
        icon_->SetTexture("Textures/Ui/Poseicon_red.png");
    } else {
        icon_->SetTexture("Textures/Ui/Poseicon.png");
    }

    icon_->Update();
}
 
void Pausemenu::IconDraw() {
    icon_->Draw();
}

// Pausemenu.cpp ã«è¿½åŠ 
void Pausemenu::CalculateEasePos(Sprite* sprite, const Vector2& targetPos, float startY, float frame, float maxFrame) {
    if (!sprite) return;

    float t = std::clamp(frame / maxFrame, 0.0f, 1.0f);
    float easeT = 0.0f;

    if (t == 0.0f) {
        easeT = 0.0f;
    } else if (t == 1.0f) {
        easeT = 1.0f;
    } else {
        // ç¾åœ¨ä½¿ç”¨ã—ã¦ã„ã‚‹ easeOutBack ã‚’ãã®ã¾ã¾åˆ©ç”¨
        const float c1 = 1.70158f;
        const float c3 = c1 + 1.0f;
        easeT = 1.0f + c3 * std::pow(t - 1.0f, 3.0f) + c1 * std::pow(t - 1.0f, 2.0f);
    }

    // Yåº§æ¨™ã‚’è£œé–“ (startY ã‹ã‚‰ targetPos.y ã¾ã§)
    float currentY = startY + (targetPos.y - startY) * easeT;
    sprite->SetPosition({ targetPos.x, currentY });
}

============================================================
File Path: project/application/pause/Pausemenu.h
============================================================
#pragma once
#include<Object3d.h>
#include<Sprite.h>
#include <vector>
#include <memory>

// ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®é¸æŠžè‚¢
enum class PauseCommand {
    Resume,     // ã‚²ãƒ¼ãƒ å†é–‹
    GoToTitle,  // ã‚¿ã‚¤ãƒˆãƒ«ã¸
    kCount,     // è¦ç´ æ•°ã‚«ã‚¦ãƒ³ãƒˆç”¨ï¼ˆå¸¸ã«æœ€å¾Œã«ç½®ãï¼‰
    None        // é¸æŠžä¸­
};

// UIãƒ‘ãƒ¼ãƒ„ã”ã¨ã®æ¼”å‡ºãƒ‡ãƒ¼ã‚¿ã‚’ã¾ã¨ã‚ãŸæ§‹é€ ä½“
struct UIElement {
    std::unique_ptr<Sprite> sprite;
    Vector2 size;   // ã‚µã‚¤ã‚º
};

/// <summary>
/// å„æ¼”å‡ºã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
/// </summary>
class Pausemenu {
public: // ãƒ¡ãƒ³ãƒé–¢æ•° 
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize();
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw();

    void CalculateEaseSize(Sprite* sprite, const Vector2& baseSize, float frame, float maxFrame);
    void CalculateEasePos(Sprite* sprite, const Vector2& targetPos, float startY, float frame, float maxFrame);
    void UpdateSelection();  // ã‚­ãƒ¼å…¥åŠ›ã«ã‚ˆã‚‹é¸æŠžé …ç›®ã®å¤‰æ›´
    void UpdateArrowPositions();
    void IconUpdate();
    void IconDraw();
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    std::unique_ptr <Sprite> menupanel_;
    std::unique_ptr <Sprite> icon_;
    // é¸æŠžè‚¢ã®è¡¨ç¤ºç”¨ï¼ˆå¿…è¦ã«å¿œã˜ã¦å¢—ã‚„ã™ï¼‰
   // std::vector<Sprite*> cursor_;
    PauseCommand command_ = PauseCommand::None;
    uint32_t selectedIndex_; // ç¾åœ¨é¸ã‚“ã§ã„ã‚‹é …ç›®
    uint32_t MAXselectedIndex_;
    float frame_;           // ç¾åœ¨ã®çµŒéŽãƒ•ãƒ¬ãƒ¼ãƒ 
    const float kMaxFrame = 30.0f; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‹ã‘ã‚‹æ™‚é–“ï¼ˆ30ãƒ•ãƒ¬ãƒ¼ãƒ  = ç´„0.5ç§’ï¼‰
    Vector2 baseSize_; // æœ€çµ‚çš„ãªã‚µã‚¤ã‚º

    bool isActive_;   // ä»Šãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ã“ã†ã¨ã—ã¦ã„ã‚‹ã‹
    bool isFinished_ = false; // é–‰ã˜ã‚‹æ¼”å‡ºãŒå®Œå…¨ã«çµ‚ã‚ã£ãŸ

    UIElement arrow_;

    // åˆ—æŒ™åž‹ã‹ã‚‰è¦ç´ æ•°ã‚’å–å¾—
    static const uint32_t kMaxCommand = static_cast<uint32_t>(PauseCommand::kCount);
    UIElement commands_[kMaxCommand];
    // é…ç½®ç”¨å®šæ•°
    const float kMenuTopY = 300.0f;     // æœ€åˆã®é …ç›®ã®Yåº§æ¨™
    const float kMenuIntervalY = 80.0f; // é …ç›®é–“ã®é–“éš”
    const float kArrowOffsetX = 120.0f; // é …ç›®ä¸­å¿ƒã‹ã‚‰è¦‹ãŸçŸ¢å°ã®å³ã‚ªãƒ•ã‚»ãƒƒãƒˆ

    float kStartOffestY;

   Vector2 panelTargetPos;
public: // ãƒ¡ãƒ³ãƒé–¢æ•° 
    // ã‚·ãƒ¼ãƒ³å´ã‹ã‚‰çŠ¶æ³ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®é–¢æ•°
    PauseCommand GetCommand() const { return command_; }


    bool IsActive() const { return isActive_; }
    // ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’èµ·å‹•ã™ã‚‹ï¼ˆã¾ãŸã¯é–‰ã˜ã‚‹æº–å‚™ã‚’ã™ã‚‹ï¼‰
    void SetActive(bool active) {
        isActive_ = active;
        isFinished_ = false; // çŠ¶æ…‹ãŒå¤‰ã‚ã‚‹ãŸã³ã«ãƒªã‚»ãƒƒãƒˆ
    }
    bool IsFinished() const { return isFinished_; }
};

============================================================
File Path: project/application/player/Player.cpp
============================================================
#include "Player.h"
#include <ModelManager.h>
#include <CameraManager.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include <Input.h>
#include<PlayerBullet.h>
#include <BulletManager.h>
#include <MatrixVector.h>
#include<TextureManager.h>
#include <algorithm>
#include <chrono>
#include <algorithm> // std::max ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã«å¿…è¦
#include <Skybox.h>
#include<ModelDate.h>

using namespace MatrixVector;

Player::~Player() {}

void Player::Initialize() {	 
    // ãƒ¢ãƒ‡ãƒ«ãƒ»ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
    ModelManager::GetInstance()->LoadModel("Gameplay/Model/Player/Player.obj");     
    ModelManager::GetInstance()->LoadModel("Bullet/PlayerBullet.obj");
    TextureManager::GetInstance()->LoadTexture("Gameplay/Texture/Target.png");

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆæœŸä½ç½®ã¨å›žè»¢ã‚’è¨­å®š
    transform_ = { {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f, 0.0f},  0.0f,0.0f,0.0f };
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”Ÿæˆ
    object = Object3d::Create("Gameplay/Model/Player/Player.obj", transform_);

    targettransform_ = { {0.3f, 0.3f, 0.3f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 30.0f} };
    target_= Object3d::Create("Bullet/PlayerBullet.obj", targettransform_);
    moveDelta = Vector3(0.0f, 0.0f, 0.0f);

    // ãƒ¬ãƒ†ã‚£ã‚¯ãƒ«åˆæœŸåŒ–
    reticleScreenPos = { 640.0f, 360.0f }; // ç”»é¢ä¸­å¤® (ä»®ã«1280x720ã®å ´åˆ)
    targetreticle_ = Sprite::Create("Gameplay/Texture/Target.png", reticleScreenPos, 0.0f, Vector2{ 100.0f, 100.0f });
    targetreticle_->SetTextureSize(Vector2{ 512.0f, 512.0f });
   	targetreticle_->SetAnchorPoint(Vector2{ 0.5f, 0.5f }); // ä¸­å¿ƒåŸºæº–
    previousTime_ = 0.0f;

    // æ­»äº¡é–¢é€£
    deathTimer_ = 0.0f;
    // å›žè»¢é€Ÿåº¦ï¼ˆãƒãƒ©ãƒãƒ©ã«å›žã‚‹æ„Ÿã˜ï¼‰
    deathRotateSpeed_ = { 0.05f, 0.07f, 0.02f };
    // è»½ãã‚¹ã‚±ãƒ¼ãƒ«ã‚’ä¸Šã’ã‚‹æ¼”å‡ºãªã©
    transform_.scale = { 0.5f, 0.5f, 0.5f };
    fallVelocity = { 0.0f,0.0f,0.0f };
}

void Player::Update() {
    CameraManager* camMgr = CameraManager::GetInstance();
    Camera* activeCam = camMgr->GetMainCamera();

    // GamePlayCamera ã˜ã‚ƒãªã„ãªã‚‰ãƒ¬ãƒ¼ãƒ«å‡¦ç†ã‚’ã—ãªã„
    if (camMgr->GetActiveSceneCamera() == SceneCameraType::Gameplay) {
        //        UpdateNonRail();   // ä½•ã‚‚ã—ãªã„ or ç°¡æ˜“æ›´æ–°

        GamePlayCamera* gameCam = camMgr->GetGameplayCamera();

        // ã‚«ãƒ¡ãƒ©ã®ãƒ™ã‚¸ã‚§ä½ç½®ï¼ˆãƒ¬ãƒ¼ãƒ«ä¸Šã®å®Ÿåº§æ¨™ï¼‰
        Vector3 camPos = gameCam->GetBezierPos();

        // ã‚«ãƒ¡ãƒ©ã®å‘ãï¼ˆã™ã§ã«æ­£è¦åŒ–ã•ã‚Œã¦ã„ã‚‹å‰æï¼‰
        Vector3 forward = gameCam->GetForward();
        Vector3 right = gameCam->GetRight();
        Vector3 up = gameCam->GetUp();

        // ====== ã‚«ãƒ¡ãƒ©åŸºæº–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆ ======
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åŸºæº–ä½ç½®ï¼ˆã‚«ãƒ¡ãƒ©ã‹ã‚‰ã®ç›¸å¯¾åº§æ¨™ï¼‰
        Vector3 cameraBaseOffset = { 0.0f, -3.0f, 30.0f };

        // ã‚«ãƒ¡ãƒ©åº§æ¨™ç³»ã«å¤‰æ›
        Vector3 cameraBaseWorld =
            right * cameraBaseOffset.x +
            up * cameraBaseOffset.y +
            forward * cameraBaseOffset.z;
        // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ä¸­
        if (CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Main) {
            // ===== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å›žè»¢ï¼ˆã‚«ãƒ¡ãƒ©æ–¹å‘ + tiltï¼‰ =====
            transform_.rotate = activeCam->GetRotate();
        }

        // ç¾åœ¨æ™‚åˆ»ã‚’å–å¾—ï¼ˆç§’ï¼‰
        float currentTime = static_cast<float>(std::chrono::duration<double>(std::chrono::high_resolution_clock::now().time_since_epoch()).count());

        // deltaTime ã‚’è¨ˆç®—
        float deltaTime = currentTime - previousTime_;
        previousTime_ = currentTime;

        if (CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Sub) {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤â€•æ­»äº¡æ¼”å‡º
            StartDeathEffect();
        }

        if (ickyActive_) {
            float currentSpeed = isBoosting_ ? boostSpeed_ : normalSpeed_;
            //UpdateBoostState();
            MoveInput(currentSpeed); // ãƒ–ãƒ¼ã‚¹ãƒˆä¸­ã¯é€Ÿãç§»å‹• 
            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ä¸­ã¯ã‚­ãƒ¼æ“ä½œã‚’å—ã‘ä»˜ã‘ã‚‹
            if (isDeadEffectActive_ && active_ == false) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤â€•æ­»äº¡æ¼”å‡º
    //            StartDeathEffect();
            } else {
                // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’çŸ¢å°ã‚­ãƒ¼ã§å‹•ã‹ã™
                UpdateTargetPosition(targettransform_, 0.4f);   // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ä½¿ã†
                // å¼¾ã®ç™ºå°„
                AttachBullet();
            }
        }

        Vector3 basePos = camPos + cameraBaseWorld + right * relativePos_.x + up * relativePos_.y;

        // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ä¸­ã¯æ­»äº¡ã‚ªãƒ•ã‚»ãƒƒãƒˆåŠ ç®—
        if (CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Sub) {
            transform_.translate = basePos + deathOffset_;
        } else {
            transform_.translate = basePos;
        }



        // ãƒ‡ãƒãƒƒã‚°ä¸­ã®ImGuiè¡¨ç¤º
        DebugImgui();
        target_->SetTranslate(copypos);
        target_->Update();
        // ç…§æº–ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ä½ç½®æ›´æ–°ï¼ˆ3Dâ†’2Då¤‰æ›)
        UpdateReticlePosition();
        targetreticle_->Update();

        // ç§»å‹•å¾Œã®ä½ç½®ã‚’Objectã«åæ˜ 
        object->SetTranslate(transform_.translate);
        object->SetRotate(transform_.rotate);
        object->SetScale(transform_.scale);
    }



    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ›´æ–°
    object->Update();
}


void Player::Draw() {
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æç”»
    object->Draw(); 
}

void Player::DrawSprite() { 
    if (isReticleVisible_) {
        targetreticle_->Draw();
    }
}

void Player::DebugImgui() {
#ifdef USE_IMGUI
    ImGui::Begin("Player Control");
    ImGui::DragFloat3("Translate", &transform_.translate.x, 0.01f);
    ImGui::DragFloat3("Rotate", &transform_.rotate.x, 0.01f);
    ImGui::DragFloat3("Scale", &transform_.scale.x, 0.01f);
    ImGui::End();
#endif // USE_IMGUI
}
void Player::MoveInput(float speed) {
    // === å…¥åŠ›å‡¦ç† ===
    Vector3 moveDelta = { 0, 0, 0 };
    Input* input = Input::GetInstance();
    //    if (CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Main && !isDeadEffectActive_) {
    if (input->Pushkey(DIK_A)) moveDelta.x -= speed;
    if (input->Pushkey(DIK_D)) moveDelta.x += speed;
    if (input->Pushkey(DIK_W)) moveDelta.y += speed;
    if (input->Pushkey(DIK_S)) moveDelta.y -= speed;
    //  }

      // === ç›¸å¯¾ç§»å‹•ã‚’åˆ¶é™ï¼ˆç”»é¢å†…ã®ç¯„å›²ï¼‰===
    float oldX = relativePos_.x;
    float oldY = relativePos_.y;

    // === ç›¸å¯¾ç§»å‹•ã‚’åˆ¶é™ï¼ˆç”»é¢å†…ã®ç¯„å›²ï¼‰===
    // ã“ã“ã¯ã€Œã‚«ãƒ¡ãƒ©ã‹ã‚‰è¦‹ãŸãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã€ä¸Šã§ã®åˆ¶é™
    relativePos_.x = std::clamp(relativePos_.x + moveDelta.x, -10.0f, 10.0f);
    relativePos_.y = std::clamp(relativePos_.y + moveDelta.y, -2.5f, 9.0f);

    // === â˜… ã‚¹ãƒ ãƒ¼ã‚ºå‚¾ãåˆ¶å¾¡ ===
    static float tiltX = 0.0f;
    static float tiltZ = 0.0f;
    const float tiltSpeed = 0.1f;
    const float maxTiltX = 0.4f;
    const float maxTiltZ = 0.4f;
    const float returnSpeed = 0.08f;

    // æ¨ªå‚¾ã
    if (relativePos_.x != oldX) {
        float dir = (relativePos_.x - oldX) > 0 ? 1.0f : -1.0f;
        tiltZ += -dir * tiltSpeed;
    } else tiltZ *= (1.0f - returnSpeed);

    // ç¸¦å‚¾ã
    if (relativePos_.y != oldY) {
        float dir = (relativePos_.y - oldY) > 0 ? -1.0f : 1.0f;
        tiltX += dir * tiltSpeed;
    } else tiltX *= (1.0f - returnSpeed);

    tiltZ = std::clamp(tiltZ, -maxTiltZ, maxTiltZ);
    tiltX = std::clamp(tiltX, -maxTiltX, maxTiltX);

    Camera* activeCam = CameraManager::GetInstance()->GetActiveCamera();
    if (activeCam && CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Main) {
        Vector3 baseRot = activeCam->GetRotate();
        transform_.rotate = {
            baseRot.x + tiltX,
            baseRot.y,
            baseRot.z + tiltZ
        };
    }
    object->SetRotate(transform_.rotate);
}

///=====================================================================
/// ãƒ–ãƒ¼ã‚¹ãƒˆçŠ¶æ…‹æ›´æ–°å‡¦ç†
///=====================================================================
void Player::UpdateBoostState() {
    Input* input = Input::GetInstance();

    // ãƒ–ãƒ¼ã‚¹ãƒˆç™ºå‹•åˆ¤å®šï¼ˆShiftã‚­ãƒ¼æŠ¼ã— && ãƒ–ãƒ¼ã‚¹ãƒˆä¸­ã§ãªã && ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ä¸­ã§ãªã„ï¼‰
    if (input->Pushkey(DIK_LSHIFT) && !isBoosting_ && !isCoolingDown_) {
        isBoosting_ = true;
        boostTime_ = 0.0f;
    }

    // ãƒ–ãƒ¼ã‚¹ãƒˆä¸­ã®å‡¦ç†
    if (isBoosting_) {
        boostTime_ += 1.0f / 60.0f; // 60FPSå‰æ

        if (boostTime_ >= boostDuration_) {
            isBoosting_ = false;
            isCoolingDown_ = true;
            cooldownTime_ = 0.0f;
        }
    }

    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ã®å‡¦ç†
    if (isCoolingDown_) {
        cooldownTime_ += 1.0f / 60.0f;

        if (cooldownTime_ >= cooldownDuration_) {
            isCoolingDown_ = false;
        }
    }
}
///=====================================================================
/// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ç§»å‹•å‡¦ç†
///=====================================================================
void Player::UpdateTargetPosition(Transform& targetTransform, float speed) {
    // --- å…¥åŠ›ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’å‹•ã‹ã™ ---
    if (Input::GetInstance()->Pushkey(DIK_LEFT))  targetTransform.translate.x -= speed;
    if (Input::GetInstance()->Pushkey(DIK_RIGHT)) targetTransform.translate.x += speed;
    if (Input::GetInstance()->Pushkey(DIK_UP))    targetTransform.translate.y += speed;
    if (Input::GetInstance()->Pushkey(DIK_DOWN))  targetTransform.translate.y -= speed;

    // --- ã‚«ãƒ¡ãƒ©åŸºæº–ã§ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’é…ç½®ã™ã‚‹ ---
    GamePlayCamera* gameCam = CameraManager::GetInstance()->GetGameCamera();
    if (!gameCam) return;

    Vector3 cameraPos = gameCam->GetbezierPos();
    Vector3 forward = gameCam->GetForward();
    Vector3 right   = Normalize(Cross({0, 1, 0}, forward));
    Vector3 up      = Normalize(Cross(forward, right));

    // === ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®ç›¸å¯¾ä½ç½®ã«å¿œã˜ãŸã‚¿ãƒ¼ã‚²ãƒƒãƒˆåˆ¶é™ ===
    // ç”»é¢å†…ã«ç›¸å½“ã™ã‚‹ä»®æƒ³åº§æ¨™ç¯„å›²ï¼ˆä¾‹ï¼šX=-10ï½ž10, Y=-5ï½ž5 ã«å¯¾å¿œã•ã›ã‚‹ï¼‰
    const float maxX = 12.0f;
    const float minX = -12.0f;
    const float maxY = 7.0f;
    const float minY = -7.0f;

    // --- ç¯„å›²å†…ã«ã‚¯ãƒ©ãƒ³ãƒ—ï¼ˆã“ã‚Œã§ã€Œç”»é¢å¤–ã«å‡ºãŸã‚‰å‹•ã‹ãªã„ã€ï¼‰---
    targetTransform.translate.x = std::clamp(targetTransform.translate.x, minX, maxX);
    targetTransform.translate.y = std::clamp(targetTransform.translate.y, minY, maxY);


    // ç”»é¢ä¸­å¤®ã‹ã‚‰ã®ç›¸å¯¾ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    Vector3 offset =
        right * targetTransform.translate.x +
        up    * targetTransform.translate.y +
        forward * 30.0f; // ã‚«ãƒ¡ãƒ©ã®å‰æ–¹æ–¹å‘ã«å›ºå®šè·é›¢

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã«åŠ ç®—
    copypos = transform_.translate + offset;
    target_->SetTranslate(copypos);
    target_->Update();
}

///=====================================================================
/// å¼¾ã®ç™ºå°„å‡¦ç†
///=====================================================================
void Player::AttachBullet() {
    bulletTimer_ += 1.0f / 60.0f;
    if (bulletTimer_ >= bulletInterval_) {
        canShoot_ = true;
        bulletTimer_ = 0.0f;
    }

    if (!canShoot_) return;
    if (Input::GetInstance()->Pushkey(DIK_SPACE)) {
        GamePlayCamera* gameCam = CameraManager::GetInstance()->GetGameCamera();
        if (!gameCam) return;
        // ã‚«ãƒ¡ãƒ©æƒ…å ±
        Vector3 cameraForward = gameCam->GetForward();

        // å¼¾ã®åˆæœŸä½ç½®ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å°‘ã—å‰ï¼‰
        Vector3 bulletStartPos = transform_.translate + gameCam->GetForward() * 2.0f;

        // --- ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆãƒ¬ãƒ†ã‚£ã‚¯ãƒ«3Dï¼‰æ–¹å‘ã¸ç™ºå°„ ---
        Vector3 targetPos = target_->GetTranslate();
        Vector3 shootDir = Normalize(targetPos - bulletStartPos);

        std::unique_ptr<PlayerBullet> bullet = std::make_unique<PlayerBullet>();
        bullet->Initialize(bulletStartPos, bulletStartPos + shootDir * 10.0f,cameraForward, 5.0f);


        BulletManager::GetInstance()->AddPlayerBullet(std::move(bullet));

        canShoot_ = false;
    }
}


///=====================================================================
/// ãƒ¬ãƒ†ã‚£ã‚¯ãƒ«ç”¨3Dåº§æ¨™ â†’ 2Dã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™å¤‰æ›
///=====================================================================
void Player::UpdateReticlePosition() {
    if (!target_ || !targetreticle_) return;

    // 3Dã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®
    Vector3 targetWorldPos = target_->GetTranslate();

    // --- ã‚«ãƒ¡ãƒ©ã‹ã‚‰2Dã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã«å¤‰æ› ---
    Camera* camera = CameraManager::GetInstance()->GetActiveCamera();
    const Matrix4x4& viewProj = camera->GetViewProjectionMatrix();

    Vector4 clipPos = {
        targetWorldPos.x * viewProj.m[0][0] + targetWorldPos.y * viewProj.m[1][0] + targetWorldPos.z * viewProj.m[2][0] + viewProj.m[3][0],
        targetWorldPos.x * viewProj.m[0][1] + targetWorldPos.y * viewProj.m[1][1] + targetWorldPos.z * viewProj.m[2][1] + viewProj.m[3][1],
        targetWorldPos.x * viewProj.m[0][2] + targetWorldPos.y * viewProj.m[1][2] + targetWorldPos.z * viewProj.m[2][2] + viewProj.m[3][2],
        targetWorldPos.x * viewProj.m[0][3] + targetWorldPos.y * viewProj.m[1][3] + targetWorldPos.z * viewProj.m[2][3] + viewProj.m[3][3]
    };

    if (clipPos.w != 0.0f) {
        clipPos.x /= clipPos.w;
        clipPos.y /= clipPos.w;
    }

    const float screenWidth = 1280.0f;
    const float screenHeight = 720.0f;

    reticleScreenPos_.x = (clipPos.x * 0.5f + 0.5f) * screenWidth;
    reticleScreenPos_.y = (-clipPos.y * 0.5f + 0.5f) * screenHeight;

    targetreticle_->SetPosition(reticleScreenPos_);
}

///=====================================================================
/// OBBå½“ãŸã‚Šåˆ¤å®šå–å¾—
///=====================================================================
OBB Player::GetOBB() const {
    OBB obb;

    // ä¸­å¿ƒåº§æ¨™
    obb.center = transform_.translate;

    // ãƒãƒ¼ãƒ•ã‚µã‚¤ã‚ºï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ã®åŠåˆ†ï¼‰
    obb.halfSize = {
        transform_.scale.x / 2.0f, 
        transform_.scale.y / 2.0f, 
        transform_.scale.z / 2.0f
    };

    // å›žè»¢è¡Œåˆ—ï¼ˆXYZé †ã§å›žè»¢ã‚’åˆæˆï¼‰
    Matrix4x4 rotX = MakeRotateXMatrix(transform_.rotate.x);
    Matrix4x4 rotY = MakeRotateYMatrix(transform_.rotate.y);
    Matrix4x4 rotZ = MakeRotateZMatrix(transform_.rotate.z);

    // Zâ†’Xâ†’Y ã®é †ã«æŽ›ã‘ã‚‹ã“ã¨ã§ã€XYZå›žè»¢ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ç©ºé–“å›žè»¢ï¼‰ã‚’å†ç¾
    Matrix4x4 rotMat = Multiply(Multiply(rotZ, rotX), rotY);

    // ãƒ­ãƒ¼ã‚«ãƒ«è»¸ï¼ˆX, Y, Zï¼‰ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰ç©ºé–“ã¸å›žè»¢é©ç”¨
    obb.axis[0] = Normalize(Multiply4x4x3(rotMat, Vector3{ 1, 0, 0 })); // Xè»¸
    obb.axis[1] = Normalize(Multiply4x4x3(rotMat, Vector3{ 0, 1, 0 })); // Yè»¸
    obb.axis[2] = Normalize(Multiply4x4x3(rotMat, Vector3{ 0, 0, 1 })); // Zè»¸

    return obb;
}

void Player::StartDeathEffect() {
    static float t = 0.0f;        // æ™‚é–“çµŒéŽ
    const float fallSpeedY = 0.02f;   // ä¸‹ã«è½ã¡ã‚‹é€Ÿã•
    const float fallSpeedZ = 0.2f;   // æ‰‹å‰ã«æµã‚Œã‚‹é€Ÿã•


    t += 1.0f / 60.0f;            // 60FPSæ›ç®—

    // åŠ é€Ÿã—ãªã„ã€‚ä¸€å®šé‡ã ã‘å‹•ã‹ã™
    deathOffset_.y -= fallSpeedY;
    deathOffset_.z += fallSpeedZ;


    // --- å›žè»¢ã‚‚æ™‚é–“ã§å¢—åŠ ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°çš„ï¼‰---
    transform_.rotate.x += 0.004f + 0.002f * sinf(t * 0.5f);
    transform_.rotate.z += 0.003f + 0.0015f * cosf(t * 0.4f);

    // ---- ã“ã“ã‹ã‚‰ç‚¹æ»…å‡¦ç† ----

    // ç‚¹æ»…å‘¨æœŸï¼ˆå€¤ã‚’å°ã•ãã™ã‚‹ã¨é«˜é€Ÿç‚¹æ»…ï¼‰
    float blinkSpeed = 50.0f;

    // 0ã€œ1 ã‚’é«˜é€Ÿã§å¾€å¾©ã™ã‚‹å€¤
    float s = (sinf(t * blinkSpeed) + 1.0f) * 0.5f;

    // ã‚ã‚‹ç¨‹åº¦ã®é–¾å€¤ã‚’è¶…ãˆãŸæ™‚ã ã‘èµ¤ãã™ã‚‹ï¼ˆãƒ‘ãƒƒã‚·ãƒ³ã‚°æ„ŸUPï¼‰
    if (s > 0.85f) {
        object->SetMaterialColor({ 1.0f, 0.0f, 0.0f, 1.0f }); // èµ¤
    } else {
        object->SetMaterialColor({ 1.0f, 1.0f, 1.0f, 1.0f }); // é€šå¸¸è‰²
    }
}

============================================================
File Path: project/application/player/Player.h
============================================================
#pragma once
#include<BaseCharacter.h>
#include<Sprite.h>
#include <ParticleEmitter.h>
#include<OBB.h>

/// <summary>
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¯ãƒ©ã‚¹
/// </summary>
class Player : public BaseCharacter {
public:// ãƒ¡ãƒ³ãƒé–¢æ•°
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~Player() override;
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize() override;
	/// <summary>
	/// æ›´æ–°æ›´æ–°
	/// </summary>
	void Update() override;
	/// <summary>
	/// 3Dãƒ¢ãƒ‡ãƒ«ã®æç”»æ›´æ–°
	/// </summary>
	void Draw() override;
    /// <summary>
    /// 2Dã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æç”»å‡¦ç†
    /// </summary>	
	void DrawSprite();	
    /// <summary>
    /// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã§ã®ç§»å‹•å‡¦ç†
    /// </summary>
    /// <param name="speed">ç§»å‹•é€Ÿåº¦</param>
	void MoveInput(float speed);	
    /// <summary>
    /// ãƒ–ãƒ¼ã‚¹ãƒˆçŠ¶æ…‹ã®æ›´æ–°
    /// </summary>
	void UpdateBoostState();
    /// <summary>
    /// ãƒ‡ãƒãƒƒã‚°ç”¨ã®ImGuiæç”»
    /// </summary>
	void DebugImgui();	
    /// <summary>
    /// å¼¾ã®ç™ºå°„å‡¦ç†
    /// </summary>
	void AttachBullet();
	/// <summary>
    /// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ›´æ–°
    /// </summary>
	void UpdateTargetPosition(Transform& targetTransform, float speed);
    /// <summary>
    /// ãƒ¬ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®ã‚’æ›´æ–°
    /// </summary>
	void UpdateReticlePosition();	   
	/// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã«ã™ã‚‹ï¼ˆç„¡åŠ¹åŒ–ï¼‰
    /// </summary>
	void SetInactive() {
		active_ = false;
	}
    /// <summary>
    /// å½“ãŸã‚Šåˆ¤å®šç”¨ã‚’å–å¾—
    /// </summary>
	OBB GetOBB() const;
	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã®å–å¾—ãƒ»è¨­å®š
    bool IsActive() const { return active_; }
	void SetActive(bool inactive) { active_ = inactive; }
	/// <summary>
    /// è¢«å¼¾ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’é–‹å§‹
    /// </summary>    
	void StartHitEffect() {
		isHit_ = true;
		hitEffectTimer_ = 0.0f;
	}

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ­»äº¡æ¼”å‡ºã®é–‹å§‹
	/// </summary>
	void StartDeathEffect();
	void SetDeadInactive() { isDeadEffectActive_ = true; }
	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã®å–å¾—ãƒ»è¨­å®š
    bool IsDead() const { return isDeadEffectActive_; }
	void SetDead_(bool isactive) { isDeadEffectActive_ = isactive; }
private:// ãƒ¡ãƒ³ãƒå¤‰æ•°
	bool active_ = true;
	std::unique_ptr <Object3d> object = nullptr;  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	Transform transform_{};	
	std::unique_ptr <Object3d> target_ = nullptr; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç”¨3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	Transform targettransform_{};
	Vector3 copypos;
	std::unique_ptr <Sprite> targetreticle_ = nullptr; // ãƒ¬ãƒ†ã‚£ã‚¯ãƒ«ç”¨ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ	
	Vector2 reticleScreenPos = { 640.0f, 360.0f }; // ç”»é¢ä¸­å¿ƒ (ä¾‹: 1280x720ã®è§£åƒåº¦)
	// çƒé–¢é€£
	float bulletTimer_ = 0.0f;                   // çµŒéŽæ™‚é–“
	const float bulletInterval_ = 0.2f;         // 30ç§’ã”ã¨ã«å¼¾ã‚’æ’ƒã¦ã‚‹
	bool canShoot_ = true;                       // å¼¾ã‚’æ’ƒã¦ã‚‹ã‹ã©ã†ã‹
	Vector3 moveOffset;
	Vector3 moveDelta{};	
	// ãƒ–ãƒ¼ã‚¹ãƒˆé–¢é€£
	float normalSpeed_ = 0.2f;
	float boostSpeed_ = 0.5f;
	bool isBoosting_ = false;
	float boostTime_ = 0.0f;
	const float boostDuration_ = 0.3f; // ãƒ–ãƒ¼ã‚¹ãƒˆæŒç¶šæ™‚é–“
	bool isCoolingDown_ = false;
	float cooldownTime_ = 0.0f;
	const float cooldownDuration_ = 3.0f; // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ™‚é–“	
    Vector3 reticleWorldPos_;    // 3Dç©ºé–“ã®ãƒ¬ãƒ†ã‚£ã‚¯ãƒ«ä½ç½®ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰
    Vector2 reticleScreenPos_;   // ç”»é¢ä¸Šã®ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»ä½ç½®ï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ï¼‰ 
	bool isHit_ = false;           // å¼¾ã«å½“ãŸã£ãŸã“ã¨ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°
    float hitEffectTimer_ = 0.0f;  // æ¼”å‡ºçµŒéŽæ™‚é–“
    const float hitEffectDuration_ = 1.0f; // æ¼”å‡ºã«ã‹ã‘ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰
	float previousTime_ = 0.0f;	    
	Vector4 originalColor_{};   // RGB + Alpha
	bool end = false; 
	std::unique_ptr <ParticleEmitter> circle_;
    RandomParameter random_;	
	bool isCharging_ = false;        // ãƒãƒ£ãƒ¼ã‚¸ä¸­ã‹
    float chargeTime_ = 0.0f;        // æŠ¼ã—ç¶šã‘ãŸæ™‚é–“
    const float maxChargeTime_ = 5.0f; // æœ€å¤§ãƒãƒ£ãƒ¼ã‚¸æ™‚é–“ï¼ˆç§’ï¼‰
	Vector3 bulletOffsetLeft  = { -0.5f, 0.0f, 0.0f }; // å·¦å´ã®ç™ºå°„ä½ç½®
	Vector3 bulletOffsetRight = {  0.5f, 0.0f, 0.0f }; // å³å´ã®ç™ºå°„ä½ç½®	
	bool ickyActive_ = false;       // â† ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ“ä½œå¯èƒ½ã‹
    bool isReticleVisible_ = false; // â† ãƒ¬ãƒ†ã‚£ã‚¯ãƒ«æç”»ON/OFF
    Vector3 relativePos_ = {0, 0, 0}; // ã‚«ãƒ¡ãƒ©å†…ã§ã®ç›¸å¯¾ä½ç½®ï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™çš„ï¼‰

	
	// æ­»äº¡é–¢é€£
	bool isDeadEffectActive_ = false;  // æ­»äº¡æ¼”å‡ºä¸­ãƒ•ãƒ©ã‚°
    float deathTimer_ = 0.0f;         // æ­»äº¡æ¼”å‡ºã®çµŒéŽæ™‚é–“
    float deathDuration_ = 2.0f;      // æ¼”å‡ºå…¨ä½“ã®é•·ã•ï¼ˆç§’ï¼‰
    Vector3 deathVelocity_ = {};      // è½ä¸‹ç”¨ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
    Vector3 deathRotateSpeed_ = {};   // å›žè»¢ã‚¹ãƒ”ãƒ¼ãƒ‰
	Vector3 deathStartPos_;

	    float deathFallSpeed_ = 0.5f; // ä¸‹æ–¹å‘ã«è½ã¡ã‚‹ã‚¹ãƒ”ãƒ¼ãƒ‰

		
		Vector3 fallVelocity;
		
		Vector3 deathOffset_;

public:// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// getter
	// å‚ç…§ã‚’è¿”ã™ï¼ˆå¤‰æ›´ä¸å¯ï¼‰
	Object3d* GetPlayerObject() { return object.get(); }
	void SetTransform(const Transform& t) {
		transform_ = t;
		object->SetTranslate(transform_.translate);
		object->SetRotate(transform_.rotate);
		object->SetScale(transform_.scale);
	}
	bool IsDeadFinished() const { return end; }
	// Transformã®positionã‚’è¿”ã™getter
	Vector3 GetPosition() const {
		return transform_.translate;
	}

    // Getter
    bool IsKeyActive() const { return ickyActive_; }
    bool IsReticleVisible() const { return isReticleVisible_; }

    // Setter
    void SetKeyActive(bool active) { ickyActive_ = active; }
    void SetReticleVisible(bool visible) { isReticleVisible_ = visible; }
};

============================================================
File Path: project/application/resource/FileSearcher.cpp
============================================================
#include"FileSearcher.h"
#include <filesystem>

std::vector<std::string> FileSearcher::GetAllFiles(const std::vector<std::string>& excludeDirs) {
    std::vector<std::string> files;
    // ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä»¥ä¸‹ã‚’å†å¸°çš„ã«èµ°æŸ»
    for (const auto& entry : std::filesystem::recursive_directory_iterator(root_)) {
        // ãƒ•ã‚¡ã‚¤ãƒ«ä»¥å¤–ï¼ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç­‰ï¼‰ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (!entry.is_regular_file()) { continue; }

        // ãƒ•ãƒ«ãƒ‘ã‚¹æ–‡å­—åˆ—ã‚’å–å¾—
        std::string pathStr = entry.path().string();
        // é™¤å¤–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«è©²å½“ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        bool skip = false;
        for (const auto& ex : excludeDirs) {
            // ãƒ‘ã‚¹æ–‡å­—åˆ—ã«é™¤å¤–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåãŒå«ã¾ã‚Œã¦ã„ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
            if (pathStr.find(ex) != std::string::npos) {
                skip = true;
                break;
            }
        }
        // é™¤å¤–å¯¾è±¡ã§ãªã‘ã‚Œã°ã€root ã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ã‚’è¿½åŠ 
        if (!skip) {
            files.push_back(std::filesystem::relative(entry.path(), root_).string());
        }
    }
    // æ¤œç´¢çµæžœã‚’è¿”ã™
    return files;
}

============================================================
File Path: project/application/resource/FileSearcher.h
============================================================
#pragma once
#include <string>
#include <vector>

/// <summary>
/// æŒ‡å®šã—ãŸãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ä»¥ä¸‹ã‚’å†å¸°çš„ã«èµ°æŸ»ã—ã€
/// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ä¸€è¦§ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹
/// </summary>
class FileSearcher {
public:
    /// <summary>
    /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    /// <param name="root">
    /// æ¤œç´¢ã®èµ·ç‚¹ã¨ãªã‚‹ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹ï¼ˆä¾‹: "Resources"ï¼‰
    /// </param>
    explicit FileSearcher(const std::string& root) : root_(root) {}
    /// <summary>
    /// ãƒ«ãƒ¼ãƒˆãƒ•ã‚©ãƒ«ãƒ€ä»¥ä¸‹ã‚’å†å¸°çš„ã«ã‚¹ã‚­ãƒ£ãƒ³ã—ã€
    /// é™¤å¤–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’è€ƒæ…®ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’è¿”ã™
    /// </summary>
    /// <param name="excludeDirs">
    /// é™¤å¤–ã—ãŸã„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªåã®ãƒªã‚¹ãƒˆ
    /// ï¼ˆä¾‹: ".git", "Temp", "EditorTemp" ãªã©ï¼‰
    /// </param>
    /// <returns>
    /// root ã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹ã§æ§‹æˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ä¸€è¦§
    /// </returns>
    std::vector<std::string> GetAllFiles(const std::vector<std::string>& excludeDirs);

private:
    // æ¤œç´¢ã®åŸºæº–ã¨ãªã‚‹ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
    std::string root_;
};

============================================================
File Path: project/application/resource/ManifestExporter.cpp
============================================================
#include"ManifestExporter.h"
#include <fstream>
#include <unordered_map>
#include <json.hpp>

///=====================================================
/// Export
///-----------------------------------------------------
/// fileList ã‚’èµ°æŸ»ã—ã€
/// åŒä¸€ Group / Name ã® Asset ã‚’çµ±åˆã—ãªãŒã‚‰ JSON ã‚’æ§‹ç¯‰ã™ã‚‹
///
/// å‡ºåŠ›å½¢å¼:
/// {
///   "Bullet": {
///     "enemybullet": {
///       "model": "...",
///       "texture": "..."
///     }
///   }
/// }
///=====================================================

void ManifestExporter::Export(const std::string& outputPath, const std::vector<std::string>& fileList) { 
    // å‡ºåŠ›ç”¨å¤‰æ•° 
    nlohmann::json manifest;

   for (const auto& file : fileList) {
        // ãƒ‘ã‚¹æ­£è¦åŒ–
        std::string normalized = NormalizePath(file);

        // æ‹¡å¼µå­å–å¾—
        std::string ext = std::filesystem::path(normalized).extension().string();

        // AssetType åˆ¤å®š
        AssetType type = GetAssetType(ext);
        if (type == AssetType::Unknown) continue;

        // Groupï¼ˆæœ€ä¸Šä½ãƒ•ã‚©ãƒ«ãƒ€ï¼‰
        std::string group = GetGroup(normalized);

        // Asset è«–ç†åï¼ˆæ‹¡å¼µå­ç„¡ã—. åŒåã®model/texture/audio ã‚’1ã¤ã«æŸã­ã‚‹ãŸã‚ã«ä½¿ç”¨
        std::string name = CreateId(normalized, type);

        // JSONã‚­ãƒ¼åï¼ˆmodel / texture / audioï¼‰
        std::string typeKey = ToString(type);

        // åŒä¸€ Group/Name ã®ä¸­ã« model/texture/audioã‚’çµ±åˆã—ã¦æ ¼ç´ã™ã‚‹
        manifest[group][name][typeKey] = normalized;
    }
    // å·®åˆ†ãŒã‚ã‚‹å ´åˆã®ã¿ä¿å­˜ã—ç„¡é§„ãªãƒ•ã‚¡ã‚¤ãƒ«æ›´æ–°ã‚’é˜²ã
    SaveIfChanged(outputPath, manifest.dump(4));
}

void ManifestExporter::SaveIfChanged(const std::string& path, const std::string& content) {
    // æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    std::ifstream ifs(path, std::ios::binary);
    if (ifs) {
        std::string existing((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
        // å†…å®¹ãŒåŒä¸€ãªã‚‰æ›¸ãè¾¼ã¿ã‚’ã‚¹ã‚­ãƒƒãƒ—
        if (existing == content) {
            return;
        }
    }

    // å·®åˆ†ãŒã‚ã‚‹å ´åˆã®ã¿ä¸Šæ›¸ãä¿å­˜
    std::ofstream ofs(path, std::ios::binary | std::ios::trunc);
    ofs << content;
}

std::string ManifestExporter::CreateId(std::string path, AssetType type) {
    std::filesystem::path p(path);
    // æ‹¡å¼µå­ã‚’é™¤ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–å¾—
    std::string id = p.stem().string();
    // å°æ–‡å­—åŒ–ï¼ˆã‚­ãƒ¼ã®æºã‚Œé˜²æ­¢ï¼‰ _model / _texture ã¯ä»˜ã‘ãªã„
    std::transform(id.begin(), id.end(), id.begin(), ::tolower);
    return id;
}


std::string ManifestExporter::NormalizePath(std::string path) {
    std::replace(path.begin(), path.end(), '\\', '/');
    return path;
}

std::string ManifestExporter::GetGroup(const std::string& path) {
    std::filesystem::path p(path);

    if (p.has_parent_path()) {
        return p.begin()->string();
    }
    // ãƒ•ã‚©ãƒ«ãƒ€ã‚’æŒãŸãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    return "Common";
}


AssetType ManifestExporter::GetAssetType(const std::string& ext) {
    std::string lowerExt = ext;

    // æ‹¡å¼µå­ã‚’å°æ–‡å­—åŒ–
    std::transform(lowerExt.begin(), lowerExt.end(), lowerExt.begin(), ::tolower);
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£
    if (lowerExt == ".png" || lowerExt == ".jpg" || lowerExt == ".jpeg" || lowerExt == ".tga" || lowerExt == ".dds") return AssetType::Texture;
    // ãƒ¢ãƒ‡ãƒ«
    if (lowerExt == ".fbx" || lowerExt == ".obj" || lowerExt == ".gltf" || lowerExt == ".glb") return AssetType::Model;
    // éŸ³æº
    if (lowerExt == ".wav" || lowerExt == ".mp3" || lowerExt == ".ogg") return AssetType::Audio;

    return AssetType::Unknown;
}

std::string ManifestExporter::ToString(AssetType type) {
    switch (type) {
    case AssetType::Texture: return "texture";
    case AssetType::Model:   return "model";
    case AssetType::Audio:   return "audio";
    default: return "";
    }
}


============================================================
File Path: project/application/resource/ManifestExporter.h
============================================================
#pragma once
#include <vector>
#include <string>

/// ãƒªã‚½ãƒ¼ã‚¹ã®ç¨®é¡žã‚’è¡¨ã™åˆ—æŒ™ä½“
enum class AssetType {
    Texture,   // ãƒ†ã‚¯ã‚¹ãƒãƒ£
    Model,     // 3Dãƒ¢ãƒ‡ãƒ«
    Audio,     // éŸ³æº
    Unknown    // éžå¯¾å¿œæ‹¡å¼µå­
};

/// <summary>
/// ManifestExporter
/// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ä¸€è¦§ã‹ã‚‰ Asset Manifest(JSON) ã‚’ç”Ÿæˆã™ã‚‹ã‚¯ãƒ©ã‚¹
/// </summary>
class ManifestExporter {
private: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// æ‹¡å¼µå­ã‹ã‚‰ AssetType ã‚’åˆ¤å®šã™ã‚‹
    /// æœªå¯¾å¿œã®æ‹¡å¼µå­ã¯ Unknown ã‚’è¿”ã™
    /// </summary>
    AssetType GetAssetType(const std::string& ext);
    /// <summary>
    /// ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã‚‰ Asset ã®è«–ç†åã‚’ç”Ÿæˆã™ã‚‹
    /// æ‹¡å¼µå­ã‚’é™¤ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’å°æ–‡å­—åŒ–ã—ãŸã‚‚ã®ã‚’ä½¿ç”¨
    /// </summary>
    std::string CreateId(std::string path, AssetType type);
    /// <summary>
    /// AssetType ã‚’ JSON ã®ã‚­ãƒ¼æ–‡å­—åˆ—ã¸å¤‰æ›ã™ã‚‹
    /// </summary>
    std::string ToString(AssetType type); 
    /// <summary>
    /// ãƒ‘ã‚¹ã®æœ€ä¸Šä½ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ Group åã¨ã—ã¦å–å¾—ã™ã‚‹
    /// ä¾‹: "Bullet/EnemyBullet.obj" â†’ "Bullet"
    /// </summary>
    std::string GetGroup(const std::string& path);
    /// <summary>
    /// ãƒ‘ã‚¹åŒºåˆ‡ã‚Šã‚’ '/' ã«æ­£è¦åŒ–ã™ã‚‹
    /// Windows / Unix æ··åœ¨å¯¾ç­–ç”¨ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    /// </summary>
    static std::string NormalizePath(std::string path);
    /// <summary>
    /// æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã¨å†…å®¹ã‚’æ¯”è¼ƒã—,å·®åˆ†ãŒã‚ã‚‹å ´åˆã®ã¿ä¸Šæ›¸ãä¿å­˜ã™ã‚‹
    /// </summary>
    void SaveIfChanged(const std::string& path, const std::string& content); 
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›å‡¦ç†
    /// ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’å—ã‘å–ã£ã¦JSONåŒ–å‡ºåŠ›ã€‚å†…å®¹ã«å·®åˆ†ãŒã‚ã‚‹å ´åˆã®ã¿ãƒ•ã‚¡ã‚¤ãƒ«ã¸æ›¸ãå‡ºã™ 
    /// </summary> 
    void Export(const std::string& outputPath, const std::vector<std::string>& fileList);
};

============================================================
File Path: project/application/scene/GameClearScene.cpp
============================================================
#include "GameClearScene.h"
#include<SceneManager.h>
#include<TextureManager.h>
#include<ModelManager.h>
#include<SpriteCommon.h>
#include<Object3dCommon.h>
#include <CameraManager.h>
#include<Input.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include <ParticleCommon.h>
#include<SkyboxCommon.h>
#include <FadeManager.h>
#include<Easing.h>
#ifdef min
#undef min
#endif
#ifdef max
#undef max
#endif

using namespace Easing;

///====================================================
/// çµ‚äº†å‡¦ç†
///====================================================
void GameClearScene::Finalize() {
    FadeManager::GetInstance()->Finalize();    //  ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®è§£æ”¾å‡¦ç†
}
///====================================================
///  åˆæœŸåŒ–å‡¦ç†
///====================================================
void GameClearScene::Initialize() {
    // ã‚«ãƒ¡ãƒ©ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    CameraManager::GetInstance()->Initialize(CameraTransform({ 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }));
    // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ã¯å›ºå®šãƒ¢ãƒ¼ãƒ‰
    CameraManager::GetInstance()->SetCameraMode(CameraMode::Default);
    // ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿  
    ModelManager::GetInstance()->LoadModel("Gameplay/Model/Player/Player.obj");


    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿
    TextureManager::GetInstance()->LoadTexture("CubemapBox.dds");    
    TextureManager::GetInstance()->LoadTexture("Gameclear/Texture/UI_01.png");
    TextureManager::GetInstance()->LoadTexture("Gameclear/Texture/Mission.png");
    TextureManager::GetInstance()->LoadTexture("Gameclear/Texture/Complete.png");

    
    ui2Timer_ = 0.0f;
    ui2Duration_ = 60.0f;
    ui3Timer_ = 0.0f;
    ui3Duration_ = 60.0f;;
    ui2StartPos = { 1280.0f, 10.0f }; // ä¸Šã«ãšã‚‰ã—ãŸåˆæœŸä½ç½®
    ui2EndPos = { 600.0f, 10.0f }; // æœ€çµ‚ä½ç½®ï¼ˆç¾åœ¨ã®å€¤ï¼‰
    ui3StartPos = { 1280.0f, 130.0f };
    ui3EndPos = { 800.0f, 130.0f };
    
       
    ui1_ = Sprite::Create("Gameclear/Texture/UI_01.png", Vector2{ 950.0f, 450.0f }, 0.0f, Vector2{ 360.0f,100.0f });
    ui1_->SetAnchorPoint(Vector2{ 0.5f, 0.5f }); // ä¸­å¿ƒåŸºæº–
    ui1_->SetTextureSize(Vector2{ 360.0f,100.0f });
        
    ui2_ = Sprite::Create("Gameclear/Texture/Mission.png", ui2StartPos, 0.0f, Vector2{ 400.0f,150.0f });
    ui2_->SetTextureSize(Vector2{ 400.0f,150.0f });

    ui3_ = Sprite::Create("Gameclear/Texture/Complete.png", ui3StartPos, 0.0f, Vector2{ 400.0f,150.0f });
    ui3_->SetTextureSize(Vector2{ 400.0f,150.0f });

   
    offset_ = { { 1.0f, 1.0f, 1.0f }, { 0.0f, 1.5f, 0.0f }, { -70.0f, 0.0f, 30.0f } };
    player_ = Object3d::Create("Gameplay/Model/Player/Player.obj", offset_);  
    startOffset_ = { -170.0f, 50.0f, 30.0f };
    endOffset_ = { 0.0f, 0.0f, 30.0f };    
    particle_ = std::make_unique<GameClearparticle>();
    particle_->Initialize(player_.get());

    // è¿½å¾“å¯¾è±¡ã‚’è¨­å®š
    CameraManager::GetInstance()->GetGameClearCamera()->SetTarget(player_.get());

    Box_ = Skybox::Create("CubemapBox.dds", Transform{ { 1000.0f, 1000.0f, 1000.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 100.0f } });

    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    FadeManager::GetInstance()->Initialize();
}
///====================================================
/// æ›´æ–°å‡¦ç†
///====================================================
void GameClearScene::Update() { 
    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
    if (!FadeManager::GetInstance()->IsFadeStart() && !FadeManager::GetInstance()->IsFading()) {
        // ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹
        FadeManager::GetInstance()->StartFadeIn(1.0f, FadeStyle::Normal);
    }
    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®æ›´æ–°å‡¦ç†
    FadeManager::GetInstance()->Update();

    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†å¾Œã«ã‚¿ã‚¤ãƒˆãƒ«ã¸
    if (FadeManager::GetInstance()->IsFadeEnd() && FadeManager::GetInstance()->GetFadeType() == FadeType::FadeOut) {
        SceneManager::GetInstance()->ChangeScene("TITLE");
    }

    /*-------------------------------------------*/
    /*--------------Cameraã®æ›´æ–°å‡¦ç†---------------*/
    /*------------------------------------------*/
    CameraManager::GetInstance()->Update();

#pragma region å…¨ã¦ã®Object3då€‹ã€…ã®æ›´æ–°å‡¦ç†    

	Box_->Update();   // èƒŒæ™¯ã®æ›´æ–°
    
    UpdateStep();	
    player_->Update(); // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ›´æ–°

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
    ParticleManager::GetInstance()->Update();
    particle_->Update();
#pragma endregion å…¨ã¦ã®Object3då€‹ã€…ã®æ›´æ–°å‡¦ç†

#pragma region å…¨ã¦ã®Spriteå€‹ã€…ã®æ›´æ–°å‡¦ç†

    ui1_->Update(); // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°
    ui2_->Update();
    ui3_->Update();


#pragma endregion å…¨ã¦ã®Spriteå€‹ã€…ã®æ›´æ–°å‡¦ç†
#pragma region  ImGuiã®æ›´æ–°å‡¦ç†é–‹å§‹
#ifdef USE_IMGUI

    // Camera
    CameraManager::GetInstance()->DrawImGui();


#endif // USE_IMGUI
#pragma endregion ImGuiã®æ›´æ–°å‡¦ç†çµ‚äº†

}
///====================================================
/// æç”»å‡¦ç†
///====================================================
void GameClearScene::Draw() {
#pragma region å…¨ã¦ã®Object3då€‹ã€…ã®æç”»å‡¦ç†
    // ç®±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    SkyboxCommon::GetInstance()->Commondrawing();
    Box_->Draw(); // èƒŒæ™¯ã®æç”»

    // 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    Object3dCommon::GetInstance()->Commondrawing();
    
    player_->Draw();// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æç”»æº–å‚™ã€‚ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€ 
    ParticleCommon::GetInstance()->Commondrawing();
    ParticleManager::GetInstance()->Draw();
#pragma endregion å…¨ã¦ã®Object3då€‹ã€…ã®æç”»å‡¦ç†

#pragma region å…¨ã¦ã®Spriteå€‹ã€…ã®æç”»å‡¦ç†
    // Spriteã®æç”»æº–å‚™ã€‚Spriteã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    SpriteCommon::GetInstance()->Commondrawing();
        
    if (ui2_->GetPosition().x == ui2EndPos.x && step_ == 1) {
        ui1_->Draw(); // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æç”» 
    }

    if (step_ != 0) {
        ui2_->Draw();
        ui3_->Draw();
    }
 
    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®æç”»
    FadeManager::GetInstance()->Draw();
#pragma endregion å…¨ã¦ã®Spriteå€‹ã€…ã®æç”»å‡¦ç†
}

void GameClearScene::UpdateStep() {
    switch (step_)
    {
    case 0:
        Step1_MovePlayerAndSwitchCamera();
        break;

    case 1:
        Step2_WaitOrDoSomething();

        break;
    case 2:
        Step3_MoveCameraOnInput();
        break;
    }
}

void GameClearScene::Step1_MovePlayerAndSwitchCamera() {
    Camera* cam = CameraManager::GetInstance()->GetActiveCamera();

    if (!step1CamMoveStart_) {
        if (offset_.translate.x > -80.0f) {
            step1CamMoveStart_ = true;
        }
    }

    if (step1CamMoveStart_ && step1CamT_ < 1.0f) {

        step1CamT_ += 0.02f; // ã‚«ãƒ¡ãƒ©ã®é€Ÿã•èª¿æ•´
        if (step1CamT_ > 1.0f) step1CamT_ = 1.0f;

        float e = EaseOutCubic(step1CamT_);

        float startX = -15.0f;
        float endX = 0.0f;

        float startY = 15.0f;
        float endY = 0.0f;

        Vector3 camPos = cam->GetTranslate();

        camPos.x = startX + (endX - startX) * e;
        camPos.y = startY + (endY - startY) * e;

        cam->SetTranslate(camPos);
        particle_->SetVelocity(Velocity{ {-0.06f, 0.0f, 0.0f},{ 0.0f,  0.0f, 0.0f},{ 0.0f,  0.0f, 0.0f} });
    }

    // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å‡¦ç†
    bool finished = EaseMove(offset_.translate, startOffset_, endOffset_, easeT_, easeSpeed_);

    player_->SetTranslate(offset_.translate);

    if (finished){
        // æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¸
        step_ = 1;
    }
}


void GameClearScene::Step2_WaitOrDoSomething() {
    Camera* cam = CameraManager::GetInstance()->GetActiveCamera();
    
    // Step2 ã®é–“ã¯ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä¸‹ã«è½ã¨ã•ãªã„
    particle_->SetVelocity(Velocity{ {-0.06f, 0.0f, 0.0f},{ 0.0f,  0.0f, 0.0f},{ 0.0f,  0.0f, 0.0f} });

    // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ã¯ã‚¤ãƒ™ãƒ³ãƒˆãƒ¢ãƒ¼ãƒ‰     
    CameraManager::GetInstance()->SetCameraMode(CameraMode::Event);

    /*-----------------------------------------------*/
    /* â‘  ã‚«ãƒ¡ãƒ©ã® X ã‚’ 0 â†’ 8 ã¸ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ç§»å‹•     */
    /*-----------------------------------------------*/
    if (step2CamT_ < 1.0f) {
        step2CamT_ += 0.01f;    // é€Ÿåº¦
        if (step2CamT_ > 1.0f) step2CamT_ = 1.0f;
        CameraManager::GetInstance()->GetGameClearCamera()->MoveCameraX(step2CamT_);
    }

    if (ui2Timer_ < ui2Duration_ && ui2_->GetPosition().x != ui2EndPos.x) {
        ui2Timer_++;

        float t = ui2Timer_ / ui2Duration_;
        float easeT = EaseOutBack(t);
        Vector2 newPos1 = {
            ui2StartPos.x + (ui2EndPos.x - ui2StartPos.x) * easeT,
            ui2StartPos.y + (ui2EndPos.y - ui2StartPos.y) * easeT
        };
        ui2_->SetPosition(newPos1);
    }

    if (ui3Timer_ < ui3Duration_ && ui2_->GetPosition().x != ui3EndPos.x && ui2_->GetPosition().x < 900) {
        ui3Timer_++;

        float t = ui3Timer_ / ui3Duration_;
        float easeT = EaseOutBack(t);
        Vector2 newPos1 = {
            ui3StartPos.x + (ui3EndPos.x - ui3StartPos.x) * easeT,
            ui3StartPos.y + (ui3EndPos.y - ui3StartPos.y) * easeT
        };
        ui3_->SetPosition(newPos1);
    }

    Vector3 pos = player_->GetTranslate();

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æºã‚Œ or Yè£œå®Œ
    if (!step2FinishPlayerEase_) {
        step2Time_ += 0.03f;
        pos.y = sinf(step2Time_) * 1.3f;
        player_->SetTranslate(pos);
    } else {
        pos.y = Vector3::Lerp(pos, Vector3{ pos.x, 0.0f, pos.z }, 0.1f).y;
        player_->SetTranslate(pos);

        // å®Œå…¨ã«0ã«ãªã£ãŸã‚‰Step3ã¸
        if (fabs(pos.y) < 0.01f) {
            step_ = 2;
        }
    }

    // ãƒœã‚¿ãƒ³ã§Step3ã«é€²ã‚ã‚‹
    if (Input::GetInstance()->Triggrkey(DIK_RETURN) && step2CamT_ == 1.0f) {
        if (!step2FinishPlayerEase_) {
            ui2Timer_ = 0;
            ui3Timer_ = 0;
            ui2StartPos = { 600.0f, 10.0f }; // ä¸Šã«ãšã‚‰ã—ãŸåˆæœŸä½ç½® 
            ui2EndPos = { 1280.0f, 10.0f }; // æœ€çµ‚ä½ç½®ï¼ˆç¾åœ¨ã®å€¤ï¼‰
            ui3StartPos = { 800.0f, 130.0f };
            ui3EndPos = { 2480.0f, 130.0f };
        }
        step2FinishPlayerEase_ = true;  // Yè£œå®Œé–‹å§‹
    }
}


void GameClearScene::Step3_MoveCameraOnInput() {
    Camera* cam = CameraManager::GetInstance()->GetActiveCamera();
    // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ã¯å›ºå®šãƒ¢ãƒ¼ãƒ‰
    CameraManager::GetInstance()->SetCameraMode(CameraMode::Default);

    if (ui2Timer_ < ui2Duration_ && ui2_->GetPosition().x != ui2EndPos.x) {
        ui2Timer_++;

        float t = ui2Timer_ / ui2Duration_;
        float easeT = EaseOutBack(t);
        Vector2 newPos1 = {
            ui2StartPos.x + (ui2EndPos.x - ui2StartPos.x) * easeT,
            ui2StartPos.y + (ui2EndPos.y - ui2StartPos.y) * easeT
        };
        ui2_->SetPosition(newPos1);
    }

    if (ui3Timer_ < ui3Duration_ && ui2_->GetPosition().x != ui3EndPos.x && ui2_->GetPosition().x > 900) {
        ui3Timer_++;

        float t = ui3Timer_ / ui3Duration_;
        float easeT = EaseOutBack(t);
        Vector2 newPos1 = {
            ui3StartPos.x + (ui3EndPos.x - ui3StartPos.x) * easeT,
            ui3StartPos.y + (ui3EndPos.y - ui3StartPos.y) * easeT
        };
        ui3_->SetPosition(newPos1);
    }


    // Step3æ™‚é–“æ›´æ–°
    step3Timer_ += (1.0f / 60.0f) * step3TimeScale ;

    Vector3 pos = player_->GetTranslate();

    /*-----------------------------------------------*/
    /* â‘  Step3é–‹å§‹æ™‚ã®ã€Œä¸€åº¦ã ã‘å¾Œã‚ã«ä¸‹ãŒã‚‹å‹•ãã€ */
    /*-----------------------------------------------*/
    if (!step3BackJumpDone_)
    {
        float backDuration = 0.3f;
        float backDistance = -30.0f;   // å¾Œã‚ï¼ˆ-Zï¼‰

        float t = step3Timer_ / backDuration;
        if (t > 1.0f) {
            t = 1.0f;
            step3BackJumpDone_ = true;

            // â˜… ã“ã®æ™‚ç‚¹ã®Zã‚’åŸºæº–ã«ã™ã‚‹
            startStep3PosZ_ = pos.z;
        }

        float ease = EaseOutBack(t);

        // Zã®ã¿å¾Œé€€
        pos.z = startStep3PosZ_ + backDistance * ease;
        pos.y = 0.0f;

        // å›žè»¢ã®ã¿å¤‰æ›´
        Vector3 rot = player_->GetRotate();
        float startRot = 1.5f;
        float endRot = 3.0f;
        rot.y = startRot + (endRot - startRot) * ease;

        player_->SetTranslate(pos);
        player_->SetRotate(rot);
        return;
    }

    /*-----------------------------------------------*/
    /* â‘¡ ã‚«ãƒ¡ãƒ©ã¸å‘ã‹ã£ã¦ X/Y/Z ç§»å‹•ï¼ˆåŠ é€Ÿä»˜ãï¼‰   */
    /*-----------------------------------------------*/
    Vector3 camPos = cam->GetTranslate();

    // ----------------------------
    // é€²è¡ŒçŽ‡
    // ----------------------------
    float t = (30.0f - pos.z) / 30.0f;
    t = std::clamp(t, 0.0f, 1.0f);

    // ----------------------------
    // ã‚¹ãƒ”ãƒ¼ãƒ‰ï¼ˆå‰å›žä½œã£ãŸæ¸›é€Ÿä»˜ãï¼‰
    // ----------------------------
    float accel = EaseOutCubic(t);
    float brake = EaseInCubic(1.0f - t);
    float speed = 1.2f + accel * brake * 8.0f;
    pos.z -= speed;

    // ----------------------------
    // ã‚«ãƒ¡ãƒ©æ¨ªã‚’é€šã‚‹ X ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    // ----------------------------
    float sideStart = -25.0f;   // ã‚«ãƒ¡ãƒ©å·¦
    float sideEnd = 25.0f;   // ã‚«ãƒ¡ãƒ©å³ï¼ˆé€šéŽï¼‰

    float sideX = Lerp(sideStart, sideEnd, EaseInOutSine(t));

    // ----------------------------
    // ä¸Šæ˜‡
    // ----------------------------
    float rise = EaseOutCubic(t) * 15.0f;

    // ----------------------------
    // ã‚«ãƒ¡ãƒ©åŸºæº–ã§ç›®æ¨™ä½ç½®ã‚’ä½œã‚‹
    // ----------------------------
    Vector3 targetPos;
    targetPos.x = camPos.x + sideX;
    targetPos.y = camPos.y + rise;
    targetPos.z = pos.z;

    // ãªã‚ã‚‰ã‹è¿½å¾“
    pos = Vector3::Lerp(pos, targetPos, 0.15f);

    player_->SetTranslate(pos);




    /*-----------------------------------------------*/
    /* â‘¢ 1ç§’å¾Œã«ä¸€çž¬ãƒ•ã‚§ãƒ¼ãƒ‰å‡¦ç†                  */
    /*-----------------------------------------------*/
    if (!step3FadeTriggered_ && step3Timer_ >= 1.0f && !FadeManager::GetInstance()->IsFading() && FadeManager::GetInstance()->IsFadeEnd()) {
        FadeManager::GetInstance()->StartFadeOut(1.8f, FadeStyle::SilhouetteSlide);
        step3FadeTriggered_ = true;
    }
}

bool GameClearScene::EaseMove(Vector3& current, const Vector3& start, const Vector3& end, float& t, float speed) {
    if (t >= 1.0f) return true;
    t = std::min(1.0f, t + speed);
    current = Easing::EaseVector3(start, end, t, Easing::EaseOutSine);
    return (t >= 1.0f);
}

============================================================
File Path: project/application/scene/GameClearScene.h
============================================================
#pragma once
#include<BaseScene.h>
#include<Sprite.h>
#include<Object3d.h>
#include<ParticleEmitter.h>
#include<SoundPlayer.h>
#include <Skybox.h>
#include<GameClearparticle.h>

/// <summary>
/// ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³
/// </summary>
class GameClearScene : public BaseScene {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize() override;
    /// <summary>
    /// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°å‡¦ç†
    /// </summary>
    void Update() override;
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw() override;


    // ã‚¯ãƒªã‚¢æ¼”å‡ºã‚’æ®µéšŽçš„ã«è¡Œã†
    void UpdateStep();
    // å„æ¼”å‡ºæ®µéšŽ
    void Step1_MovePlayerAndSwitchCamera();
    void Step2_WaitOrDoSomething();
    void Step3_MoveCameraOnInput();

    bool EaseMove(Vector3& current, const Vector3& start, const Vector3& end, float& t, float speed);

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    std::unique_ptr <Sprite> ui1_ = nullptr;     // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ 
    std::unique_ptr <Skybox> Box_ = nullptr;     //ã€€èƒŒæ™¯


    std::unique_ptr <Object3d> player_ = nullptr;  // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ        
    Transform offset_;



    uint32_t step_ = 0;

    float easeT_ = 0.0f;  // 0.0 â†’ 1.0 ã¾ã§é€²ã‚ã¦ã„ã
    float easeSpeed_ = 0.01f; // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é€Ÿåº¦
    Vector3 startOffset_;
    Vector3 endOffset_;
    // Step1 ã‚«ãƒ¡ãƒ©
    float step1CamT_ = 0.0f;
    bool step1CamMoveStart_ = false;




    float step2CamT_ = 0.0f;   // ã‚«ãƒ¡ãƒ©Xç§»å‹•ç”¨ã®t
    float step2Time_ = 0.0f;   // ä¸Šä¸‹æºã‚Œç”¨ã®æ™‚é–“
    // GameClearScene.h ã«ãƒ•ãƒ©ã‚°è¿½åŠ 
    bool step2FinishPlayerEase_ = false;
    // GameClearScene.h
    float step3Timer_ = 0.0f;           // Step3é–‹å§‹ã‹ã‚‰ã®çµŒéŽæ™‚é–“
    bool step3FadeTriggered_ = false;   // 1ç§’å¾Œã®çŸ­ã„ãƒ•ã‚§ãƒ¼ãƒ‰å‡¦ç†ãƒ•ãƒ©ã‚°
    // Step3åˆ¶å¾¡
    bool step3BackJumpDone_ = false;   // å¾Œã‚ã«ä¸‹ãŒã‚‹æ¼”å‡ºãŒå®Œäº†ã—ãŸã‹
    float startStep3PosX_ = 0.0f;     // Step3é–‹å§‹æ™‚ã®X


    float startStep3PosZ_;

    std::unique_ptr <Sprite> ui2_ = nullptr;     // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ      
    std::unique_ptr <Sprite> ui3_ = nullptr;     // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ 

    // UIç§»å‹•åˆ¶å¾¡ç”¨ã®å¤‰æ•°
    float ui2Timer_;
    float ui2Duration_; // ç´„1ç§’
    float ui3Timer_;
    float ui3Duration_;

    Vector2 ui2StartPos; // ä¸Šã«ãšã‚‰ã—ãŸåˆæœŸä½ç½®
    Vector2 ui2EndPos; // æœ€çµ‚ä½ç½®ï¼ˆç¾åœ¨ã®å€¤ï¼‰
    Vector2 ui3StartPos; // ä¸Šã«ãšã‚‰ã—ãŸåˆæœŸä½ç½®
    Vector2 ui3EndPos; // æœ€çµ‚ä½ç½®ï¼ˆç¾åœ¨ã®å€¤ï¼‰
    float step3TimeScale = 0.7f; // 0.3ï½ž0.6 ã‚ãŸã‚ŠãŒãŠã™ã™ã‚
    std::unique_ptr <GameClearparticle> particle_;
};

============================================================
File Path: project/application/scene/GameOverScene.cpp
============================================================
#include "GameOverScene.h"
#include<SceneManager.h>
#include<TextureManager.h>
#include<ModelManager.h>
#include<SpriteCommon.h>
#include<Object3dCommon.h>
#include <CameraManager.h>
#include<Input.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include <ParticleCommon.h>
#include<SkyboxCommon.h>
#include<FadeManager.h>
#include <random>
///====================================================
/// çµ‚äº†å‡¦ç†
///====================================================
void GameOverScene::Finalize() {
    FadeManager::GetInstance()->Finalize();
}
///====================================================
///  åˆæœŸåŒ–å‡¦ç†
///====================================================
void GameOverScene::Initialize() {
    // ã‚«ãƒ¡ãƒ©ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    CameraManager::GetInstance()->Initialize(CameraTransform({ 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }));
   // CameraManager::GetInstance()->SetCameraMode(CameraMode::Default);
    // ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿    
    ModelManager::GetInstance()->LoadModel("Gameover/Model/parts_01.obj");
    ModelManager::GetInstance()->LoadModel("Gameover/Model/parts_02.obj");
    ModelManager::GetInstance()->LoadModel("Gameover/Model/parts_03.obj");
    ModelManager::GetInstance()->LoadModel("Gameover/Model/parts_04.obj");

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿
    TextureManager::GetInstance()->LoadTexture("CubemapBox.dds");
    TextureManager::GetInstance()->LoadTexture("Gameover/Texture/Gameover.png");
    TextureManager::GetInstance()->LoadTexture("Gameover/Texture/UI_01.png");

    ui1Timer_ = 0.0f;
    ui1Duration_ = 60.0f; // ç´„1ç§’
    ui2Timer_ = 0.0f;
    ui2Duration_ = 60.0f;
    ui1StartPos = { 1000.0f, -100.0f }; // ä¸Šã«ãšã‚‰ã—ãŸåˆæœŸä½ç½®
    ui1EndPos = { 1000.0f, 200.0f }; // æœ€çµ‚ä½ç½®ï¼ˆç¾åœ¨ã®å€¤ï¼‰
    ui2StartPos = { 1000.0f, -250.0f };
    ui2EndPos = { 1000.0f, 350.0f };
    phase_ = 0;

    ui1_ = Sprite::Create("Gameover/Texture/Gameover.png", ui1StartPos, 0.0f, Vector2{ 300.0f,120.0f });
    ui1_->SetAnchorPoint(Vector2{ 0.5f, 0.5f }); // ä¸­å¿ƒåŸºæº–
    ui1_->SetTextureSize(Vector2{ 300.0f,120.0f });
    ui2_ = Sprite::Create("Gameover/Texture/UI_01.png", ui2StartPos, 0.0f, Vector2{ 360.0f,100.0f });
    ui2_->SetAnchorPoint(Vector2{ 0.5f, 0.5f }); // ä¸­å¿ƒåŸºæº–
    ui2_->SetTextureSize(Vector2{ 360.0f,100.0f });

    Box_ = Skybox::Create("CubemapBox.dds", Transform{ { 1000.0f, 1000.0f, 1000.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 100.0f } });

    // ãƒ©ãƒ³ãƒ€ãƒ Xã‚’ç”Ÿæˆï¼ˆ-0.5ï½ž0.5ã®ç¯„å›²ï¼‰
    std::random_device rd;
    std::mt19937 randomEngine(rd());
    std::uniform_real_distribution<float> transformY(10.0f, 13.0f);
    std::uniform_real_distribution<float> distX(-10.0f, 3.0f);
    std::uniform_real_distribution<float> distY(0.01f, 0.03f);
    std::uniform_real_distribution<float> rotateX(-0.01f, 0.01f);
    std::uniform_real_distribution<float> rotateY(-0.01f, 0.01f);
    std::uniform_real_distribution<float> rotateZ(-0.01f, 0.01f);

    std::vector<std::string> textureNames = {
    "Gameover/Model/parts_01.obj",
    "Gameover/Model/parts_02.obj",
    "Gameover/Model/parts_03.obj",
    "Gameover/Model/parts_04.obj",
    };

    partCount_ = 7;
    for (size_t  i = 0; i < partCount_; ++i) {
        PartInfo part;

        part.transform = { {1.0f, 1.0f, 1.0f}, {0.0f,0.0f,0.0f}, {distX(randomEngine), transformY(randomEngine), 30.0f} };
        // 1ã¤ç›®ã¯ãã®ã¾ã¾ã€ãã‚Œä»¥é™ã¯2å€‹ãšã¤ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’åˆ‡ã‚Šæ›¿ãˆ
        size_t textureIndex = 0; // 1ã¤ç›®ã¯ 0
        if (i > 0) {
            textureIndex = ((i - 1) / 2) + 1; // 2å€‹ã”ã¨ã«åˆ‡ã‚Šæ›¿ãˆ
            if (textureIndex >= textureNames.size()) textureIndex = textureNames.size() - 1; // é…åˆ—ã‚ªãƒ¼ãƒãƒ¼é˜²æ­¢
        }

        part.obj = Object3d::Create("Gameover/Model/parts_01.obj", part.transform);
        part.obj->SetModel(textureNames[textureIndex]); // å¾Œã‹ã‚‰ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¨­å®š

        part.fallSpeed = { 0.0f, distY(randomEngine), 0.0f }; // Yè»¸è½ä¸‹
        part.rotateSpeed = { rotateX(randomEngine), rotateY(randomEngine), rotateZ(randomEngine) };

        partsList.push_back(std::move(part));
    }    
    std::vector<Object3d*> partTargets;
    partTargets.reserve(partsList.size());  // æœ€é©åŒ–

    for (auto& part : partsList) {
        partTargets.push_back(part.obj.get());  // unique_ptr â†’ raw pointer ã«å¤‰æ›
    }
    particles_ = std::make_unique<GameOverparticle>();
    particles_->Initialize(partTargets);
    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    FadeManager::GetInstance()->Initialize();
}
///====================================================
/// æ›´æ–°å‡¦ç†
///====================================================
void GameOverScene::Update() {
    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
    if (!FadeManager::GetInstance()->IsFadeStart() && !FadeManager::GetInstance()->IsFading()) {
        // ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹
        FadeManager::GetInstance()->StartFadeIn(1.0f, FadeStyle::Normal);
    }
    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®æ›´æ–°å‡¦ç†
    FadeManager::GetInstance()->Update();

    // ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³ã¸ã®å…¥åŠ›å‡¦ç†
    if (Input::GetInstance()->Triggrkey(DIK_RETURN) && !FadeManager::GetInstance()->IsFading() && FadeManager::GetInstance()->IsFadeEnd()) {
        // UIæ¼”å‡ºå®Œäº†å¾Œã®ã¿ã‚­ãƒ¼å…¥åŠ›ã‚’è¨±å¯
        if (phase_ == 2) {
            // ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹
            FadeManager::GetInstance()->StartFadeOut(1.0f, FadeStyle::SilhouetteSlide);
        }
    }

    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†å¾Œã«ã‚¿ã‚¤ãƒˆãƒ«ã¸
    if (FadeManager::GetInstance()->IsFadeEnd() && FadeManager::GetInstance()->GetFadeType() == FadeType::FadeOut) {
        SceneManager::GetInstance()->ChangeScene("TITLE");
    }

    /*-------------------------------------------*/
    /*--------------Cameraã®æ›´æ–°å‡¦ç†---------------*/
    /*------------------------------------------*/
    CameraManager::GetInstance()->Update();

#pragma region å…¨ã¦ã®Object3då€‹ã€…ã®æ›´æ–°å‡¦ç†
    Box_->Update();   // èƒŒæ™¯ã®æ›´æ–°
   
    UpdateParts(); //  è½ä¸‹å‡¦ç†

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
    ParticleManager::GetInstance()->Update(); 
    particles_->Update();
#pragma endregion å…¨ã¦ã®Object3då€‹ã€…ã®æ›´æ–°å‡¦ç†

#pragma region å…¨ã¦ã®Spriteå€‹ã€…ã®æ›´æ–°å‡¦ç†
    

    UpdateUI(); // UIã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

   
#pragma endregion å…¨ã¦ã®Spriteå€‹ã€…ã®æ›´æ–°å‡¦ç†
#pragma region  ImGuiã®æ›´æ–°å‡¦ç†é–‹å§‹
#ifdef USE_IMGUI

    // Camera
    CameraManager::GetInstance()->DrawImGui();


#endif // USE_IMGUI
#pragma endregion ImGuiã®æ›´æ–°å‡¦ç†çµ‚äº†

}
///====================================================
/// æç”»å‡¦ç†
///====================================================
void GameOverScene::Draw() {
#pragma region å…¨ã¦ã®Object3då€‹ã€…ã®æç”»å‡¦ç†
    // ç®±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    SkyboxCommon::GetInstance()->Commondrawing();
    Box_->Draw(); // èƒŒæ™¯ã®æç”»

    // 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    Object3dCommon::GetInstance()->Commondrawing();
    
    for (PartInfo& part : partsList) {
        part.obj->Draw();
    }

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æç”»æº–å‚™ã€‚ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€ 
    ParticleCommon::GetInstance()->Commondrawing();
    ParticleManager::GetInstance()->Draw();
#pragma endregion å…¨ã¦ã®Object3då€‹ã€…ã®æç”»å‡¦ç†

#pragma region å…¨ã¦ã®Spriteå€‹ã€…ã®æç”»å‡¦ç†
    // Spriteã®æç”»æº–å‚™ã€‚Spriteã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    SpriteCommon::GetInstance()->Commondrawing();

    ui1_->Draw(); // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æç”»
    ui2_->Draw();

    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®æç”»
    FadeManager::GetInstance()->Draw();
#pragma endregion å…¨ã¦ã®Spriteå€‹ã€…ã®æç”»å‡¦ç†
}

void GameOverScene::UpdateParts() {
    for (PartInfo& part : partsList) {
        if (!FadeManager::GetInstance()->IsFading() && FadeManager::GetInstance()->IsFadeEnd() || phase_ == 2) {
            // è½ä¸‹
            part.transform.translate.y -= part.fallSpeed.y;
            if (part.transform.translate.y < -20.0f) {
                part.transform.translate.y = -20.0f; // åœ°é¢ã§æ­¢ã‚ã‚‹
            }

            // å›žè»¢
            part.transform.rotate -= part.rotateSpeed;

            // æ›´æ–°åæ˜ 
            part.obj->SetTranslate(part.transform.translate);
            part.obj->SetRotate(part.transform.rotate);
        }
        part.obj->Update();
    }
}

void GameOverScene::UpdateUI() {
    if (!FadeManager::GetInstance()->IsFading() && FadeManager::GetInstance()->IsFadeEnd()) {
        switch (phase_) {
        case 0: // --- UI1ç§»å‹•ä¸­ ---
            if (ui1Timer_ < ui1Duration_) {
                ui1Timer_++;

                float t = ui1Timer_ / ui1Duration_;
                float easeT = EaseOutBack(t);

                Vector2 newPos1 = {
                    ui1StartPos.x + (ui1EndPos.x - ui1StartPos.x) * easeT,
                    ui1StartPos.y + (ui1EndPos.y - ui1StartPos.y) * easeT
                };
                ui1_->SetPosition(newPos1);
            }

            // --- åˆ°ç€ãƒã‚§ãƒƒã‚¯ ---
            if (fabsf(ui1_->GetPosition().y - ui1EndPos.y) < 0.5f) {
                ui1_->SetPosition(ui1EndPos);
                phase_ = 1;     // æ¬¡ã®UIã¸
                ui2Timer_ = 0;  // æ¬¡ã®ã‚¿ã‚¤ãƒžãƒ¼ãƒªã‚»ãƒƒãƒˆ
            }
            ui1_->Update();
            break;

        case 1: // --- UI2ç§»å‹•ä¸­ ---
            if (ui2Timer_ < ui2Duration_) {
                ui2Timer_++;

                float t = ui2Timer_ / ui2Duration_;
                float easeT = EaseOutBack(t);

                Vector2 newPos2 = {
                    ui2StartPos.x + (ui2EndPos.x - ui2StartPos.x) * easeT,
                    ui2StartPos.y + (ui2EndPos.y - ui2StartPos.y) * easeT
                };
                ui2_->SetPosition(newPos2);
            }

            if (fabsf(ui2_->GetPosition().y - ui2EndPos.y) < 0.5f) {
                ui2_->SetPosition(ui2EndPos);
                phase_ = 2; // å®Œäº†
            }
            ui2_->Update();
            break;

        case 2:
            // --- å…¨ã¦å®Œäº† ---
            break;
        }
    }
}

============================================================
File Path: project/application/scene/GameOverScene.h
============================================================
#pragma once
#include<BaseScene.h>
#include<Sprite.h>
#include<Object3d.h>
#include<ParticleEmitter.h>
#include<SoundPlayer.h>
#include <Skybox.h>
#include<GameOverparticle.h>

struct PartInfo {
    std::unique_ptr<Object3d> obj;
    Transform transform;
    Vector3 fallSpeed;
    Vector3 rotateSpeed;
};

/// <summary>
/// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¼ãƒ³
/// </summary>
class GameOverScene : public BaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize() override;
    /// <summary>
    /// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°å‡¦ç†
    /// </summary>
    void Update() override;
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw() override;

    // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆEaseOutCubicï¼‰
    float EaseOutCubic(float t) {
        return 1.0f - powf(1.0f - t, 3.0f);
    }
    float EaseOutBack(float t) {
        float c1 = 1.70158f;
        float c3 = c1 + 1.0f;
        return 1.0f + c3 * powf(t - 1.0f, 3) + c1 * powf(t - 1.0f, 2);
    }

    void UpdateParts();/// ãƒ‘ãƒ¼ãƒ„è½ä¸‹ãƒ»å›žè»¢å‡¦ç†
    void UpdateUI();/// UIã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°      
    std::vector<PartInfo> partsList; // è¤‡æ•°ã®ãƒ‘ãƒ¼ãƒ„ç”¨
    uint32_t partCount_; // ç”Ÿæˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°
    std::unique_ptr <Sprite> ui1_ = nullptr;     // UIã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ 
    std::unique_ptr <Sprite> ui2_ = nullptr;     // UIã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ 
    std::unique_ptr <Skybox> Box_ = nullptr;     //ã€€èƒŒæ™¯
    // UIç§»å‹•åˆ¶å¾¡ç”¨ã®å¤‰æ•°
    float ui1Timer_;
    float ui1Duration_; // ç´„1ç§’
    float ui2Timer_;
    float ui2Duration_;

    Vector2 ui1StartPos; // ä¸Šã«ãšã‚‰ã—ãŸåˆæœŸä½ç½®
    Vector2 ui1EndPos; // æœ€çµ‚ä½ç½®ï¼ˆç¾åœ¨ã®å€¤ï¼‰

    Vector2 ui2StartPos;
    Vector2 ui2EndPos;
    uint32_t phase_;
    
    std::unique_ptr <GameOverparticle> particles_;
};

============================================================
File Path: project/application/scene/GamePlayScene.cpp
============================================================
#include "GamePlayScene.h"
#include<SceneManager.h>
#include<TextureManager.h>
#include<ModelManager.h>
#include<SpriteCommon.h>
#include<Object3dCommon.h>
#include <CameraManager.h>
#include <ParticleCommon.h>
#include<Input.h>
#include<Controller.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include<SkyboxCommon.h>
#include<Player.h>
#include <BulletManager.h>
#include<MatrixVector.h>
#include<Collision.h>

using namespace Collision;
using namespace MatrixVector;

///====================================================
/// çµ‚äº†å‡¦ç†ï¼ˆãƒªã‚½ãƒ¼ã‚¹è§£æ”¾ï¼‰
///====================================================
void GamePlayScene::Finalize() {
    BulletManager::GetInstance()->Finalize();  // å¼¾ã®è§£æ”¾å‡¦ç†
    FadeManager::GetInstance()->Finalize();    //  ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®è§£æ”¾å‡¦ç†
    EventManager::GetInstance()->Finalize();   //  ã‚¤ãƒ™ãƒ³ãƒˆãƒžãƒãƒ¼ã‚¸ãƒ£ã®è§£æ”¾å‡¦ç†
    StageManager::GetInstance()->Finalize();		  // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒžãƒãƒ¼ã‚¸ãƒ£ã®è§£æ”¾å‡¦ç†
}
///====================================================
/// åˆæœŸåŒ–å‡¦ç†
///====================================================
void GamePlayScene::Initialize() {
    // ã‚«ãƒ¡ãƒ©ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    CameraManager::GetInstance()->Initialize(CameraTransform({ 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }));     
    CameraManager::GetInstance()->SetTypeview(ViewCameraType::Main);

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’èª­ã¿è¾¼ã‚€
        
    TextureManager::GetInstance()->LoadTexture("Gameplay/Texture/UI_01.png");
    TextureManager::GetInstance()->LoadTexture("Gameplay/Texture/UI_02.png");
    TextureManager::GetInstance()->LoadTexture("Gameplay/Texture/UI_03.png");
        
    TextureManager::GetInstance()->LoadTexture("Gameplay/Texture/Gage.png");
    TextureManager::GetInstance()->LoadTexture("Gameplay/Texture/Player_ui.png");
    

    MAXui_ = 1;
    uis_.push_back(Sprite::Create("Gameplay/Texture/UI_01.png", Vector2{ 8.0f, 430.0f }, 0.0f, Vector2{ 200.0f,80.0f })); 
    uis_.push_back(Sprite::Create("Gameplay/Texture/UI_02.png", Vector2{ 8.0f, 530.0f }, 0.0f, Vector2{ 200.0f,80.0f })); 
    uis_.push_back(Sprite::Create("Gameplay/Texture/UI_03.png", Vector2{ 8.0f, 630.0f }, 0.0f, Vector2{ 200.0f,80.0f })); 
    uis_[0]->SetTextureSize(Vector2{200.0f,80.0f});
    uis_[1]->SetTextureSize(Vector2{200.0f,80.0f});
    uis_[2]->SetTextureSize(Vector2{200.0f,80.0f});
    
    gage_ = Sprite::Create("Gameplay/Texture/Gage.png", Vector2{ 380.0f, 10.0f }, 0.0f, Vector2{ 500.0f,30.0f });
    gage_->SetTextureSize(Vector2{ 500.0f,30.0f });     	 
    player_ui_ = Sprite::Create("Gameplay/Texture/Player_ui.png", Vector2{ 380.0f, 12.3f }, 0.0f, Vector2{ 25.0f,25.0f });
    player_ui_->SetTextureSize(Vector2{ 25.0f,25.0f });     

    // .objãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€
    ModelManager::GetInstance()->LoadModel("Bullet/PlayerBullet.obj");
    ModelManager::GetInstance()->LoadModel("Bullet/EnemyBullet.obj");
    ModelManager::GetInstance()->LoadModel("Gameplay/Model/Goal/Goal.obj");

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½œæˆã¨åˆæœŸåŒ–
    player_ = std::make_unique<Player>();
    player_->Initialize(); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆæœŸåŒ–
    CameraManager::GetInstance()->SetGamecameraTarget(player_->GetPlayerObject());
    playerhp_ = player_->IsActive();
    // ã‚«ãƒ¡ãƒ©ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½ã‚ã›ã‚‹

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
    particles_ = std::make_unique<GamePlayparticle>();
    particles_->Initialize(player_->GetPlayerObject());

    // æ•µé–¢é€£ã®åˆæœŸåŒ–
	MAX_ENEMY = 300; // æ•µã®æœ€å¤§æ•°
    // æ•µã‚’ãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã¦åˆæœŸåŒ–
    for (int i = 0; i < MAX_ENEMY; ++i) {
        std::unique_ptr<Enemy> enemy = std::make_unique<Enemy>();
        enemy->Initialize();
        enemy->SetPlayer(player_.get());
        enemy->SetActive(false);  // éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¦ãŠã
        enemies_.emplace_back(std::move(enemy));
    }
    // æ•µå‡ºç¾ãƒˆãƒªã‚¬ãƒ¼
    enemySpawner_ = std::make_unique<EnemySpawner>(); enemySpawner_->Initialize(player_.get(), CameraManager::GetInstance(), &enemies_);

    // ã‚¯ãƒªã‚¢ã‚²ãƒ¼ãƒˆ(ä»®)
    wall = Object3d::Create("Gameplay/Model/Goal/Goal.obj", Transform{ { 2.0f, 2.0f, 2.0f }, { 0.0f, 0.0f, 0.0f }, { 8.0f, 39.0f, 800.0f } });
    // ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®ä½œæˆ
    TextureManager::GetInstance()->LoadTexture("CubemapBox.dds");
    Box_ = Skybox::Create("CubemapBox.dds", Transform{ { 1000.0f, 1000.0f, 1000.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 100.0f } });
    // ã‚´ãƒ¼ãƒ«ãƒ•ãƒ©ã‚°åˆæœŸåŒ–
    goal_ = false;
    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    FadeManager::GetInstance()->Initialize();
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    EventManager::GetInstance()->Initialize("gamestart");
	// ã‚²ãƒ¼ãƒ ã‚«ãƒ¡ãƒ©ã®ç§»å‹•è¨±å¯
   // CameraManager::GetInstance()->GetGameCamera()->Setmovefige(true);
    // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    StageManager::GetInstance()->Initialize();

    end = false;
    // ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
    pausemenu_ = std::make_unique<Pausemenu>();
    pausemenu_->Initialize();
    isPaused_ = false;
    isPausedevent_ = false;
}
///====================================================
/// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°å‡¦ç†
///====================================================
void GamePlayScene::Update() { 
    pausemenu_->IconUpdate();
    // Enterã‚­ãƒ¼ã§ãƒãƒ¼ã‚ºã®ã€Œé–‹å§‹ã€ã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯
    if (isPausedevent_ && !isPaused_ && Input::GetInstance()->Triggrkey(DIK_TAB)) {
        isPaused_ = true;
        pausemenu_->SetActive(true); // æ¼”å‡ºé–‹å§‹ï¼
    }

    //  ãƒãƒ¼ã‚ºä¸­ã®å‡¦ç†
    if (isPaused_) {
        pausemenu_->Update();
        // ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼å†…ã§ã®æ¼”å‡ºï¼ˆé€†å†ç”Ÿå«ã‚€ï¼‰ãŒã™ã¹ã¦çµ‚ã‚ã£ãŸã‹ãƒã‚§ãƒƒã‚¯
        if (pausemenu_->IsFinished()) {
            isPaused_ = false; // ã‚²ãƒ¼ãƒ å†é–‹
        }

        // Resumeï¼ˆå†é–‹ï¼‰ã®å ´åˆã¯ã€ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒé–‰ã˜çµ‚ã‚ã‚‹ã®ã‚’å¾…ã¤
        if (pausemenu_->IsFinished() && pausemenu_->GetCommand() == PauseCommand::Resume) {
            isPaused_ = false;
        } else if (pausemenu_->GetCommand() == PauseCommand::GoToTitle) {
            // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®æ›´æ–°   
            FadeManager::GetInstance()->Update();
            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãŒè¡¨ç¤ºã•ã‚ŒãŸã¾ã¾ã€ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚’é–‹å§‹
            if (!goal_) {
                FadeManager::GetInstance()->StartFadeOut(1.0f, FadeStyle::Normal);
                goal_ = true; // ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹ãƒ•ãƒ©ã‚°ã¨ã—ã¦åˆ©ç”¨
            }

            // ãƒ•ã‚§ãƒ¼ãƒ‰ãŒçµ‚ã‚ã£ãŸã‚‰ã‚·ãƒ¼ãƒ³é·ç§»
            if (FadeManager::GetInstance()->IsFadeEnd()) {
                SceneManager::GetInstance()->ChangeScene("TITLE");
            }
            // ã‚¿ã‚¤ãƒˆãƒ«ç§»è¡Œæ™‚ã¯ã“ã“ã§returnã—ã€èƒŒå¾Œã®ã‚²ãƒ¼ãƒ å‡¦ç†ã‚’æ­¢ã‚ãŸã¾ã¾ã«ã™ã‚‹
            return;
        }
        // ãƒãƒ¼ã‚ºæ¼”å‡ºä¸­ã¯ã‚²ãƒ¼ãƒ ã®ä»–ã®æ›´æ–°ã‚’æ­¢ã‚ã‚‹
        return;
    }

    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
    if (!FadeManager::GetInstance()->IsFadeStart() && !FadeManager::GetInstance()->IsFading()) {
        // ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹
        FadeManager::GetInstance()->StartFadeIn(1.0f, FadeStyle::SilhouetteExplode);
    }
    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®æ›´æ–°   
    FadeManager::GetInstance()->Update();
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒžãƒãƒ¼ã‚¸ãƒ£ã®æ›´æ–°
    EventManager::GetInstance()->Update(); 	

    // æ­»äº¡æ¼”å‡º
    if (end && CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Main) {
        CameraManager::GetInstance()->SetMode(CameraMode::Default);   
        CameraManager::GetInstance()->SetTypeview(ViewCameraType::Sub);
        player_->SetKeyActive(false);
        player_->SetReticleVisible(false);
        // ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹             
        end = false;
    }

    if (CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Sub && CameraManager::GetInstance()->GetMode() == CameraMode::Default) {
        FadeManager::GetInstance()->StartFadeOut(1.0f, FadeStyle::Normal);
        CameraManager::GetInstance()->SetMode(CameraMode::Follow);
    }

    // ã‚´ãƒ¼ãƒ«æ¼”å‡º
    if (!goal_ && player_->GetPosition().z >= CameraManager::GetInstance()->GetGameplayCamera()->GetBezierPoints().back().controlPoint.z && CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Main) {
        FadeManager::GetInstance()->StartFadeOut(1.0f, FadeStyle::Normal);
        player_->SetKeyActive(false);
        player_->SetReticleVisible(false);
        // ãƒ•ã‚§ãƒ¼ãƒ‰é–‹å§‹             
        goal_ = true;
        end = false;
    }

    // ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆã‚¤ãƒ™ãƒ³ãƒˆãŒçµ‚äº†ã—ãŸã‚‰ãƒ—ãƒ¬ã‚¤ãƒ¤â€•æ“ä½œå¯èƒ½ã«
    if (EventManager::GetInstance()->IsFinished() && CameraManager::GetInstance()->GetTypeview() == ViewCameraType::Main) {
        // ã‚¤ãƒ™ãƒ³ãƒˆçµ‚äº† â†’ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ“ä½œå¯èƒ½ã«
        player_->SetKeyActive(true);
        player_->SetReticleVisible(true);
        isPausedevent_ = true;
        // é€²è¡Œåº¦ã‚’è¨­å®š
        StartStageProgressUI();
    }
    
    // ===== UIé€²è¡Œæ›´æ–° =====
    UpdateStageProgressUI();

    StageManager::GetInstance()->Update();

    /*-------------------------------------------*/
    /*--------------Cameraã®æ›´æ–°å‡¦ç†---------------*/
    /*------------------------------------------*/
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½ã‚ã›ã‚‹
    CameraManager::GetInstance()->SetGamecameraTarget(player_->GetPlayerObject());
    CameraManager::GetInstance()->Update();
#pragma region å…¨ã¦ã®Object3då€‹ã€…ã®æ›´æ–°å‡¦ç†
    playerhp_ = player_->IsActive();
    // çµ‚äº†ã—ãªã„é™ã‚Šæ›´æ–°å‡¦ç†
    if (!end) {
        if (EventManager::GetInstance()->IsFinished() ){
            // æ•µå‡ºç¾å‹•ä½œ
            enemySpawner_->Update();
        }
        // å„è¡çªåˆ¤å®š
        CheckBulletEnemyCollisionsOBB();
        CheckEnemyBulletPlayerCollisionsOBB(); 
        CheckEnemyPlayerCollisionsOBB();
        // æ›´æ–°å‡¦ç†
        player_->Update();
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚´ãƒ¼ãƒ«æ‰‹å‰ã¾ã§ã¯æ•µã‚‚æ›´æ–°
        if (player_->GetPosition().z <=  CameraManager::GetInstance()->GetGameplayCamera()->GetBezierPoints().back().controlPoint.z) {
            // æ•µã®æ›´æ–°
            for (auto& enemy : enemies_) {
                if (enemy->IsActive()) {
                    enemy->SetPlayer(player_.get());
                    enemy->Update();
                }
            }
        }
        wall->Update();
        // Bulletãƒžãƒãƒ¼ã‚¸ãƒ£ã®æ›´æ–°å‡¦ç†
        BulletManager::GetInstance()->Update();
    }

    // æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰é›¢ã‚Œã™ãŽãŸã‚‰å‰Šé™¤ï¼ˆéŽåŽ»ã®æ•µæŽƒé™¤ï¼‰
    for (auto& enemy : enemies_) {
        if (!enemy->IsActive()) continue;
        float playerZ = player_->GetPosition().z;
        float spawnZ = enemy->GetSpawnBaseZ();  // å‡ºç¾åŸºæº–Z
        if (playerZ > spawnZ + 30) { // å‡ºç¾ä½ç½®ã‚ˆã‚Šé€²ã‚“ã§ãŸã‚‰å‰Šé™¤
            enemy->Kill();
        }
    }

    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆãŒå®Œäº†ã—ãŸã‚‰æ¬¡ã®ã‚·ãƒ¼ãƒ³ã¸
    if (FadeManager::GetInstance()->IsFadeEnd() && FadeManager::GetInstance()->GetFadeType() == FadeType::FadeOut) {
        if (!playerhp_) {
            // ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
            SceneManager::GetInstance()->ChangeScene("GAMEOVER");
        } else {
            // ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
            SceneManager::GetInstance()->ChangeScene("GAMECLEAR");
        }
    }

    // æ­»ã‚“ã æ•µã®å‰Šé™¤
    enemies_.erase(
        std::remove_if(enemies_.begin(), enemies_.end(),
            [](const std::unique_ptr<Enemy>& e) {
                return e->IsDead();  // â† å‡ºç¾å‰ã®éžã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã¯æ®‹ã™ï¼
            }),
        enemies_.end());
    // ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹æ›´æ–°
    Box_->Update(); 

    for (auto& enemy : enemies_) {
        enemy->onDeathCallback = [this](const Vector3& pos) {
            particles_->AddHitPosition(pos);
            };
    }
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
    ParticleManager::GetInstance()->Update();
    particles_->Update();
#pragma endregion å…¨ã¦ã®Object3då€‹ã€…ã®æ›´æ–°å‡¦ç†

#pragma region å…¨ã¦ã®Spriteå€‹ã€…ã®æ›´æ–°å‡¦ç†

    for (std::unique_ptr<Sprite>& ui : uis_) {
        ui->Update();
    }

    gage_->Update();
    player_ui_->Update();

#pragma endregion å…¨ã¦ã®Spriteå€‹ã€…ã®æ›´æ–°å‡¦ç†

#pragma region  ImGuiã®æ›´æ–°å‡¦ç†é–‹å§‹
#ifdef USE_IMGUI 
    ImGui::Begin("=== GamePlayScene Debug ===");
    // ã€Œendã€ãƒ•ãƒ©ã‚°ã‚’åˆ‡ã‚Šè¿”ã™ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
    ImGui::Checkbox("End Flag", &end);
    ImGui::End();

  //  Object3dCommon::GetInstance()->DrawImGui(); // object3dã®lightã®ImGuiåˆ¶å¾¡
    CameraManager::GetInstance()->DrawImGui();  // ã‚«ãƒ¡ãƒ©ãƒžãƒãƒ¼ã‚¸ãƒ£ã®ImGuiåˆ¶å¾¡
//	FadeManager::GetInstance()->DrawImGui();    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®ImGuiåˆ¶å¾¡ 
///	EventManager::GetInstance()->DrawImGui();   // ã‚¤ãƒ™ãƒ³ãƒˆãƒžãƒãƒ¼ã‚¸ãƒ£ã®ImGuiåˆ¶å¾¡
	//stageManager_->DebugImGui(); 			  // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒžãƒãƒ¼ã‚¸ãƒ£ã®ImGuiåˆ¶å¾¡
#endif // USE_IMGUI
#pragma endregion ImGuiã®æ›´æ–°å‡¦ç†çµ‚äº† 
}
///====================================================
/// æç”»å‡¦ç†
///====================================================
void GamePlayScene::Draw() {
#pragma region å…¨ã¦ã®Object3då€‹ã€…ã®æç”»å‡¦ç†
    // ç®±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    SkyboxCommon::GetInstance()->Commondrawing();
    Box_->Draw();
    // 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    Object3dCommon::GetInstance()->Commondrawing();
    StageManager::GetInstance()->Draw();

    // æç”»å‡¦ç†
    if (!end) {
        player_->Draw();
        // Bulletãƒžãƒãƒ¼ã‚¸ãƒ£ã®æç”»å‡¦ç†
        BulletManager::GetInstance()->Draw();
    }
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚´ãƒ¼ãƒ«åœ°ç‚¹ã«é”ã™ã‚‹ã¾ã§ã¯æ•µã‚„å£ã‚’æç”»
    if (player_->GetPosition().z <= CameraManager::GetInstance()->GetGameplayCamera()->GetBezierPoints().back().controlPoint.z) {
        // æ•µã®æ›´æ–°
        for (auto& enemy : enemies_) {
            if (enemy->IsActive()) {
                enemy->Draw();
            }
        }
    }
    wall->Draw();
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒžãƒãƒ¼ã‚¸ãƒ£ã®æç”»å‡¦ç†
    EventManager::GetInstance()->Drawo3Dbject();

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æç”»æº–å‚™ã€‚ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€ 
    ParticleCommon::GetInstance()->Commondrawing();
    ParticleManager::GetInstance()->Draw();
#pragma endregion å…¨ã¦ã®Object3då€‹ã€…ã®æç”»å‡¦ç†

#pragma region å…¨ã¦ã®Spriteå€‹ã€…ã®æç”»å‡¦ç†
    // Spriteã®æç”»æº–å‚™ã€‚Spriteã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    SpriteCommon::GetInstance()->Commondrawing();
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®UIã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
    if (!end) {
        player_->DrawSprite();
    }

    for (std::unique_ptr<Sprite>& ui : uis_) {
        ui->Draw();
    }

    gage_->Draw();
    player_ui_->Draw();
    if (isPausedevent_) {
        if (isPaused_) {
            pausemenu_->Draw();
        }
        pausemenu_->IconDraw();
    }
    // ã‚¤ãƒ™ãƒ³ãƒˆãƒžãƒãƒ¼ã‚¸ãƒ£ã®æç”»å‡¦ç†
    EventManager::GetInstance()->Draw2DSprite();
    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®æç”»
    FadeManager::GetInstance()->Draw();
#pragma endregion å…¨ã¦ã®Spriteå€‹ã€…ã®æç”»å‡¦ç†
}

///====================================================
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¼¾ vs æ•µã®å½“ãŸã‚Šåˆ¤å®š
///====================================================
void GamePlayScene::CheckBulletEnemyCollisionsOBB() {
    const auto& bullets = BulletManager::GetInstance()->GetPlayerBullets();

    for (const std::unique_ptr<PlayerBullet>& bullet : bullets) {
        if (!bullet->IsActive()) continue;

        for (auto& enemy : enemies_) {
            if (!enemy->IsActive()) continue;

            OBB bulletOBB = bullet->GetOBB(); // bulletãŒOBBæƒ…å ±ã‚’æŒã£ã¦ã„ã‚‹å¿…è¦ã‚ã‚Š
            OBB enemyOBB = enemy->GetOBB();   // æ•µã®OBBã‚‚åŒæ§˜ã«

            if (IsOBBIntersect(bulletOBB, enemyOBB)) {
                bullet->SetInactive();
                enemy->OnHit();
                
               // particles_->AddHitPosition(enemy->GetPosition());
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆãªã©
                break;
            }
        }
    }
}
///====================================================
/// æ•µå¼¾ vs ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å½“ãŸã‚Šåˆ¤å®š
///====================================================
void GamePlayScene::CheckEnemyBulletPlayerCollisionsOBB() {
    const auto& bullets = BulletManager::GetInstance()->GetEnemyBullets();

    if (!player_ || !player_->IsActive()) return;

    OBB playerOBB = player_->GetOBB(); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒOBBã‚’è¿”ã™ã‚ˆã†ã«ã—ã¦ãŠãå¿…è¦ã‚ã‚Š

    for (const std::unique_ptr<EnemyBullet>& bullet : bullets) {
        if (!bullet->IsActive()) continue;

        OBB bulletOBB = bullet->GetOBB(); // å¼¾ã«ã‚‚OBBãŒå¿…è¦

        if (IsOBBIntersect(bulletOBB, playerOBB)) {
            bullet->SetInactive();
            player_->SetInactive();  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç„¡åŠ¹ã«ã™ã‚‹

            end = true;
            // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã©è¿½åŠ 
            break;
        }
    }
}
///====================================================
/// æ•µ vs ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ ã®å½“ãŸã‚Šåˆ¤å®š
///====================================================
void GamePlayScene::CheckEnemyPlayerCollisionsOBB() {
    if (!player_ || !player_->IsActive()) return;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®OBBã‚’å–å¾—
    OBB playerOBB = player_->GetOBB();

    for (auto& enemy : enemies_) {
        if (!enemy->IsActive() || enemy->IsDead()) continue;

        // æ•µã®OBBã‚’å–å¾—
        OBB enemyOBB = enemy->GetOBB();

        // è¡çªåˆ¤å®š
        if (IsOBBIntersect(playerOBB, enemyOBB)) {
            player_->SetInactive();
            end = true; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã¸é·ç§»ãªã©

            break;
        }
    }
}

void GamePlayScene::StartStageProgressUI() {
    if (uiProgressStarted_) return;
    uiStartRailLength_ = CameraManager::GetInstance()->GetGameplayCamera()->GetCurrentRailLength();

    uiProgressStarted_ = true;
}

void GamePlayScene::UpdateStageProgressUI() {
    if (!uiProgressStarted_ || uiProgressFinished_) return;

    auto* cam = CameraManager::GetInstance()->GetGameplayCamera();

    float current = cam->GetCurrentRailLength();
    float total   = cam->GetTotalRailLength();

    float uiTotalLength = total - uiStartRailLength_;
    if (uiTotalLength <= 0.0001f) return;

    float progress = (current - uiStartRailLength_) / uiTotalLength;

    if (progress >= 1.0f) {
        progress = 1.0f;
        uiProgressFinished_ = true;
    }

    progress = std::clamp(progress, 0.0f, 1.0f);

    constexpr float gageX = 380.0f;
    constexpr float gageWidth = 500.0f;
    constexpr float playerWidth = 25.0f;

    float movableWidth = gageWidth - playerWidth;
    float uiX = gageX + progress * movableWidth;

    player_ui_->SetPosition(Vector2{ uiX, 12.3f });
}

============================================================
File Path: project/application/scene/GamePlayScene.h
============================================================
#pragma once
#include<BaseScene.h>
#include<Sprite.h>
#include<Object3d.h>
#include<ParticleEmitter.h>
#include<SoundPlayer.h>
#include<Skybox.h>
#include<CharacterLoader.h>
#include<Player.h>
#include<Enemy.h>
#include<FadeManager.h>
#include<EventManager.h>
#include<StageManager.h>
#include<GamePlayparticle.h>
#include <EnemySpawner.h>
#include<Pausemenu.h>

/// <summary>
/// ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³
/// </summary>
class GamePlayScene : public BaseScene
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize() override;
    /// <summary>
    /// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°å‡¦ç†
    /// </summary>
    void Update() override;
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw() override;

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾ã¨æ•µã¨ã®è¡çªåˆ¤å®šå‡¦ç†
    /// </summary>
    void CheckBulletEnemyCollisionsOBB();
    /// <summary>
    /// æ•µã®å¼¾ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çªåˆ¤å®šå‡¦ç†
    /// </summary>
    void CheckEnemyBulletPlayerCollisionsOBB();

    void CheckEnemyPlayerCollisionsOBB();

    void StartStageProgressUI();
    void UpdateStageProgressUI();
    void UpdateRandomMove();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ãƒ¼ã‚¿
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    std::unique_ptr <Player> player_ = nullptr;
    bool playerhp_ = true;
    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãƒ­ãƒ¼ãƒ€ãƒ¼
    std::unique_ptr<CharacterLoader> levelLoader_ = nullptr;
    // ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
    LevelData* levelData = nullptr;
    bool end;
    // æœ€å¤§æ•°
    int MAX_ENEMY;
    // æ•µãƒªã‚¹ãƒˆ
    std::vector<std::unique_ptr<Enemy>> enemies_;
    std::unique_ptr<EnemySpawner> enemySpawner_;
    // æ•µå‡ºç¾ãƒˆãƒªã‚¬ãƒ¼ãƒªã‚¹ãƒˆ
    std::vector<EnemySpawnTrigger> spawnTriggers_;
    // ã‚¯ãƒªã‚¢ã‚²ãƒ¼ãƒˆ(ä»®)
    std::unique_ptr <Object3d> wall = nullptr;
    // ã‚´ãƒ¼ãƒ«ãƒ•ãƒ©ã‚°
    bool goal_ = false;
    // ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹
    std::unique_ptr <Skybox> Box_ = nullptr;
    // ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
    std::vector<EventManager> event_;
    /// UI(ã‚¿ã‚¤ãƒˆãƒ«ã¸(ä»®))
    std::unique_ptr <Sprite> ui1_;
    std::vector<std::unique_ptr<Sprite>> uis_;
    uint32_t MAXui_;

    std::unique_ptr <GamePlayparticle> particles_;

    std::unique_ptr <Sprite> gage_;
    std::unique_ptr <Sprite> player_ui_;
    // ===== UIé€²è¡Œç®¡ç† =====
    float uiStartRailLength_ = 0.0f;
    bool uiProgressStarted_ = false;
    bool uiProgressFinished_ = false;

    std::unique_ptr <Pausemenu> pausemenu_;
    bool isPausedevent_;
    bool isPaused_;
};

============================================================
File Path: project/application/scene/TitleScene.cpp
============================================================
#include "TitleScene.h"
#include<SceneManager.h>
#include<TextureManager.h>
#include<ModelManager.h>
#include<SpriteCommon.h>
#include<Object3dCommon.h>
#include <CameraManager.h>
#include<Input.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include <ParticleCommon.h>
#include<SkyboxCommon.h>
#include<FadeManager.h>
#include<Tools/AssetGenerator/engine/math/LoadResourceID.h>

using namespace LoadResourceID;
namespace { constexpr float kFadeDuration = 1.0f; }

void TitleScene::Finalize() {
    FadeManager::GetInstance()->Finalize();  //  ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®è§£æ”¾å‡¦ç†
}

void TitleScene::Initialize() {
#pragma region ã‚·ãƒ¼ãƒ³ã®åˆæœŸåŒ–  
    // ã‚«ãƒ¡ãƒ©ã®åˆæœŸåŒ–
    InitializeCamera();
    // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    FadeManager::GetInstance()->Initialize();
    // ãƒªã‚½ãƒ¼ã‚¹ã®èª­ã¿è¾¼ã¿
    LoadResources();
    // UIã®åˆæœŸåŒ–
    InitializeUI();
    // ãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
    InitializeModel();
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã®ç”Ÿæˆã€åˆæœŸåŒ–
    particle_ = std::make_unique<Titleparticle>();
    particle_->Initialize(player_->GetPlayerObject());
        
    CameraManager::GetInstance()->SetCameraMode(CameraMode::Default);      

#pragma endregion ã‚·ãƒ¼ãƒ³ã®åˆæœŸåŒ–
}

void TitleScene::InitializeCamera() {
    // ã‚«ãƒ¡ãƒ©ãƒžãƒãƒ¼ã‚¸ãƒ£ã®ç”Ÿæˆã€åˆæœŸåŒ–
    CameraManager::GetInstance()->Initialize(CameraTransform({ 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }));
}

void TitleScene::LoadResources() {
    //  ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿
    TextureManager::GetInstance()->LoadTexture(texture::Ui02);
    TextureManager::GetInstance()->LoadTexture(texture::Title);
    TextureManager::GetInstance()->LoadTexture("CubemapBox.dds");
}

void TitleScene::InitializeUI() {  
    // ã‚¿ã‚¤ãƒˆãƒ«ãƒ­ã‚´ã®ç”Ÿæˆ
    ui_title_ = Sprite::Create(texture::Title, Vector2{300.0f, 100.0f}, 0.0f, Vector2{600.0f,300.0f});
    ui_title_->SetTextureSize(Vector2{ 600.0f,300.0f });
    // ã‚¹ã‚¿ãƒ¼ãƒˆUIã®ç”Ÿæˆ
    ui_start_ = Sprite::Create(texture::Ui02, Vector2{ 420.0f, 500.0f }, 0.0f, Vector2{ 360.0f,90.0f });
    ui_start_->SetTextureSize(Vector2{ 360.0f,90.0f });
    // æ›´æ–°ãƒ»æç”»å¯¾è±¡ã¨ã—ã¦ã¾ã¨ã‚ã‚‹
    uiSprites_.clear();
    uiSprites_ = { ui_start_.get(),ui_title_.get() };
}

void TitleScene::InitializeModel() {
    // ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ç”Ÿæˆ 
    skybox_ = Skybox::Create("CubemapBox.dds", Transform{ { 1000.0f, 1000.0f, 1000.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 100.0f } });
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ 
    playertransform_ = { {1.0f, 1.0f, 1.0f}, {0.0f, 0.3f, 0.0f},  -20.0f,0.0f,40.0f };
    titleStartX_ = -20.0f;
    titleEndX_ = -10.0f;
    // ãƒ¢ãƒ‡ãƒ«ç§»å‹•ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    timer = 0.0f;
    moveDuration = kTitleMoveDuration;  // ç§»å‹•ã«ã‹ã‘ã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼ˆç´„2ç§’ï¼‰     
    moveFinished = false;
    time = 0.0f;          // çµŒéŽæ™‚é–“ 
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç”Ÿæˆã€åˆæœŸåŒ–
    player_ = std::make_unique<Player>();
    player_->Initialize();
    player_->SetTransform(playertransform_);
    // è¿½å¾“å¯¾è±¡ã‚’è¨­å®š
    CameraManager::GetInstance()->GetTitleCamera()->SetTarget(player_->GetPlayerObject());
}

void TitleScene::Update() {
    // ã‚·ãƒ¼ãƒ³é–‹å§‹æ™‚ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚’é–‹å§‹
    UpdateFadeIn();
    // ã‚­ãƒ¼æ“ä½œã§ã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚’é–‹å§‹
    UpdateFadeOut();
    // æ¬¡ã®ã‚·ãƒ¼ãƒ³ã¸ç§»è¡Œã™ã‚‹
    UpdateSceneTransition();
    /*------------------------------------------*/
    /*--------------Cameraã®æ›´æ–°å‡¦ç†--------------*/
    /*------------------------------------------*/
    CameraManager::GetInstance()->Update();
#pragma region å…¨ã¦ã®Object3då€‹ã€…ã®æ›´æ–°å‡¦ç† 
    // Skyboxã®å›žè»¢
    Transform skyTrans = skybox_->GetTransform();
    skyTrans.rotate.y += 0.001f; // Yè»¸å›žè»¢ï¼ˆ1ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«å°‘ã—ãšã¤ï¼‰
    skybox_->SetRotate(skyTrans.rotate);
    skybox_->Update();
     
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ¼”å‡º
    UpdateTitlePlayerMotion();
    player_->Update();

    ParticleManager::GetInstance()->Update(); 
    particle_->Update();
#pragma endregion å…¨ã¦ã®Object3då€‹ã€…ã®æ›´æ–°å‡¦ç†

#pragma region å…¨ã¦ã®Spriteå€‹ã€…ã®æ›´æ–°å‡¦ç†
    for (Sprite* sprite : uiSprites_) {
        sprite->Update();
    }
#pragma endregion å…¨ã¦ã®Spriteå€‹ã€…ã®æ›´æ–°å‡¦ç†

#pragma region  ImGuiã®æ›´æ–°å‡¦ç†é–‹å§‹
#ifdef USE_IMGUI
	FadeManager::GetInstance()->DrawImGui(); // ãƒ•ã‚§ãƒ¼ãƒ‰ãƒžãƒãƒ¼ã‚¸ãƒ£ã®ImGuiåˆ¶å¾¡    
    CameraManager::GetInstance()->DrawImGui();  // ã‚«ãƒ¡ãƒ©ãƒžãƒãƒ¼ã‚¸ãƒ£ã®ImGuiåˆ¶å¾¡
#endif // USE_IMGUI
#pragma endregion ImGuiã®æ›´æ–°å‡¦ç†çµ‚äº†
}

void TitleScene::Draw() {
#pragma region å…¨ã¦ã®Object3då€‹ã€…ã®æç”»å‡¦ç† 
    // ç®±ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    SkyboxCommon::GetInstance()->Commondrawing();
    skybox_->Draw();
    // 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    Object3dCommon::GetInstance()->Commondrawing();
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æç”»å‡¦ç†
    player_->Draw();
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æç”»æº–å‚™ã€‚ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€ 
    ParticleCommon::GetInstance()->Commondrawing();
    ParticleManager::GetInstance()->Draw();
#pragma endregion å…¨ã¦ã®Object3då€‹ã€…ã®æç”»å‡¦ç†

#pragma region å…¨ã¦ã®Spriteå€‹ã€…ã®æç”»å‡¦ç†
    // Spriteã®æç”»æº–å‚™ã€‚Spriteã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    SpriteCommon::GetInstance()->Commondrawing();
    // å„UIã®æç”»å‡¦ç†
    for (Sprite* sprite : uiSprites_) {
        sprite->Draw();
    }
	// ãƒ•ã‚§ãƒ¼ãƒ‰ã®æç”»
    FadeManager::GetInstance()->Draw();
#pragma endregion å…¨ã¦ã®Spriteå€‹ã€…ã®æç”»å‡¦ç†
}

void TitleScene::UpdateFadeIn() {
    // ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ã«ãŠã‘ã‚‹ãƒ•ã‚§ãƒ¼ãƒ‰åˆ¶å¾¡ã‚’æ‹…å½“
    FadeManager* fade = FadeManager::GetInstance();
    // ãƒ•ã‚§ãƒ¼ãƒ‰ãŒæœªé–‹å§‹ã‹ã¤å®Ÿè¡Œä¸­ã§ãªã„å ´åˆã®ã¿ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚’é–‹å§‹
    if (!fade->IsFadeStart() && !fade->IsFading()) {
        fade->StartFadeIn(kFadeDuration, FadeStyle::SilhouetteSlide);
    }
    // ãƒ•ã‚§ãƒ¼ãƒ‰çŠ¶æ…‹ã®æ›´æ–°
    fade->Update();
}

void TitleScene::UpdateFadeOut() {
    // ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ã«ãŠã‘ã‚‹ãƒ•ã‚§ãƒ¼ãƒ‰åˆ¶å¾¡ã‚’æ‹…å½“
    FadeManager* fade = FadeManager::GetInstance(); 
    // ãƒ•ã‚§ãƒ¼ãƒ‰ä¸­ã§ã¯ãªããƒ•ã‚§ãƒ¼ãƒ‰å®Œäº†çŠ¶æ…‹ã®æ™‚ã«Enterã‚­ãƒ¼ã‚’æŠ¼ã™ã¨ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹
    if (Input::GetInstance()->Triggrkey(DIK_RETURN) && !fade->IsFading() && fade->IsFadeEnd() && !isPlayerBoost_ && CameraManager::GetInstance()->GetActiveCamera()->GetTranslate().x >= 30.0f) {
        fade->StartFadeOut(2.5f, FadeStyle::SilhouetteExplode);
        CameraManager::GetInstance()->SetCameraMode(CameraMode::Follow);

        // ===== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ¼”å‡ºé–‹å§‹ =====
        isPlayerBoost_ = true;
        playerSpeedX_ = 0.0f;
    }
}

void TitleScene::UpdateSceneTransition() {
    // ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ã«ãŠã‘ã‚‹ãƒ•ã‚§ãƒ¼ãƒ‰åˆ¶å¾¡ã‚’æ‹…å½“
    FadeManager* fade = FadeManager::GetInstance();
    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†å¾Œã«ã‚·ãƒ¼ãƒ³é·ç§»å‡¦ç†ã‚’è¡Œã†
    if (fade->IsFadeEnd() && fade->GetFadeType() == FadeType::FadeOut) {
        // ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ã¸ç§»è¡Œ
        SceneManager::GetInstance()->ChangeScene("GAMEPLAY");
    }
}

void TitleScene::UpdateTitlePlayerMotion() {

    FadeManager* fade = FadeManager::GetInstance();

    // ==============================
    // ãƒ•ã‚§ãƒ¼ãƒ‰ä¸­ï¼šåŠ é€Ÿã—ã¦é£›ã¶
    // ==============================
    if (isPlayerBoost_ && fade->IsFading() && fade->GetFadeType() == FadeType::FadeOut) {

        playerSpeedX_ += playerAccelX_;
        playerSpeedX_ = std::min(playerSpeedX_, playerMaxSpeedX_);

        playertransform_.translate.z += playerSpeedX_;

        // ã¡ã‚‡ã£ã¨ä¸Šã«æµ®ã‹ã›ã‚‹ã¨ã€Œé£›ã³æ„Ÿã€UP
        playertransform_.translate.y += 0.05f;

    }

    // ===== æ¨ªç§»å‹•ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼‰ =====
    if (!moveFinished) {
        timer += 1.0f;
        float t = std::clamp(timer / moveDuration, 0.0f, 1.0f);

        // EaseOutCubic
        float easeT = 1.0f - powf(1.0f - t, 3.0f);

        playertransform_.translate.x =
            titleStartX_ + (titleEndX_ - titleStartX_) * easeT;

        if (t >= 1.0f) {
            moveFinished = true;
            timer = 0.0f;
        }
    }
    if (fade->GetFadeType() != FadeType::FadeOut) {
        // ===== ä¸Šä¸‹ã®æµ®éŠ =====
        time += kFloatSpeed;
        playertransform_.translate.y = sinf(time) * kFloatAmplitude;
    }

    // ===== Transform ã‚’ Object ã«åæ˜  =====
    player_->GetPlayerObject()->SetTranslate(playertransform_.translate);
}

============================================================
File Path: project/application/scene/TitleScene.h
============================================================
#pragma once
#include<BaseScene.h>
#include<Sprite.h>
#include<Object3d.h>
#include<ParticleEmitter.h>
#include<SoundPlayer.h>
#include <Skybox.h>
#include<FadeManager.h>
#include<Titleparticle.h>
#include<Player.h>

/// <summary>
/// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³
/// ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã‚’ç®¡ç†ã™ã‚‹ã‚·ãƒ¼ãƒ³ã€‚
/// UI è¡¨ç¤ºã€ã‚¿ã‚¤ãƒˆãƒ«æ¼”å‡ºç”¨ãƒ¢ãƒ‡ãƒ«ã€ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã€ãƒ•ã‚§ãƒ¼ãƒ‰åˆ¶å¾¡ã‚’æ‹…å½“ã™ã‚‹ã€‚
/// </summary>
class TitleScene : public BaseScene {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize() override;
    /// <summary>
    /// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ ã®æ›´æ–°å‡¦ç†
    /// </summary>
    void Update() override;
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw() override;
    /// <summary>
    /// ã‚«ãƒ¡ãƒ©ã®åˆæœŸåŒ–ã‚’è¡Œã†
    /// </summary> 
    void InitializeCamera();
    /// <summary>
    /// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ã€ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿
    /// </summary>
    void LoadResources();
    /// <summary>
    /// UIã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ç”Ÿæˆã¨åˆæœŸåŒ–ã‚’è¡Œã†
    /// </summary> 
    void InitializeUI();
    /// <summary>
    /// ãƒ¢ãƒ‡ãƒ«ã®ç”Ÿæˆã¨åˆæœŸåŒ–ã‚’è¡Œã†
    /// </summary> 
    void InitializeModel();
    /// <summary>
    /// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹ãŠã‚ˆã³æ›´æ–°å‡¦ç†
    /// </summary>
    void UpdateFadeIn();
    /// <summary>
    /// å…¥åŠ›ã«å¿œã˜ãŸãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹å‡¦ç†
    /// </summary>
    void UpdateFadeOut();
    /// <summary>
    /// ãƒ•ã‚§ãƒ¼ãƒ‰å®Œäº†å¾Œã®ã‚·ãƒ¼ãƒ³é·ç§»å‡¦ç†
    /// </summary>
    void UpdateSceneTransition();
    /// <summary>
    /// ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ¼”å‡ºæ›´æ–°
    /// ãƒ»æ¨ªæ–¹å‘ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ç§»å‹•
    /// ãƒ»ä¸Šä¸‹ã®æµ®éŠã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    /// </summary>
    void UpdateTitlePlayerMotion();
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    std::unique_ptr <Sprite> ui_title_;
    std::unique_ptr <Sprite> ui_start_;
    std::vector<Sprite*> uiSprites_;

    std::unique_ptr <Player> player_;;
    // èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ 
    std::unique_ptr <Skybox> skybox_ = nullptr;
    // æ¼”å‡ºç”¨ãƒ¢ãƒ‡ãƒ«
    Transform playertransform_{};
    // ç§»å‹•åˆ¶å¾¡
    float timer;
    float moveDuration;
    bool moveFinished;
    // ç§»å‹•ç¯„å›²è¨­å®š 
    float titleStartX_;
    float titleEndX_;
    // ãƒ•ã‚§ãƒ¼ãƒ‰åˆ¶å¾¡        
    float time = 0.0f;          // çµŒéŽæ™‚é–“ 
    bool hasCheckedFade_ = false; // ãƒ•ã‚§ãƒ¼ãƒ‰å‡¦ç†æ¸ˆã¿ã‹ã©ã†ã‹

    std::unique_ptr <Titleparticle> particle_;


    static constexpr float kTitleMoveDuration = 240.0f;
    static constexpr float kFloatSpeed = 0.03f;
    static constexpr float kFloatAmplitude = 2.3f;

    // ãƒ•ã‚§ãƒ¼ãƒ‰æ¼”å‡ºç”¨
bool isPlayerBoost_ = false;
float playerSpeedX_ = 0.0f;
float playerAccelX_ = 0.15f;   // åŠ é€Ÿé‡
float playerMaxSpeedX_ = 5.0f; // ä¸Šé™ï¼ˆä»»æ„ï¼‰
};

============================================================
File Path: project/application/stage/StageManager.cpp
============================================================
#include "StageManager.h"
#include <ModelManager.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<StageManager> StageManager::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
StageManager* StageManager::GetInstance() {
    if (!instance) {
        instance = std::make_unique<StageManager>();
    }
    return instance.get();
}

// çµ‚äº†
void StageManager::Finalize() {
    instance.reset();  // `delete` ä¸è¦
    // åœ°é¢ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è§£æ”¾
    //grass.reset();
    // ãƒ‡ãƒãƒƒã‚°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¯ãƒªã‚¢
   // debugObjects_.parts();
    // ãã®ä»–ã®3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚ã‚¯ãƒªã‚¢
 //   object3ds_.parts();
}

void StageManager::Initialize() {
    // LevelLoader ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆs
    loader_ = new CharacterLoader();
    levelData_ = loader_->LoadFile("stage");  // â†ã“ã“ã§ãƒ­ãƒ¼ãƒ‰

    // æ•µãƒ¢ãƒ‡ãƒ«ã‚’ã‚ã‚‰ã‹ã˜ã‚èª­ã¿è¾¼ã‚€
   // ModelManager::GetInstance()->LoadModel("Enemy.obj");
    ModelManager::GetInstance()->LoadModel("Gameplay/Model/Tile/Tile.obj");
    
    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ
    // åœ°é¢ã®ä½œæˆ
    grass = Object3d::Create("Gameplay/Model/Tile/Tile.obj", Transform({ 1000.0f, 1.0f, 1000.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, -8.0f, 50.0f }));

    //// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èª­ã¿è¾¼ã‚€
    //for (auto& objData : levelData_->objects) {
    //    // Point_ ã§å§‹ã¾ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«åã®ã¿å¯¾è±¡
    //    if (objData.fileName.rfind("Point_", 0) == 0) {

    //        Transform tr;
    //        tr.scale = objData.scaling;
    //        tr.rotate = objData.rotation;
    //        tr.translate = objData.translation;

    //        // ãƒ¢ãƒ‡ãƒ«ã¯å›ºå®šã§ Enemy.obj ã‚’ä½¿ç”¨
    //        std::string modelName = "Enemy.obj";

    //        // Object3d ã‚’ç”Ÿæˆ
    //        auto obj = Object3d::Create(modelName, tr);
    //        debugObjects_.push_back(std::move(obj));
    //    }
    //} 

    showDebugObjects_ = false; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯éžè¡¨ç¤º
#ifdef _DEBUG
    // === ãƒ‡ãƒãƒƒã‚°å¯è¦–åŒ–ç”¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ===
    //ModelManager::GetInstance()->LoadModel("Enemy.obj"); // ç›®å°ç”¨ãƒ¢ãƒ‡ãƒ«ï¼ˆSphereã‚„Cubeãªã©ï¼‰

    //for (auto& objData : levelData_->objects) {
    //    // Point_ ã§å§‹ã¾ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ‡ãƒãƒƒã‚°å¯è¦–åŒ–å¯¾è±¡ã«ã™ã‚‹
    //    if (objData.fileName.rfind("Point_", 0) == 0) {
    //        Transform tr;
    //        tr.scale = { 0.5f, 0.5f, 0.5f }; // å°ã•ãç›®å°è¡¨ç¤º
    //        tr.rotate = objData.rotation;
    //        tr.translate = objData.translation;

    //        auto debugObj = Object3d::Create("Enemy.obj", tr);
    //        debugObjects_.push_back(std::move(debugObj));
    //    }
    //}
#endif
}

void StageManager::Update() {
#ifdef _DEBUG
    if (showDebugObjects_) {
        // å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ›´æ–°
        for (auto& obj : debugObjects_) {
            obj->Update();
        }
    }
#endif

    // åœ°é¢    
    grass->Update();

}

void StageManager::Draw() {
#ifdef _DEBUG
    if (showDebugObjects_) {
        // å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»
        for (auto& obj : debugObjects_) {
            obj->Draw();
        }
    }
#endif


    grass->Draw();
}
    
void StageManager::DebugImGui() {
#ifdef USE_IMGUI
    ImGui::Begin("Stage Debug");
    ImGui::Checkbox("Show Debug Objects", &showDebugObjects_);
    ImGui::Text("Loaded objects: %d", (int)object3ds_.size());
    ImGui::Text("Debug points: %d", (int)debugObjects_.size());
    ImGui::End();
#endif
}

============================================================
File Path: project/application/stage/StageManager.h
============================================================
#pragma once
#include <vector>
#include<BaseCharacter.h>
#include <CharacterLoader.h>

/// <summary>
/// ã‚¹ãƒ†ãƒ¼ã‚¸ãƒžãƒãƒ¼ã‚¸ãƒ£
/// </summary>
class StageManager
{
private:
    static std::unique_ptr<StageManager> instance;

    StageManager(StageManager&) = delete;
    StageManager& operator=(StageManager&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    StageManager() = default;
    ~StageManager() = default;
    // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
    static StageManager* GetInstance();
    // çµ‚äº†
    void Finalize();
    void Initialize();
    void Update();
    void Draw();
    
    void DebugImGui();

private:
    // ãƒã‚¤ãƒ³ã‚¿
    CharacterLoader* loader_ = nullptr;
    // ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
    LevelData* levelData_ = nullptr;
    // --- æœ¬ç•ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
    std::vector<std::unique_ptr<Object3d>> object3ds_;  // é€šå¸¸ã‚²ãƒ¼ãƒ ç”¨
    // --- ãƒ‡ãƒãƒƒã‚°å¯è¦–åŒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ ---
    std::vector<std::unique_ptr<Object3d>> debugObjects_; // åˆ¶å¾¡ç‚¹ãƒ»ã‚«ãƒ¼ãƒ–ãƒ»ã‚«ãƒ¡ãƒ©ä½ç½®ãªã©
    // --- ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºãƒ•ãƒ©ã‚° ---
    bool showDebugObjects_ = false; // ImGuiã§åˆ‡ã‚Šæ›¿ãˆå¯èƒ½ã«ã™ã‚‹

    // åœ°é¢
    std::unique_ptr <Object3d> grass = nullptr; 
};

============================================================
File Path: project/engine/2d/Sprite.cpp
============================================================
#include "Sprite.h"
#include"SpriteCommon.h"
#include <cassert>
#include "MatrixVector.h"
#include "TextureManager.h"
#include "SrvManager.h"
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include <ResourceFactory.h>

using namespace MatrixVector;
using namespace ResourceFactory;

void Sprite::Initialize(SpriteCommon* spriteCommon) {
	// NULLæ¤œå‡º
	assert(spriteCommon);
	// å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
	this->spriteCommon_ = spriteCommon;
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	VertexDatacreation();
	// ãƒžãƒ†ãƒªã‚¢ãƒ«ã®ç”Ÿæˆã€åˆæœŸåŒ–
	MaterialGenerate();
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã‚’ã‚¤ãƒ¡ãƒ¼ã‚¸ã«åˆã‚ã›ã‚‹
	//AdjustTextureSize();
	// WVP,Worldç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆã€åˆæœŸåŒ–
	TransformationMatrixGenerate();
}

void Sprite::VertexDatacreation() {
	// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	vertexResoruce = CreateBufferResource(spriteCommon_->GetDxCommon()->GetDevice(), sizeof(VertexData) * 4);
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã™ã‚‹
	// ãƒªã‚½ãƒ¼ã‚¹ã®å…ˆé ­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ã†
	vertexBufferView.BufferLocation = vertexResoruce->GetGPUVirtualAddress();
	// ä½¿ç”¨ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã¯4ã¤åˆ†ã®ã‚µã‚¤ã‚º
	vertexBufferView.SizeInBytes = sizeof(VertexData) * 4;
	// 1é ‚ç‚¹å½“ãŸã‚Šã®ã‚µã‚¤ã‚º
	vertexBufferView.StrideInBytes = sizeof(VertexData);
	// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
	// æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	vertexResoruce->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));

	// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	indexResource = CreateBufferResource(spriteCommon_->GetDxCommon()->GetDevice(), sizeof(uint32_t) * 6);
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã™ã‚‹
	// ãƒªã‚½ãƒ¼ã‚¹ã®å…ˆé ­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ã†
	indexBufferView.BufferLocation = indexResource->GetGPUVirtualAddress();
	// ä½¿ç”¨ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã¯6ã¤åˆ†ã®ã‚µã‚¤ã‚º
	indexBufferView.SizeInBytes = sizeof(uint32_t) * 6;
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯uint32_tã¨ã™ã‚‹
	indexBufferView.Format = DXGI_FORMAT_R32_UINT;
}


void Sprite::MaterialGenerate() {
	// ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	materialResource = CreateBufferResource(spriteCommon_->GetDxCommon()->GetDevice(), sizeof(Material));
	// Spriteç”¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));
	// ä»Šå›žã¯ç™½
	materialData->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	// Spriteã¯Lightingã—ãªã„ã§falseã‚’è¨­å®šã™ã‚‹
	materialData->endbleLighting = false;
	// å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
	materialData->uvTransform = MakeIdentity4x4();
}

void Sprite::TransformationMatrixGenerate() {
	// Spriteç”¨ã®TransformationMatrixç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹ã€‚
	transformationMatrixResource = CreateBufferResource(spriteCommon_->GetDxCommon()->GetDevice(), sizeof(TransformationMatrix));
	// ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	transformationMatrixResource->Map(0, nullptr, reinterpret_cast<void**>(&transformationMatrixData));
	// å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
	transformationMatrixData->World = MakeIdentity4x4();
	transformationMatrixData->WVP = MakeIdentity4x4();
}

void Sprite::Update() {
	
	transform.translate = { position_.x,position_.y,0.0f };
	transform.rotate = { 0.0f,0.0f,rotation_ };
	transform.scale = { size_.x,size_.y,1.0f };

	// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
	float left = 0.0f - anchorPoint.x;
	float right = 1.0f - anchorPoint.x;
	float top = 0.0f - anchorPoint.y;
	float bottom = 1.0f - anchorPoint.y;

	// ãƒ•ãƒªãƒƒãƒ—
	if (isFlipX_) {
		left = -left;
		right = -right;
	}
	if (isFlipY_) {
		top = -top;
		bottom = -bottom;
	}

	// é ‚ç‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
	vertexData[0].position = { left,bottom,0.0f,1.0f };    // å·¦ä¸‹
	vertexData[1].position = { left,top,0.0f,1.0f };    // å³ä¸Š
	vertexData[2].position = { right,bottom,0.0f,1.0f };    // å³ä¸‹
	vertexData[3].position = { right,top,0.0f,1.0f };    // å·¦ä¸Š

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç¯„å›²æŒ‡å®š
	const DirectX::TexMetadata& metadata = TextureManager::GetInstance()->GetMetaData(textureFilePath_);
	// UVåº§æ¨™ç³»ã«å¤‰æ›ã™ã‚‹
	float tex_left = textureLeftTop.x / metadata.width;
	float tex_right = (textureLeftTop.x + textureSize.x) / metadata.width;
	float tex_top = textureLeftTop.y / metadata.height;
	float tex_bottom = (textureLeftTop.y + textureSize.y) / metadata.height;

	// é ‚ç‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
	vertexData[0].texcoord = { tex_left,tex_bottom };    // å·¦ä¸‹
	vertexData[1].texcoord = { tex_left,tex_top };    // å³ä¸Š
	vertexData[2].texcoord = { tex_right,tex_bottom };    // å³ä¸‹
	vertexData[3].texcoord = { tex_right,tex_top };    // å·¦ä¸Š

	for (int i = 0; i < 4; i++) {
		vertexData[i].normal = { 0.0f,0.0f,-1.0f };
	}

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
	indexResource->Map(0, nullptr, reinterpret_cast<void**>(&indexData));
	indexData[0] = 0; indexData[1] = 1; indexData[2] = 2;
	indexData[3] = 1; indexData[4] = 3; indexData[5] = 2;

	/*--------------------------------------------*/
	/*------worldViewProjectionMatrixã‚’ä½œã‚‹--------*/
	/*--------------------------------------------*/
	Matrix4x4 worldMatrixSprite = MakeAftineMatrix(transform.scale, transform.rotate, transform.translate);
	Matrix4x4 viewMatrixSprite = MakeIdentity4x4();
	Matrix4x4 projectionMatrixSprite = MakeOrthographicMatrix(0.0f, 0.0f, float(WinApp::kClientWidth), float(WinApp::kClientHeight), 0.0f, 100.0f);
	Matrix4x4 worldViewProjectionMatrixSprite = Multiply(worldMatrixSprite, Multiply(viewMatrixSprite, projectionMatrixSprite));
	transformationMatrixData->World = worldMatrixSprite;
	transformationMatrixData->WVP = worldViewProjectionMatrixSprite;

	/*----------------------------------------*/
	/*---------UVTransformç”¨ã®è¡Œåˆ—ã‚’ä½œã‚‹--------*/
	/*----------------------------------------*/
	Matrix4x4 uvTransformMatrix = MatrixVector::MakeScaleMatrix(uvTransform.scale);
	uvTransformMatrix = MatrixVector::Multiply(uvTransformMatrix, MatrixVector::MakeRotateZMatrix(uvTransform.rotate.z));
	uvTransformMatrix = MatrixVector::Multiply(uvTransformMatrix, MatrixVector::MakeTranslateMatrix(uvTransform.translate));
	materialData->uvTransform = uvTransformMatrix;
}

void Sprite::Draw() {
	// wvpç”¨ã®CBufferã®å ´æ‰€ã‚’è¨­å®š
	spriteCommon_->GetDxCommon()->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
	spriteCommon_->GetDxCommon()->GetCommandList()->IASetIndexBuffer(&indexBufferView);//IBVã‚’è¨­å®š
	// Spriteã®æç”»ã€‚å¤‰æ›´ãŒå¿…è¦ãªã‚‚ã®ã ã‘å¤‰æ›´ã™ã‚‹
	spriteCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());
	// TransformationMatrixBufferã®å ´æ‰€ã‚’è¨­å®š
	spriteCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(1, transformationMatrixResource->GetGPUVirtualAddress());
	//// Spriteã®æç”»ã¯å¸¸ã«uvCheckerã«ã™ã‚‹
	//spriteCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2, textureSrvHandleGPU);
	// SRVã®Descriptortableã®å…ˆé ­ã‚’è¨­å®š
	spriteCommon_->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2, TextureManager::GetInstance()->GetSrvHandleGPU(textureFilePath_));
	// æç”»! (DrawCall/ãƒ‰ãƒ­ãƒ¼ã‚³ãƒ¼ãƒ«) 6å€‹ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—1ã¤ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æç”»ã€ãã®ä»–ã¯å½“é¢ï¼ã§è‰¯ã„
	spriteCommon_->GetDxCommon()->GetCommandList()->DrawIndexedInstanced(6, 1, 0, 0, 0);
}

void Sprite::SetTexture(const std::string& textureFilePath) {
	// Resources/ ã‚’ä»˜ã‘ã‚‹ï¼ˆCreateã¨åŒã˜è¦å‰‡ã«ã™ã‚‹ï¼‰
	std::string fullPath = "Resources/" + textureFilePath;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‘ã‚¹ã‚’æ›´æ–°
	this->textureFilePath_ = fullPath;

	// æ–°ã—ã„ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	uint32_t newTextureIndex = TextureManager::GetInstance()->GetSrvIndex(fullPath);
	this->textureindex = newTextureIndex;
}

void Sprite::AdjustTextureSize() {
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	const DirectX::TexMetadata& metadata = TextureManager::GetInstance()->GetMetaData(textureFilePath_);
	textureSize.x = static_cast<float>(metadata.width);
	textureSize.y = static_cast<float>(metadata.height);
	// ç”»åƒã‚µã‚¤ã‚ºã‚’ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
	size_ = textureSize;
}

std::unique_ptr<Sprite> Sprite::Create(std::string textureFilePath, Vector2 position, float rotation, Vector2 size) {
	std::unique_ptr<Sprite> sprite = std::make_unique<Sprite>();
	sprite->Initialize(SpriteCommon::GetInstance());
	// å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
	sprite->textureFilePath_ = "Resources/" + textureFilePath;
	// å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
	sprite->textureindex = TextureManager::GetInstance()->GetSrvIndex(sprite->textureFilePath_);
	sprite->position_ = position;
	sprite->rotation_ = rotation;
	sprite->size_ = size;
	sprite->SetTextureSize(size);
	// Transformã®åˆæœŸåŒ–
	sprite->transform.translate = { sprite->position_.x,sprite->position_.y,0.0f };
	sprite->transform.rotate = { 0.0f,0.0f,sprite->rotation_ };
	sprite->transform.scale = { sprite->size_.x,sprite->size_.y,1.0f };
	return sprite;
}

void Sprite::DrawImGui() {
#ifdef USE_IMGUI
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã‚’æŒ‡å®š
	ImGui::Begin("Sprite");
	// åº§æ¨™
	ImGui::SliderFloat2("position", &position_.x, 0.0f, 1280.0f, "%.01f");
	// å›žè»¢
	ImGui::SliderFloat("rotation", &rotation_, -6.2f, 6.2f, "%.01f");
	// ã‚µã‚¤ã‚º
	ImGui::SliderFloat2("size", &size_.x, 0.0f, 1000.0f, "%.01f");
	// ã‚«ãƒ©ãƒ¼
	ImGui::ColorEdit4("color", reinterpret_cast<float*>(&materialData->color));
	// UVåº§æ¨™ã®å¤‰æ›´
	ImGui::DragFloat2("UVTranslate", &uvTransform.translate.x, 0.01f, -10.0f, 10.0f);
	// UVã®å¤§ãã•ã®å¤‰æ›´
	ImGui::DragFloat2("UVScale", &uvTransform.scale.x, 0.01f, -10.0f, 10.0f);
	// UVã®å›žè»¢ã®å¤‰æ›´
	ImGui::SliderAngle("UVRotate", &uvTransform.rotate.z);
	ImGui::End();
#endif // USE_IMGUI
}

============================================================
File Path: project/engine/2d/Sprite.h
============================================================
#pragma once
#include"Transform.h"
#include"Vector2.h"
#include"Vector3.h"
#include"Vector4.h"
#include "Matrix4x4.h"
#include<wrl.h>
#include<d3d12.h>
#include<cstdint>
#include<fstream>
#include<Vertex.h>
#include<Material.h>

class SpriteCommon;

class Sprite
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°	
	// åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿
	struct TransformationMatrix {
		Matrix4x4 WVP;
		Matrix4x4 World;
	};

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// åˆæœŸåŒ–
	void Initialize(SpriteCommon* spriteCommon);
	// æ›´æ–°å‡¦ç†
	void Update();
	// æç”»å‡¦ç†
	void Draw();

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆä½œæˆé–¢æ•°
	static std::unique_ptr<Sprite> Create(std::string textureFilePath, Vector2 position, float rotation, Vector2 size);

	// ImGuiã®æ›´æ–°
	void DrawImGui();

private:
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ä½œæˆ	
	void VertexDatacreation();
	// ãƒªã‚½ãƒ¼ã‚¹
	// ãƒžãƒ†ãƒªã‚¢ãƒ«
	void MaterialGenerate();
	// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ãƒžãƒˆãƒªãƒƒã‚¯ã‚¹
	void TransformationMatrixGenerate();
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã‚’ã‚¤ãƒ¡ãƒ¼ã‚¸ã«åˆã‚ã›ã‚‹
	void AdjustTextureSize();
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒã‚¤ãƒ³ã‚¿
	SpriteCommon* spriteCommon_ = nullptr;
	// ä½¿ç”¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«
	std::string textureFilePath_;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> vertexResoruce;
	Microsoft::WRL::ComPtr <ID3D12Resource> indexResource;
	Microsoft::WRL::ComPtr <ID3D12Resource> materialResource;
	Microsoft::WRL::ComPtr <ID3D12Resource> transformationMatrixResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexData* vertexData = nullptr;
	uint32_t* indexData = nullptr;
	Material* materialData = nullptr;
	TransformationMatrix* transformationMatrixData = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ä½¿ã„é“ã‚’è£œè¶³ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView;
	D3D12_INDEX_BUFFER_VIEW indexBufferView;

	// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
	Transform transform{ {1.0f,1.0f,1.0f},{0.0f,0.0f,0.0f},{0.0f,0.0f,0.0f} };
	Transform  uvTransform{ {1.0f,1.0f,1.0f},{0.0f,0.0f,0.0f},{0.0f,0.0f,0.0f} };

	Vector2 position_{};
	float rotation_;
	Vector2 size_{};

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·
	uint32_t textureindex = 0;
	// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
	Vector2 anchorPoint = { 0.0f,0.0f };
	// å·¦å³ãƒ•ãƒªãƒƒãƒ—
	bool isFlipX_ = false;
	// ä¸Šä¸‹ãƒ•ãƒªãƒƒãƒ—
	bool isFlipY_ = false;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™
	Vector2 textureLeftTop = { 0.0f,0.0f };
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
	Vector2 textureSize = { 640.0f,640.0f };
public:
	// getter
	const Vector2& GetPosition() const { return position_; }
	float GetRotation() const { return rotation_; }
	const Vector4& GetColor() const { return materialData->color; }
	const Vector2& GetSize()const { return size_; }
	const Vector2& GetAnchorPoint()const { return anchorPoint; }
	const bool& GetisFlipX()const { return isFlipX_; }
	const bool& GetisFlipY()const { return isFlipY_; }
	const Vector2& GetTextureLeftTop()const { return textureLeftTop; }
	const Vector2& GetTextureSize()const { return textureSize; }
	// setter
	void SetPosition(const Vector2& position) { this->position_ = position; }
	void SetRotation(float rotation) { this->rotation_ = rotation; }
	void SetColor(const Vector4& color) { materialData->color = color; }
	void SetSize(const Vector2& size) { this->size_ = size; }
	void SetTexture(const std::string& textureFilePath);
	void SetAnchorPoint(const Vector2& anchorPoint) { this->anchorPoint = anchorPoint; }
	void SetisFlipX(const bool& isFlipX) { this->isFlipX_ = isFlipX; }
	void SetisFlipY(const bool& isFlipY) { this->isFlipY_ = isFlipY; }
	void SetTextureLeftTop(const Vector2& textureLeftTop) { this->textureLeftTop = textureLeftTop; }
	void SetTextureSize(const Vector2& textureSize) { this->textureSize = textureSize; }
};

============================================================
File Path: project/engine/2d/SpriteCommon.cpp
============================================================
#include "SpriteCommon.h"
#include <Logger.h>
#include <StringUtility.h>
#include <ShaderCompiler.h>
#include<DsvManager.h>

using namespace Microsoft::WRL;

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<SpriteCommon> SpriteCommon::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
SpriteCommon* SpriteCommon::GetInstance() {
    if (!instance) {
        instance = std::make_unique<SpriteCommon>();
    }
    return instance.get();
}

// çµ‚äº†
void SpriteCommon::Finalize() {
    instance.reset();  // `delete` ä¸è¦
}

void SpriteCommon::Initialize(DirectXCommon* dxCommon,DsvManager* dsvManager) {
    assert(dxCommon); 
    assert(dsvManager);
    // å¼•æ•°ã‚’å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
    dxCommon_ = dxCommon;
    dsvManager_ = dsvManager;
    // ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
    GraphicsPipelineGenerate();
}

void SpriteCommon::Commondrawing() {
    // RootSignatureã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‘ã©åˆ¥é€”è¨­å®šãŒå¿…è¦
    dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
    dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
    // å½¢çŠ¶ã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã¯ã¾ãŸåˆ¥ã€‚åŒã˜ã‚‚ã®ã‚’è¨­å®šã™ã‚‹
    dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

void SpriteCommon::RootSignatureGenerate() {
    HRESULT hr;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------DescriptorRangeä½œæˆ-------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
    descriptorRange[0].BaseShaderRegister = 0;
    descriptorRange[0].NumDescriptors = 1;
    descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
    descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------RootParameterä½œæˆ---------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_ROOT_PARAMETER rootParameters[4] = {};
    rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;// PixelShaderã§ä½¿ã†
    rootParameters[0].Descriptor.ShaderRegister = 0;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†

    rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;// VertexShaderã§ã‚’ä½¿ã†
    rootParameters[1].Descriptor.ShaderRegister = 0;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†

    rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;//DescriptorTableã‚’ä½¿ã†
    rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
    rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRange;//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
    rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange);//åˆ©ç”¨ã™ã‚‹æ•°

    rootParameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;// PixelShaderã§ä½¿ã†
    rootParameters[3].Descriptor.ShaderRegister = 1;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·1ã‚’ä½¿ã†

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------RootSignatureä½œæˆ---------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
    descriptionRootSignature.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
    descriptionRootSignature.pParameters = rootParameters;// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
    descriptionRootSignature.NumParameters = _countof(rootParameters);// é…åˆ—ã®é•·ã•

    /*----------------------------------------------------------------------------------*/
    /*-----------------------------------Samplerã®è¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
    staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;//ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿	
    staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//0ï½ž1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ		
    staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;//æ¯”è¼ƒã—ãªã„		
    staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;//ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†	
    staticSamplers[0].ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼ã‚’ä½¿ã†
    staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
    descriptionRootSignature.pStaticSamplers = staticSamplers;
    descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

    /*----------------------------------------------------------------------------------*/
    /*-------------------------ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã«ã™ã‚‹--------------------------------*/
    /*----------------------------------------------------------------------------------*/
    ComPtr <ID3DBlob> signatureBlob = nullptr;
    ComPtr <ID3DBlob> errorBlob = nullptr;
    hr = D3D12SerializeRootSignature(&descriptionRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
    if (FAILED(hr)) {
        Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
        assert(false);
    }
    //ãƒã‚¤ãƒŠãƒªã‚’å…ƒã«ä½œæˆ
    hr = dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
    assert(SUCCEEDED(hr));
}

void SpriteCommon::GraphicsPipelineGenerate() {
    // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
    RootSignatureGenerate();
    HRESULT hr;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------InputLayoutè¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_INPUT_ELEMENT_DESC inputElementDescs[3] = {};
    inputElementDescs[0].SemanticName = "POSITION";
    inputElementDescs[0].SemanticIndex = 0;
    inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
    inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    inputElementDescs[1].SemanticName = "TEXCOORD";
    inputElementDescs[1].SemanticIndex = 0;
    inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
    inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    inputElementDescs[2].SemanticName = "NORMAL";
    inputElementDescs[2].SemanticIndex = 0;
    inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
    inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    D3D12_INPUT_LAYOUT_DESC inputLayoutDesc{};
    inputLayoutDesc.pInputElementDescs = inputElementDescs;
    inputLayoutDesc.NumElements = _countof(inputElementDescs);

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------BlendStateã®è¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_BLEND_DESC blendDesc{};
    //å…¨ã¦ã®è‰²è¦ç´ ã‚’æ›¸ãè¾¼ã‚€
    blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
    blendDesc.RenderTarget[0].BlendEnable = TRUE;
    blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
    blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
    blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
    blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;           // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;         // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_INV_SRC_ALPHA;         // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// åŠ ç®—åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;       // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;           // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ONE;            // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// æ¸›ç®—åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;         // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;    // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;              // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// ä¹—ç®—åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;           // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;         // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_SRC_COLOR;    // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_INV_DEST_COLOR;    // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;             // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;              // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //===== RasterizerStateã®è¨­å®šã‚’è¡Œã† ======//   
    D3D12_RASTERIZER_DESC rasterizerDesc{};
    //è£é¢(æ™‚è¨ˆå›žã‚Š)ã‚’è¡¨ç¤ºã—ãªã„
    rasterizerDesc.CullMode = D3D12_CULL_MODE_BACK;
    //ä¸‰è§’å½¢ã®ä¸­ã‚’å¡—ã‚Šã¤ã¶ã™
    rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

    /*----------------------------------------------------------------------------------*/
    /*--------------------------------Shaderã‚’Compile-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    ComPtr <IDxcBlob> vertexShaderBlob = ShaderCompiler::GetInstance()->CompileShader(L"Resources/shaders/Sprite/Sprite.VS.hlsl", L"vs_6_0");
    assert(vertexShaderBlob != nullptr);
    ComPtr <IDxcBlob> pixelShaderBlob = ShaderCompiler::GetInstance()->CompileShader(L"Resources/shaders/Sprite/Sprite.PS.hlsl", L"ps_6_0");
    assert(pixelShaderBlob != nullptr);

    /*-----------------------------------------------------------------------------------*/
    /*-------------------------------------PSOç”Ÿæˆ----------------------------------------*/
    /*-----------------------------------------------------------------------------------*/
    D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
    graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();   // RootSignature
    graphicsPipelineStateDesc.InputLayout = inputLayoutDesc;    // InputLayout
    graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };  // VertexShader
    graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };    // PixelShader
    graphicsPipelineStateDesc.BlendState = blendDesc;// BlendState
    graphicsPipelineStateDesc.RasterizerState = rasterizerDesc; //RasterizerState
    // æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
    graphicsPipelineStateDesc.NumRenderTargets = 1;
    graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
    //åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸(å½¢çŠ¶)ã®ã‚¿ã‚¤ãƒ—
    graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
    // ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã‹ã®è¨­å®š(æ°—ã«ã—ãªãã¦è‰¯ã„)
    graphicsPipelineStateDesc.SampleDesc.Count = 1;
    graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
    // DepthStencilã®è¨­å®š
    // DSVManager ã‹ã‚‰å–å¾—ã—ãŸè¨­å®šã‚’ã‚³ãƒ”ãƒ¼
    D3D12_DEPTH_STENCIL_DESC spriteDepthStencilDesc = dsvManager_->GetDepthStencilDesc();
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã¯æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã«æ›¸ãè¾¼ã¾ãªã„ï¼ˆé€éŽè¡¨ç¤ºç”¨ï¼‰ 
    spriteDepthStencilDesc.DepthEnable = FALSE;
    spriteDepthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
    spriteDepthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_ALWAYS;
    spriteDepthStencilDesc.StencilEnable = FALSE;

    graphicsPipelineStateDesc.DepthStencilState = spriteDepthStencilDesc;
    graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;

    // å®Ÿéš›ã«ç”Ÿæˆ
    hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));
    assert(SUCCEEDED(hr));
}


============================================================
File Path: project/engine/2d/SpriteCommon.h
============================================================
#pragma once
#include"DirectXCommon.h"

class DsvManager;

// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šéƒ¨
class SpriteCommon {
private:
	static std::unique_ptr<SpriteCommon> instance;

	SpriteCommon(SpriteCommon&) = delete;
	SpriteCommon& operator=(SpriteCommon&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	SpriteCommon() = default;
	~SpriteCommon() = default;

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static SpriteCommon* GetInstance();
	// çµ‚äº†
	void Finalize();
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* dxCommon,DsvManager* dsvManager);
	// å…±é€šæç”»è¨­å®š
	void Commondrawing();

private:
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	void RootSignatureGenerate();
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	void GraphicsPipelineGenerate();
private:
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_;
	DsvManager* dsvManager_;
	// RootSignature
	Microsoft::WRL::ComPtr <ID3D12RootSignature> rootSignature = nullptr;
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
public:
	// gettre
	DirectXCommon* GetDxCommon() const { return  dxCommon_; }
};

============================================================
File Path: project/engine/3d/Model.cpp
============================================================
#include "Model.h"
#include "Object3d.h"
#include "MatrixVector.h"
#include "TextureManager.h"
#include <ResourceFactory.h>
#include<assimp/Importer.hpp>
#include<assimp/scene.h>
#include<assimp/postprocess.h>

using namespace MatrixVector;
using namespace ResourceFactory;

void Model::Initialize(ModelCommon* modelCommon, const std::string& directorypath, const std::string& filename) {
    // NULLæ¤œå‡º
    assert(modelCommon);
    // å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
    this->modelCommon = modelCommon;
    
    // æ‹¡å¼µå­ã‚’å–å¾—ã—ã¦å°æ–‡å­—åŒ–
    std::string extension = filename.substr(filename.find_last_of('.') + 1);
    std::transform(extension.begin(), extension.end(), extension.begin(), ::tolower);

    // ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨
    bool isGLTF = false;

    // æ‹¡å¼µå­ã§åˆ†å²
    if (extension == "obj") {
        modelDate = LoadObjFile(directorypath, filename);
    }
    else if (extension == "gltf" || extension == "glb") {
        glTFModelData gltfData = LoadModelFile(directorypath, filename);

        // glTFãƒ¢ãƒ‡ãƒ«ã‚’ModelDateã«å¤‰æ›ã—ã¦çµ±ä¸€ï¼ˆæç”»ã‚³ãƒ¼ãƒ‰ã®å…±é€šåŒ–ï¼‰
        modelDate.vertices = gltfData.vertices;
        modelDate.material = gltfData.material;
        isGLTF = true;
    }
    else {
        assert(false && "Unsupported model format (only .obj, .gltf, .glb are supported)");
    }

    // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
  //  modelDate = LoadObjFile(directorypath, filename);

    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
    VertexDatacreation();
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ã®ç”Ÿæˆã€åˆæœŸåŒ–
    MaterialGenerate();

    // .objã®å‚ç…§ã—ã¦ã„ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
    TextureManager::GetInstance()->LoadTexture(modelDate.material.textureFilePath);
    // èª­ã¿è¾¼ã‚“ã ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç•ªå·ã‚’å–å¾—
    modelDate.material.textureindex = TextureManager::GetInstance()->GetSrvIndex(modelDate.material.textureFilePath);
}

void Model::Draw() {
    // VertexBufferViewã®è¨­å®š
    modelCommon->GetDxCommon()->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
    // ãƒžãƒ†ãƒªã‚¢ãƒ«CBufferã®å ´æ‰€ã‚’è¨­å®š
    modelCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());
    //SRVã®Descriptortableã®å…ˆé ­ã‚’è¨­å®šã€‚ï¼’ã¯rootParameter[2]ã§ã‚ã‚‹ã€‚
    //SRVã‚’åˆ‡ã‚Šæ›¿ãˆã¦ç”»åƒã‚’å¤‰ãˆã‚‹S
    modelCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2, TextureManager::GetInstance()->GetSrvHandleGPU(modelDate.material.textureFilePath));

    // æç”»ï¼(ä»Šå›žã¯çƒ)
    modelCommon->GetDxCommon()->GetCommandList()->DrawInstanced(UINT(modelDate.vertices.size()), 1, 0, 0);
}

void Model::VertexDatacreation() {

    // é–¢æ•°åŒ–ã—ãŸResouceã§ä½œæˆ
    vertexResoruce = CreateBufferResource(modelCommon->GetDxCommon()->GetDevice(), sizeof(VertexData) * modelDate.vertices.size());

    //é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã™ã‚‹
    // ãƒªã‚½ãƒ¼ã‚¹ã®å…ˆé ­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ã†
    vertexBufferView.BufferLocation = vertexResoruce->GetGPUVirtualAddress();
    // ä½¿ç”¨ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã¯ã®é ‚ç‚¹ã®ã‚µã‚¤ã‚º
    vertexBufferView.SizeInBytes = UINT(sizeof(VertexData) * modelDate.vertices.size());
    // 1é ‚ç‚¹å½“ãŸã‚Šã®ã‚µã‚¤ã‚º
    vertexBufferView.StrideInBytes = sizeof(VertexData);

    // é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    vertexResoruce->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚½ãƒ¼ã‚¹ã«ã‚³ãƒ”ãƒ¼
    std::memcpy(vertexData, modelDate.vertices.data(), sizeof(VertexData) * modelDate.vertices.size());
}

void Model::MaterialGenerate() {
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹
    materialResource = CreateBufferResource(modelCommon->GetDxCommon()->GetDevice(), sizeof(Material));
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ç”¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸå€¤ã‚’æ›¸ãè¾¼ã‚€
    materialData->color = { 1.0f, 1.0f, 1.0f, 1.0f };
    // Spriteã¯Lightingã—ãªã„ã§falseã‚’è¨­å®šã™ã‚‹
    materialData->endbleLighting = true;
    // å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
    materialData->uvTransform = MakeIdentity4x4();
    // å…‰æ²¢åº¦ã‚’æ›¸ãè¾¼ã‚€
    materialData->shinimess = 70;
}


MaterialDate Model::LoadMaterialTemplateFile(const std::string& directoryPath, const std::string& filename) {
    // 1. ä¸­ã§å¿…è¦ã¨ãªã‚‹å¤‰æ•°ã®å®£è¨€
    MaterialDate materialDate; // æ§‹ç¯‰ã™ã‚‹MaterialDate
    std::string line; // ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã‚“ã 1è¡Œã‚’æ ¼ç´ã™ã‚‹ã‚‚ã®
    std::ifstream file(directoryPath + "/" + filename); // 2.ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
    assert(file.is_open()); // ã¨ã‚Šã‚ãˆãšé–‹ã‘ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹
    // 3. å®Ÿéš›ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿ã€MaterialDateã‚’æ§‹ç¯‰ã—ã¦ã„ã
    while (std::getline(file, line)) {
        std::string identifier;
        std::istringstream s(line);
        s >> identifier;

        // identifierã®å¿œã˜ãŸå‡¦ç†
        if (identifier == "map_Kd") {
            std::string textureFilename;
            s >> textureFilename;
            // é€£çµã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã«ã™ã‚‹
            materialDate.textureFilePath = directoryPath + "/" + textureFilename;
        }
    }
    return materialDate;
}

ModelDate Model::LoadObjFile(const std::string& directoryPath, const std::string& filename) {
    // 1. ä¸­ã§å¿…è¦ã¨ãªã‚‹å¤‰æ•°ã®å®£è¨€
    ModelDate modelDate; // æ§‹ç¯‰ã™ã‚‹ModelDate
    // 2. Assimpã§ã®èª­ã¿è¾¼ã¿
    Assimp::Importer importer;
    std::string filePath(directoryPath + "/" + filename); // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
    const aiScene* scene = importer.ReadFile(filePath.c_str(), aiProcess_Triangulate | aiProcess_FlipUVs);
	assert(scene->HasMeshes()); // ãƒ¡ãƒƒã‚·ãƒ¥ãŒãªã„ã®ã¯å¯¾å¿œã—ãªã„

    // 3. Meshã‚’è§£æžã™ã‚‹
    for (size_t meshIndex = 0; meshIndex < scene->mNumMeshes; ++meshIndex) {
        aiMesh* mesh = scene->mMeshes[meshIndex];
        assert(mesh->HasNormals()); // æ³•ç·šãŒãªã„Meshã¯ä»Šå›žã¯éžå¯¾å¿œ
        assert(mesh->HasTextureCoords(0)); // TexcoordãŒãªã„Meshã¯ä»Šå›žã¯éžå¯¾å¿œ
        // Meshã®ä¸­èº«(Face)ã‚’è§£æžã—ã¦ã„ã
        for (size_t faceIndex = 0; faceIndex < mesh->mNumFaces; ++faceIndex) {
            aiFace& face = mesh->mFaces[faceIndex];
            assert(face.mNumIndices == 3); // ä¸‰è§’å½¢ã®ã¿ã‚µãƒãƒ¼ãƒˆ
            // Faceã®ä¸­èº«(Vertex)ã‚’è§£æžã—ã¦ã„ã
            for (size_t elememt = 0; elememt < face.mNumIndices; ++elememt) {
                uint32_t vertexIndex = face.mIndices[elememt];
                // é ‚ç‚¹ã®å„è¦ç´ ã‚’å–å¾—
                aiVector3D& position = mesh->mVertices[vertexIndex];
                aiVector3D& normal = mesh->mNormals[vertexIndex];
                aiVector3D& texcoord = mesh->mTextureCoords[0][vertexIndex];
                // 1é ‚ç‚¹åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰ã—ã¦ModelDateã«è¿½åŠ ã—ã¦ã„ã
                VertexData vertex;
                vertex.position = { -position.x,position.y,position.z,1.0f };// ä½ç½®ã®xæˆåˆ†ã‚’åè»¢
                vertex.normal = { -normal.x,normal.y,normal.z };// æ³•ç·šã®xæˆåˆ†ã‚’åè»¢
                vertex.texcoord = { texcoord.x,texcoord.y };// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ã®yæˆåˆ†ã‚’åè»¢
				// aiProcess_MakeLeftHandedã¯z*=-1ã§ã€å³æ‰‹->å·¦æ‰‹ã«å¤‰æ›ã™ã‚‹ã®ã§æ‰‹å‹•ã§å¯¾å‡¦
                vertex.position.x *= -1.0f;
                vertex.normal.x *= -1.0f;
                modelDate.vertices.push_back(vertex);
            }
        }
    }

    // 4. Materialã®è§£æž
    for (size_t materialIndex = 0; materialIndex < scene->mNumMaterials; ++materialIndex) {
		aiMaterial* material = scene->mMaterials[materialIndex];
        if (material->GetTextureCount(aiTextureType_DIFFUSE) != 0) {
            aiString textureFilePath;
			material->GetTexture(aiTextureType_DIFFUSE, 0, &textureFilePath);
			modelDate.material.textureFilePath = directoryPath + "/" + textureFilePath.C_Str();
		}  
    }
    
    // 5. ModelDateã‚’è¿”ã™
    return modelDate;
}

Node Model::ReadNode(aiNode* node) {
    Node result;
    aiMatrix4x4 aiLocalMatrix = node->mTransformation; // nodeã®localMatrixã‚’å–å¾—
    aiLocalMatrix.Transpose(); // åˆ—ãƒ™ã‚¯ãƒˆãƒ«å½¢å¼ã‚’è¡Œãƒ™ã‚¯ãƒˆãƒ«å½¢å¼ã«è»¢ç½®
    result.localMatrix.m[0][0] = aiLocalMatrix[0][0]; result.localMatrix.m[0][1] = aiLocalMatrix[0][1]; result.localMatrix.m[0][2] = aiLocalMatrix[0][2]; result.localMatrix.m[0][3] = aiLocalMatrix[0][3];
    result.localMatrix.m[1][0] = aiLocalMatrix[1][0]; result.localMatrix.m[1][1] = aiLocalMatrix[1][1]; result.localMatrix.m[1][2] = aiLocalMatrix[1][2]; result.localMatrix.m[1][3] = aiLocalMatrix[1][3];
    result.localMatrix.m[2][0] = aiLocalMatrix[2][0]; result.localMatrix.m[2][1] = aiLocalMatrix[2][1]; result.localMatrix.m[2][2] = aiLocalMatrix[2][2]; result.localMatrix.m[2][3] = aiLocalMatrix[2][3];
    result.localMatrix.m[3][0] = aiLocalMatrix[3][0]; result.localMatrix.m[3][1] = aiLocalMatrix[3][1]; result.localMatrix.m[3][2] = aiLocalMatrix[3][2]; result.localMatrix.m[3][3] = aiLocalMatrix[3][3];
    result.name = node->mName.C_Str(); // Nodeåã‚’æ ¼ç´
    result.children.resize(node->mNumChildren); // å­ä¾›ã®æ•°ã ã‘ç¢ºä¿
    for (uint32_t childIndex = 0; childIndex < node->mNumChildren; ++childIndex) {
        // å†å¸°çš„ã«èª­ã‚“ã§éšŽå±¤æ§‹é€ ã‚’ä½œã£ã¦ã„ã
        result.children[childIndex] = ReadNode(node->mChildren[childIndex]);
    }
    return result;
}

glTFModelData Model::LoadModelFile(const std::string& directoryPath, const std::string& filename) {
    glTFModelData modelData; // æ§‹ç¯‰ã™ã‚‹ModelDate
    Assimp::Importer importer;
    std::string filePath = directoryPath + "/" + filename;
    const aiScene* scene = importer.ReadFile(filePath.c_str(), aiProcess_FlipWindingOrder | aiProcess_FlipUVs);
    assert(scene->HasMeshes()); // ãƒ¡ãƒƒã‚·ãƒ¥ãŒãªã„ã®ã¯å¯¾å¿œã—ãªã„
    // meshã‚’è§£æžã™ã‚‹
    for (uint32_t meshIndex = 0; meshIndex < scene->mNumMeshes; ++meshIndex) {
        aiMesh* mesh = scene->mMeshes[meshIndex];
        assert(mesh->HasNormals()); // æ³•ç·šãŒãªã„Meshã¯ä»Šå›žã¯éžå¯¾å¿œ
        assert(mesh->HasTextureCoords(0)); // TexcoordãŒãªã„Meshã¯ä»Šå›žã¯éžå¯¾å¿œ
        // ã“ã“ã‹ã‚‰Meshã®ä¸­èº«(Face)ã®è§£æžã‚’è¡Œã£ã¦ã„ã
        for (uint32_t faceIndex = 0; faceIndex < mesh->mNumFaces; ++faceIndex) {
            aiFace face = mesh->mFaces[faceIndex];
            //  ã“ã“ã‹ã‚‰Faceã®ä¸­èº«(Vertex)ã®è§£æžã‚’è¡Œã£ã¦ã„ã

            for (uint32_t element = 0; element < face.mNumIndices; ++element) {
                uint32_t vertexIndex = face.mIndices[element];
                aiVector3D& position = mesh->mVertices[vertexIndex];
                aiVector3D& normal = mesh->mNormals[vertexIndex];
                aiVector3D& texcoord = mesh->mTextureCoords[0][vertexIndex];
                VertexData vertex;
                vertex.position = { position.x,position.y,position.z,1.0f };
                vertex.normal = { normal.x,normal.y,normal.z };
                vertex.texcoord = { texcoord.x,texcoord.y };
                // aiProcess_MakeLeftHandedã¯z*=-1ã§ã€å³æ‰‹->å·¦æ‰‹ã«å¤‰åŒ–ã™ã‚‹ã®ã§æ‰‹å‹•ã§å¯¾å‡¦
                vertex.position.x *= -1.0f;
                vertex.normal.x *= -1.0f;
                modelData.vertices.push_back(vertex);
            }
        }
    }

    for (uint32_t materialIndex = 0; materialIndex < scene->mNumMaterials; ++materialIndex) {
        aiMaterial* material = scene->mMaterials[materialIndex];
        if (material->GetTextureCount(aiTextureType_DIFFUSE) != 0) {
            aiString textureFilePath;
            material->GetTexture(aiTextureType_DIFFUSE, 0, &textureFilePath);
            modelData.material.textureFilePath = directoryPath + "/" + textureFilePath.C_Str();
        }
    }

    modelData.rootNode = ReadNode(scene->mRootNode);
    return modelData;
}

============================================================
File Path: project/engine/3d/Model.h
============================================================
#pragma once
#include"ModelCommon.h"
#include"Transform.h"
#include"Vector2.h"
#include"Vector4.h"
#include "Matrix4x4.h"
#include<d3d12.h>
#include<wrl.h>
#include<cstdint>
#include<fstream>
#include<string>
#include<vector>
#include<Vertex.h>
#include<Material.h>
#include<MaterialDate.h>
#include<ModelDate.h>
#include <assimp/mesh.h>

struct Node {
    Matrix4x4 localMatrix;
    std::string name;
    std::vector<Node> children;
};

struct glTFModelData {
    std::vector<VertexData> vertices;
    MaterialDate material;
    Node rootNode;
};

class Model
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// åˆæœŸåŒ–
	void Initialize(ModelCommon* modelCommon, const std::string& directorypath, const std::string& filename);
	// æç”»å‡¦ç†
	void Draw();

	// .mtlãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿å–ã‚Š
	static MaterialDate LoadMaterialTemplateFile(const std::string& directoryPath, const std::string& filename);
	// .objãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿å–ã‚Š
	static ModelDate LoadObjFile(const std::string& directoryPath, const std::string& filename);

	// å†å¸°çš„ã«ãƒŽãƒ¼ãƒ‰ã‚’èª­ã¿å–ã‚‹
	Node ReadNode(aiNode* node);	
	// .gltfãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿å–ã‚Š
	glTFModelData LoadModelFile(const std::string& directoryPath, const std::string& filename);
private:
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ä½œæˆ
	void VertexDatacreation();
	// ãƒªã‚½ãƒ¼ã‚¹
	// ãƒžãƒ†ãƒªã‚¢ãƒ«
	void MaterialGenerate();
private:
	// ãƒã‚¤ãƒ³ã‚¿
	ModelCommon* modelCommon = nullptr;
	// Objãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ãƒ¼ã‚¿
	ModelDate modelDate;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> vertexResoruce;
	Microsoft::WRL::ComPtr <ID3D12Resource> materialResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ä½¿ã„é“ã‚’è£œè¶³ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexData* vertexData = nullptr;
	Material* materialData = nullptr;
public:
	// getter

	Material* GetMaterialData() { return materialData; }
	
	void SetMaterialData(Vector4 color) { materialData->color = color; }
void SetMaterial(Material* material) {
    if (materialData) delete materialData; // æ—¢å­˜ã®è§£æ”¾
    materialData = material;
}

	// materialDataã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ç‹¬ç«‹ã•ã›ã‚‹
	std::unique_ptr<Material> CloneMaterial() const {
		if (materialData) {
			return std::make_unique<Material>(*materialData);
		}
		return nullptr;
	}
};

============================================================
File Path: project/engine/3d/ModelCommon.cpp
============================================================
#include "ModelCommon.h"

void ModelCommon::Initialize(DirectXCommon* dxCommon) {
    // NULLæ¤œå‡º
    assert(dxCommon);
    // å¼•æ•°ã‚’å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
    dxCommon_ = dxCommon;
}

============================================================
File Path: project/engine/3d/ModelCommon.h
============================================================
#pragma once
#include"DirectXCommon.h"

// 3Dãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨
class ModelCommon
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* dxCommon);

private:
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_;
public:
	// getter
	DirectXCommon* GetDxCommon()  { return  dxCommon_; }
};

============================================================
File Path: project/engine/3d/Object3d.cpp
============================================================
#include "Object3d.h"
#include "Object3dCommon.h"
#include<fstream>
#include<sstream>
#include <cassert>
#include "MatrixVector.h"
#include "ModelManager.h"
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include <numbers>
#include <CameraManager.h>
#include <ResourceFactory.h>

using namespace MatrixVector;
using namespace ResourceFactory;

Vector3 Object3d::GetWorldPosition() const {
    Matrix4x4 worldMatrix = MatrixVector::MakeAffineMatrix(
        transform_.scale, transform_.rotate, transform_.translate
    );

    Vector3 worldPos = {
        worldMatrix.m[3][0],
        worldMatrix.m[3][1],
        worldMatrix.m[3][2]
    };

    return worldPos;
}

void Object3d::Initialize(Object3dCommon* object3dCommon) {
    // NULLæ¤œå‡º
    assert(object3dCommon);
    // å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
    this->object3dCommon = object3dCommon;
    this->camera = object3dCommon->GetDefaultCamera();
    // WVP,Worldç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆã€åˆæœŸåŒ–
    TransformationMatrixGenerate();
    // ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆã€åˆæœŸåŒ–
    CameraForGPUGenerate();
}

void Object3d::Update() {
    // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®ä½œæˆ
    Matrix4x4 worldMatrix = MakeAftineMatrix(transform_.scale, transform_.rotate, transform_.translate);
    // ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒ»ãƒ“ãƒ¥ãƒ¼ãƒ»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—
    Matrix4x4 worldViewProjectionMatrix;
    // ã‚«ãƒ¡ãƒ©ã‚’ CameraManager çµŒç”±ã§å–å¾—
    Camera* activeCamera = CameraManager::GetInstance()->GetActiveCamera();
    if (activeCamera) {
        const Matrix4x4& viewProjectionMatrix = activeCamera->GetViewProjectionMatrix();
        worldViewProjectionMatrix = Multiply(worldMatrix, viewProjectionMatrix);

        // ã‚«ãƒ¡ãƒ©ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’GPUç”¨ã«æ¸¡ã™
        cameraForGPUData->worldPosition = activeCamera->GetTranslate();
    } else {
        worldViewProjectionMatrix = worldMatrix;
        // ã‚«ãƒ¡ãƒ©ãŒãªã„å ´åˆã‚‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ã«ã—ã¦ãŠã
        cameraForGPUData->worldPosition = { 0.0f, 0.0f, -1000.0f };
    }

    transformationMatrixData->WVP = worldViewProjectionMatrix;
    transformationMatrixData->World = worldMatrix;
    // WorldInverseTransposeè¡Œåˆ—ã‚’å†è¨ˆç®—
    transformationMatrixData->WorldInverseTranspose = InverseTranspose(worldMatrix);
}

void Object3d::Draw() {
    // åº§æ¨™å¤‰åŒ–è¡Œåˆ—CBufferã®å ´æ‰€ã‚’è¨­å®š
    object3dCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(1, transformationMatrixResource->GetGPUVirtualAddress());

    // ã‚«ãƒ¡ãƒ©ã®å ´æ‰€ã‚’è¨­å®š 
    object3dCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(4, cameraResource->GetGPUVirtualAddress());

    // 3Dãƒ¢ãƒ‡ãƒ«ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã‚Œã°æç”»ã™ã‚‹
    if (model) {
        model->Draw();
    }
}

void Object3d::TransformationMatrixGenerate() {
    // WVP,Worldç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹ã€‚TransformationMatrixã‚’ç”¨æ„ã™ã‚‹
    transformationMatrixResource = CreateBufferResource(object3dCommon->GetDxCommon()->GetDevice(), sizeof(TransformationMatrix));
    // ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    transformationMatrixResource->Map(0, nullptr, reinterpret_cast<void**>(&transformationMatrixData));
    // å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
    transformationMatrixData->WVP = MakeIdentity4x4();
    transformationMatrixData->World = MakeIdentity4x4();
    // WorldInverseTransposeã‚’è¨ˆç®—ã—ã¦ã‚»ãƒƒãƒˆ
    transformationMatrixData->WorldInverseTranspose = InverseTranspose(transformationMatrixData->World);
}

void Object3d::CameraForGPUGenerate() {
    // ã‚«ãƒ¡ãƒ©ç”¨ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
    cameraResource = CreateBufferResource(object3dCommon->GetDxCommon()->GetDevice(), sizeof(Object3d::CameraForGPU));
    // æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    cameraResource->Map(0, nullptr, reinterpret_cast<void**>(&cameraForGPUData));
    // å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
    if (camera) {
        cameraForGPUData->worldPosition = camera->GetTranslate();
    } else {
        // ã‚«ãƒ¡ãƒ©ãŒãªã„å ´åˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ã«ã—ã¦ãŠã
        cameraForGPUData->worldPosition = { 0.0f, 0.0f, -100.0f };
    }
}

void Object3d::SetModel(const std::string& filePath) {
    // ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢ã—ã¦ã‚»ãƒƒãƒˆã™ã‚‹
    model = ModelManager::GetInstance()->FindModel(filePath);
}

void Object3d::SetMaterialColor(const Vector4& color) {
    if (!model) return;   // ãƒ¢ãƒ‡ãƒ«ãŒç„¡ã„ãªã‚‰ä½•ã‚‚ã—ãªã„

    Material* mat = model->GetMaterialData();
    if (!mat) return;     // ãƒžãƒ†ãƒªã‚¢ãƒ«ãŒç„¡ã„ãªã‚‰ä½•ã‚‚ã—ãªã„

    mat->color = color;   // GPUã«ãƒžãƒƒãƒ—æ¸ˆã¿ã®CBufferã‚’æ›¸ãæ›ãˆã‚‹
}

std::unique_ptr<Object3d> Object3d::Create(std::string filePath, Transform transform) {
    std::unique_ptr<Object3d> object3d = std::make_unique<Object3d>();
    // åˆæœŸåŒ–
    object3d->Initialize(Object3dCommon::GetInstance());
    // ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢ã—ã¦ã‚»ãƒƒãƒˆã™ã‚‹
    object3d->model = ModelManager::GetInstance()->FindModel(filePath);
    // åˆæœŸè‰²ã‚’ã‚»ãƒƒãƒˆ
    object3d->SetMaterialColor({ 1.0f, 1.0f, 1.0f, 1.0f });
    // åº§æ¨™ã‚’ã‚»ãƒƒãƒˆ
    object3d->transform_ = transform;
    return object3d;
}

void Object3d::DrawImGui(const std::string& name) {
#ifdef USE_IMGUI
    ImGui::Begin(name.c_str());
    // åº§æ¨™ã‚»ã‚¯ã‚·ãƒ§ãƒ³
    if (ImGui::CollapsingHeader("Transform")) {
        ImGui::DragFloat3("Translate", &transform_.translate.x, 0.01f);
        ImGui::DragFloat3("Rotate", &transform_.rotate.x, 0.01f);
        ImGui::DragFloat3("Scale", &transform_.scale.x, 0.01f);
    }
    // ã‚«ãƒ©ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³
    if (ImGui::CollapsingHeader("Material Color")) {
        ImGui::ColorEdit4("Color", reinterpret_cast<float*>(&model->GetMaterialData()->color));
        ImGui::DragFloat("Shininess", &model->GetMaterialData()->shinimess, 0.01f);
    }
    ImGui::End();
#endif // USE_IMGUI
}

============================================================
File Path: project/engine/3d/Object3d.h
============================================================
#pragma once
#include"Model.h"
#include "Camera.h"
#include<TransformationMatrix.h>

class Object3dCommon;

//  3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
class Object3d {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	struct CameraForGPU
	{
		Vector3 worldPosition;
	};

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// åˆæœŸåŒ–
	void Initialize(Object3dCommon* object3dCommon);
	// æ›´æ–°å‡¦ç†
	void Update();
	// æç”»å‡¦ç†
	void Draw();

	// 3Dobjectä½œæˆé–¢æ•°
	static std::unique_ptr<Object3d> Create(std::string filePath, Transform transform);

	// imgui
	void DrawImGui(const std::string& name);

	Vector3 GetWorldPosition() const;

private:
	// ãƒªã‚½ãƒ¼ã‚¹
	// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ãƒžãƒˆãƒªãƒƒã‚¯ã‚¹
	void TransformationMatrixGenerate();
	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹
	void CameraForGPUGenerate();

private:
	// ãƒã‚¤ãƒ³ã‚¿
	Object3dCommon* object3dCommon = nullptr;
	Model* model = nullptr;
	Camera* camera = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> transformationMatrixResource;
	Microsoft::WRL::ComPtr<ID3D12Resource> cameraResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	TransformationMatrix* transformationMatrixData = nullptr;
	CameraForGPU* cameraForGPUData = nullptr;

	Transform transform_;
public:
	// getter	
    Model* GetModel() const { return model; }
	const Transform& GetTransform() const { return transform_; }
	const Vector3& GetScale() const { return transform_.scale; }
	const Vector3& GetRotate() const { return transform_.rotate; }
	const Vector3& GetTranslate() const { return transform_.translate; }
	
	// setter
	void SetModel(const std::string& filePath);
	void SetScale(const Vector3& scale) { this->transform_.scale = scale; }
	void SetRotate(const Vector3& rotate) { this->transform_.rotate = rotate; }
	void SetTranslate(const Vector3& translate) { this->transform_.translate = translate; }
	void SetCamera(Camera* camera) { this->camera = camera; }

	const Vector4 GetMaterialColor() const { return model->GetMaterialData()->color; }

	void SetMaterialColor(const Vector4& color);
};

============================================================
File Path: project/engine/3d/Object3dCommon.cpp
============================================================
#include "Object3dCommon.h"
#include <Logger.h>
#include <StringUtility.h>
#include <ShaderCompiler.h>
#include <ResourceFactory.h>
#include <numbers>
#include <MatrixVector.h>
#include<DsvManager.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI

using namespace Microsoft::WRL;
using namespace MatrixVector;
using namespace ResourceFactory;

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<Object3dCommon> Object3dCommon::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
Object3dCommon* Object3dCommon::GetInstance() {
    if (!instance) {
        instance = std::make_unique<Object3dCommon>();
    }
    return instance.get();
}

// çµ‚äº†
void Object3dCommon::Finalize() {
    instance.reset();  // `delete` ä¸è¦
}

void Object3dCommon::Initialize(DirectXCommon* dxCommon,DsvManager* dsvManager) {
    assert(dxCommon);
    assert(dsvManager);
    // å¼•æ•°ã‚’å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
    dxCommon_ = dxCommon;     
    dsvManager_ = dsvManager;
    // ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
    GraphicsPipelineGenerate();

    // ãƒªã‚½ãƒ¼ã‚¹
    // å¹³è¡Œå…‰æºã®ç”Ÿæˆ,åˆæœŸåŒ–
    DirectionalLightGenerate();
    // ç‚¹å…‰æºãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆã€åˆæœŸåŒ–
    PointlightSourceGenerate();
    // ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆã€åˆæœŸåŒ–
    SpotlightGenerate();
}

void Object3dCommon::Commondrawing() {
    // RootSignatureã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‘ã©åˆ¥é€”è¨­å®šãŒå¿…è¦
    dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
    dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
    // å½¢çŠ¶ã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã¯ã¾ãŸåˆ¥ã€‚åŒã˜ã‚‚ã®ã‚’è¨­å®šã™ã‚‹
    dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    // å¹³è¡Œå…‰æºç”¨ã®CBufferã®å ´æ‰€ã‚’è¨­å®š 
    dxCommon_->GetCommandList()->SetGraphicsRootConstantBufferView(3, directionalLightResource->GetGPUVirtualAddress());
    // ç‚¹å…‰æºã‚’è¨­å®š 
    dxCommon_->GetCommandList()->SetGraphicsRootConstantBufferView(5, pointLightResource->GetGPUVirtualAddress());
    // ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã‚’è¨­å®š 
    dxCommon_->GetCommandList()->SetGraphicsRootConstantBufferView(6, spotLightResource->GetGPUVirtualAddress());
}

void Object3dCommon::RootSignatureGenerate() {
    HRESULT hr;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------DescriptorRangeä½œæˆ-------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
    descriptorRange[0].BaseShaderRegister = 0;
    descriptorRange[0].NumDescriptors = 1;
    descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
    descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------RootParameterä½œæˆ---------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_ROOT_PARAMETER rootParameters[7] = {};
    rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;// PixelShaderã§ä½¿ã†
    rootParameters[0].Descriptor.ShaderRegister = 0;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†

    rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;// VertexShaderã§ã‚’ä½¿ã†
    rootParameters[1].Descriptor.ShaderRegister = 0;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†

    rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;//DescriptorTableã‚’ä½¿ã†
    rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
    rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRange;//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
    rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange);//åˆ©ç”¨ã™ã‚‹æ•°

    rootParameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;// PixelShaderã§ä½¿ã†
    rootParameters[3].Descriptor.ShaderRegister = 1;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·1ã‚’ä½¿ã†

    rootParameters[4].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[4].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;// PixelShaderã§ä½¿ã†
    rootParameters[4].Descriptor.ShaderRegister = 2;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·2ã‚’ä½¿ã†

    rootParameters[5].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[5].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;// PixelShaderã§ä½¿ã†
    rootParameters[5].Descriptor.ShaderRegister = 3;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·3ã‚’ä½¿ã†

    rootParameters[6].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[6].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;// PixelShaderã§ä½¿ã†
    rootParameters[6].Descriptor.ShaderRegister = 4;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·4ã‚’ä½¿ã†

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------RootSignatureä½œæˆ---------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
    descriptionRootSignature.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
    descriptionRootSignature.pParameters = rootParameters;// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
    descriptionRootSignature.NumParameters = _countof(rootParameters);// é…åˆ—ã®é•·ã•

    /*----------------------------------------------------------------------------------*/
    /*-----------------------------------Samplerã®è¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
    staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;//ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿	
    staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//0ï½ž1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ		
    staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;//æ¯”è¼ƒã—ãªã„		
    staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;//ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†	
    staticSamplers[0].ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼ã‚’ä½¿ã†
    staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
    descriptionRootSignature.pStaticSamplers = staticSamplers;
    descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

    /*----------------------------------------------------------------------------------*/
    /*-------------------------ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã«ã™ã‚‹--------------------------------*/
    /*----------------------------------------------------------------------------------*/
    ComPtr <ID3DBlob> signatureBlob = nullptr;
    ComPtr <ID3DBlob> errorBlob = nullptr;
    hr = D3D12SerializeRootSignature(&descriptionRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
    if (FAILED(hr)) {
        Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
        assert(false);
    }
    //ãƒã‚¤ãƒŠãƒªã‚’å…ƒã«ä½œæˆ
    hr = dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
    assert(SUCCEEDED(hr));
}

void Object3dCommon::GraphicsPipelineGenerate() {
    // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
    RootSignatureGenerate();
    HRESULT hr;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------InputLayoutè¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_INPUT_ELEMENT_DESC inputElementDescs[3] = {};
    inputElementDescs[0].SemanticName = "POSITION";
    inputElementDescs[0].SemanticIndex = 0;
    inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
    inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    inputElementDescs[1].SemanticName = "TEXCOORD";
    inputElementDescs[1].SemanticIndex = 0;
    inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
    inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    inputElementDescs[2].SemanticName = "NORMAL";
    inputElementDescs[2].SemanticIndex = 0;
    inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
    inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    D3D12_INPUT_LAYOUT_DESC inputLayoutDesc{};
    inputLayoutDesc.pInputElementDescs = inputElementDescs;
    inputLayoutDesc.NumElements = _countof(inputElementDescs);

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------BlendStateã®è¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_BLEND_DESC blendDesc{};
    //å…¨ã¦ã®è‰²è¦ç´ ã‚’æ›¸ãè¾¼ã‚€
    blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
    blendDesc.RenderTarget[0].BlendEnable = TRUE;
    blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
    blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
    blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
    blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;           // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;         // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;         // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// åŠ ç®—åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;       // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;           // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ONE;            // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// æ¸›ç®—åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;         // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;    // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;              // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// ä¹—ç®—åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;           // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;         // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_SRC_COLOR;    // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_INV_DEST_COLOR;    // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;             // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;              // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //===== RasterizerStateã®è¨­å®šã‚’è¡Œã† ======//   
    D3D12_RASTERIZER_DESC rasterizerDesc{};
    //è£é¢(æ™‚è¨ˆå›žã‚Š)ã‚’è¡¨ç¤ºã—ãªã„
    rasterizerDesc.CullMode = D3D12_CULL_MODE_BACK;
    //ä¸‰è§’å½¢ã®ä¸­ã‚’å¡—ã‚Šã¤ã¶ã™
    rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

    /*----------------------------------------------------------------------------------*/
    /*--------------------------------Shaderã‚’Compile-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    ComPtr <IDxcBlob> vertexShaderBlob = ShaderCompiler::GetInstance()->CompileShader(L"Resources/shaders/Object3d/Object3D.VS.hlsl", L"vs_6_0");
    assert(vertexShaderBlob != nullptr);
    ComPtr <IDxcBlob> pixelShaderBlob = ShaderCompiler::GetInstance()->CompileShader(L"Resources/shaders/Object3d/Object3D.PS.hlsl", L"ps_6_0");
    assert(pixelShaderBlob != nullptr);

    /*-----------------------------------------------------------------------------------*/
    /*-------------------------------------PSOç”Ÿæˆ----------------------------------------*/
    /*-----------------------------------------------------------------------------------*/
    D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
    graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();   // RootSignature
    graphicsPipelineStateDesc.InputLayout = inputLayoutDesc;    // InputLayout
    graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };  // VertexShader
    graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };    // PixelShader
    graphicsPipelineStateDesc.BlendState = blendDesc;// BlendState
    graphicsPipelineStateDesc.RasterizerState = rasterizerDesc; //RasterizerState
    // æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
    graphicsPipelineStateDesc.NumRenderTargets = 1;
    graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
    //åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸(å½¢çŠ¶)ã®ã‚¿ã‚¤ãƒ—
    graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
    // ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã‹ã®è¨­å®š(æ°—ã«ã—ãªãã¦è‰¯ã„)
    graphicsPipelineStateDesc.SampleDesc.Count = 1;
    graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
    // DepthStencilã®è¨­å®š
    graphicsPipelineStateDesc.DepthStencilState = dsvManager_->GetDepthStencilDesc();
    graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;

    // å®Ÿéš›ã«ç”Ÿæˆ
    hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));
    assert(SUCCEEDED(hr));
}


void Object3dCommon::DirectionalLightGenerate() {
    // å¹³è¡Œå…‰æºç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
    directionalLightResource = CreateBufferResource(dxCommon_->GetDevice(), sizeof(DirectionalLight));
    // å¹³è¡Œå…‰æºç”¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    directionalLightResource->Map(0, nullptr, reinterpret_cast<void**>(&directionalLightDate));
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã¯ã¨ã‚Šã‚ãˆãšä»¥ä¸‹ã®ã‚ˆã†ã«ã—ã¦ç½®ã
    directionalLightDate->color = { 1.0f, 1.0f, 1.0f, 1.0f };
    directionalLightDate->direction = { 0.0f,-1.0f,0.0f };
    directionalLightDate->intensity = 1.0f;
}

void Object3dCommon::PointlightSourceGenerate() {
    // ç‚¹å…‰æºç”¨ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
    pointLightResource = CreateBufferResource(dxCommon_->GetDevice(), sizeof(PointLight));
    // æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    pointLightResource->Map(0, nullptr, reinterpret_cast<void**>(&pointLightData));
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
    pointLightData->color = { 1.0f,1.0f,1.0f,1.0f };
    pointLightData->position = { 0.0f,2.0f,0.0f };
    pointLightData->intensity = 0.0f;
    pointLightData->radius = 10.0f;
    pointLightData->decay = 1.0f;
}

void Object3dCommon::SpotlightGenerate() {
    // ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
    spotLightResource = CreateBufferResource(dxCommon_->GetDevice(), sizeof(SpotLight));
    // æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    spotLightResource->Map(0, nullptr, reinterpret_cast<void**>(&spotLightData));
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
    spotLightData->color = { 1.0f,1.0f,1.0f,1.0f };
    spotLightData->position = { 2.0f,1.25f,0.0f };
    spotLightData->distance = 7.0f;
    spotLightData->direction =
        Normalize({ -1.0f,-1.0f,0.0f });
    spotLightData->intensity = 4.0f;
    spotLightData->decay = 2.0f;
    spotLightData->cosFalloffStart = 1.0f;
    spotLightData->cosAngle =
        std::cos(std::numbers::pi_v<float> / 3.0f);
}

void Object3dCommon::DrawImGui() {
#ifdef USE_IMGUI
    ImGui::Begin("lighting");
    // ãƒ©ã‚¤ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³
    if (ImGui::CollapsingHeader("Directional Light")) {
        ImGui::DragFloat3("Direction", &directionalLightDate->direction.x, 0.01f);
        ImGui::DragFloat("Intensity", &directionalLightDate->intensity, 0.01f);
    }
    // ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆ
    if (ImGui::CollapsingHeader("Point Light")) {
        ImGui::DragFloat3("Point Light : Position", &pointLightData->position.x, 0.01f);
        ImGui::DragFloat("Point Light : Intensity", &pointLightData->intensity, 0.01f);
        ImGui::DragFloat("Point Light : Radius", &pointLightData->radius, 0.01f);
        ImGui::DragFloat("Point Light : Decay", &pointLightData->decay, 0.01f);
    }
    // ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ
    if (ImGui::CollapsingHeader("Spot Light")) {
        ImGui::DragFloat3("Spot Light : Position", &spotLightData->position.x, 0.01f);
        ImGui::DragFloat("Spot Light : Intensity", &spotLightData->intensity, 0.01f);
        ImGui::DragFloat3("Spot Light : Direction", &spotLightData->direction.x, 0.01f);
        ImGui::DragFloat("Spot Light : Decay", &spotLightData->decay, 0.01f);
        ImGui::DragFloat("Spot Light : CosAngle", &spotLightData->cosAngle, 0.01f);
        ImGui::DragFloat("Spot Light : CosFalloffStart", &spotLightData->cosFalloffStart, 0.01f);
    }

    ImGui::End();
#endif // USE_IMGUI
}

============================================================
File Path: project/engine/3d/Object3dCommon.h
============================================================
#pragma once
#include"DirectXCommon.h"
#include"Camera.h"
#include<DirectionalLight.h>
#include<SpotLight.h>
#include<PointLight.h>

class DsvManager;

// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…±é€šéƒ¨
class Object3dCommon {
private:
	static std::unique_ptr<Object3dCommon> instance;

	Object3dCommon(Object3dCommon&) = delete;
	Object3dCommon& operator=(Object3dCommon&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	Object3dCommon() = default;
	~Object3dCommon() = default;

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static Object3dCommon* GetInstance();
	// çµ‚äº†
	void Finalize();
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* dxCommon,DsvManager* dsvManager);
	// å…±é€šæç”»è¨­å®š
	void Commondrawing();	
	// imgui
	void DrawImGui();
private:
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	void RootSignatureGenerate();
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	void GraphicsPipelineGenerate();
	// å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹
	void DirectionalLightGenerate();
	// ç‚¹å…‰æºãƒªã‚½ãƒ¼ã‚¹
	void PointlightSourceGenerate();
	// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆãƒªã‚½ãƒ¼ã‚¹
	void SpotlightGenerate();

private:
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_;
	Camera* defaultCamera = nullptr;
	DsvManager* dsvManager_;
	// RootSignature
	Microsoft::WRL::ComPtr <ID3D12RootSignature> rootSignature = nullptr;
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> directionalLightResource;
	Microsoft::WRL::ComPtr<ID3D12Resource> pointLightResource;
	Microsoft::WRL::ComPtr<ID3D12Resource> spotLightResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	DirectionalLight* directionalLightDate = nullptr;
	PointLight* pointLightData = nullptr;
	SpotLight* spotLightData = nullptr;
public:
	// setter
	void SetDefaultCamera(Camera* camera) { this->defaultCamera = camera; }
	// getter
	DirectXCommon* GetDxCommon() const { return  dxCommon_; }
	Camera* GetDefaultCamera() const { return defaultCamera; }
};

============================================================
File Path: project/engine/3d/Particle/ParticleCommon.cpp
============================================================
#include "ParticleCommon.h"
#include <Logger.h>
#include <StringUtility.h>
#include <ShaderCompiler.h>
#include<DsvManager.h>

using namespace Microsoft::WRL;

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<ParticleCommon> ParticleCommon::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
ParticleCommon* ParticleCommon::GetInstance() {
    if (!instance) {
        instance = std::make_unique<ParticleCommon>();
    }
    return instance.get();
}

// çµ‚äº†
void ParticleCommon::Finalize() {
    instance.reset();  // `delete` ä¸è¦
}

void ParticleCommon::Initialize(DirectXCommon* dxCommon, DsvManager* dsvManager) {
    assert(dxCommon);
    assert(dsvManager);
    // å¼•æ•°ã‚’å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
    dxCommon_ = dxCommon;
    dsvManager_ = dsvManager;
    // ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
    GraphicsPipelineGenerate();
}

void ParticleCommon::Commondrawing() {
    // RootSignatureã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‘ã©åˆ¥é€”è¨­å®šãŒå¿…è¦
    dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
    dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
    // å½¢çŠ¶ã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã¯ã¾ãŸåˆ¥ã€‚åŒã˜ã‚‚ã®ã‚’è¨­å®šã™ã‚‹
    dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

void ParticleCommon::RootSignatureGenerate() {

    HRESULT hr;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------DescriptorRangeä½œæˆ-------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
    descriptorRange[0].BaseShaderRegister = 0;
    descriptorRange[0].NumDescriptors = 1;
    descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
    descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

    // Instancingä½œæˆ
    D3D12_DESCRIPTOR_RANGE descriptorRangeForInstancing[1] = {};
    descriptorRangeForInstancing[0].BaseShaderRegister = 0; // 0ã‹ã‚‰å§‹ã‚ã‚‹
    descriptorRangeForInstancing[0].NumDescriptors = 1; // æ•°ã¯1ã¤
    descriptorRangeForInstancing[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
    descriptorRangeForInstancing[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------RootParameterä½œæˆ---------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_ROOT_PARAMETER rootParameters[4] = {};
    rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;// PixelShaderã§ä½¿ã†
    rootParameters[0].Descriptor.ShaderRegister = 0;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†

    rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
    rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX; // VertexShaderã§ä½¿ã†
    rootParameters[1].DescriptorTable.pDescriptorRanges = descriptorRangeForInstancing; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
    rootParameters[1].DescriptorTable.NumDescriptorRanges = _countof(descriptorRangeForInstancing); // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

    rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;//DescriptorTableã‚’ä½¿ã†
    rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
    rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRange;//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
    rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange);//åˆ©ç”¨ã™ã‚‹æ•°

    rootParameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;// CBVã‚’ä½¿ã†
    rootParameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;// PixelShaderã§ä½¿ã†
    rootParameters[3].Descriptor.ShaderRegister = 1;// ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·1ã‚’ä½¿ã†

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------RootSignatureä½œæˆ---------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
    descriptionRootSignature.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
    descriptionRootSignature.pParameters = rootParameters;// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
    descriptionRootSignature.NumParameters = _countof(rootParameters);// é…åˆ—ã®é•·ã•

    /*----------------------------------------------------------------------------------*/
    /*-----------------------------------Samplerã®è¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
    staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;//ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿	
    staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//0ï½ž1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ		
    staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
    staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;//æ¯”è¼ƒã—ãªã„		
    staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;//ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†	
    staticSamplers[0].ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼ã‚’ä½¿ã†
    staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
    descriptionRootSignature.pStaticSamplers = staticSamplers;
    descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

    /*----------------------------------------------------------------------------------*/
    /*-------------------------ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã«ã™ã‚‹--------------------------------*/
    /*----------------------------------------------------------------------------------*/
    ComPtr <ID3DBlob> signatureBlob = nullptr;
    ComPtr <ID3DBlob> errorBlob = nullptr;
    hr = D3D12SerializeRootSignature(&descriptionRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
    if (FAILED(hr)) {
        Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
        assert(false);
    }
    // ãƒã‚¤ãƒŠãƒªã‚’å…ƒã«ä½œæˆ
    hr = dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
    assert(SUCCEEDED(hr));
}

void ParticleCommon::GraphicsPipelineGenerate() {
    // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
    RootSignatureGenerate();
    HRESULT hr;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------InputLayoutè¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_INPUT_ELEMENT_DESC inputElementDescs[3] = {};
    inputElementDescs[0].SemanticName = "POSITION";
    inputElementDescs[0].SemanticIndex = 0;
    inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
    inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    inputElementDescs[1].SemanticName = "TEXCOORD";
    inputElementDescs[1].SemanticIndex = 0;
    inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
    inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    inputElementDescs[2].SemanticName = "NORMAL";
    inputElementDescs[2].SemanticIndex = 0;
    inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
    inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    D3D12_INPUT_LAYOUT_DESC inputLayoutDesc{};
    inputLayoutDesc.pInputElementDescs = inputElementDescs;
    inputLayoutDesc.NumElements = _countof(inputElementDescs);

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------BlendStateã®è¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_BLEND_DESC blendDesc{};
    //å…¨ã¦ã®è‰²è¦ç´ ã‚’æ›¸ãè¾¼ã‚€
blendDesc.RenderTarget[0].BlendEnable = TRUE;
blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_SRC_ALPHA;    // alpha ã‚‚åŒæ§˜ã«
blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_INV_SRC_ALPHA;
blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;

    //// åŠ ç®—åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;       // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;           // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;            // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// æ¸›ç®—åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;         // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;    // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;              // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// ä¹—ç®—åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;           // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;         // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_SRC_COLOR;    // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //// ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åˆæˆ
    //blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_INV_DEST_COLOR;    // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    //blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;             // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    //blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;              // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)


    //===== RasterizerStateã®è¨­å®šã‚’è¡Œã† ======//   
    D3D12_RASTERIZER_DESC rasterizerDesc{};
    // è£é¢(æ™‚è¨ˆå›žã‚Š)ã‚’è¡¨ç¤ºã—ãªã„
    //rasterizerDesc.CullMode = D3D12_CULL_MODE_BACK;
    // è£é¢(æ™‚è¨ˆå›žã‚Š)ã‚’è¡¨ç´™ã™ã‚‹
    rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
    // ä¸‰è§’å½¢ã®ä¸­ã‚’å¡—ã‚Šã¤ã¶ã™
    rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

    /*----------------------------------------------------------------------------------*/
    /*--------------------------------Shaderã‚’Compile-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    ComPtr <IDxcBlob> vertexShaderBlob = ShaderCompiler::GetInstance()->CompileShader(L"Resources/shaders/Particle/Particle.VS.hlsl", L"vs_6_0");
    assert(vertexShaderBlob != nullptr);
    ComPtr <IDxcBlob> pixelShaderBlob = ShaderCompiler::GetInstance()->CompileShader(L"Resources/shaders/Particle/Particle.PS.hlsl", L"ps_6_0");
    assert(pixelShaderBlob != nullptr);

    /*-----------------------------------------------------------------------------------*/
    /*-------------------------------------PSOç”Ÿæˆ----------------------------------------*/
    /*-----------------------------------------------------------------------------------*/
    D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
    graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();   // RootSignature
    graphicsPipelineStateDesc.InputLayout = inputLayoutDesc;    // InputLayout
    graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };  // VertexShader
    graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };    // PixelShader
    graphicsPipelineStateDesc.BlendState = blendDesc;// BlendState
    graphicsPipelineStateDesc.RasterizerState = rasterizerDesc; //RasterizerState
    // æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
    graphicsPipelineStateDesc.NumRenderTargets = 1;
    graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
    // åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸(å½¢çŠ¶)ã®ã‚¿ã‚¤ãƒ—
    graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
    // ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã‹ã®è¨­å®š(æ°—ã«ã—ãªãã¦è‰¯ã„)
    graphicsPipelineStateDesc.SampleDesc.Count = 1;
    graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
    // DepthStencilã®è¨­å®š
    graphicsPipelineStateDesc.DepthStencilState = dsvManager_->GetDepthStencilDesc();
    graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;

    // å®Ÿéš›ã«ç”Ÿæˆ
    hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));
    assert(SUCCEEDED(hr));
}

============================================================
File Path: project/engine/3d/Particle/ParticleCommon.h
============================================================
#pragma once
#include"DirectXCommon.h"
#include"Camera.h"

class DsvManager;

// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…±é€šéƒ¨
class ParticleCommon
{
private:
	static std::unique_ptr<ParticleCommon> instance;

	ParticleCommon(ParticleCommon&) = delete;
	ParticleCommon& operator=(ParticleCommon&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	ParticleCommon() = default;
	~ParticleCommon() = default;

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static ParticleCommon* GetInstance();
	// çµ‚äº†
	void Finalize();
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* dxCommon, DsvManager* dsvManager);
	// å…±é€šæç”»è¨­å®š
	void Commondrawing();
private:
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	void RootSignatureGenerate();
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	void GraphicsPipelineGenerate();
private:
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_;
	DsvManager* dsvManager_;
	Camera* defaultCamera = nullptr;
	// RootSignature
	Microsoft::WRL::ComPtr <ID3D12RootSignature> rootSignature = nullptr;
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
public:
	// setter
	void SetDefaultCamera(Camera* camera) { this->defaultCamera = camera; }
	// getter
	DirectXCommon* GetDxCommon() const { return  dxCommon_; }
	Camera* GetDefaultCamera() const { return defaultCamera; }
};

============================================================
File Path: project/engine/3d/Particle/ParticleEmitter.cpp
============================================================
#include "ParticleEmitter.h"
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include <ModelManager.h>

// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’å®šç¾©
std::vector<std::string> ParticleEmitter::textureList_ = {
	"Resources/uvChecker.png",
	"Resources/circle2.png",
};

ParticleEmitter::ParticleEmitter(const std::string& name, const uint32_t count, const Transform& transform, const Vector4& color, const float lifetime, const float currentTime, const Velocity& Velocity, const RandomParameter& randomParameter) {
	name_ = name;//åå‰
	this->count = count;//count
	transform_ = transform;//ä½ç½®
	this->color = color; // ã‚«ãƒ©ãƒ¼
	frequency = lifetime;//å¯¿å‘½
	frequencyTime = currentTime;//ç¾åœ¨ã®å¯¿å‘½
	velocity_ = Velocity; // é¢¨ã®å¼·ã•
	randomParameter_ = randomParameter; // ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
}

void ParticleEmitter::Update()
{
	// æ™‚é–“ã‚’é€²ã‚ã‚‹
	frequencyTime += 1.0f / 60.0f;

	// isAutoEmit_ ãŒ true ã®ã¨ãã€è‡ªå‹•ç™ºç”Ÿå‡¦ç†
	if (isAutoEmit_) {
		// ç™ºç”Ÿé–“éš”ã‚’è¶…ãˆãŸã‚‰ Emit å®Ÿè¡Œ
		if (frequencyTime >= frequency) {
			frequencyTime = 0.0f; // ãƒªã‚»ãƒƒãƒˆ
			Emit(); // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿ
		}
	}
}

void ParticleEmitter::Emit()
{
	//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç™ºç”Ÿ
	ParticleManager::GetInstance()->Emit(name_, transform_, color, count, velocity_, frequency, randomParameter_);
}

void ParticleEmitter::DrawImGuiUI() {
#ifdef USE_IMGUI
	//if (ImGui::CollapsingHeader(name_.c_str(), ImGuiTreeNodeFlags_DefaultOpen)) { // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§é–‹ã„ã¦ãŠã
	if (ImGui::CollapsingHeader(name_.c_str())) { // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§é–‹ã„ã¦ãŠã
		ImGui::Separator();
		ImGui::TextColored(ImVec4(1, 1, 0, 1), "%s", name_.c_str()); // é»„è‰²ã§å¼·èª¿

		ImGui::Checkbox(("Update##" + name_).c_str(), &isAutoEmit_);
		
		// --- ã“ã“ã«å€‹æ•°å¤‰æ›´UIã‚’è¿½åŠ  ---
		int countInt = static_cast<int>(count);
		if (ImGui::InputInt(("Emit Count##" + name_).c_str(), &countInt)) {
			if (countInt < 0) countInt = 0; // è² æ•°é˜²æ­¢
			count = static_cast<uint32_t>(countInt);
		}

		// --- ãƒ†ã‚¯ã‚¹ãƒãƒ£é¸æŠž Combo ---
		if (ImGui::BeginCombo(("Texture##" + name_).c_str(), textureList_[textureIndex_].c_str())) {
			for (int i = 0; i < textureList_.size(); ++i) {
				bool selected = (textureIndex_ == i);
				if (ImGui::Selectable(textureList_[i].c_str(), selected)) {
					textureIndex_ = i;

					// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¨­å®šï¼ˆã“ã“ã§ ParticleManager ã«åæ˜ ï¼‰
					ParticleManager::GetInstance()->SetParticleGroupTexture(name_, textureList_[textureIndex_]);
				}
				if (selected) ImGui::SetItemDefaultFocus();
			}
			ImGui::EndCombo();
		}

		// Transformã®ç·¨é›†
		if (ImGui::TreeNode(("Transform##" + name_).c_str())) {
			ImGui::DragFloat3(("Position##" + name_).c_str(), &transform_.translate.x, 0.01f);
			ImGui::DragFloat3(("Rotation##" + name_).c_str(), &transform_.rotate.x, 0.01f);
			ImGui::DragFloat3(("Scale##" + name_).c_str(), &transform_.scale.x, 0.01f);
			ImGui::TreePop();
		}

		auto& group = ParticleManager::GetInstance()->GetGroup(name_);
		size_t currentCount = group.particles.size();
		uint32_t maxCount = ParticleManager::GetInstance()->GetMaxInstanceCount();
		uint32_t availableToEmit = static_cast<uint32_t>(std::min<size_t>(count, maxCount - currentCount));

		// --- Emit ãƒœã‚¿ãƒ³ ---
		if (ImGui::Button(("Emit Particles##" + name_).c_str())) {
			if (availableToEmit > 0) {
				// ç™ºç”Ÿ
				ParticleManager::GetInstance()->Emit(name_, transform_, color, availableToEmit, velocity_, frequency, randomParameter_);
			}
		}
	}
#endif
}


============================================================
File Path: project/engine/3d/Particle/ParticleEmitter.h
============================================================
#pragma once
#include<Vector3.h>
#include <string>
#include <vector>
#include <Transform.h>
#include<ParticleManager.h>

// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿå™¨
class ParticleEmitter
{
public:
	//ã»ã¨ã‚“ã©ã®ãƒ¡ãƒ³ãƒå¤‰æ•°ã‚’ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚Šã€ãƒ¡ãƒ³ãƒå¤‰æ•°ã«ä»£å…¥ã™ã‚‹
	ParticleEmitter(const std::string& name,const uint32_t count, const Transform& transform, const Vector4& color, const float lifetime, const float currentTime, const Velocity& Velocity, const RandomParameter& randomParameter);

	// æ›´æ–°å‡¦ç†
	void Update();
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿ
	void Emit();
	// imgui
	void DrawImGuiUI();

private:
	// åå‰
	std::string name_;
	// åº§æ¨™
	Transform transform_;
	// ã‚«ãƒ©ãƒ¼
	Vector4 color;
	// æ•°
	uint32_t count;
	// é¢¨ã®å¼·ã•
	Velocity velocity_;
	// å¯¿å‘½
	float frequency;
	// ç¾åœ¨ã®å¯¿å‘½
	float frequencyTime;
	// è‡ªå‹•ç™ºç”Ÿã™ã‚‹ã‹ã©ã†ã‹ã®
	bool isAutoEmit_ = true;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å¤‰æ›´ãƒ•ãƒ©ã‚°
	bool isTextureChange_ = false;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚¹ãƒˆ
	static std::vector<std::string> textureList_;
	// é¸æŠžä¸­ã®ãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	int textureIndex_ = 0;
	RandomParameter randomParameter_;

	//random_ = {
	//	//åº§æ¨™
	//	{0.0f,0.0f,0.0f},  // æœ€å°
	//	{0.0f,0.0f,0.0f},  // æœ€å¤§
	//	// å›žè»¢
	//	{0.0f,0.0f,-std::numbers::pi_v<float>},  // æœ€å°
	//	{0.0f,0.0f, std::numbers::pi_v<float>},  // æœ€å¤§
	//	// ã‚µã‚¤ã‚º
	//	{0.0f,0.4f,0.0f}, // æœ€å°
	//	{0.0f,1.5f,0.0f}, // æœ€å¤§
	//	// ã‚«ãƒ©ãƒ¼
	//	0.0f,  // æœ€å°
	//	1.0f,  // æœ€å¤§
	//	// å¯¿å‘½
	//	0.0f, // æœ€å°
	//	0.0f, // æœ€å¤§
	//	// é€Ÿåº¦
	//	{0.0f,0.0f,0.0f},// æœ€å°
	//	{0.0f,0.0f,0.0f} // æœ€å¤§
	//};

public:
	float GetfrequencyTime() {return frequencyTime; }

};

============================================================
File Path: project/engine/3d/Particle/ParticleManager.cpp
============================================================
#include "ParticleManager.h"
#include <MatrixVector.h>
#include <cassert>
#include <ModelManager.h>
#include <TextureManager.h>
#include <numbers>
#include <externals/DirectXTex/d3dx12.h>
#include <Object3dCommon.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include <ResourceFactory.h>
#include <CameraManager.h>

using namespace MatrixVector;
using namespace Microsoft::WRL;
using namespace ResourceFactory;

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<ParticleManager> ParticleManager::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
ParticleManager* ParticleManager::GetInstance() {
    if (!instance) {
        instance = std::make_unique<ParticleManager>();
    }
    return instance.get();
}

// çµ‚äº†
void ParticleManager::Finalize() {
    instance.reset();
}

void ParticleManager::ClearAll() {
    particleGroups.clear();   // å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å‰Šé™¤
}

void ParticleManager::Initialize(DirectXCommon* birectxcommon, SrvManager* srvmanager) {
    // NULLæ¤œå‡º
    assert(birectxcommon);
    assert(srvmanager);
    // ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²
    this->dxCommon_ = birectxcommon;
    this->srvmanager_ = srvmanager;
    // ä¹±æ•°ã‚¨ãƒ³ã‚¸ãƒ³ã‚’åˆæœŸåŒ–
    std::random_device rd;// ä¹±æ•°ç”Ÿæˆå™¨
    randomEngine = std::mt19937(rd());
    //ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—ä½œæˆ
    backToFrontMatrix = MakeRotateYMatrix(std::numbers::pi_v<float>);
}

void ParticleManager::Update() {
    Matrix4x4 billboardMatrix;
    Matrix4x4 viewMatrix;
    Matrix4x4 projectionMatrix;
    // ã‚«ãƒ¡ãƒ©ã‚’ CameraManager çµŒç”±ã§å–å¾—
    Camera* activeCamera = CameraManager::GetInstance()->GetActiveCamera();
    if (activeCamera) {
        // ã‚«ãƒ¡ãƒ©ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‚’å–å¾—ã—ã€ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—ã‚’è¨ˆç®—
        billboardMatrix = Multiply(backToFrontMatrix, activeCamera->GetWorldMatrix());  // ä¿®æ­£: GetWorldMatrix
        // ã‚«ãƒ¡ãƒ©ã‹ã‚‰ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã‚’å–å¾—
        viewMatrix = activeCamera->GetViewMatrix();
        projectionMatrix = activeCamera->GetProjectionMatrix();
    } else {
        // ã‚«ãƒ¡ãƒ©ãŒãªã„å ´åˆã®å‡¦ç†ï¼ˆå¿…è¦ã§ã‚ã‚Œã°ï¼‰
    }

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®ã‚’ã‚«ãƒ¡ãƒ©ã®æ–¹å‘ã«åˆã‚ã›ã‚‹ãŸã‚ã«è¨­å®š
    billboardMatrix.m[3][0] = 0.0f;
    billboardMatrix.m[3][1] = 0.0f;
    billboardMatrix.m[3][2] = 0.0f;

    // å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®å‡¦ç†
    for (auto& [name, group] : particleGroups) {
        group.kNumInstance = 0;
        for (auto particleIterator = group.particles.begin(); particleIterator != group.particles.end();) {
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç¾åœ¨ã®æ™‚é–“ã‚’å¢—åŠ ã•ã›ã‚‹
            (*particleIterator).currentTime += 1.0f / 60.0f;  // 60fpsã§æ™‚é–“ã‚’ã‚«ã‚¦ãƒ³ãƒˆã‚¢ãƒƒãƒ—

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å¯¿å‘½ãŒå°½ããŸã‚‰å‰Šé™¤
            if ((*particleIterator).currentTime >= (*particleIterator).lifetime) {
                particleIterator = group.particles.erase(particleIterator);  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‰Šé™¤
                continue;
            }

            // é€æ˜Žåº¦ã®æ›´æ–°ï¼ˆæ™‚é–“ã«åŸºã¥ã„ã¦ãƒ•ã‚§ãƒ¼ãƒ‰ï¼‰
            float alpha = 1.0f - (*particleIterator).currentTime / (*particleIterator).lifetime;
            (*particleIterator).color.w = alpha;

            
            if (particleIterator->useGravity) {
                particleIterator->Velocity.translate.y -= 0.003f; // é‡åŠ›ã¨ã—ã¦é€Ÿåº¦ã«åŠ ãˆã‚‹
            }


            // é€Ÿåº¦ã‚’è¶³ã™
            // åº§æ¨™
            particleIterator->transform.translate.x += particleIterator->Velocity.translate.x;
            particleIterator->transform.translate.y += particleIterator->Velocity.translate.y;
            particleIterator->transform.translate.z += particleIterator->Velocity.translate.z;
            // å›žè»¢
            particleIterator->transform.rotate.x += particleIterator->Velocity.rotate.x;
            particleIterator->transform.rotate.y += particleIterator->Velocity.rotate.y;
            particleIterator->transform.rotate.z += particleIterator->Velocity.rotate.z;
            // ã‚µã‚¤ã‚º
            particleIterator->transform.scale.x += particleIterator->Velocity.scale.x;
            particleIterator->transform.scale.y += particleIterator->Velocity.scale.y;
            particleIterator->transform.scale.z += particleIterator->Velocity.scale.z;

            // worldè¡Œåˆ—ã®è¨ˆç®—
            Matrix4x4 scaleMatrix = MakeScaleMatrix((*particleIterator).transform.scale);
            // å›žè»¢è¡Œåˆ—ã‚’å„è»¸ã”ã¨ã«ä½œæˆã—ã¦åˆæˆ
            Matrix4x4 rotateXMatrix = MakeRotateXMatrix((*particleIterator).transform.rotate.x);
            Matrix4x4 rotateYMatrix = MakeRotateYMatrix((*particleIterator).transform.rotate.y);
            Matrix4x4 rotateZMatrix = MakeRotateZMatrix((*particleIterator).transform.rotate.z);
            // å›žè»¢é †åº: Z â†’ X â†’ Yï¼ˆç”¨é€”ã«ã‚ˆã‚Šèª¿æ•´ï¼‰
            Matrix4x4 rotateMatrix = Multiply(Multiply(rotateZMatrix, rotateXMatrix), rotateYMatrix);
            Matrix4x4 translateMatrix = MakeTranslateMatrix((*particleIterator).transform.translate);
            // SRTé †ã«ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰ã‚’å«ã‚ã¦åˆæˆ
            Matrix4x4 worldMatrix = Multiply(Multiply(Multiply(scaleMatrix, rotateMatrix), billboardMatrix), translateMatrix);

            // worldViewProjectionè¡Œåˆ—ã®è¨ˆç®—
            Matrix4x4 viewProjectionMatrix = Multiply(viewMatrix, projectionMatrix);
            Matrix4x4 worldViewProjectionMatrix = Multiply(worldMatrix, viewProjectionMatrix);

            // â˜… æ­£ã—ãæ ¼ç´
            group.instanceData[group.kNumInstance].WVP = worldViewProjectionMatrix;
            group.instanceData[group.kNumInstance].World = worldMatrix;
            group.instanceData[group.kNumInstance].color = particleIterator->color;
            ++group.kNumInstance;

            ++particleIterator;
        }

        // æœªä½¿ç”¨é ˜åŸŸã®ã‚¯ãƒªã‚¢ã¯ã€Œæç”»æ•°ã‚ˆã‚Šå¾Œã‚ã€ã ã‘
        for (uint32_t i = group.kNumInstance; i < MaxInstanceCount; ++i) {
            group.instanceData[i].color = { 0,0,0,0 };
            group.instanceData[i].WVP = MakeIdentity4x4();
            group.instanceData[i].World = MakeIdentity4x4();
        }
    }
}

void ParticleManager::Draw() {
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã«æç”»å‡¦ç†ã‚’è¡Œã†
    for (const auto& [name, particleGroup] : particleGroups) {
        // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ãŒ0ã®å ´åˆã¯æç”»ã—ãªã„
        if (particleGroup.kNumInstance == 0) {
            continue;
        }
        // ãƒ¢ãƒ‡ãƒ«ã«å¿…è¦ãªãƒãƒƒãƒ•ã‚¡ã‚’ãƒã‚¤ãƒ³ãƒ‰ï¼ˆé ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚„å®šæ•°ãƒãƒƒãƒ•ã‚¡ãªã©ï¼‰
        particleGroup.model->Draw();
        // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã® SRV ã‚’è¨­å®šï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’æŒ‡å®šï¼‰
        srvmanager_->SetGraphicsRootDescriptorTable(1, particleGroup.srvindex);
        // SRVã§ç”»åƒã‚’è¡¨ç¤º
        srvmanager_->SetGraphicsRootDescriptorTable(2, particleGroup.materialData.textureindex);
        // æç”»ï¼ˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ï¼‰ã‚’å®Ÿè¡Œ
        dxCommon_->GetCommandList()->DrawInstanced(static_cast<UINT>(particleGroup.model->GetVertexCount()), static_cast<UINT>(particleGroup.kNumInstance), 0, 0);
    }
}

void ParticleManager::CreateParticleGroup(const std::string& name, const std::string& textureFilepath, const std::string& filename, VertexType vertexType) {
    // ã™ã§ã«ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
    if (!TextureManager::GetInstance()->IsTextureLoaded(textureFilepath)) {
        // ãƒžãƒ†ãƒªã‚¢ãƒ«ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰
        TextureManager::GetInstance()->LoadTexture(textureFilepath);
    }

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—åãŒæ—¢ã«å­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    auto it = particleGroups.find(name);
    if (it != particleGroups.end()) {
        // åå‰ãŒä¸€è‡´ã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ãŒå­˜åœ¨ã™ã‚‹å ´åˆã€ãã®ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒä¸€è‡´ã™ã‚‹ã‹ç¢ºèª
        if (it->second.materialData.textureFilePath == textureFilepath) {
            // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒä¸€è‡´ã™ã‚‹å ´åˆã€æ—¢å­˜ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å†åˆ©ç”¨
            return;
        } else {
            // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒç•°ãªã‚‹å ´åˆã€æ—¢å­˜ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ›´æ–°
            it->second.materialData.textureFilePath = textureFilepath;
            it->second.materialData.textureindex = TextureManager::GetInstance()->GetSrvIndex(textureFilepath);
            // å¿…è¦ã«å¿œã˜ã¦ãƒªã‚½ãƒ¼ã‚¹ã®å†å‰²ã‚Šå½“ã¦ãªã©ã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã™
        }
    } else {
        // æ–°ã—ã„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
        ParticleGroup& newGroup = particleGroups[name];
        newGroup.model = std::make_unique<ParticleModel>();
        // é ‚ç‚¹ã‚¿ã‚¤ãƒ—ã‚’ã‚»ãƒƒãƒˆ
        newGroup.model->SetVertexType(vertexType);
        // ãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
        newGroup.model->Initialize(dxCommon_, filename);

        // æ–°ã—ã„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã«ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‘ã‚¹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨­å®š
        newGroup.materialData.textureFilePath = textureFilepath;
        newGroup.materialData.textureindex = TextureManager::GetInstance()->GetSrvIndex("Resources/" + textureFilepath);
        newGroup.kNumInstance = 0;

        // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆ
        newGroup.Resource = CreateBufferResource(dxCommon_->GetDevice(), sizeof(InstanceData) * MaxInstanceCount);
        newGroup.instanceData = nullptr;
        newGroup.Resource->Map(0, nullptr, reinterpret_cast<void**>(&newGroup.instanceData));

        // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–
        for (uint32_t index = 0; index < MaxInstanceCount; ++index) {
            newGroup.instanceData[index].WVP = MakeIdentity4x4();
            newGroup.instanceData[index].World = MakeIdentity4x4();
            newGroup.instanceData[index].color = { 1.0f, 1.0f, 1.0f, 0.0f }; // é€æ˜Ž
        }
        // æ›¸ãè¾¼ã¿å¾Œã«ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¢ãƒ³ãƒžãƒƒãƒ—
        newGroup.Resource->Unmap(0, nullptr);
        // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒƒãƒ•ã‚¡ç”¨ã®SRVã‚’å‰²ã‚Šå½“ã¦ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨˜éŒ²
        newGroup.srvindex = srvmanager_->Allocate();
        // æ§‹é€ ä½“ãƒãƒƒãƒ•ã‚¡ç”¨ã®SRVã‚’ä½œæˆ
        srvmanager_->CreateSRVforStructuredBuffer(newGroup.srvindex, newGroup.Resource.Get(), MaxInstanceCount, sizeof(InstanceData));
    }
}

void ParticleManager::Emit(const std::string& name, const Transform& transform, const Vector4& color, uint32_t count, const Velocity& velocity, float lifetime,const RandomParameter& randomParameter) {

    auto it = particleGroups.find(name);
    if (it == particleGroups.end()) {
        throw std::runtime_error("Particle group not found: " + name);
    }

    ParticleGroup& group = it->second;

    size_t currentParticleCount = group.particles.size();
    if (currentParticleCount + count > MaxInstanceCount) {
        count = static_cast<uint32_t>(MaxInstanceCount - currentParticleCount);
    }

    if (count == 0) return;

    for (uint32_t i = 0; i < count; ++i) {
        ParticleRandomData randData = GenerateRandomParticleData(randomParameter, velocity, lifetime, randomEngine);

        Particle newParticle;
        newParticle.transform.translate = { transform.translate.x + randData.offset.x, transform.translate.y + randData.offset.y, transform.translate.z + randData.offset.z };
        newParticle.transform.rotate = { transform.rotate.x + randData.rotation.x, transform.rotate.y + randData.rotation.y, transform.rotate.z + randData.rotation.z };
        newParticle.transform.scale = { transform.scale.x + randData.scale.x, transform.scale.y + randData.scale.y, transform.scale.z + randData.scale.z };
        newParticle.color = { color.x + randData.color.x,color.y + randData.color.y ,color.z + randData.color.z ,color.w };
        newParticle.lifetime = randData.lifetime;
        newParticle.currentTime = 0.0f;
        newParticle.Velocity.translate = randData.velocity.translate;
        newParticle.Velocity.rotate = randData.velocity.rotate;
        newParticle.Velocity.scale = randData.velocity.scale;

        newParticle.useGravity = (name == "Firework");
        // ä½œæˆã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒªã‚¹ãƒˆã«è¿½åŠ 
        group.particles.push_back(newParticle);
    }
    // æç”»ã§ä½¿ç”¨ã™ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ã‚’æ›´æ–°
    group.kNumInstance = static_cast<uint32_t>(group.particles.size());
}

void ParticleManager::DebugUpdata() {
#ifdef USE_IMGUI
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã‚’æŒ‡å®š
    ImGui::Begin("Particle");
    // å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®åˆè¨ˆæ•°ã‚’è¡¨ç¤º
    int totalCount = 0;
    for (const auto& [name, group] : particleGroups) {
        totalCount += static_cast<int>(group.particles.size());
    }
    ImGui::SliderInt("MaxInstanceCount", (int*)&MaxInstanceCount, 0, 1000);
    ImGui::Text("Max Particles: %u", MaxInstanceCount);
    ImGui::Text("Current Total Particles: %d", totalCount);

    // å„ã‚°ãƒ«ãƒ¼ãƒ—ã”ã¨ã®è©³ç´°ã‚‚è¡¨ç¤ºï¼ˆä»»æ„ï¼‰
    for (const auto& [name, group] : particleGroups) {
        ImGui::Separator();
        ImGui::Text("Group: %s", name.c_str());
        ImGui::Text("  Particles: %zu", group.particles.size());
        ImGui::Text("  Instances: %u", group.kNumInstance);
    }
    ImGui::End();
#endif // USE_IMGUI
}

void ParticleManager::SetParticleGroupTexture(const std::string& name, const std::string& textureFilepath) {
    auto it = particleGroups.find(name);
    if (it == particleGroups.end()) {
        throw std::runtime_error("Particle group not found: " + name);
    }

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒã™ã§ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã‘ã‚Œã°èª­ã¿è¾¼ã‚€
    if (!TextureManager::GetInstance()->IsTextureLoaded(textureFilepath)) {
        TextureManager::GetInstance()->LoadTexture(textureFilepath);
    }

    it->second.materialData.textureFilePath = textureFilepath;
    it->second.materialData.textureindex = TextureManager::GetInstance()->GetSrvIndex(textureFilepath);
}

void ParticleManager::SetParticleGroupModel(const std::string& name, const std::string& modelFilepath) {
    auto it = particleGroups.find(name);
    if (it == particleGroups.end()) {
        throw std::runtime_error("Particle group not found: " + name);
    }

    // ãƒ¢ãƒ‡ãƒ«ãŒã¾ã èª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã¯èª­ã¿è¾¼ã‚€
    if (!ModelManager::GetInstance()->FindModel(modelFilepath)) {
        ModelManager::GetInstance()->LoadModel(modelFilepath);
    }

    // ãƒ¢ãƒ‡ãƒ«å·®ã—æ›¿ãˆ
    if (it->second.model) {
        // ãƒ¢ãƒ‡ãƒ«ãŒæ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯å†åˆæœŸåŒ–ã™ã‚‹
        it->second.model->Initialize(dxCommon_, modelFilepath);
    } else {
        // ãƒ¢ãƒ‡ãƒ«ãŒãªã‘ã‚Œã°æ–°ãŸã«ä½œæˆã—ã¦åˆæœŸåŒ–
        it->second.model = std::make_unique<ParticleModel>();
        it->second.model->SetVertexType(VertexType::Model); // å¿…è¦ãªã‚‰åˆ¥é€”å¼•æ•°ã§æŒ‡å®š
        it->second.model->Initialize(dxCommon_, modelFilepath);
    }
}

ParticleRandomData ParticleManager::GenerateRandomParticleData(const RandomParameter& param, const Velocity& baseVelocity, float baseLifetime, std::mt19937& randomEngine) {
    // ãƒ©ãƒ³ãƒ€ãƒ åˆ†å¸ƒã®å®šç¾©
    std::uniform_real_distribution<float> distX(param.offsetMin.x, param.offsetMax.x);
    std::uniform_real_distribution<float> distY(param.offsetMin.y, param.offsetMax.y);
    std::uniform_real_distribution<float> distZ(param.offsetMin.z, param.offsetMax.z);

    std::uniform_real_distribution<float> distRotateX(param.rotateMin.x, param.rotateMax.x);
    std::uniform_real_distribution<float> distRotateY(param.rotateMin.y, param.rotateMax.y);
    std::uniform_real_distribution<float> distRotateZ(param.rotateMin.z, param.rotateMax.z);

    std::uniform_real_distribution<float> distScaleX(param.scaleMin.x, param.scaleMax.x);
    std::uniform_real_distribution<float> distScaleY(param.scaleMin.y, param.scaleMax.y);
    std::uniform_real_distribution<float> distScaleZ(param.scaleMin.z, param.scaleMax.z);

    std::uniform_real_distribution<float> distVeltranslateX(param.velocityMin.translate.x, param.velocityMax.translate.x);
    std::uniform_real_distribution<float> distVeltranslateY(param.velocityMin.translate.y, param.velocityMax.translate.y);
    std::uniform_real_distribution<float> distVeltranslateZ(param.velocityMin.translate.z, param.velocityMax.translate.z);

    std::uniform_real_distribution<float> distVelrotateX(param.velocityMin.rotate.x, param.velocityMax.rotate.x);
    std::uniform_real_distribution<float> distVelrotateY(param.velocityMin.rotate.y, param.velocityMax.rotate.y);
    std::uniform_real_distribution<float> distVelrotateZ(param.velocityMin.rotate.z, param.velocityMax.rotate.z);

    std::uniform_real_distribution<float> distVelscaleX(param.velocityMin.scale.x, param.velocityMax.scale.x);
    std::uniform_real_distribution<float> distVelscaleY(param.velocityMin.scale.y, param.velocityMax.scale.y);
    std::uniform_real_distribution<float> distVelscaleZ(param.velocityMin.scale.z, param.velocityMax.scale.z);

    std::uniform_real_distribution<float> distLifetime(param.lifetimeMin, param.lifetimeMax);
    std::uniform_real_distribution<float> distColor(param.colorMin, param.colorMax);

    ParticleRandomData data;
    data.offset = { distX(randomEngine), distY(randomEngine), distZ(randomEngine) };
    data.rotation = { distRotateX(randomEngine), distRotateY(randomEngine), distRotateZ(randomEngine) };
    data.scale = { distScaleX(randomEngine), distScaleY(randomEngine), distScaleZ(randomEngine) };
    data.velocity.translate = { baseVelocity.translate.x + distVeltranslateX(randomEngine), baseVelocity.translate.y + distVeltranslateY(randomEngine), baseVelocity.translate.z + distVeltranslateZ(randomEngine) };
    data.velocity.rotate = { baseVelocity.rotate.x + distVelrotateX(randomEngine), baseVelocity.rotate.y + distVelrotateY(randomEngine), baseVelocity.rotate.z + distVelrotateZ(randomEngine) };
    data.velocity.scale = { baseVelocity.scale.x + distVelscaleX(randomEngine), baseVelocity.scale.y + distVelscaleY(randomEngine), baseVelocity.scale.z + distVelscaleZ(randomEngine) };
    data.lifetime = baseLifetime + distLifetime(randomEngine);
    data.color = { distColor(randomEngine), distColor(randomEngine), distColor(randomEngine), 1.0f };

    return data;
}


============================================================
File Path: project/engine/3d/Particle/ParticleManager.h
============================================================
#pragma once
#include<DirectXCommon.h>
#include<SrvManager.h>
#include<random>
#include<Vector2.h>
#include<Model.h>
#include<ParticleModel.h>
#include<RandomParameter.h>
#include<ParticleRandomData.h>
#include<ParticleGroup.h>

// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…±é€šéƒ¨
class ParticleManager {
public:
	static std::unique_ptr<ParticleManager> instance;

	ParticleManager(ParticleManager&) = delete;
	ParticleManager& operator=(ParticleManager&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	ParticleManager() = default;
	~ParticleManager() = default;

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static ParticleManager* GetInstance();
	// çµ‚äº†
	void Finalize();
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* birectxcommon, SrvManager* srvmanager);
	// æ›´æ–°å‡¦ç†
	void Update();
	// æç”»å‡¦ç†
	void Draw();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆ
	void CreateParticleGroup(const std::string& name, const std::string& textureFilepath, const std::string& filename, VertexType vertexType);

	// ç™ºç”Ÿ
	void Emit(const std::string& name, const Transform& transform, const Vector4& color, uint32_t count, const Velocity& velocity, float lifetime, const RandomParameter& randomParameter);

	void SetParticleGroupTexture(const std::string& name, const std::string& textureFilepath);
	void SetParticleGroupModel(const std::string& name, const std::string& modelFilepath);

	void DebugUpdata();

	ParticleRandomData GenerateRandomParticleData(const RandomParameter& param, const Velocity& baseVelocity, float baseLifetime, std::mt19937& randomEngine);
	
	void ClearAll();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_;
	SrvManager* srvmanager_;
	// ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³
	std::mt19937 randomEngine;
	//æœ€å¤§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	uint32_t MaxInstanceCount = 1500;
	//ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—
	Matrix4x4 backToFrontMatrix;
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚³ãƒ³ãƒ†ãƒŠ
	std::unordered_map<std::string, ParticleGroup> particleGroups;

public:
	// getter
	ParticleGroup& GetGroup(const std::string& name) {
		assert(particleGroups.count(name));
		return particleGroups[name];
	}
	uint32_t GetMaxInstanceCount() const { return MaxInstanceCount; }

};

============================================================
File Path: project/engine/3d/Particle/ParticleModel.cpp
============================================================
#include "ParticleModel.h"
#include <MatrixVector.h>
#include <cassert>
#include <ModelManager.h>
#include <TextureManager.h>
#include <numbers>
#include <externals/DirectXTex/d3dx12.h>
#include <Object3dCommon.h>
#include <ResourceFactory.h>
#include <assimp/material.h>
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include<assimp/scene.h>
using namespace MatrixVector;
using namespace Microsoft::WRL;
using namespace PrimitiveGenerator;
using namespace ResourceFactory;

void ParticleModel::Initialize(DirectXCommon* birectxcommon, const std::string& filename) {
    // NULLæ¤œå‡º
    assert(birectxcommon);
    // ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²
    this->dxCommon_ = birectxcommon;
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ã®ç”Ÿæˆã¨åˆæœŸåŒ–
    MaterialGenerate();
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	if (vertexType_ == VertexType::Model) { // ãƒ¢ãƒ‡ãƒ«ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        modelDate = LoadObjFile("Resources/Particle", filename);
        VertexDataModel();  // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ”ãƒ¼
        //.objã®å‚ç…§ã—ã¦ã„ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
        TextureManager::GetInstance()->LoadTexture(modelDate.material.textureFilePath);
        // èª­ã¿è¾¼ã‚“ã ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç•ªå·ã‚’å–å¾—
        modelDate.material.textureindex = TextureManager::GetInstance()->GetSrvIndex(modelDate.material.textureFilePath);
	} else if (vertexType_ == VertexType::Ring) { // ãƒªãƒ³ã‚°ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        VertexDataRing();
	} else if (vertexType_ == VertexType::Sphere) { // çƒã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        VertexDataSphere();
	} else if (vertexType_ == VertexType::Cylinder) { // å††æŸ±ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        VertexDataCylinder();
	} else if (vertexType_ == VertexType::Star) { // æ˜Ÿã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        VertexDataStar();
    } else if (vertexType_ == VertexType::Spiral) { // ã‚¹ãƒ‘ã‚¤ãƒ©ãƒ«çŠ¶ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        VertexDataSpiral();
    } else if (vertexType_ == VertexType::Circle) { // ã‚µãƒ¼ã‚¯ãƒ«ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        VertexDataCircle();
    } else if (vertexType_ == VertexType::Box) { // æ­£æ–¹å½¢ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        VertexDataBox();
    } else if (vertexType_ == VertexType::Cloud) { // æ­£æ–¹å½¢ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        VertexDataCloud();
    }
}

void ParticleModel::Draw() {
    // VertexBufferView ã‚’è¨­å®š
    dxCommon_->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ç”¨ã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®š
    dxCommon_->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());
}

void ParticleModel::CreateVertexBuffer() {
    // é–¢æ•°åŒ–ã—ãŸResouceã§ä½œæˆ
    vertexResoruce = CreateBufferResource(dxCommon_->GetDevice(), sizeof(VertexData) * modelDate.vertices.size());
    //é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã™ã‚‹
    // ãƒªã‚½ãƒ¼ã‚¹ã®å…ˆé ­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ã†
    vertexBufferView.BufferLocation = vertexResoruce->GetGPUVirtualAddress();
    // ä½¿ç”¨ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã¯ã®é ‚ç‚¹ã®ã‚µã‚¤ã‚º
    vertexBufferView.SizeInBytes = UINT(sizeof(VertexData) * modelDate.vertices.size());
    // 1é ‚ç‚¹å½“ãŸã‚Šã®ã‚µã‚¤ã‚º
    vertexBufferView.StrideInBytes = sizeof(VertexData);
    // é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    vertexResoruce->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
}

void ParticleModel::VertexDataModel() {
    // å…±é€šã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼å‡¦ç†
    CreateVertexBuffer();
    std::memcpy(vertexData, modelDate.vertices.data(), sizeof(VertexData) * modelDate.vertices.size());
}

void ParticleModel::VertexDataRing() {
    const uint32_t kRingDivide = 32;
    const float kOuterRadius = 1.0f;
    const float kInnerRadius = 0.2f;
    vertexCount = kRingDivide * 6;
    // é ‚ç‚¹æ•°ã‚’è¨ˆç®—
    modelDate.vertices.resize(vertexCount);
    // å…±é€šã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼å‡¦ç†
    CreateVertexBuffer();
    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    modelDate.vertices = DrawRing(vertexData, kRingDivide, kOuterRadius, kInnerRadius);
}

void ParticleModel::VertexDataSphere() {
    const uint32_t kSubdivision = 16;
    vertexCount = kSubdivision * kSubdivision * 6;
    // é ‚ç‚¹æ•°ã‚’è¨ˆç®—
    modelDate.vertices.resize(vertexCount);
    // å…±é€šã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼å‡¦ç†
    CreateVertexBuffer();
    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    modelDate.vertices = DrawSphere(kSubdivision, vertexData);
}

void ParticleModel::VertexDataCylinder() {
    const uint32_t kCylinderDivide = 32;
    const float kTopRadius = 1.0f;
    const float kBottomRadius = 1.0f;
    const float kHeight = 3.0f;
    const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kCylinderDivide);
    vertexCount = kCylinderDivide * 6;
    // é ‚ç‚¹æ•°ã‚’è¨ˆç®—
    modelDate.vertices.resize(vertexCount);
    // å…±é€šã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼å‡¦ç†
    CreateVertexBuffer();
    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    modelDate.vertices = DrawCylinder(vertexData, kCylinderDivide, kTopRadius, kBottomRadius, kHeight);
}

void ParticleModel::VertexDataStar() {
    const uint32_t kNumPoints = 5;  // æ˜Ÿã®å…ˆç«¯æ•°
    const float kOuterRadius = 1.0f;
    const float kInnerRadius = 0.5f;
    vertexCount = kNumPoints * 6;
    // é ‚ç‚¹æ•°ã‚’è¨ˆç®—
    modelDate.vertices.resize(vertexCount);
    // å…±é€šã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼å‡¦ç†
    CreateVertexBuffer();
    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    modelDate.vertices = DrawStar(vertexData, kNumPoints, kOuterRadius, kInnerRadius);
}

void ParticleModel::VertexDataSpiral() {
    uint32_t kSpiralDiv = 100;
    vertexCount = kSpiralDiv + 1;
    // é ‚ç‚¹æ•°ã‚’è¨ˆç®—
    modelDate.vertices.resize(vertexCount);
    // å…±é€šã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼å‡¦ç†
    CreateVertexBuffer();
    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    DrawSpiral(kSpiralDiv, 5.0f, 10.0f, 3, vertexData);
}

void ParticleModel::MaterialGenerate() {
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹
    materialResource = CreateBufferResource(dxCommon_->GetDevice(), sizeof(Material));
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ç”¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸå€¤ã‚’æ›¸ãè¾¼ã‚€
    materialData->color = { 1.0f, 1.0f, 1.0f, 1.0f };
    materialData->endbleLighting = true;
    materialData->uvTransform = MakeIdentity4x4();
}

void ParticleModel::VertexDataCircle() {
    const uint32_t kSegmentCount = 64;
    const float kRadius = 1.0f;
    // é ‚ç‚¹æ•°ã¯ç·šã§å††ã‚’æ§‹æˆã™ã‚‹ã®ã§ segmentCount+1ï¼ˆãƒ«ãƒ¼ãƒ—é–‰ã˜ï¼‰
    vertexCount = (kSegmentCount + 1);
    modelDate.vertices.resize(vertexCount);
    // é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ä½œæˆ
    CreateVertexBuffer();
    modelDate.vertices = DrawCircle(vertexData, kSegmentCount, kRadius);
}

MaterialDate ParticleModel::LoadMaterialTemplateFile(const std::string& directoryPath, const std::string& filename) {
    // 1. ä¸­ã§å¿…è¦ã¨ãªã‚‹å¤‰æ•°ã®å®£è¨€
    MaterialDate materialDate; // æ§‹ç¯‰ã™ã‚‹MaterialDate
    std::string line; // ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã‚“ã 1è¡Œã‚’æ ¼ç´ã™ã‚‹ã‚‚ã®
    std::ifstream file(directoryPath + "/" + filename); // 2.ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
    assert(file.is_open()); // ã¨ã‚Šã‚ãˆãšé–‹ã‘ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹
    // 3. å®Ÿéš›ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿ã€MaterialDateã‚’æ§‹ç¯‰ã—ã¦ã„ã
    while (std::getline(file, line)) {
        std::string identifier;
        std::istringstream s(line);
        s >> identifier;

        // identifierã®å¿œã˜ãŸå‡¦ç†
        if (identifier == "map_Kd") {
            std::string textureFilename;
            s >> textureFilename;
            // é€£çµã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã«ã™ã‚‹
            materialDate.textureFilePath = directoryPath + "/" + textureFilename;
        }
    }
    return materialDate;
}

void ParticleModel::VertexDataCloud() {
    const int kCloudParts = 10; // é›²ã®æ§‹æˆè¦ç´ ï¼ˆå††ï¼‰ã®æ•°
    const float kRadius = 1.0f; // å„å††ã®åŠå¾„
    const float kSpread = 1.5f; // é›²ã®åºƒãŒã‚Š

    std::vector<VertexData> cloudVertices;

    for (int i = 0; i < kCloudParts; ++i) {
        // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«å††ã‚’é…ç½®
        float offsetX = ((rand() % 100) / 100.0f - 0.5f) * kSpread * 2.0f;
        float offsetY = ((rand() % 100) / 100.0f - 0.5f) * kSpread * 2.0f;

        // å„å††ã®é ‚ç‚¹ã‚’ç”Ÿæˆ
        std::vector<VertexData> part = GenerateCircle(offsetX, offsetY, 0.0f, kRadius, 32);
        cloudVertices.insert(cloudVertices.end(), part.begin(), part.end());
    }

    vertexCount = static_cast<int>(cloudVertices.size());
    modelDate.vertices = cloudVertices;

    CreateVertexBuffer();
    std::memcpy(vertexData, modelDate.vertices.data(), sizeof(VertexData) * vertexCount);
}


void ParticleModel::VertexDataBox() {
    vertexCount = 36; // ç«‹æ–¹ä½“ã¯å¸¸ã«36é ‚ç‚¹
    modelDate.vertices.resize(vertexCount);
    CreateVertexBuffer();
    modelDate.vertices = DrawBox(vertexData);
}

ModelDate ParticleModel::LoadObjFile(const std::string& directoryPath, const std::string& filename) {
    // 1. ä¸­ã§å¿…è¦ã¨ãªã‚‹å¤‰æ•°ã®å®£è¨€
    ModelDate modelDate; // æ§‹ç¯‰ã™ã‚‹ModelDate
    // 2. Assimpã§ã®èª­ã¿è¾¼ã¿
    Assimp::Importer importer;
    std::string filePath(directoryPath + "/" + filename); // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
    const aiScene* scene = importer.ReadFile(filePath.c_str(), aiProcess_Triangulate | aiProcess_FlipUVs);
    assert(scene->HasMeshes()); // ãƒ¡ãƒƒã‚·ãƒ¥ãŒãªã„ã®ã¯å¯¾å¿œã—ãªã„

    // 3. Meshã‚’è§£æžã™ã‚‹
    for (size_t meshIndex = 0; meshIndex < scene->mNumMeshes; ++meshIndex) {
        aiMesh* mesh = scene->mMeshes[meshIndex];
        assert(mesh->HasNormals()); // æ³•ç·šãŒãªã„Meshã¯ä»Šå›žã¯éžå¯¾å¿œ
        assert(mesh->HasTextureCoords(0)); // TexcoordãŒãªã„Meshã¯ä»Šå›žã¯éžå¯¾å¿œ
        // Meshã®ä¸­èº«(Face)ã‚’è§£æžã—ã¦ã„ã
        for (size_t faceIndex = 0; faceIndex < mesh->mNumFaces; ++faceIndex) {
            aiFace& face = mesh->mFaces[faceIndex];
            assert(face.mNumIndices == 3); // ä¸‰è§’å½¢ã®ã¿ã‚µãƒãƒ¼ãƒˆ
            // Faceã®ä¸­èº«(Vertex)ã‚’è§£æžã—ã¦ã„ã
            for (size_t elememt = 0; elememt < face.mNumIndices; ++elememt) {
                uint32_t vertexIndex = face.mIndices[elememt];
                // é ‚ç‚¹ã®å„è¦ç´ ã‚’å–å¾—
                aiVector3D& position = mesh->mVertices[vertexIndex];
                aiVector3D& normal = mesh->mNormals[vertexIndex];
                aiVector3D& texcoord = mesh->mTextureCoords[0][vertexIndex];
                // 1é ‚ç‚¹åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰ã—ã¦ModelDateã«è¿½åŠ ã—ã¦ã„ã
                VertexData vertex;
                vertex.position = { -position.x,position.y,position.z,1.0f };// ä½ç½®ã®xæˆåˆ†ã‚’åè»¢
                vertex.normal = { -normal.x,normal.y,normal.z };// æ³•ç·šã®xæˆåˆ†ã‚’åè»¢
                vertex.texcoord = { texcoord.x,texcoord.y };// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ã®yæˆåˆ†ã‚’åè»¢
                // aiProcess_MakeLeftHandedã¯z*=-1ã§ã€å³æ‰‹->å·¦æ‰‹ã«å¤‰æ›ã™ã‚‹ã®ã§æ‰‹å‹•ã§å¯¾å‡¦
                vertex.position.x *= -1.0f;
                vertex.normal.x *= -1.0f;
                modelDate.vertices.push_back(vertex);
            }
        }
    }
    // 4. Materialã®è§£æž
    for (size_t materialIndex = 0; materialIndex < scene->mNumMaterials; ++materialIndex) {
        aiMaterial* material = scene->mMaterials[materialIndex];
        if (material->GetTextureCount(aiTextureType_DIFFUSE) != 0) {
            aiString textureFilePath;
            material->GetTexture(aiTextureType_DIFFUSE, 0, &textureFilePath);
            modelDate.material.textureFilePath = directoryPath + "/" + textureFilePath.C_Str();
        }
    }

    // 5. ModelDateã‚’è¿”ã™
    return modelDate;
}

============================================================
File Path: project/engine/3d/Particle/ParticleModel.h
============================================================
#pragma once
#include<Model.h>
#include<DirectXCommon.h>	
#include<PrimitiveGenerator.h>

enum class VertexType {
	Model,
	Ring,
	Sphere,
	Cylinder,
	Star,
	Spiral,
	Circle,
	Box,
	Cloud,
};

// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ¢ãƒ‡ãƒ«
class ParticleModel
{
public:
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* birectxcommon, const std::string& filename);
	// æç”»å‡¦ç†
	void Draw();

private:
	// .mtlãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿å–ã‚Š
	static MaterialDate LoadMaterialTemplateFile(const std::string& directoryPath, const std::string& filename);
	// .objãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿å–ã‚Š
	static ModelDate LoadObjFile(const std::string& directoryPath, const std::string& filename);
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ä½œæˆ
	void CreateVertexBuffer();        // å…±é€šå‡¦ç†ã«ã™ã‚‹
	void VertexDataModel();
	void VertexDataRing();
	void VertexDataSphere();
	void VertexDataStar();
	void VertexDataCylinder();
	void VertexDataSpiral();
	void VertexDataCircle();
	void VertexDataBox();
	void VertexDataCloud();
	// ãƒžãƒ†ãƒªã‚¢ãƒ«
	void MaterialGenerate();
private:
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_;
	// Objãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ãƒ¼ã‚¿
	ModelDate modelDate;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> vertexResoruce;
	Microsoft::WRL::ComPtr<ID3D12Resource> materialResource;;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexData* vertexData = nullptr;
	Material* materialData = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ä½¿ã„é“ã‚’è£œè¶³ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView;

	VertexType vertexType_ = VertexType::Model;

	uint32_t vertexCount; // é ‚ç‚¹æ•°
public:

	size_t GetVertexCount() const { return modelDate.vertices.size(); }


	void SetVertexType(VertexType type) { vertexType_ = type; }

};

============================================================
File Path: project/engine/3d/Skybox.cpp
============================================================
#include "Skybox.h"
#include<SkyboxCommon.h>
#include <ResourceFactory.h>
#include <MatrixVector.h>
#include <CameraManager.h>
#include <TextureManager.h>
#define _USE_MATH_DEFINES
#include <math.h>

using namespace ResourceFactory;
using namespace MatrixVector;

void Skybox::Initialize(SkyboxCommon* skyboxCommon) {
    // NULLæ¤œå‡º
    assert(skyboxCommon);
    // å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
    this->skyboxCommon = skyboxCommon;
    this->camera = skyboxCommon->GetDefaultCamera();
    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
    VertexDatacreation();
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ã®ç”Ÿæˆã€åˆæœŸåŒ–
    MaterialGenerate();
    // WVP,Worldç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆã€åˆæœŸåŒ–
    TransformationMatrixGenerate();
    // ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆã€åˆæœŸåŒ–
    CameraForGPUGenerate();
}

void Skybox::Update() {   
    // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®ä½œæˆ
    Matrix4x4 worldMatrix = MakeAftineMatrix(transform_.scale, transform_.rotate, transform_.translate);
    // ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒ»ãƒ“ãƒ¥ãƒ¼ãƒ»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—
    Matrix4x4 worldViewProjectionMatrix;
    // ã‚«ãƒ¡ãƒ©ã‚’ CameraManager çµŒç”±ã§å–å¾—
    Camera* activeCamera = CameraManager::GetInstance()->GetActiveCamera();
    if (activeCamera) {
        const Matrix4x4& viewProjectionMatrix = activeCamera->GetViewProjectionMatrix();
        worldViewProjectionMatrix = Multiply(worldMatrix, viewProjectionMatrix);

        // ã‚«ãƒ¡ãƒ©ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’GPUç”¨ã«æ¸¡ã™
        cameraForGPUData->worldPosition = activeCamera->GetTranslate();
    } else {
        worldViewProjectionMatrix = worldMatrix;
        // ã‚«ãƒ¡ãƒ©ãŒãªã„å ´åˆã‚‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ã«ã—ã¦ãŠã
        cameraForGPUData->worldPosition = { 0.0f, 0.0f, -1000.0f };
    }

    transformationMatrixData->WVP = worldViewProjectionMatrix;
    transformationMatrixData->World = worldMatrix;
    // WorldInverseTransposeè¡Œåˆ—ã‚’å†è¨ˆç®—
    transformationMatrixData->WorldInverseTranspose = InverseTranspose(worldMatrix);
}

void Skybox::Draw() {
    // é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®è¨­å®š
    skyboxCommon->GetDxCommon()->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
    // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿[0] = b1 : ãƒžãƒ†ãƒªã‚¢ãƒ«ç”¨CBV
    skyboxCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());
    // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿[1] = b0 : å¤‰æ›è¡Œåˆ—ç”¨CBV
    skyboxCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(1, transformationMatrixResource->GetGPUVirtualAddress());
    // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿[2] = t0 : ã‚­ãƒ¥ãƒ¼ãƒ–ãƒžãƒƒãƒ—SRV
    skyboxCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2, TextureManager::GetInstance()->GetSrvHandleGPU(modelDate.material.textureFilePath));
    // æç”»å‘¼ã³å‡ºã—ã‚’å¤‰æ›´ï¼
    skyboxCommon->GetDxCommon()->GetCommandList()->DrawInstanced(vertexCount, 1, 0, 0);
}

void Skybox::SetTexture(const std::string& textureFilePath) {
    // ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å–å¾—
    modelDate.material.textureFilePath = "Resources/" + textureFilePath;
    // èª­ã¿è¾¼ã‚“ã ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç•ªå·ã‚’å–å¾—
    modelDate.material.textureindex = TextureManager::GetInstance()->GetSrvIndex(modelDate.material.textureFilePath);
}

std::unique_ptr<Skybox> Skybox::Create(const std::string& textureFilePath, Transform transform) {
    std::unique_ptr<Skybox> object = std::make_unique<Skybox>();
    // åˆæœŸåŒ–
    object->Initialize(SkyboxCommon::GetInstance());
    // ãƒ¢ãƒ‡ãƒ«ã‚’ã‚»ãƒƒãƒˆã™ã‚‹
    object->SetTexture(textureFilePath);
    // åº§æ¨™ã‚’ã‚»ãƒƒãƒˆ
    object->transform_ = transform;
    return object;
}

void Skybox::VertexDatacreation() {   
    // é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    modelDate.vertices = CreateSkyboxCubeVertices();
    // é ‚ç‚¹æ•°æ›´æ–°
    vertexCount = static_cast<uint32_t>(modelDate.vertices.size());
    // é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ç”¨ãƒªã‚½ãƒ¼ã‚¹ä½œæˆ
    vertexResoruce = CreateBufferResource(skyboxCommon->GetDxCommon()->GetDevice(), sizeof(VertexShaderInput) * vertexCount);
    // é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®è¨­å®š
    vertexBufferView.BufferLocation = vertexResoruce->GetGPUVirtualAddress();
    vertexBufferView.SizeInBytes = sizeof(VertexShaderInput) * vertexCount;
    vertexBufferView.StrideInBytes = sizeof(VertexShaderInput);
    // GPUãƒãƒƒãƒ•ã‚¡ã«æ›¸ãè¾¼ã¿ï¼ˆMap/Unmapï¼‰
    vertexResoruce->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
    memcpy(vertexData, modelDate.vertices.data(), sizeof(VertexShaderInput) * vertexCount);
    vertexResoruce->Unmap(0, nullptr);
}

void Skybox::MaterialGenerate() {
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹
    materialResource = CreateBufferResource(skyboxCommon->GetDxCommon()->GetDevice(), sizeof(Material));
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ç”¨ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));
    // ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸå€¤ã‚’æ›¸ãè¾¼ã‚€
    materialData->color = { 1.0f, 1.0f, 1.0f, 1.0f };
    materialData->uvTransform = MakeIdentity4x4();
}

void Skybox::TransformationMatrixGenerate() {
    // WVP,Worldç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹ã€‚TransformationMatrixã‚’ç”¨æ„ã™ã‚‹
    transformationMatrixResource = CreateBufferResource(skyboxCommon->GetDxCommon()->GetDevice(), sizeof(TransformationMatrix));
    // ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    transformationMatrixResource->Map(0, nullptr, reinterpret_cast<void**>(&transformationMatrixData));
    // å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
    transformationMatrixData->WVP = MakeIdentity4x4();
    transformationMatrixData->World = MakeIdentity4x4();
    // WorldInverseTransposeã‚’è¨ˆç®—ã—ã¦ã‚»ãƒƒãƒˆ
    transformationMatrixData->WorldInverseTranspose = InverseTranspose(transformationMatrixData->World);
}

void Skybox::CameraForGPUGenerate() {
    // ã‚«ãƒ¡ãƒ©ç”¨ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
    cameraResource = CreateBufferResource(skyboxCommon->GetDxCommon()->GetDevice(), sizeof(Skybox::CameraForGPU));
    // æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    cameraResource->Map(0, nullptr, reinterpret_cast<void**>(&cameraForGPUData));
    // å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
    if (camera) {
        cameraForGPUData->worldPosition = camera->GetTranslate();
    } else {
        // ã‚«ãƒ¡ãƒ©ãŒãªã„å ´åˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ã«ã—ã¦ãŠã
        cameraForGPUData->worldPosition = { 0.0f, 0.0f, -100.0f };
    }
}

std::vector<Skybox::VertexShaderInput> Skybox::CreateSkyboxCubeVertices()
{
    float halfSize = 1.0f;

    // 6é¢ Ã— 2ä¸‰è§’å½¢ Ã— 3é ‚ç‚¹ = 36é ‚ç‚¹
    Skybox::VertexShaderInput vertices[36] = {};

    // å³é¢ (+X)
    vertices[0].position = { halfSize,  halfSize,  halfSize, 1.0f };
    vertices[1].position = { halfSize, -halfSize,  halfSize, 1.0f };
    vertices[2].position = { halfSize,  halfSize, -halfSize, 1.0f };
    vertices[3].position = { halfSize,  halfSize, -halfSize, 1.0f };
    vertices[4].position = { halfSize, -halfSize,  halfSize, 1.0f };
    vertices[5].position = { halfSize, -halfSize, -halfSize, 1.0f };

    // å·¦é¢ (-X)
    vertices[6].position = { -halfSize,  halfSize, -halfSize, 1.0f };
    vertices[7].position = { -halfSize, -halfSize, -halfSize, 1.0f };
    vertices[8].position = { -halfSize,  halfSize,  halfSize, 1.0f };
    vertices[9].position = { -halfSize,  halfSize,  halfSize, 1.0f };
    vertices[10].position = { -halfSize, -halfSize, -halfSize, 1.0f };
    vertices[11].position = { -halfSize, -halfSize,  halfSize, 1.0f };

    // å‰é¢ (+Z)
    vertices[12].position = { -halfSize,  halfSize,  halfSize, 1.0f };
    vertices[13].position = { -halfSize, -halfSize,  halfSize, 1.0f };
    vertices[14].position = { halfSize,  halfSize,  halfSize, 1.0f };
    vertices[15].position = { halfSize,  halfSize,  halfSize, 1.0f };
    vertices[16].position = { -halfSize, -halfSize,  halfSize, 1.0f };
    vertices[17].position = { halfSize, -halfSize,  halfSize, 1.0f };

    // èƒŒé¢ (-Z)
    vertices[18].position = { halfSize,  halfSize, -halfSize, 1.0f };
    vertices[19].position = { halfSize, -halfSize, -halfSize, 1.0f };
    vertices[20].position = { -halfSize,  halfSize, -halfSize, 1.0f };
    vertices[21].position = { -halfSize,  halfSize, -halfSize, 1.0f };
    vertices[22].position = { halfSize, -halfSize, -halfSize, 1.0f };
    vertices[23].position = { -halfSize, -halfSize, -halfSize, 1.0f };

    // ä¸Šé¢ (+Y)
    vertices[24].position = { -halfSize,  halfSize, -halfSize, 1.0f };
    vertices[25].position = { halfSize,  halfSize, -halfSize, 1.0f };
    vertices[26].position = { -halfSize,  halfSize,  halfSize, 1.0f };
    vertices[27].position = { -halfSize,  halfSize,  halfSize, 1.0f };
    vertices[28].position = { halfSize,  halfSize, -halfSize, 1.0f };
    vertices[29].position = { halfSize,  halfSize,  halfSize, 1.0f };

    // åº•é¢ (-Y)
    vertices[30].position = { -halfSize, -halfSize,  halfSize, 1.0f };
    vertices[31].position = { halfSize, -halfSize,  halfSize, 1.0f };
    vertices[32].position = { -halfSize, -halfSize, -halfSize, 1.0f };
    vertices[33].position = { -halfSize, -halfSize, -halfSize, 1.0f };
    vertices[34].position = { halfSize, -halfSize,  halfSize, 1.0f };
    vertices[35].position = { halfSize, -halfSize, -halfSize, 1.0f };

    // æ­£è¦åŒ–ãŒå¿…è¦
    for (int i = 0; i < 36; ++i) {
        Vector3 dir = Vector3(vertices[i].position.x, vertices[i].position.y, vertices[i].position.z);
        dir = Normalize(dir);
        vertices[i].texcoord = dir;
    }

    return std::vector<VertexShaderInput>(vertices, vertices + 36);
}


============================================================
File Path: project/engine/3d/Skybox.h
============================================================
#pragma once
#include "Camera.h"
#include<TransformationMatrix.h>
#include <memory>
#include <wrl.h>
#include <d3d12.h>
#include<vector>
#include<Material.h>
#include<MaterialDate.h>

class SkyboxCommon;

//  3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
class Skybox {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	struct CameraForGPU
	{
		Vector3 worldPosition;
	};
	struct VertexShaderInput {
		Vector4 position{};
		Vector3 texcoord{};
	};

	struct skyModelDate {
		std::vector<VertexShaderInput> vertices;
		MaterialDate material;
	};

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// åˆæœŸåŒ–
	void Initialize(SkyboxCommon* skyboxCommon);
	// æ›´æ–°å‡¦ç†
	void Update();
	// æç”»å‡¦ç†
	void Draw();
	std::vector<VertexShaderInput> CreateSkyboxCubeVertices();
	void SetTexture(const std::string& textureFilePath);
	
	static std::unique_ptr<Skybox> Create(const std::string& textureFilePath, Transform transform);

private:
	// ãƒªã‚½ãƒ¼ã‚¹
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ä½œæˆ
	void VertexDatacreation();
	// ãƒžãƒ†ãƒªã‚¢ãƒ«
	void MaterialGenerate();
	// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ãƒžãƒˆãƒªãƒƒã‚¯ã‚¹
	void TransformationMatrixGenerate();
	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹
	void CameraForGPUGenerate();
private:
	// ãƒã‚¤ãƒ³ã‚¿
	SkyboxCommon* skyboxCommon = nullptr;
	Camera* camera = nullptr;
	// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	skyModelDate modelDate;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> vertexResoruce;
	Microsoft::WRL::ComPtr <ID3D12Resource> materialResource;
	Microsoft::WRL::ComPtr <ID3D12Resource> transformationMatrixResource;
	Microsoft::WRL::ComPtr<ID3D12Resource> cameraResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexShaderInput* vertexData = nullptr;
	Material* materialData = nullptr;
	TransformationMatrix* transformationMatrixData = nullptr;
	CameraForGPU* cameraForGPUData = nullptr;

	uint32_t vertexCount;
	Transform transform_;
public:
	// getter
	const Transform& GetTransform() const { return transform_; }
	const Vector3& GetScale() const { return transform_.scale; }
	const Vector3& GetRotate() const { return transform_.rotate; }		
	const Vector3& GetTranslate() const { return transform_.translate; }
	//setter
	void SetTransform(const Transform& transform) { this->transform_ = transform; }	
	void SetScale(const Vector3& scale) { this->transform_.scale = scale; }
	void SetRotate(const Vector3& rotate) { this->transform_.rotate = rotate; }
	void SetTranslate(const Vector3& translate) { this->transform_.translate = translate; }
};

============================================================
File Path: project/engine/3d/SkyboxCommon.cpp
============================================================
#include "SkyboxCommon.h"
#include <Logger.h>
#include <StringUtility.h>
#include <ShaderCompiler.h>
#include<DsvManager.h>

using namespace Microsoft::WRL;

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<SkyboxCommon> SkyboxCommon::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
SkyboxCommon* SkyboxCommon::GetInstance() {
    if (!instance) {
        instance = std::make_unique<SkyboxCommon>();
    }
    return instance.get();
}

// çµ‚äº†
void SkyboxCommon::Finalize() {
    instance.reset();  // `delete` ä¸è¦
}

void SkyboxCommon::Initialize(DirectXCommon* dxCommon,DsvManager* dsvManager) {
    assert(dxCommon); 
    assert(dsvManager);
    // å¼•æ•°ã‚’å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
    dxCommon_ = dxCommon;
    dsvManager_ = dsvManager;
    // Skybox ã§ã¯æ·±åº¦æ›¸ãè¾¼ã¿ã‚’ç„¡åŠ¹åŒ–        
    skyboxDepthStencilDesc.DepthEnable = true;
    skyboxDepthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
    skyboxDepthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
    // ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
    GraphicsPipelineGenerate();
}

void SkyboxCommon::Commondrawing() {
    // RootSignatureã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‘ã©åˆ¥é€”è¨­å®šãŒå¿…è¦
    dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
    dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
    // å½¢çŠ¶ã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã¯ã¾ãŸåˆ¥ã€‚åŒã˜ã‚‚ã®ã‚’è¨­å®šã™ã‚‹
    dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}

void SkyboxCommon::RootSignatureGenerate() {
    HRESULT hr;

    // SRVï¼ˆã‚­ãƒ¥ãƒ¼ãƒ–ãƒžãƒƒãƒ—ï¼‰ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¬ãƒ³ã‚¸è¨­å®š
    D3D12_DESCRIPTOR_RANGE descriptorRange{};
    descriptorRange.BaseShaderRegister = 0;
    descriptorRange.NumDescriptors = 1;
    descriptorRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
    descriptorRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

    // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆMaterialå®šæ•°ãƒãƒƒãƒ•ã‚¡ã€Transformå®šæ•°ãƒãƒƒãƒ•ã‚¡ã€SRVã€å¿…è¦ã«å¿œã˜ã¦è¿½åŠ ï¼‰
    D3D12_ROOT_PARAMETER rootParameters[3] = {};

    // rootParameters[0]: gMaterial â†’ register(b1)
    rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
    rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
    rootParameters[0].Descriptor.ShaderRegister = 1; // â† b1 ã«ä¿®æ­£ï¼

    // rootParameters[1]: gTransformationMatrix â†’ register(b0)ï¼ˆå¤‰æ›´ãªã—ï¼‰
    rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
    rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
    rootParameters[1].Descriptor.ShaderRegister = 0; // b0

    // ã‚­ãƒ¥ãƒ¼ãƒ–ãƒžãƒƒãƒ—ç”¨ SRVï¼ˆPixelShaderç”¨ï¼‰
    rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
    rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
    rootParameters[2].DescriptorTable.NumDescriptorRanges = 1;
    rootParameters[2].DescriptorTable.pDescriptorRanges = &descriptorRange;

    // ã‚µãƒ³ãƒ—ãƒ©ãƒ¼ï¼ˆãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿ï¼‰
    D3D12_STATIC_SAMPLER_DESC staticSampler{};
    staticSampler.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
    staticSampler.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    staticSampler.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    staticSampler.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    staticSampler.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
    staticSampler.MaxLOD = D3D12_FLOAT32_MAX;
    staticSampler.ShaderRegister = 0;
    staticSampler.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

    // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£è¨˜è¿°å­
    D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc{};
    rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
    rootSignatureDesc.NumParameters = _countof(rootParameters);
    rootSignatureDesc.pParameters = rootParameters;
    rootSignatureDesc.NumStaticSamplers = 1;
    rootSignatureDesc.pStaticSamplers = &staticSampler;

    // ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã¨ç”Ÿæˆ
    ComPtr<ID3DBlob> signatureBlob;
    ComPtr<ID3DBlob> errorBlob;
    hr = D3D12SerializeRootSignature(&rootSignatureDesc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
    if (FAILED(hr)) {
        Logger::Log(reinterpret_cast<const char*>(errorBlob->GetBufferPointer()));
        assert(false);
    }

    hr = dxCommon_->GetDevice()->CreateRootSignature(
        0,
        signatureBlob->GetBufferPointer(),
        signatureBlob->GetBufferSize(),
        IID_PPV_ARGS(&rootSignature));
    assert(SUCCEEDED(hr));
}

void SkyboxCommon::GraphicsPipelineGenerate() {
    // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
    RootSignatureGenerate();
    HRESULT hr;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------InputLayoutè¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_INPUT_ELEMENT_DESC inputElementDescs[2] = {};
    inputElementDescs[0].SemanticName = "POSITION";
    inputElementDescs[0].SemanticIndex = 0;
    inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
    inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    inputElementDescs[1].SemanticName = "TEXCOORD";
    inputElementDescs[1].SemanticIndex = 0;
    inputElementDescs[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
    inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

    D3D12_INPUT_LAYOUT_DESC inputLayoutDesc{};
    inputLayoutDesc.pInputElementDescs = inputElementDescs;
    inputLayoutDesc.NumElements = _countof(inputElementDescs);

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------BlendStateã®è¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_BLEND_DESC blendDesc{};
    //å…¨ã¦ã®è‰²è¦ç´ ã‚’æ›¸ãè¾¼ã‚€
    blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
    blendDesc.RenderTarget[0].BlendEnable = TRUE;
    blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
    blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
    blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
    blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;           // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;         // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;         // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //===== RasterizerStateã®è¨­å®šã‚’è¡Œã† ======//   
    D3D12_RASTERIZER_DESC rasterizerDesc{};
    //è£é¢(æ™‚è¨ˆå›žã‚Š)ã‚’è¡¨ç¤ºã—ãªã„
    rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
    //ä¸‰è§’å½¢ã®ä¸­ã‚’å¡—ã‚Šã¤ã¶ã™
    rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

    /*----------------------------------------------------------------------------------*/
    /*--------------------------------Shaderã‚’Compile-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    ComPtr <IDxcBlob> vertexShaderBlob = ShaderCompiler::GetInstance()->CompileShader(L"Resources/shaders/Skybox/Skybox.VS.hlsl", L"vs_6_0");
    assert(vertexShaderBlob != nullptr);
    ComPtr <IDxcBlob> pixelShaderBlob = ShaderCompiler::GetInstance()->CompileShader(L"Resources/shaders/Skybox/Skybox.PS.hlsl", L"ps_6_0");
    assert(pixelShaderBlob != nullptr);

    /*-----------------------------------------------------------------------------------*/
    /*-------------------------------------PSOç”Ÿæˆ----------------------------------------*/
    /*-----------------------------------------------------------------------------------*/
    D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
    graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();   // RootSignature
    graphicsPipelineStateDesc.InputLayout = inputLayoutDesc;    // InputLayout
    graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };  // VertexShader
    graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };    // PixelShader
    graphicsPipelineStateDesc.BlendState = blendDesc;// BlendState
    graphicsPipelineStateDesc.RasterizerState = rasterizerDesc; //RasterizerState
    // æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
    graphicsPipelineStateDesc.NumRenderTargets = 1;
    graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
    //åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸(å½¢çŠ¶)ã®ã‚¿ã‚¤ãƒ—
    graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
    // ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã‹ã®è¨­å®š(æ°—ã«ã—ãªãã¦è‰¯ã„)
    graphicsPipelineStateDesc.SampleDesc.Count = 1;
    graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
    // DepthStencilã®è¨­å®š
    graphicsPipelineStateDesc.DepthStencilState = skyboxDepthStencilDesc;
    graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;

    // å®Ÿéš›ã«ç”Ÿæˆ
    hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));
    assert(SUCCEEDED(hr));
}


============================================================
File Path: project/engine/3d/SkyboxCommon.h
============================================================
#pragma once
#include"DirectXCommon.h"
#include"Camera.h"

class DsvManager;

// ç®±ã®å…±é€šéƒ¨
class SkyboxCommon {
private:
	static std::unique_ptr<SkyboxCommon> instance;

	SkyboxCommon(SkyboxCommon&) = delete;
	SkyboxCommon& operator=(SkyboxCommon&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	SkyboxCommon() = default;
	~SkyboxCommon() = default;

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static SkyboxCommon* GetInstance();
	// çµ‚äº†
	void Finalize();
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* dxCommon,DsvManager* dsvManager);
	// å…±é€šæç”»è¨­å®š
	void Commondrawing();

private:
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	void RootSignatureGenerate();
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	void GraphicsPipelineGenerate();
	// DsvManager ã‹ã‚‰å…ƒã®è¨­å®šã‚’å–å¾—
	D3D12_DEPTH_STENCIL_DESC skyboxDepthStencilDesc;
private:
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_;
	DsvManager* dsvManager_;
	Camera* defaultCamera = nullptr;
	// RootSignature
	Microsoft::WRL::ComPtr <ID3D12RootSignature> rootSignature = nullptr;
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
public:
	// setter
	void SetDefaultCamera(Camera* camera) { this->defaultCamera = camera; }
	// getter
	DirectXCommon* GetDxCommon() const { return  dxCommon_; }
	Camera* GetDefaultCamera() const { return defaultCamera; }
};

============================================================
File Path: project/engine/audio/SoundLoader.cpp
============================================================
#include "SoundLoader.h"
#include <cassert>

using namespace Microsoft::WRL;

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<SoundLoader> SoundLoader::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
SoundLoader* SoundLoader::GetInstance() {
    if (!instance) {
        instance = std::make_unique<SoundLoader>();
    }
    return instance.get();
}

// çµ‚äº†
void SoundLoader::Finalize() {
    GetIXAudio2();
    instance.reset();
}

void SoundLoader::Initialize() {
    HRESULT result;
    // XAudioã‚¨ãƒ³ã‚¸ãƒ³ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
    result = XAudio2Create(&xAudio2, 0, XAUDIO2_DEFAULT_PROCESSOR);
    // ãƒžã‚¹ã‚¿ãƒ¼ãƒœã‚¤ã‚¹ã®ç”Ÿæˆ
    result = xAudio2->CreateMasteringVoice(&masterVoice);
}

SoundData SoundLoader::SoundLoadWave(const char* filename)
{
    // â‘ ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³
    // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
    std::ifstream file;
    // Resources/Audio/ ã‚’å‰ã«ã¤ã‘ã¦ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ§‹ç¯‰
    std::string fullPath = "Resources/Audio/" + std::string(filename);
    // .wavãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§é–‹ã
    file.open(fullPath, std::ios_base::binary);
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³å¤±æ•—ã‚’æ¤œå‡ºã™ã‚‹
    assert(file.is_open());
    // â‘¡.wavãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    // RIFFãƒ˜ãƒƒãƒ€ãƒ¼ã®èª­ã¿è¾¼ã¿
    RiffHeader riff;
    file.read((char*)&riff, sizeof(riff));
    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒRIFFã‹ãƒã‚§ãƒƒã‚¯
    if (strncmp(riff.chunk.id, "RIFF", 4) != 0) {
        assert(0);
    }
    // ã‚¿ã‚¤ãƒ—ãŒWAVEã‹ãƒã‚§ãƒƒã‚¯
    if (strncmp(riff.type, "WAVE", 4) != 0) {
        assert(0);
    }
    // Formatãƒãƒ£ãƒ³ã‚¯ã®èª­ã¿è¾¼ã¿
    FormatChunk format = {};
    // ãƒãƒ£ãƒ³ã‚¯ãƒ˜ãƒƒãƒ€ãƒ¼ã®ç¢ºèª
    file.read((char*)&format, sizeof(ChunkHeader));
    if (strncmp(format.chunk.id, "fmt ", 4) != 0) {
        assert(0);
    }
    // ãƒãƒ£ãƒ³ã‚¯æœ¬ä½“ã®èª­ã¿è¾¼ã¿
    assert(format.chunk.size <= sizeof(format.fmt));
    file.read((char*)&format.fmt, format.chunk.size);
    // Dataãƒãƒ£ãƒ³ã‚¯ã®èª­ã¿è¾¼ã¿
    ChunkHeader data;
    file.read((char*)&data, sizeof(data));
    // JUNKãƒãƒ£ãƒ³ã‚¯ã‚’æ¤œå‡ºã—ãŸå ´åˆ
    if (strncmp(data.id, "JUNK", 4) == 0) {
        // èª­ã¿å–ã‚Šä½ç½®ã‚’JUNKãƒãƒ£ãƒ³ã‚¯ã®çµ‚ã‚ã‚Šã¾ã§é€²ã‚ã‚‹
        file.seekg(data.size, std::ios_base::cur);
        // å†èª­ã¿è¾¼ã¿
        file.read((char*)&data, sizeof(data));
    }
    if (strncmp(data.id, "data", 4) != 0) {
        assert(0);
    }
    // Dataãƒãƒ£ãƒ³ã‚¯ã®ãƒ‡ãƒ¼ã‚¿éƒ¨(æ³¢å½¢ãƒ‡ãƒ¼ã‚¿)ã®èª­ã¿è¾¼ã¿
    char* pBuffer = new char[data.size];
    file.read(pBuffer, data.size);
    // Waveãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
    file.close();

    // â‘£èª­ã¿è¾¼ã‚“ã éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’return
    SoundData soundData = {};
    soundData.wfex = format.fmt;
    soundData.pBuffer = reinterpret_cast<BYTE*>(pBuffer);
    soundData.bufferSize = data.size;
    return soundData;
}


============================================================
File Path: project/engine/audio/SoundLoader.h
============================================================
#pragma once
#include<xaudio2.h>
#pragma comment(lib,"xaudio2.lib")
#include<fstream>
#include <wrl.h>

// ãƒãƒ£ãƒ³ã‚¯ãƒ˜ãƒƒãƒ€
struct ChunkHeader
{
    char id[4]; // ãƒãƒ£ãƒ³ã‚¯æ¯Žã®ID
    int32_t size; // ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º
};

// RIFFãƒ˜ãƒƒãƒ€ãƒãƒ£ãƒ³ã‚¯
struct RiffHeader
{
    ChunkHeader chunk; // "RIFF"
    char type[4]; // "WAVE"
};

// FMTãƒãƒ£ãƒ³ã‚¯
struct FormatChunk
{
    ChunkHeader chunk; // "fmt"
    WAVEFORMATEX fmt; // æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ
};

// éŸ³å£°ãƒ‡ãƒ¼ã‚¿
struct SoundData
{
    // æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ
    WAVEFORMATEX wfex;
    // ãƒãƒƒãƒ•ã‚¡ã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹
    BYTE* pBuffer;
    // ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚º
    unsigned int bufferSize;
};

class SoundLoader
{
private:
    static std::unique_ptr<SoundLoader> instance;

    SoundLoader(SoundLoader&) = delete;
    SoundLoader& operator=(SoundLoader&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    SoundLoader() = default;
    ~SoundLoader() = default;

    // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
    static SoundLoader* GetInstance();
    // çµ‚äº†
    void Finalize();
    // åˆæœŸåŒ–
    void Initialize();
    // wavãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
    static SoundData SoundLoadWave(const char* filename);
private:// ãƒ¡ãƒ³ãƒå¤‰æ•°
    Microsoft::WRL::ComPtr<IXAudio2> xAudio2;
    IXAudio2MasteringVoice* masterVoice;
public:
    // getter
    Microsoft::WRL::ComPtr<IXAudio2> GetIXAudio2() const { return xAudio2; }
};

============================================================
File Path: project/engine/audio/SoundPlayer.cpp
============================================================
#include "SoundPlayer.h"
#include <cassert>

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<SoundPlayer> SoundPlayer::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
SoundPlayer* SoundPlayer::GetInstance() {
    if (!instance) {
        instance = std::make_unique<SoundPlayer>();
    }
    return instance.get();
}

// çµ‚äº†
void SoundPlayer::Finalize() {
    instance.reset();
}

void SoundPlayer::Initialize(SoundLoader* soundLoader) {
    // NULLæ¤œå‡º
    assert(soundLoader);
    // ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²
    this->soundLoader_ = soundLoader;
}

void SoundPlayer::SoundPlayWave(const SoundData& soundData, bool loop) {
    HRESULT result;

    // æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã‚’å…ƒã«SourceVoiceã®ç”Ÿæˆ
    IXAudio2SourceVoice* pSourceVoice = nullptr;
    result = soundLoader_->GetIXAudio2()->CreateSourceVoice(&pSourceVoice, &soundData.wfex);
    assert(SUCCEEDED(result));

    // å†ç”Ÿã™ã‚‹æ³¢å½¢ãƒ‡ãƒ¼ã‚¿ã®è¨­å®š
    XAUDIO2_BUFFER buf{};
    buf.pAudioData = soundData.pBuffer;
    buf.AudioBytes = soundData.bufferSize;

    // å†ç”Ÿã‚’ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã‹ã©ã†ã‹
    if (loop) {
        // ç„¡é™ãƒ«ãƒ¼ãƒ—
        buf.LoopCount = XAUDIO2_LOOP_INFINITE;
    } else {
        // 1åº¦ã ã‘å†ç”Ÿ
        buf.Flags = XAUDIO2_END_OF_STREAM;
    }

    // æ³¢å½¢ãƒ‡ãƒ¼ã‚¿ã®å†ç”Ÿ
    result = pSourceVoice->SubmitSourceBuffer(&buf);
    result = pSourceVoice->Start();
}

void SoundPlayer::SoundUnload(SoundData* soundData)
{
    // ãƒãƒƒãƒ•ã‚¡ã®ãƒ¡ãƒ¢ãƒªã‚’è§£æ”¾
    delete[] soundData->pBuffer;
    soundData->pBuffer = 0;
    soundData->bufferSize = 0;
    soundData->wfex = {};
}

============================================================
File Path: project/engine/audio/SoundPlayer.h
============================================================
#pragma once
#include "SoundLoader.h"

// éŸ³å£°å†ç”Ÿ
class SoundPlayer {
private:
    static std::unique_ptr<SoundPlayer> instance;

    SoundPlayer(SoundPlayer&) = delete;
    SoundPlayer& operator=(SoundPlayer&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    SoundPlayer() = default;
    ~SoundPlayer() = default;

    // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
    static SoundPlayer* GetInstance();
    // çµ‚äº†
    void Finalize();
    // åˆæœŸåŒ–
    void Initialize(SoundLoader* soundLoader);
    // éŸ³å£°å†ç”Ÿ
    void SoundPlayWave(const SoundData& soundData, bool loop);
    // éŸ³å£°ãƒ‡ãƒ¼ã‚¿è§£æ”¾
    void SoundUnload(SoundData* soundData);
private:
    SoundLoader* soundLoader_ = nullptr;
};

============================================================
File Path: project/engine/base/CopylmageCommon.cpp
============================================================
#include "CopylmageCommon.h"
#include <ShaderCompiler.h>
#include "Logger.h"
#include "StringUtility.h"
#include<SrvManager.h>
#include<RtvManager.h>
#include<DsvManager.h>

using namespace Microsoft::WRL;

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<CopylmageCommon> CopylmageCommon::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
CopylmageCommon* CopylmageCommon::GetInstance() {
    if (!instance) {
        instance = std::make_unique<CopylmageCommon>();
    }
    return instance.get();
}

// çµ‚äº†
void CopylmageCommon::Finalize() {
    instance.reset();  // `delete` ä¸è¦
}

void CopylmageCommon::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, RtvManager* rtvManager, DsvManager* dsvManager) {
    assert(dxCommon);
    assert(srvManager);
    assert(rtvManager);
    assert(dsvManager);
    // å¼•æ•°ã‚’å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
    dxCommon_ = dxCommon;
    dsvManager_ = dsvManager;
    // ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
    GraphicsPipelineGenerate();
    // SRVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®å–å¾—
    srvIndex = srvManager->CreateSRVForRenderTexture(rtvManager->GetrenderTextureResource());

    // --- æ™‚é–“ç”¨å®šæ•°ãƒãƒƒãƒ•ã‚¡ä½œæˆ ---
    D3D12_HEAP_PROPERTIES heapProps{};
    heapProps.Type = D3D12_HEAP_TYPE_UPLOAD;

    D3D12_RESOURCE_DESC resourceDesc{};
    resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
    resourceDesc.Width = (sizeof(float) + 255) & ~255; // 256ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ³
    resourceDesc.Height = 1;
    resourceDesc.DepthOrArraySize = 1;
    resourceDesc.MipLevels = 1;
    resourceDesc.SampleDesc.Count = 1;
    resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

    dxCommon_->GetDevice()->CreateCommittedResource(
        &heapProps,
        D3D12_HEAP_FLAG_NONE,
        &resourceDesc,
        D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr,
        IID_PPV_ARGS(&timeConstBuffer_));

    // ãƒžãƒƒãƒ”ãƒ³ã‚°
    timeConstBuffer_->Map(0, nullptr, reinterpret_cast<void**>(&mappedTime_));
}

void CopylmageCommon::Commondrawing(SrvManager* srvManager) {
     // ---- æ™‚é–“ã‚’æ›´æ–° ----
    mappedTime_->time += 1.0f / 60.0f; // æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ é€²ã‚€ã€‚

    // RootSignatureã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‘ã©åˆ¥é€”è¨­å®šãŒå¿…è¦
    dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
    dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
    // å½¢çŠ¶ã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã¯ã¾ãŸåˆ¥ã€‚åŒã˜ã‚‚ã®ã‚’è¨­å®šã™ã‚‹
    dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	// SRVã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã¸ãƒã‚¤ãƒ³ãƒ‰
    srvManager->SetGraphicsRootDescriptorTable(0, srvIndex);
       // å®šæ•°ãƒãƒƒãƒ•ã‚¡ï¼ˆb0ï¼‰ã‚’ã‚»ãƒƒãƒˆ
    dxCommon_->GetCommandList()->SetGraphicsRootConstantBufferView(1, timeConstBuffer_->GetGPUVirtualAddress());
    // æç”»å‘½ä»¤ã‚’å‡ºã™
    dxCommon_->GetCommandList()->DrawInstanced(3, 1, 0, 0);
}

void CopylmageCommon::RootSignatureGenerate() {
    HRESULT hr;

    // ===== DescriptorTable(SRV) ===== //
    D3D12_DESCRIPTOR_RANGE descriptorRange{};
    descriptorRange.BaseShaderRegister = 0;
    descriptorRange.NumDescriptors = 1;
    descriptorRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
    descriptorRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

    // ===== Root Parameters ===== //
    D3D12_ROOT_PARAMETER rootParameters[2] = {};

    // SRV (ã‚³ãƒ”ãƒ¼å…ƒãƒ†ã‚¯ã‚¹ãƒãƒ£)
    rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
    rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
    rootParameters[0].DescriptorTable.NumDescriptorRanges = 1;
    rootParameters[0].DescriptorTable.pDescriptorRanges = &descriptorRange;

    // CBVï¼ˆãƒˆãƒ¼ãƒ³ãƒžãƒƒãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãªã©ã€å¿…è¦ã«å¿œã˜ã¦ï¼‰
    rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
    rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
    rootParameters[1].Descriptor.ShaderRegister = 0;

    // ===== Static Sampler ===== //
    D3D12_STATIC_SAMPLER_DESC staticSampler{};
    staticSampler.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
    staticSampler.AddressU = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
    staticSampler.AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
    staticSampler.AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
    staticSampler.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
    staticSampler.ShaderRegister = 0;
    staticSampler.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
    staticSampler.MaxLOD = D3D12_FLOAT32_MAX;

    // ===== Root Signature Description ===== //
    D3D12_ROOT_SIGNATURE_DESC rootSigDesc{};
    rootSigDesc.NumParameters = _countof(rootParameters);
    rootSigDesc.pParameters = rootParameters;
    rootSigDesc.NumStaticSamplers = 1;
    rootSigDesc.pStaticSamplers = &staticSampler;
    rootSigDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;

    // ===== Serialize and Create Root Signature ===== //
    ComPtr<ID3DBlob> signatureBlob;
    ComPtr<ID3DBlob> errorBlob;
    hr = D3D12SerializeRootSignature(&rootSigDesc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
    if (FAILED(hr)) {
        if (errorBlob) {
            Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
        }
        assert(false);
    }

    hr = dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
    assert(SUCCEEDED(hr));
}


void CopylmageCommon::GraphicsPipelineGenerate() {
    // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
    RootSignatureGenerate();
    HRESULT hr;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------InputLayoutè¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/

    D3D12_INPUT_LAYOUT_DESC inputLayoutDesc{};
    inputLayoutDesc.pInputElementDescs = nullptr;
    inputLayoutDesc.NumElements = 0;

    /*----------------------------------------------------------------------------------*/
    /*---------------------------------BlendStateã®è¨­å®š-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    D3D12_BLEND_DESC blendDesc{};
    //å…¨ã¦ã®è‰²è¦ç´ ã‚’æ›¸ãè¾¼ã‚€
    blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
    blendDesc.RenderTarget[0].BlendEnable = TRUE;
    blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
    blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
    blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
    blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;           // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€è‰²ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹è‰² (ã‚½ãƒ¼ã‚¹ã‚«ãƒ©â€•)
    blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;         // ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€Î±ã€‚PixeShaderã‹ã‚‰å‡ºåŠ›ã™ã‚‹Î±å€¤ (ã‚½ãƒ¼ã‚¹ã‚¢ãƒ«ãƒ•ã‚¡)
    blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;         // ã™ã§ã«æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹è‰² (ãƒ‡ã‚¹ãƒˆã‚«ãƒ©ãƒ¼)

    //===== RasterizerStateã®è¨­å®šã‚’è¡Œã† ======//   
    D3D12_RASTERIZER_DESC rasterizerDesc{};
    //è£é¢(æ™‚è¨ˆå›žã‚Š)ã‚’è¡¨ç¤ºã—ãªã„
    rasterizerDesc.CullMode = D3D12_CULL_MODE_BACK;
    //ä¸‰è§’å½¢ã®ä¸­ã‚’å¡—ã‚Šã¤ã¶ã™
    rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

    /*----------------------------------------------------------------------------------*/
    /*--------------------------------Shaderã‚’Compile-----------------------------------*/
    /*----------------------------------------------------------------------------------*/
    ComPtr <IDxcBlob> vertexShaderBlob = ShaderCompiler::GetInstance()->CompileShader(L"Resources/shaders/Fullscreen/Fullscreen.VS.hlsl", L"vs_6_0");
    assert(vertexShaderBlob != nullptr);
    type_ = PixelShaderType::Fullscreen; // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’é¸æŠž
    ComPtr <IDxcBlob> pixelShaderBlob = ShaderCompiler::GetInstance()->CompileShader(GetPixelShaderPath(type_), L"ps_6_0");
    assert(pixelShaderBlob != nullptr);

    /*-----------------------------------------------------------------------------------*/
    /*-------------------------------------PSOç”Ÿæˆ----------------------------------------*/
    /*-----------------------------------------------------------------------------------*/
    D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
    graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();   // RootSignature
    graphicsPipelineStateDesc.InputLayout = inputLayoutDesc;    // InputLayout
    graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };  // VertexShader
    graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };    // PixelShader
    graphicsPipelineStateDesc.BlendState = blendDesc;// BlendState
    graphicsPipelineStateDesc.RasterizerState = rasterizerDesc; //RasterizerState
    // æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
    graphicsPipelineStateDesc.NumRenderTargets = 1;
    graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
    //åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸(å½¢çŠ¶)ã®ã‚¿ã‚¤ãƒ—
    graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
    // ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã‹ã®è¨­å®š(æ°—ã«ã—ãªãã¦è‰¯ã„)
    graphicsPipelineStateDesc.SampleDesc.Count = 1;
    graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
    // DepthStencilã®è¨­å®š
    graphicsPipelineStateDesc.DepthStencilState = dsvManager_->GetDepthStencilDesc();
    graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;

    // å®Ÿéš›ã«ç”Ÿæˆ
    hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));
    assert(SUCCEEDED(hr));
}

std::wstring CopylmageCommon::GetPixelShaderPath(PixelShaderType type) {
    switch (type) {
    case PixelShaderType::Fullscreen:
        return L"Resources/shaders/Fullscreen/Fullscreen.PS.hlsl";
    case PixelShaderType::Vignette:
        return L"Resources/shaders/Fullscreen/Vignette.PS.hlsl";
    case PixelShaderType::BoxFilter:
        return L"Resources/shaders/Fullscreen/BoxFilter.PS.hlsl";
    case PixelShaderType::GaussianFilter:
        return L"Resources/shaders/Fullscreen/GaussianFilter.PS.hlsl";
    case PixelShaderType::LuminancsBasedOutline:
        return L"Resources/shaders/Fullscreen/LuminancsBasedOutline.PS.hlsl";
    case PixelShaderType::RadialBlur:
        return L"Resources/shaders/Fullscreen/RadialBlur.PS.hlsl";
    case PixelShaderType::Random:
        return L"Resources/shaders/Fullscreen/Random.PS.hlsl";
    default:
        return L"";
    }
}

============================================================
File Path: project/engine/base/CopylmageCommon.h
============================================================
#pragma once
#include"DirectXCommon.h"

class SrvManager;
class RtvManager;
class DsvManager;

struct TimeBuffer {
	float time;
};

class CopylmageCommon
{
private:
	static std::unique_ptr<CopylmageCommon> instance;

	CopylmageCommon(CopylmageCommon&) = delete;
	CopylmageCommon& operator=(CopylmageCommon&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	CopylmageCommon() = default;
	~CopylmageCommon() = default;

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static CopylmageCommon* GetInstance();
	// çµ‚äº†
	void Finalize();
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager,RtvManager* rtvManager,DsvManager* dsvManager);
	// å…±é€šæç”»è¨­å®š
	void Commondrawing(SrvManager* srvManager);
private:
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ç¨®é¡ž
	enum class PixelShaderType {
		Fullscreen,
		Vignette,
		BoxFilter,
		GaussianFilter,
		LuminancsBasedOutline,			
		RadialBlur,		
		Random,
	};
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’å–å¾—
	std::wstring GetPixelShaderPath(PixelShaderType type);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	void RootSignatureGenerate();
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	void GraphicsPipelineGenerate();
	// SRVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	uint32_t srvIndex;
private:
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_;		
	DsvManager* dsvManager_;
	// RootSignature
	Microsoft::WRL::ComPtr <ID3D12RootSignature> rootSignature = nullptr;
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚¿ã‚¤ãƒ—
	PixelShaderType type_;
	Microsoft::WRL::ComPtr <ID3D12Resource> timeConstBuffer_;
	TimeBuffer* mappedTime_;
public:
	// gettre
	DirectXCommon* GetDxCommon() const { return  dxCommon_; }
};

============================================================
File Path: project/engine/base/DirectXCommon/DescriptorUtils.cpp
============================================================
#include "DescriptorUtils.h"

namespace DescriptorUtils {

    D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(Microsoft::WRL::ComPtr <ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorsize, uint32_t index) {

        D3D12_CPU_DESCRIPTOR_HANDLE handleCPU = descriptorHeap->GetCPUDescriptorHandleForHeapStart();
        handleCPU.ptr += (descriptorsize * index);
        return handleCPU;
    }

    D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(Microsoft::WRL::ComPtr <ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorsize, uint32_t index) {
        D3D12_GPU_DESCRIPTOR_HANDLE handleGPU = descriptorHeap->GetGPUDescriptorHandleForHeapStart();
        handleGPU.ptr += (descriptorsize * index);
        return handleGPU;
    }
}

============================================================
File Path: project/engine/base/DirectXCommon/DescriptorUtils.h
============================================================
#pragma once
#include <d3d12.h>
#include <wrl.h>
#include<cstdint>

namespace DescriptorUtils {
	/// <summary>
	/// æŒ‡å®šç•ªå·ã®CPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(Microsoft::WRL::ComPtr <ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorsize, uint32_t index);

	/// <summary>
	/// æŒ‡å®šç•ªå·ã®GPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—ã‚’ã™ã‚‹
	/// </summary>
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(Microsoft::WRL::ComPtr<ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorsize, uint32_t index);
};

============================================================
File Path: project/engine/base/DirectXCommon/DirectXCommon.cpp
============================================================
#include "DirectXCommon.h"
#include <cassert>
#include <format>
#include <thread>
#include <Logger.h>
#include <StringUtility.h>
#include <DescriptorUtils.h>
#include <ResourceFactory.h>
#pragma comment(lib,"d3d12.lib")
#pragma comment(lib,"dxgi.lib")

using namespace Microsoft::WRL;
using namespace DescriptorUtils;
using namespace ResourceFactory;

DirectXCommon::~DirectXCommon() { viewport_.reset(); }

void DirectXCommon::Initialize(WinApp* winApp){ 
    // NULLæ¤œå‡º
    assert(winApp);
    // ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²
    this->winApp_ = winApp;    
    // ãƒã‚¤ãƒ³ã‚¿ç”Ÿæˆ 
    viewport_ = std::make_unique<ViewportManager>();  
    fence_ = std::make_unique<FenceManager>();
    fpscontroller_ = std::make_unique<FPSController>();
    swapchain_ = std::make_unique<SwapChainManager>();
    // åˆæœŸåŒ–é–¢æ•°
    fpscontroller_->Initialize();                                                     // FPSå›ºå®šã®åˆæœŸåŒ–
	DebugInitialize();	                                                              // ãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–
	CommandInitialize();	                                                          // ã‚³ãƒžãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–
    swapchain_->Initialize(winApp_->Gethwnd(), commandQueue, dxgiFactory, // ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ç”Ÿæˆ
    WinApp::kClientWidth, WinApp::kClientHeight);
	CreateDepthStencilGenerate();	                                                  // æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
    fence_->Initialize(device);                                                       // ãƒ•ã‚§ãƒ³ã‚¹ã®åˆæœŸåŒ–
    viewport_->Initialize(WinApp::kClientWidth,WinApp::kClientHeight);                // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆãƒ» ã‚·ã‚¶ãƒªãƒ³ã‚°çŸ©å½¢ã®åˆæœŸåŒ–
}

void DirectXCommon::DebugInitialize() {

    HRESULT hr;

    ///---------------------------------------------------------------------///
    ///-----------------------ãƒ‡ãƒãƒƒã‚¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚ªãƒ³----------------------------///
    ///---------------------------------------------------------------------///
#ifdef _DEBUG
    ComPtr <ID3D12Debug1> debugController = nullptr;

    if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)))) {
        //ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æœ‰åŠ¹åŒ–
        debugController->EnableDebugLayer();
        //ã•ã‚‰ã«GPUå´ã§ã‚‚ãƒã‚§ãƒƒã‚¯ã‚’è¡Œãˆã‚‹ã‚ˆã†ã«ã™ã‚‹
        debugController->SetEnableGPUBasedValidation(TRUE);
    }
#endif // _DEBUG

    ///---------------------------------------------------------------------///
    ///----------------------IDXGIã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ç”Ÿæˆ---------------------------///
    ///---------------------------------------------------------------------///

    // HRESULTã¯Windowsç³»ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Šã€
    // é–¢æ•°ãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’SUCCEEDEDãƒžã‚¯ãƒ­ã§åˆ¤å®šã§ãã‚‹
    hr = CreateDXGIFactory(IID_PPV_ARGS(&dxgiFactory));
    //åˆæœŸåŒ–ã®æ ¹æœ¬çš„ãªéƒ¨åˆ†ã§ã‚¨ãƒ©ãƒ¼ãŒå‡ºãŸå ´åˆã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒé–“é•ã£ã¦ã„ã‚‹ã‹ã€ã©ã†ã«ã‚‚ã§ããªã„å ´åˆãŒ
    //å¤šã„ã®ã§assertã«ã™ã‚‹
    assert(SUCCEEDED(hr));

    ///---------------------------------------------------------------------///
    ///--------------------------ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®åˆ—æŒ™------------------------------///
    ///---------------------------------------------------------------------///
    //ä»•æ§˜ã™ã‚‹ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ç”¨ã®å¤‰æ•°ã€‚æœ€åˆã«nullptrã‚’å…¥ã‚Œã¦ãŠã
    ComPtr <IDXGIAdapter4> useAdapter = nullptr;
    //è‰¯ã„é †ã«ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚’é ¼ã‚€
    for (UINT i = 0; dxgiFactory->EnumAdapterByGpuPreference(i,
        DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE, IID_PPV_ARGS(&useAdapter)) !=
        DXGI_ERROR_NOT_FOUND; ++i) {
        //ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹
        DXGI_ADAPTER_DESC3 adapterDesc{};
        hr = useAdapter->GetDesc3(&adapterDesc);
        assert(SUCCEEDED(hr));//å–å¾—ã§ããªã„ã®ã¯ä¸€å¤§äº‹
        //ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã§ãªã‘ã‚Œã°æŽ¡ç”¨
        if (!(adapterDesc.Flags & DXGI_ADAPTER_FLAG3_SOFTWARE)) {
            //æŽ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ã®æƒ…å ±ã‚’ãƒ­ã‚°ã«å‡ºåŠ›ã€‚wstringã®æ–¹ãªã®ã§æ³¨æ„
            Logger::Log(StringUtility::ConvertString(std::format(L"Use Adapater:{}\n", adapterDesc.Description)));
            break;
        }
        useAdapter = nullptr;//ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¢ãƒ€ãƒ—ã‚¿ã®å ´åˆã¯è¦‹ãªã‹ã£ãŸã“ã¨ã«ã™ã‚‹
    }
    //é©åˆ‡ãªã‚¢ãƒ€ãƒ—ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã®ã§èµ·å‹•ã§ããªã„
    assert(useAdapter != nullptr);

    ///---------------------------------------------------------------------///
    ///---------------------------ãƒ‡ãƒã‚¤ã‚¹ã®ç”Ÿæˆ------------------------------///
    ///---------------------------------------------------------------------///
    
    //æ©Ÿèƒ½ãƒ¬ãƒ™ãƒ«ã¨ãƒ­ã‚°å‡ºåŠ›ç”¨ã®æ–‡å­—åˆ—
    D3D_FEATURE_LEVEL featureLevels[] = {
      D3D_FEATURE_LEVEL_12_2,D3D_FEATURE_LEVEL_12_1,D3D_FEATURE_LEVEL_12_0
    };
    const char* featureLevelStrings[] = { "12.2","12.1","12.0" };
    //é«˜ã„é †ã«ç”Ÿæˆã§ãã‚‹ã‹è©¦ã™
    for (size_t i = 0; i < _countof(featureLevels); ++i) {
        //æŽ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã§ãƒ‡ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ
        hr = D3D12CreateDevice(useAdapter.Get(), featureLevels[i], IID_PPV_ARGS(&device));
        //æŒ‡å®šã—ãŸæ©Ÿèƒ½ãƒ¬ãƒ™ãƒ«ã§ãƒ‡ãƒã‚¤ã‚¹ãŒç”Ÿæˆã§ããŸã‹ç¢ºèª
        if (SUCCEEDED(hr)) {
            //ç”Ÿæˆã§ããŸã®ã§ãƒ­ã‚°å‡ºåŠ›ã‚’è¡Œã£ã¦ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
            Logger::Log(std::format("FeatureLevel : {}\n", featureLevelStrings[i]));
            break;
        }
    }
    //ãƒ‡ãƒã‚¤ã‚¹ã®ç”ŸæˆãŒã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
    assert(device != nullptr);
    Logger::Log("Complete create D3D12Device!!!\n");//åˆæœŸåŒ–å®Œäº†ã®ãƒ­ã‚°ã‚’å‡ºã™

    ///---------------------------------------------------------------------///
    ///-------------------------ã‚¨ãƒ©ãƒ¼æ™‚ã«ãƒ–ãƒ¬â€•ã‚¯-----------------------------///
    ///--------------------------------------------------------------------///
#ifdef _DEBUG
    ComPtr<ID3D12InfoQueue> infoQueue = nullptr;
    if (SUCCEEDED(device->QueryInterface(IID_PPV_ARGS(&infoQueue)))) {
        //ãƒ¤ãƒã‚¤ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
        infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
        //ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
        infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);
        //è­¦å‘Šæ™‚ã«æ­¢ã¾ã‚‹
        infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true);
        //æŠ‘åˆ¶ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ID
        D3D12_MESSAGE_ID denyIds[] = {
            //Windows11ã§ã®DXGIãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨DX12ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›¸äº’ä½œç”¨ãƒã‚°ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            //https://stackoverflow.com/questions/69805245/directx-12-application-is-crashing-in-windows-11
            D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE
        };
        //æŠ‘åˆ¶ã™ã‚‹ãƒ¬ãƒ™ãƒ«
        D3D12_MESSAGE_SEVERITY severities[] = { D3D12_MESSAGE_SEVERITY_INFO };
        D3D12_INFO_QUEUE_FILTER filter{};
        filter.DenyList.NumIDs = _countof(denyIds);
        filter.DenyList.pIDList = denyIds;
        filter.DenyList.NumSeverities = _countof(severities);
        filter.DenyList.pSeverityList = severities;
        //æŒ‡å®šã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤ºã‚’æŠ‘åˆ¶
        infoQueue->PushStorageFilter(&filter);
    }
#endif
}

void DirectXCommon::CommandInitialize() {

    HRESULT hr;
    ///---------------------------------------------------------------------///
    ///------------------------ã‚³ãƒžãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹-------------------------///
    ///---------------------------------------------------------------------///
    D3D12_COMMAND_QUEUE_DESC commandQueueDesc{};
    hr = device->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(&commandQueue));
    //ã‚³ãƒžãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã®ç”ŸæˆãŒã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
    assert(SUCCEEDED(hr));

    ///---------------------------------------------------------------------///
    ///---------------------ã‚³ãƒžãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’ç”Ÿæˆã™ã‚‹-------------------------///
    ///---------------------------------------------------------------------///
    //ã‚³ãƒžãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹
    hr = device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocator));
    //ã‚³ãƒžãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã®ç”ŸæˆãŒã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
    assert(SUCCEEDED(hr));

    ///---------------------------------------------------------------------///
    ///------------------------ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹-------------------------///
    ///---------------------------------------------------------------------///
    //ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆã™ã‚‹
    hr = device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator.Get(), nullptr, IID_PPV_ARGS(&commandList));
    //ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ç”ŸæˆãŒã†ã¾ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
    assert(SUCCEEDED(hr));
}

void DirectXCommon::CreateDepthStencilGenerate() {

    // ç”Ÿæˆã™ã‚‹Resourceã®è¨­å®š
    D3D12_RESOURCE_DESC resourceDesc{};
    resourceDesc.Width = WinApp::kClientWidth; // Textureã®å¹…
    resourceDesc.Height = WinApp::kClientHeight; // Textureã®é«˜ã•
    resourceDesc.MipLevels = 1; // mipmapã®æ•°
    resourceDesc.DepthOrArraySize = 1; // å¥¥è¡Œã€€or é…åˆ—ã®Textureé…åˆ—æ•°
    resourceDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT; // DepthStencilã¨ã—ã¦åˆ©ç”¨å¯èƒ½ãªãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ
    resourceDesc.SampleDesc.Count = 1; // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆ 1å›ºå®š
    resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D; // 2æ¬¡å…ƒ
    resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL; // DepthStencilã¨ã—ã¦ä½¿ã†é€šçŸ¥

    // åˆ©ç”¨Heapã®è¨­å®š
    D3D12_HEAP_PROPERTIES heapProperies{};
    heapProperies.Type = D3D12_HEAP_TYPE_DEFAULT; // VRAWä¸Šã«ä½œã‚‹

    // æ·±åº¦å€¤ã®ã‚¯ãƒªã‚¢è¨­å®š
    D3D12_CLEAR_VALUE depthClearValue{};
    depthClearValue.DepthStencil.Depth = 1.0f; // 1.0f (æœ€å¤§å€¤)ã§ã‚¯ãƒªã‚¢
    depthClearValue.Format = DXGI_FORMAT_D24_UNORM_S8_UINT; // ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã€‚ Resourceã¨åˆã‚ã›ã‚‹

    //3. Resourceã‚’ç”Ÿæˆã™ã‚‹
    HRESULT hr = device->CreateCommittedResource(
        &heapProperies, //Heapã®è¨­å®š
        D3D12_HEAP_FLAG_NONE, //Heapã®ç‰¹æ®Šãªè¨­å®šã€‚ç‰¹ã«ãªã—ã€‚
        &resourceDesc, //Resourceã®è¨­å®š
        D3D12_RESOURCE_STATE_DEPTH_WRITE, //æ·±åº¦å€¤ã‚’æ›¸ãè¾¼ã‚€çŠ¶æ…‹ã«ã—ã¦ãŠã
        &depthClearValue, //Clearæœ€é©å€¤
        IID_PPV_ARGS(&depthbufferresource)); //ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
    assert(SUCCEEDED(hr));
}

void DirectXCommon::PreDrawRenderTexture(D3D12_CPU_DESCRIPTOR_HANDLE RtvHandles, Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> DsvDescriptorHeap, const Vector4 color) {
    // æç”»å…ˆ = rtvHandles[2]ï¼ˆä¸­é–“ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼‰
    D3D12_CPU_DESCRIPTOR_HANDLE rtHandle = RtvHandles;

    dsvHandle = DsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart();
    commandList->OMSetRenderTargets(1, &rtHandle, false, &dsvHandle);

    // ã‚«ã‚¹ã‚¿ãƒ RenderTargetç”¨ã§è¨­å®šã—ãŸå€¤ã‚’ä½¿ã£ã¦ç”»é¢å…¨ä½“ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
    float clearColor[] = { color.x, color.y, color.z, color.w };
    commandList->ClearRenderTargetView(rtHandle, clearColor, 0, nullptr);
    commandList->ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
    commandList->RSSetViewports(1, &viewport_->GetViewport());
    commandList->RSSetScissorRects(1, &viewport_->GetScissorRect());
}

void DirectXCommon::PreDraw(D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle,Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> DsvDescriptorHeap) {
    // ã“ã“ã‹ã‚‰æ›¸ãè¾¼ã‚€ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    UINT backBufferIndex = swapchain_->GetSwapChain()->GetCurrentBackBufferIndex();
    // ä»Šå›žã®ãƒãƒªã‚¢ã¯Transition
    barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    // Noneã«ã—ã¦ãŠã
    barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
    // ãƒãƒªã‚¢ã‚’å¼µã‚‹å¯¾è±¡ã®ãƒªã‚½ãƒ¼ã‚¹ã€‚ç¾åœ¨ã®ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã«å¯¾ã—ã¦è¡Œã†
    barrier.Transition.pResource = swapchain_->GetBuffer(backBufferIndex).Get();
    // é·ç§»å‰ã®ResourceState
    barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
    // é·ç§»å¾Œã®ResourceState
    barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
    // TransitionBarrierã‚’å¼µã‚‹
    commandList->ResourceBarrier(1, &barrier);
    // æç”»å…ˆã®RTVã¨DSVã‚’è¨­å®šã™ã‚‹
    dsvHandle = DsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart();
    // æç”»å…ˆã®RTVã‚’æŒ‡å®šã™ã‚‹
    commandList->OMSetRenderTargets(1, &rtvHandle, false, &dsvHandle);
    // æŒ‡å®šã—ãŸè‰²ã§ç”»é¢å…¨ä½“ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
    float clearColor[] = { 0.1f,0.25f,0.5f,1.0f };//é’ã£ã½ã„è‰²ã€‚RGBAã®é †
    commandList->ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
    commandList->RSSetViewports(1, &viewport_->GetViewport());
    commandList->RSSetScissorRects(1, &viewport_->GetScissorRect());
    // æŒ‡å®šã—ãŸæ·±åº¦ã§ç”»é¢å…¨ä½“ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
    commandList->ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
}

void DirectXCommon::PostDrow() {
    HRESULT hr;
    // ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ç•ªå·ã‚’å–å¾—
    UINT bbIndex = swapchain_->GetSwapChain()->GetCurrentBackBufferIndex();
    // ç”»é¢ã«æãå‡¦ç†ã¯ã™ã¹ã¦çµ‚ã‚ã‚Šã€ç”»é¢ã«ç§»ã™ã®ã§ã€çŠ¶æ…‹ã‚’é·ç§»
    // ä»Šå›žã¯RenderTargetã‹ã‚‰Presentã«ã™ã‚‹
    // PostDrow å†…ã§å†è¨­å®šãŒå¿…è¦ï¼ˆPreDrawã¨ã¯åˆ¥ãƒ•ãƒ¬ãƒ¼ãƒ ãªã®ã§ï¼‰ï¼š
    barrier.Transition.pResource = swapchain_->GetBuffer(bbIndex).Get();
    barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
    barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
    // TransitionBarrierã‚’å¼µã‚‹
    commandList->ResourceBarrier(1, &barrier);
    // ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºå®šã•ã›ã‚‹ã€‚å…¨ã¦ã®ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚“ã§ã‹ã‚‰Closeã™ã‚‹ã“ã¨
    hr = commandList->Close();
    assert(SUCCEEDED(hr));
    if (FAILED(hr)) {
        OutputDebugStringA("commandList->Close() failed!\n");
        // hr ã‚’èª¿ã¹ã‚‹
    }
    // GPUã«ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒªã‚¹ãƒˆã®å®Ÿè¡Œã‚’è¡Œã‚ã›ã‚‹
    ID3D12CommandList* commandLists[] = { commandList.Get() };
    commandQueue->ExecuteCommandLists(1, commandLists);
    // GPUã¨OSã«ç”»é¢ã®äº¤æ›ã‚’è¡Œã†ã‚ˆã†ã«é€šçŸ¥ã™ã‚‹
    swapchain_->GetSwapChain()->Present(1, 0);
 
    // æç”»å¾Œã®Fence
    fence_->SignalAndWait(commandQueue);
 
    //  FPSå›ºå®š
    fpscontroller_->Update();

    // æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ã®ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æº–å‚™
    hr = commandAllocator->Reset();
    assert(SUCCEEDED(hr));
    hr = commandList->Reset(commandAllocator.Get(), nullptr);
    assert(SUCCEEDED(hr));
}

ComPtr <ID3D12DescriptorHeap> DirectXCommon::CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE heapType, UINT numDescriptors, bool shaderVisible){
    //ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
    ComPtr <ID3D12DescriptorHeap> descriptorHeap = nullptr;
    D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc{};
    descriptorHeapDesc.Type = heapType;
    descriptorHeapDesc.NumDescriptors = numDescriptors;
    descriptorHeapDesc.Flags = shaderVisible ? D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE : D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
    HRESULT hr = device->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&descriptorHeap));
    //ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ãŒä½œã‚Œãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
    assert(SUCCEEDED(hr));
    return descriptorHeap;
}

============================================================
File Path: project/engine/base/DirectXCommon/DirectXCommon.h
============================================================
#pragma once
#include<d3d12.h>
#include<dxgi1_6.h>
#include<wrl.h>
#include<array>
#include<dxcapi.h>
#include<chrono>
#include<WinApp.h>
#include <Vector4.h>
#include <ViewportManager.h>
#include <FenceManager.h>
#include <FPSController.h>
#include<SwapChainManager.h>
#include "externals/DirectXTex/DirectXTex.h"
#pragma comment(lib,"dxcompiler.lib")

// DirectxåŸºç›¤
class DirectXCommon
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°

	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~DirectXCommon();
	// åˆæœŸåŒ–
	void Initialize(WinApp* winApp);
	// æç”»å‰å‡¦ç†
	void PreDraw(D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle,Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> DsvDescriptorHeap);
	// æç”»å¾Œå‡¦ç†
	void PostDrow();

	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	void PreDrawRenderTexture(D3D12_CPU_DESCRIPTOR_HANDLE RtvHandles, Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> DsvDescriptorHeap, const Vector4 color);

	/// <summary>
	/// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ç”Ÿæˆã™ã‚‹
	/// </summary>
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE heapType, UINT numDescriptors, bool shaderVisible);

private: // ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ãƒ³ãƒé–¢æ•°
	// ãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–
	void DebugInitialize();
	// ã‚³ãƒžãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–
	void CommandInitialize();
	// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	void CreateDepthStencilGenerate();
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒã‚¤ãƒ³ã‚¿
	WinApp* winApp_ = nullptr;
    std::unique_ptr<ViewportManager> viewport_;
    std::unique_ptr<FenceManager> fence_;	
	std::unique_ptr<FPSController> fpscontroller_;	
	std::unique_ptr<SwapChainManager> swapchain_;
	Microsoft::WRL::ComPtr <ID3D12Device> device;	                                  // Devicex12ãƒ‡ãƒã‚¤ã‚¹
	Microsoft::WRL::ComPtr <IDXGIFactory7> dxgiFactory;		                          // DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒª
	Microsoft::WRL::ComPtr <ID3D12CommandAllocator> commandAllocator = nullptr;	      // ã‚³ãƒžãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿
	Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> commandList;		              // ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	Microsoft::WRL::ComPtr <ID3D12CommandQueue> commandQueue;			              // ã‚³ãƒžãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼
	Microsoft::WRL::ComPtr<ID3D12Resource> depthbufferresource;			              // æ·±åº¦ãƒãƒƒãƒ•ã‚¡
	// TransitionBarrierã®è¨­å®š
	D3D12_RESOURCE_BARRIER barrier{};
	// æç”»å…ˆã®RTVã¨DSVã‚’è¨­å®šã™ã‚‹
	D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle;
public:
	// getter
	Microsoft::WRL::ComPtr <ID3D12Device> GetDevice() { return device; }
	Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> GetCommandList() const { return commandList.Get(); }
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ãƒªã‚½ãƒ¼ã‚¹ã®æ•°ã‚’å–å¾—
	SwapChainManager* GetSwapChain() { return swapchain_.get(); }
};

============================================================
File Path: project/engine/base/DirectXCommon/FPSController.cpp
============================================================
#include "FPSController.h"
#include <thread>

void FPSController::Initialize() {
    // ç¾åœ¨æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
    reference_ = std::chrono::steady_clock::now();
}

void FPSController::Update() {
    // 1/60ç§’ã´ã£ãŸã‚Šã®æ™‚é–“
    const std::chrono::microseconds kMinTime(uint64_t(1000000.0f / 60.0f));
    // 1/60ç§’ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“
    const std::chrono::microseconds kMinCheckTime(uint64_t(1000000.0f / 65.0f));

    // ç¾åœ¨æ™‚é–“ã‚’å–å¾—ã™ã‚‹
    std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();
    // å‰å›žè¨˜éŒ²ã‹ã‚‰ã®çµŒéŽæ™‚é–“ã‚’å–å¾—ã™ã‚‹
    std::chrono::microseconds elapsed =
        std::chrono::duration_cast<std::chrono::microseconds>(now - reference_);

    // 1/60ç§’ (ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“)ã€€çµŒã£ã¦ã„ãªã„å ´åˆ
    if (elapsed < kMinCheckTime) {
        // 1/60ç§’çµŒéŽã™ã‚‹ã¾ã§å¾®å°ãªã‚¹ãƒªãƒ¼ãƒ—ã‚’ç¹°ã‚Šè¿”ã™
        while (std::chrono::steady_clock::now() - reference_ < kMinTime) {
            // 1ãƒžã‚¤ã‚¯ãƒ­ç§’ã‚¹ãƒªãƒ¼ãƒ—
            std::this_thread::sleep_for(std::chrono::microseconds(1));
        }
    }
    // ç¾åœ¨æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
    reference_ = std::chrono::steady_clock::now();
}

============================================================
File Path: project/engine/base/DirectXCommon/FPSController.h
============================================================
#pragma once
#include <chrono>

// FPSå›ºå®š
class FPSController {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// FPSå›ºå®šåˆæœŸåŒ–(ç¾åœ¨æ™‚åˆ»ã‚’åŸºæº–ã«ã™ã‚‹ï¼‰
	/// </summary>
	void Initialize();
	//  FPSå›ºå®šæ›´æ–°
	void Update();	
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// è¨˜éŒ²æ™‚é–“(FPSå›ºå®š)
	std::chrono::steady_clock::time_point reference_;
};

============================================================
File Path: project/engine/base/DirectXCommon/FenceManager.cpp
============================================================
#include "FenceManager.h"
#include <cassert>

using namespace Microsoft::WRL;

FenceManager::~FenceManager() {
    if (fenceEvent_) {
        // Win32APIã®é–‹æ”¾
        CloseHandle(fenceEvent_);        
        fenceEvent_ = nullptr;
    }
}

void FenceManager::Initialize(ComPtr <ID3D12Device>& device) {
	// ãƒ•ã‚§ãƒ³ã‚¹ã®åˆæœŸåŒ–	  
    HRESULT hr;
    //åˆæœŸå€¤0ã§Fenceã‚’ä½œã‚‹
    hr = device->CreateFence(fenceVal_, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence_));
    assert(SUCCEEDED(hr));
    //Fenceã®Signalã‚’å¾…ã¤ãŸã‚ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹
    assert(fenceEvent_ != nullptr);
}


void FenceManager::SignalAndWait(ComPtr <ID3D12CommandQueue>& commandQueue) {    
    // Fenceã®å€¤ã®æ›´æ–°
    fenceVal_++;
    // GPUãŒã“ã“ã¾ã§ãŸã©ã‚Šç€ã„ãŸã¨ãã«ã€Fenceã®å€¤ã«ä»£å…¥ã™ã‚‹ã‚ˆã†ã«Signalã‚’é€ã‚‹
    commandQueue->Signal(fence_.Get(), fenceVal_);
    // Fenceã®å€¤ãŒæŒ‡å®šã—ãŸSignalå€¤ã«ãŸã©ã‚Šç€ã„ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
    // GetCompletedValueã®åˆæœŸå€¤ã¯Fenceä½œæˆæ™‚ã«æ¸¡ã—ãŸåˆæœŸå€¤
    if (fence_->GetCompletedValue() < fenceVal_) {

        // æŒ‡å®šã—ãŸSignalã«ãŸã©ã‚Šã¤ã„ã¦ã„ãªã„ã®ã§ã€ãŸã©ã‚Šç€ãã¾ã§å¾…ã¤ã‚ˆã†ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®šã™ã‚‹
        fence_->SetEventOnCompletion(fenceVal_, fenceEvent_);
        //ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¾…ã¤
        WaitForSingleObject(fenceEvent_, INFINITE);
    }
}

============================================================
File Path: project/engine/base/DirectXCommon/FenceManager.h
============================================================
#pragma once
#include<d3d12.h>
#include<dxgi1_6.h>
#include<wrl.h>

// ãƒ•ã‚§ãƒ³ã‚¹ãƒžãƒãƒ¼ã‚¸ãƒ£
class FenceManager
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	~FenceManager();
    /// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    void Initialize(Microsoft::WRL::ComPtr <ID3D12Device>& device);
	// æç”»å¾Œã®Fenceã®å€¤    
	void SignalAndWait(Microsoft::WRL::ComPtr <ID3D12CommandQueue>& commandQueue);
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ•ã‚§ãƒ³ã‚¹ã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr <ID3D12Fence> fence_ = nullptr;
	// åˆæœŸå€¤0ã§Fenceã‚’ä½œã‚‹
	UINT64 fenceVal_ = 0;
	//Fenceã®Signalã‚’å¾…ã¤ãŸã‚ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹
	HANDLE fenceEvent_ = CreateEvent(NULL, FALSE, FALSE, NULL);	
public: // getter
	const Microsoft::WRL::ComPtr <ID3D12Fence>& GetFence() const { return fence_; }
    const HANDLE& GetfenceEvent() const { return fenceEvent_; }
};

============================================================
File Path: project/engine/base/DirectXCommon/ShaderCompiler.cpp
============================================================
#include "ShaderCompiler.h"
#include <Logger.h>
#include <StringUtility.h>
#include <format>
#include <cassert>

using namespace Microsoft::WRL;

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<ShaderCompiler> ShaderCompiler::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
ShaderCompiler* ShaderCompiler::GetInstance() {
    if (!instance) {
        instance = std::make_unique<ShaderCompiler>();
    }
    return instance.get();
}

// çµ‚äº†
void ShaderCompiler::Finalize() {
    instance.reset();  // `delete` ä¸è¦
}

void ShaderCompiler::Initialize() { 
    // DXCã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ç”Ÿæˆ
    HRESULT hr;

    // dxCompilerã‚’åˆæœŸåŒ–
    hr = DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&dxcUtils));
    assert(SUCCEEDED(hr));
    hr = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&dxcCompiler));
    assert(SUCCEEDED(hr));
    //ç¾æ™‚ç‚¹ã§includeã¯ã—ãªã„ãŒã€includeã«å¯¾å¿œã™ã‚‹ãŸã‚ã®è¨­å®šã‚’è¡Œã£ã¦ã„ã
    hr = dxcUtils->CreateDefaultIncludeHandler(&includeHandler);
    assert(SUCCEEDED(hr));
}

ComPtr <IDxcBlob> ShaderCompiler::CompileShader(const std::wstring& filePath,const wchar_t* profile) {
    //1.hlslãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€
    //ã“ã‚Œã‹ã‚‰ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹æ—¨ã‚’ãƒ­ã‚°ã«å‡ºã™
    Logger::Log(StringUtility::ConvertString(std::format(L"Begin CompileShader,path:{},profile:{}\n", filePath, profile)));
    Microsoft::WRL::ComPtr <IDxcBlobEncoding> shaderSource = nullptr;
    HRESULT hr = dxcUtils->LoadFile(filePath.c_str(), nullptr, &shaderSource);
    //èª­ã‚ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹
    assert(SUCCEEDED(hr));

    //èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’è¨­å®šã™ã‚‹
    DxcBuffer shaderSourceBuffer;
    shaderSourceBuffer.Ptr = shaderSource->GetBufferPointer();
    shaderSourceBuffer.Size = shaderSource->GetBufferSize();
    shaderSourceBuffer.Encoding = DXC_CP_UTF8;//UTF8ã®ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’é€šçŸ¥
    
    //2.Compileã™ã‚‹
    LPCWSTR arguments[] =
    {

         filePath.c_str(),
         L"-E",L"main",
         L"-T",profile,
         L"-Zi",L"-Qembed_debug",
         L"-Od",
         L"-Zpr",
    };
    //å®Ÿéš›ã«shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
    ComPtr <IDxcResult> shaderResult = nullptr;
    hr = dxcCompiler->Compile(
        &shaderSourceBuffer,
        arguments,
        _countof(arguments),
        includeHandler.Get(),
        IID_PPV_ARGS(&shaderResult)
    );
    assert(SUCCEEDED(hr));

    //è­¦å‘Šãƒ»ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ãŸã‚‰ãƒ­ã‚°ã‚’å‡ºã—ã¦æ­¢ã‚ã‚‹
    ComPtr <IDxcBlobUtf8> shaderError = nullptr;
    shaderResult->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&shaderError), nullptr);
    if (shaderError != nullptr && shaderError->GetStringLength() != 0) {
        Logger::Log(shaderError->GetStringPointer());
        assert(false);
    }
    //ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæžœã‹ã‚‰å®Ÿè¡Œç”¨ã®ãƒã‚¤ãƒŠãƒªéƒ¨åˆ†ã‚’å–å¾—
    Microsoft::WRL::ComPtr <IDxcBlob> shaderBlob = nullptr;
    hr = shaderResult->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&shaderBlob), nullptr);
    assert(SUCCEEDED(hr));
    //æˆåŠŸã—ãŸãƒ­ã‚°ã‚’å‡ºã™
    Logger::Log(StringUtility::ConvertString(std::format(L"Compile Succeeded,path:{},profile:{}\n", filePath, profile)));
    //å®Ÿè¡Œç”¨ã®ãƒã‚¤ãƒŠãƒªã‚’è¿”å´
    return shaderBlob;
}

============================================================
File Path: project/engine/base/DirectXCommon/ShaderCompiler.h
============================================================
#pragma once
#include<DirectXCommon.h>

// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
class ShaderCompiler
{
private:
	static std::unique_ptr<ShaderCompiler> instance;

	ShaderCompiler(ShaderCompiler&) = delete;
	ShaderCompiler& operator=(ShaderCompiler&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	ShaderCompiler() = default;
	~ShaderCompiler() = default;

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static ShaderCompiler* GetInstance();
	// çµ‚äº†
	void Finalize();
	// åˆæœŸåŒ–
	void Initialize();

	// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼
	Microsoft::WRL::ComPtr <IDxcBlob> CompileShader(const std::wstring& filePath, const wchar_t* profile);
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// DXCã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®åˆæœŸåŒ–
	Microsoft::WRL::ComPtr <IDxcUtils> dxcUtils = nullptr;
	Microsoft::WRL::ComPtr <IDxcCompiler3> dxcCompiler = nullptr;
	Microsoft::WRL::ComPtr <IDxcIncludeHandler> includeHandler = nullptr;
};

============================================================
File Path: project/engine/base/DirectXCommon/SwapChainManager.cpp
============================================================
#include "SwapChainManager.h"
#include <cassert>

using namespace Microsoft::WRL;

void SwapChainManager::Initialize(HWND hwnd, ComPtr<ID3D12CommandQueue>& commandQueue, ComPtr<IDXGIFactory7>& dxgiFactory, uint32_t width, uint32_t height) {
    ///---------------------------------------------------------------------///
    ///--------------SwapChain(ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³)ã‚’è¨­å®šã™ã‚‹----------------------///
    ///---------------------------------------------------------------------///
    DXGI_SWAP_CHAIN_DESC1 swapChainDesc{};
    swapChainDesc.Width = width;//ç”»é¢ã®å¹…ã€‚ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’åŒã˜ã‚‚ã®ã«ã—ã¦ãŠã
    swapChainDesc.Height = height;//ç”»é¢ã®é«˜ã•ã€‚ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’åŒã˜ã‚‚ã®ã«ã—ã¦ãŠã
    swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;//è‰²ã®å½¢å¼
    swapChainDesc.SampleDesc.Count = 1;//ãƒžãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ã—ãªã„
    swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;//æç”»ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦åˆ©ç”¨ã™ã‚‹
    swapChainDesc.BufferCount = 2;//ãƒ€ãƒ–ãƒ«ãƒãƒƒãƒ•ã‚¡
    swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;//ãƒ¢ãƒ‹ã‚¿ã«ç§»ã—ãŸã‚‰ã€ä¸­èº«å±…ã‚’ç ´æ£„

    ///---------------------------------------------------------------------///
    ///--------------SwapChain(ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³)ã‚’ç”Ÿæˆã™ã‚‹----------------------///
    ///---------------------------------------------------------------------///
    HRESULT hr = dxgiFactory->CreateSwapChainForHwnd(commandQueue.Get(), hwnd, &swapChainDesc, nullptr, nullptr, reinterpret_cast<IDXGISwapChain1**>(swapChain_.GetAddressOf()));
    assert(SUCCEEDED(hr));
    
    // ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®å–å¾—
    // SwapChainã‹ã‚‰Resourceã‚’å¼•ã£å¼µã£ã¦ãã‚‹
    for (int i = 0; i < 2; ++i) {
        hr = swapChain_->GetBuffer(i, IID_PPV_ARGS(&resources_[i])); 
        //ä¸Šæ‰‹ãå–å¾—ã§ããªã‘ã‚Œã°èµ·å‹•ã§ããªã„
        assert(SUCCEEDED(hr));
    }
}

============================================================
File Path: project/engine/base/DirectXCommon/SwapChainManager.h
============================================================
#pragma once
#include <wrl.h>
#include <dxgi1_6.h>
#include <d3d12.h>
#include <cstdint>
#include <array>

class SwapChainManager
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	  void Initialize(
        HWND hwnd,
        Microsoft::WRL::ComPtr<ID3D12CommandQueue>& commandQueue,
        Microsoft::WRL::ComPtr<IDXGIFactory7>& dxgiFactory,
        uint32_t width,
        uint32_t height
    );
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// SwapChain(ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³)
	Microsoft::WRL::ComPtr <IDXGISwapChain4> swapChain_;	
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ãƒªã‚½ãƒ¼ã‚¹
	std::array<Microsoft::WRL::ComPtr<ID3D12Resource>, 2> resources_;
public: // getter
    Microsoft::WRL::ComPtr<IDXGISwapChain4> GetSwapChain() const { return swapChain_; }
   // ãƒªã‚½ãƒ¼ã‚¹é…åˆ—ã”ã¨å–å¾—ã—ãŸã„å ´åˆï¼ˆå‚ç…§ or ãƒã‚¤ãƒ³ã‚¿ï¼‰
    const std::array<Microsoft::WRL::ComPtr<ID3D12Resource>, 2>& GetResources() const { return resources_; }
    Microsoft::WRL::ComPtr<ID3D12Resource> GetBuffer(uint32_t index) const { return resources_[index]; }
};

============================================================
File Path: project/engine/base/DirectXCommon/ViewportManager.cpp
============================================================
#include "ViewportManager.h"

void ViewportManager::Initialize(uint32_t width, uint32_t height) {
    // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®åˆæœŸåŒ–
    //ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®ã‚µã‚¤ã‚ºã¨ä¸€ç·’ã«ã—ã¦ç”»é¢å…¨ä½“ã«è¡¨ç¤º
    viewport_.Width = static_cast<float>(width);
    viewport_.Height = static_cast<float>(height);
    viewport_.TopLeftX = 0;
    viewport_.TopLeftY = 0;
    viewport_.MinDepth = 0.0f;
    viewport_.MaxDepth = 1.0f;

	// ã‚·ã‚¶ãƒªãƒ³ã‚°çŸ©å½¢
    // åŸºæœ¬çš„ã«ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã¨åŒã˜çŸ©å½¢ãŒæ§‹æˆã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
    scissorRect_.left = 0;
    scissorRect_.right = static_cast<LONG>(width);
    scissorRect_.top = 0;
    scissorRect_.bottom = static_cast<LONG>(height);
}

============================================================
File Path: project/engine/base/DirectXCommon/ViewportManager.h
============================================================
#pragma once
#include <d3d12.h>
#include <cstdint>

// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆãƒ»ã‚·ã‚¶ãƒ¼ç®¡ç†
class ViewportManager{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
    /// åˆæœŸåŒ–
    /// </summary>
    void Initialize(uint32_t width, uint32_t height);
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ
	D3D12_VIEWPORT viewport_{};
	// ã‚·ã‚¶ãƒ¼çŸ­å½¢
	D3D12_RECT scissorRect_{};	
public: // getter
	const D3D12_VIEWPORT& GetViewport() const { return viewport_; }
    const D3D12_RECT& GetScissorRect() const { return scissorRect_; }
};

============================================================
File Path: project/engine/base/Framework.cpp
============================================================
#include "Framework.h"
#include<D3DResourceLeakChecker.h>
#include<DirectXCommon.h>
#include<ModelCommon.h>
#include<SrvManager.h>
#include<SceneFactory.h>
#include<ShaderCompiler.h>
#include<CopylmageCommon.h>
#include<Controller.h>
#include<psapi.h>
#include<SkyboxCommon.h>
#include <FileSearcher.h>
#include <ManifestExporter.h>

void Framework::Run() {
    // ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
    Initialize();

    while (true) // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
    {
        // æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°
        Update();
        // çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæ¥ãŸã‚‰ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
        if (IsEndRequst()) {
            break;
        }
        // æç”»
        Draw();
    }
    // ã‚²ãƒ¼ãƒ ã®çµ‚äº†
    Finalize();
}

void Framework::Finalize() {
    // ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªã®è§£æ”¾ 
    sceneFactory_.reset();
    // ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã®è§£æ”¾
    SceneManager::GetInstance()->Finalize();
    // åŸºç›¤ã‚·ã‚¹ãƒ†ãƒ ã®è§£æ”¾
    SkyboxCommon::GetInstance()->Finalize();
    ParticleCommon::GetInstance()->Finalize();
    SpriteCommon::GetInstance()->Finalize();
    Object3dCommon::GetInstance()->Finalize();
    // å…¥åŠ›è§£æ”¾
    Input::GetInstance()->Finalize();
    // ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£å…±é€šéƒ¨ã®è§£æ”¾
    CopylmageCommon::GetInstance()->Finalize();
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒžãƒãƒ¼ã‚¸ãƒ£ã®çµ‚äº†
    ParticleManager::GetInstance()->Finalize();
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒžãƒãƒ¼ã‚¸ãƒ£ã®çµ‚äº†
    TextureManager::GetInstance()->Finalize();
    // 3Dãƒ¢ãƒ‡ãƒ«ãƒžãƒãƒ¼ã‚¸ãƒ£ã®çµ‚äº†
    ModelManager::GetInstance()->Finalize();
    // ImGuiãƒžãƒãƒ¼ã‚¸ãƒ£ã®è§£æ”¾
    ImGuiManager::GetInstance()->Finalize();   
    // DSVãƒžãƒãƒ¼ã‚¸ãƒ£ã®é–‹æ”¾
    dsvManager.reset();
    // RTVãƒžãƒãƒ¼ã‚¸ãƒ£ã®é–‹æ”¾
    rtvManager.reset();
    // SRVãƒžãƒãƒ¼ã‚¸ãƒ£ã®é–‹æ”¾
    srvManager.reset();
    // DirectXã®è§£æ”¾
    dxCommon.reset();
    // WindowsAPIã®è§£æ”¾
    winApp.reset();
    //ãƒªã‚½ãƒ¼ã‚¹ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚¯
    D3DResourceLeakChecker leakCheck;
}

void Framework::Initialize() {
    OutputDebugStringA("Hello,Directx!\n");
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½œæˆ
    // WindowsAPIã®åˆæœŸåŒ–
    winApp = std::make_unique <WinApp>();    
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¤‰æ›´
	winApp->SetWindowTitle(L"LE3B_07_ã‚ªãƒŽãƒ‡ãƒ©_ãƒ¦ãƒ…ã‚­_Skyraider");
    winApp->Initialize();
    // DirectXã®åˆæœŸåŒ–
    dxCommon = std::make_unique <DirectXCommon>();
    dxCommon->Initialize(winApp.get()); 
    // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã®åˆæœŸåŒ–
    ShaderCompiler::GetInstance()->Initialize();
    // éŸ³å£°èª­ã¿è¾¼ã¿
    SoundLoader::GetInstance()->Initialize();
    // éŸ³å£°å†ç”Ÿ
    SoundPlayer::GetInstance()->Initialize(SoundLoader::GetInstance());
    // SRVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
    srvManager = std::make_unique <SrvManager>();
    srvManager->Initialize(dxCommon.get());   
    // RTVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
    rtvManager = std::make_unique <RtvManager>();
    rtvManager->Initialize(dxCommon.get());      
    // DSVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
    dsvManager = std::make_unique <DsvManager>();
    dsvManager->Initialize(dxCommon.get());
    // ImGuiãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    ImGuiManager::GetInstance()->Initialize(winApp.get(), dxCommon.get(), srvManager.get());
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    TextureManager::GetInstance()->Initialize(dxCommon.get(), srvManager.get());
    // 3Dãƒ¢ãƒ‡ãƒ«ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    ModelManager::GetInstance()->Initialize(dxCommon.get());
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒžãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
    ParticleManager::GetInstance()->Initialize(dxCommon.get(), srvManager.get()); 


    // 1. æ¤œç´¢ã‚¯ãƒ©ã‚¹
    FileSearcher searcher("Resources");
    
    // 2. å‡ºåŠ›ã‚¯ãƒ©ã‚¹
    ManifestExporter exporter;

    // 3. å®Ÿè¡Œï¼šæ¤œç´¢ã—ãŸçµæžœã‚’ãã®ã¾ã¾å‡ºåŠ›ã«æ¸¡ã™
    auto files = searcher.GetAllFiles({ "EditorTemp", ".git" });
    exporter.Export("Resources/manifest.json", files);

#pragma region åŸºç›¤ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–

    // å…¥åŠ›ã®åˆæœŸåŒ–
    Input::GetInstance()->Initialize(winApp.get());

    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šéƒ¨ã®åˆæœŸåŒ–
    SpriteCommon::GetInstance()->Initialize(dxCommon.get(),dsvManager.get());

    // 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…±é€šéƒ¨ã®åˆæœŸåŒ–
    Object3dCommon::GetInstance()->Initialize(dxCommon.get(),dsvManager.get());

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å…±é€šéƒ¨ã®åˆæœŸåŒ–
    ParticleCommon::GetInstance()->Initialize(dxCommon.get(),dsvManager.get());
 
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£å…±é€šéƒ¨ã®åˆæœŸåŒ–
    CopylmageCommon::GetInstance()->Initialize(dxCommon.get(), srvManager.get(),rtvManager.get(),dsvManager.get());
    
    // ç®±ã®å…±é€šéƒ¨ã®åˆæœŸåŒ–
    SkyboxCommon::GetInstance()->Initialize(dxCommon.get(),dsvManager.get());

#pragma endregion åŸºç›¤ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
}

void Framework::Update() {
    // Windowã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
    if (winApp->ProcessMessage()) {
        // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
        endRequst_ = true;
    }
    // å…¥åŠ›ã®æ›´æ–°
    Input::GetInstance()->Update();
    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã®æ›´æ–°
    Controller::GetInstance()->Update();
    // ImGuiã®å—ä»˜é–‹å§‹
    ImGuiManager::GetInstance()->Begin();
    // ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã®æ›´æ–°å‡¦ç†
    SceneManager::GetInstance()->Update(); 
    // ãƒ‡ãƒãƒƒã‚°ç³»ImGuiè¡¨ç¤º
    DrawDebug();
    // ImGuiã®æç”»å‰æº–å‚™
    ImGuiManager::GetInstance()->End();
}

void Framework::Draw() {
    //  æç”»ç”¨ã®DescriptorHeapã®è¨­å®š
    srvManager->PreDraw();
    // ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã—ã¦æç”»é–‹å§‹æº–å‚™
    rtvManager->PreDrawRenderTexture();
    dxCommon->PreDrawRenderTexture(rtvManager->GetRtvHandle(2),dsvManager->GetDsvDescriptorHeap(), rtvManager->GetkRenderTargetClearValue());
    // ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã®æç”»å‡¦ç†
    SceneManager::GetInstance()->Draw();
    // ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’SRVã¨ã—ã¦ä½¿ã†ãŸã‚ã®çŠ¶æ…‹ã«é·ç§»
    rtvManager->PostDrawRenderTexture();
    //  DirectXã®æç”»æº–å‚™ã€‚å…¨ã¦ã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒžãƒ³ãƒ‰ã‚’ç©ã‚€
    // ã“ã“ã‹ã‚‰æ›¸ãè¾¼ã‚€ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
    UINT backBufferIndex = dxCommon->GetSwapChain()->GetSwapChain()->GetCurrentBackBufferIndex();
    dxCommon->PreDraw(rtvManager->GetRtvHandle(backBufferIndex),dsvManager->GetDsvDescriptorHeap());
	// ãƒã‚¹ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆæç”»ï¼ˆãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ â†’ ç”»é¢ï¼‰
    CopylmageCommon::GetInstance()->Commondrawing(srvManager.get());
}

void Framework::DrawDebug() {
#ifdef USE_IMGUI
    ImGui::Begin("System Monitor");
    
    // FPSã¨1ãƒ•ãƒ¬ãƒ¼ãƒ ã®å‡¦ç†æ™‚é–“ã‚’è¡¨ç¤ºï¼ˆå¹³å‡å‡¦ç†æ™‚é–“ = 1000 / FPSï¼‰
    ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);
    // FPSã®æŽ¨ç§»ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã®ãƒãƒƒãƒ•ã‚¡ï¼ˆ100ãƒ•ãƒ¬ãƒ¼ãƒ åˆ†ï¼‰
    static float values[100] = {};
    static int frame = 0;
    values[frame++ % 100] = ImGui::GetIO().Framerate;
    // FPSã®å±¥æ­´ã‚’æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•ã§è¡¨ç¤º
    ImGui::PlotLines("FPS History", values, 100, 0, nullptr, 0.0f, 100.0f);

    PROCESS_MEMORY_COUNTERS pmc;  
    // ç¾åœ¨ã®ãƒ—ãƒ­ã‚»ã‚¹ï¼ˆã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨æƒ…å ±ã‚’å–å¾—
    if (GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc))) {
        ImGui::Text("Memory Used: %.2f MB", pmc.WorkingSetSize / (1024.0f * 1024.0f));    // ä½¿ç”¨ä¸­ã®ãƒ¡ãƒ¢ãƒªï¼ˆç‰©ç†ãƒ¡ãƒ¢ãƒªï¼‰ã‚’MBå˜ä½ã§è¡¨ç¤º
    }
    ImGui::End();
#endif
}

============================================================
File Path: project/engine/base/Framework.h
============================================================
#pragma once
#include<Input.h>
#include<ResourceObject.h>
#include<TextureManager.h>
#include<SpriteCommon.h>
#include<Object3dCommon.h>
#include<ParticleCommon.h>
#include<ModelCommon.h>
#include<ModelManager.h>
#include<Camera.h>
#include<ImGuiManager.h>
#include<SoundPlayer.h>
#include<SceneManager.h>
#include<ParticleManager.h>
#include<RtvManager.h>
#include<DsvManager.h>

class WinApp;
class DirectXCommon;
class ModelCommon;
class SrvManager;
class AbstractSceneFactory;

// ã‚²ãƒ¼ãƒ å…¨ä½“
class Framework
{
public:// ãƒ¡ãƒ³ãƒé–¢æ•°
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	virtual ~Framework() = default;

	// åˆæœŸåŒ–
	virtual void Initialize();
	// çµ‚äº†
	virtual void Finalize();
	// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°
	virtual void Update();
	// æç”»
	virtual void Draw() = 0;

	// å®Ÿè¡Œ
	void Run();
	// imgui
	void DrawDebug();
protected:
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
	std::unique_ptr <AbstractSceneFactory> sceneFactory_ = nullptr;
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒã‚¤ãƒ³ã‚¿
	std::unique_ptr <WinApp> winApp = nullptr;
	std::unique_ptr <DirectXCommon> dxCommon = nullptr;
	std::unique_ptr <ModelCommon> modelCommon = nullptr;
	std::unique_ptr <SrvManager> srvManager = nullptr;	
	std::unique_ptr <RtvManager> rtvManager = nullptr;
	std::unique_ptr <DsvManager> dsvManager = nullptr;
	// ã‚²ãƒ¼ãƒ çµ‚äº†ãƒ•ãƒ©ã‚°
	bool endRequst_ = false;
public:
	// getter 
	WinApp* GetWinApp() const { return winApp.get(); }
	DirectXCommon* GetDirectXCommon() const { return dxCommon.get(); }
	SrvManager* GetSrvManager() const { return srvManager.get(); }
	// çµ‚äº†ãƒ•ãƒ©ã‚°ã®ãƒã‚§ãƒƒã‚¯
	virtual bool IsEndRequst() { return  endRequst_; }
};

============================================================
File Path: project/engine/base/ImGuiManager.cpp
============================================================
#include "ImGuiManager.h"
#include<WinApp.h>
#include<DirectXCommon.h>

using namespace Microsoft::WRL;

ImGuiManager* ImGuiManager::instance = nullptr;

ImGuiManager* ImGuiManager::GetInstance() {
	if (instance == nullptr) {
		instance = new ImGuiManager;
	}
	return instance;
}

void ImGuiManager::Finalize() {
#ifdef USE_IMGUI
	// ImGuiã®çµ‚äº†å‡¦ç†ã€‚å¾Œå§‹æœ«
	ImGui_ImplDX12_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();
#endif // USE_IMGUI
	delete instance;
	instance = nullptr;
}

void ImGuiManager::Initialize([[maybe_unused]] WinApp* winApp, [[maybe_unused]] DirectXCommon* DxCommon, [[maybe_unused]] SrvManager* srvManager) {
#ifdef USE_IMGUI
	// å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
	this->winApp_ = winApp;
	this->DxCommon_ = DxCommon;
	this->srvManager_ = srvManager;

	// ImGuiã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆ
	ImGui::CreateContext();
	
	// iniãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã‚‰ãªã„ã‚ˆã†ã«è¨­å®š
	ImGuiIO& io = ImGui::GetIO();
	io.IniFilename = nullptr;

	// ImGuiã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š
	ImGui::StyleColorsDark();

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç¢ºä¿
	imguiindex = srvManager_->Allocate();
	ImGuiHandleCPU = srvManager_->GetCPUDescriptorHandle(imguiindex);
	ImGuiHandleGPU = srvManager_->GetGPUDescriptorHandle(imguiindex);

	// Win32ç”¨åˆæœŸåŒ–
	ImGui_ImplWin32_Init(winApp_->Gethwnd());
	// DirectX12ç”¨åˆæœŸåŒ–
	ImGui_ImplDX12_Init(
		DxCommon_->GetDevice().Get(),
		static_cast<int>(DxCommon_->GetSwapChain()->GetResources().size()),
		DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,
		srvManager_->GetDescriptorHeap().Get(),
		ImGuiHandleCPU,
		ImGuiHandleGPU
	);
#endif // USE_IMGUI
}

void ImGuiManager::Begin() {
#ifdef USE_IMGUI
	// ImGuiãƒ•ãƒ¬ãƒ¼ãƒ é–‹å§‹
	ImGui_ImplDX12_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();
#endif // USE_IMGUI
}

void ImGuiManager::End() {
#ifdef USE_IMGUI
	// æç”»å‰æº–å‚™
	ImGui::Render();
#endif // USE_IMGUI
}

void ImGuiManager::Draw() {
#ifdef USE_IMGUI
	ComPtr<ID3D12GraphicsCommandList> commandList = DxCommon_->GetCommandList();
	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®é…åˆ—ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã‚³ãƒžãƒ³ãƒ‰
	ComPtr<ID3D12DescriptorHeap> ppheaps[] = { srvManager_->GetDescriptorHeap().Get() };
	commandList->SetDescriptorHeaps(_countof(ppheaps), ppheaps->GetAddressOf());
	// æç”»ã‚³ãƒžãƒ³ãƒ‰ã‚’ç™ºè¡Œ
	ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), commandList.Get());
#endif // USE_IMGUI
}

============================================================
File Path: project/engine/base/ImGuiManager.h
============================================================
#pragma once
#include<SrvManager.h>
#ifdef USE_IMGUI
#include<externals/imgui/imgui_impl_dx12.h>
#include<externals/imgui/imgui_impl_win32.h>
#endif // USE_IMGUI

class WinApp;
class DirectXCommon;

// ImGUIã®ç®¡ç†
class ImGuiManager
{
private:
	static ImGuiManager* instance;

	ImGuiManager() = default;
	~ImGuiManager() = default;
	ImGuiManager(ImGuiManager&) = delete;
	ImGuiManager& operator=(ImGuiManager&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static ImGuiManager* GetInstance();
	///<summary>
	/// åˆæœŸåŒ–
	///</summary>
	// åˆæœŸåŒ–
	void Initialize(WinApp* winApp, DirectXCommon* DxCommon, SrvManager* srvManager);

	/// <summary>
	/// çµ‚äº†
	/// </summary>
	void Finalize();

	/// <summary>
	/// ImGuiå—ä»˜é–‹å§‹
	/// </summary>
	void Begin();

	/// <summary>
	/// ImGuiå—ä»˜çµ‚äº†
	/// </summary>
	void End();

	/// <summary>
	/// ç”»é¢ã¸ã®æç”»
	/// </summary>
	void Draw();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒã‚¤ãƒ³ã‚¿
	WinApp* winApp_;
	DirectXCommon* DxCommon_;
	SrvManager* srvManager_;
	// imguiç•ªå·
	uint32_t imguiindex;
	// ãƒãƒ³ãƒ‰ãƒ«
	D3D12_CPU_DESCRIPTOR_HANDLE ImGuiHandleCPU;
	D3D12_GPU_DESCRIPTOR_HANDLE ImGuiHandleGPU;
};

============================================================
File Path: project/engine/base/Utility/Logger.cpp
============================================================
#include "Logger.h"
#include "externals/DirectXTex/DirectXTex.h"

namespace Logger {
	void Log(const std::string& message) {
		OutputDebugStringA(message.c_str());;
	}
}

============================================================
File Path: project/engine/base/Utility/Logger.h
============================================================
#pragma once
#include <string>

// ãƒ­ã‚°å‡ºåŠ›
namespace Logger
{
	void Log(const std::string& message);
};

============================================================
File Path: project/engine/base/Utility/StringUtility.cpp
============================================================
#include "StringUtility.h"
#include "externals/DirectXTex/DirectXTex.h"

namespace StringUtility {

    std::wstring ConvertString(const std::string& str) {
        if (str.empty()) {
            return std::wstring();
        }

        auto sizeNeeded = MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), NULL, 0);
        if (sizeNeeded == 0) {
            return std::wstring();
        }
        std::wstring result(sizeNeeded, 0);
        MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), &result[0], sizeNeeded);
        return result;
    }

    std::string ConvertString(const std::wstring& str) {
        if (str.empty()) {
            return std::string();
        }

        auto sizeNeeded = WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), NULL, 0, NULL, NULL);
        if (sizeNeeded == 0) {
            return std::string();
        }
        std::string result(sizeNeeded, 0);
        WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), result.data(), sizeNeeded, NULL, NULL);
        return result;
    }

}

============================================================
File Path: project/engine/base/Utility/StringUtility.h
============================================================
#pragma once
#include <string>

// æ–‡å­—ã‚³ãƒ¼ãƒ‰ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
namespace StringUtility
{
	// stringã‚’wstringã«å¤‰æ›ã™ã‚‹
	std::wstring ConvertString(const std::string& str);

	// wstringã‚’stringã«å¤‰æ›ã™ã‚‹
	std::string ConvertString(const std::wstring& str);
};

============================================================
File Path: project/engine/base/ViewManager/DsvManager.cpp
============================================================
#include "DsvManager.h"
#include<ResourceFactory.h>
#include <DescriptorUtils.h>

using namespace ResourceFactory;
using namespace DescriptorUtils;

void DsvManager::Initialize(DirectXCommon* directXCommon) { 
    assert(directXCommon);
    // å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹ 
    this->dxCommon_ = directXCommon;

    // DSVç”¨ã®ãƒ’ãƒ¼ãƒ—ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ•°ã¯1ã€‚DSVã¯shaderå†…ã§è§¦ã‚‹ã‚‚ã®ã§ã¯ãªã„ã®ã§ã€ShaderVisibleã¯false
    dsvDescriptorHeap = dxCommon_->CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_DSV, 1, false);
    // DescriptorSizeã‚’å–å¾—ã™ã‚‹
    descriptorsizeDSV = dxCommon_->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);

    //------------------æ·±åº¦ã‚¹ãƒ†ãƒ«ã‚¹ãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–---------------------//
    /*------------------------------------------------------------*/
    /*--------------------------DSVã®è¨­å®š--------------------------*/
    /*------------------------------------------------------------*/
    // DepthStencilTextureã‚’ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã®ã‚µã‚¤ã‚ºã§ä½œæˆ
    depthStencilResource = CreateDepthStencilTextureResource(dxCommon_->GetDevice(), WinApp::kClientWidth, WinApp::kClientHeight);

    // DSVã®è¨­å®š
    D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc{};
    dsvDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;//Formatã€‚åŸºæœ¬çš„ã«ã¯Resourceåˆã‚ã›ã‚‹
    dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D; //2dTexture 
    // DSVDescã®å…ˆé ­ã«DSVã‚’ä½œã‚‹
    dxCommon_->GetDevice()->CreateDepthStencilView(depthStencilResource.Get(), &dsvDesc, dsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart());

    // DepthStencilStateã®è¨­å®š
    // Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
    depthStencilDesc.DepthEnable = true;
    // æ›¸ãè¾¼ã¿ã™ã‚‹
    depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
    // æ›¸ãè¾¼ã¿ã—ãªã„
    //depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
    // æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
    depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
}

============================================================
File Path: project/engine/base/ViewManager/DsvManager.h
============================================================
#pragma once
#include<DirectXCommon.h>

class DsvManager {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°

	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* directXCommon);


	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> GetDsvDescriptorHeap() const { return dsvDescriptorHeap; }

	D3D12_DEPTH_STENCIL_DESC GetDepthStencilDesc() const { return depthStencilDesc; }
	void SetDepthStencilDesc(D3D12_DEPTH_STENCIL_DESC StencilDesc) { depthStencilDesc = StencilDesc; }

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°		
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_ = nullptr;
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> dsvDescriptorHeap;	// DSVç”¨ã®ãƒ’ãƒ¼ãƒ—ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿
	// å„DescriptorSizeã‚’å–å¾—ã™ã‚‹
	uint32_t descriptorsizeDSV;	 // DSVç”¨
	// DepthStencilTextureã‚’ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã®ã‚µã‚¤ã‚º
	Microsoft::WRL::ComPtr <ID3D12Resource> depthStencilResource;	
	// DepthStencilStateã®è¨­å®š
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};
};

============================================================
File Path: project/engine/base/ViewManager/RtvManager.cpp
============================================================
#include "RtvManager.h"
#include<ResourceFactory.h>
#include <DescriptorUtils.h>

using namespace ResourceFactory;
using namespace DescriptorUtils;

void RtvManager::Initialize(DirectXCommon* directXCommon) {
    assert(directXCommon);
    // å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹ 
    this->dxCommon_ = directXCommon;
    // RTVç”¨ã®ãƒ’ãƒ¼ãƒ—ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ•°ã¯2ã€‚RTVã¯shaderå†…ã§è§¦ã‚‹ã‚‚ã®ã§ã¯ãªã„ã®ã§ã€ShaderVisibleã¯false
    descriptorHeap = dxCommon_->CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_RTV, 3, false);
    // DescriptorSizeã‚’å–å¾—ã™ã‚‹
    descriptorSize = dxCommon_->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

    /*--------------------------------------------------------------------------------*/
    /*--------------------------ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–---------------------------*/
    /*--------------------------------------------------------------------------------*/ 

    // ã‚«ã‚¹ã‚¿ãƒ RenderTargetç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ä½œæˆ
    kRenderTargetClearValue = { 0.1f,0.25f,0.5f,1.0f };
    // [2]ã«renderTexture ã‚’ä½œã‚‹
    renderTextureResource = CreateRenderTextureResource(
        dxCommon_->GetDevice().Get(),
        WinApp::kClientWidth,
        WinApp::kClientHeight,
        DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,
        kRenderTargetClearValue
    );

    /*-----------------------------------------------------------*/
    /*--------------------------RTVã®è¨­å®š--------------------------*/
    /*------------------------------------------------------------*/
    
    //RTVã®è¨­å®š
    rtvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;//å‡ºåŠ›çµæžœã‚’SRGB2å¤‰æ›ã—ã¦æ›¸ãè¾¼ã‚€
    rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;//2Dãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ã—ã¦èª­ã¿è¾¼ã‚€
    //ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å…ˆé ­ã‚’å–å¾—ã™ã‚‹
    D3D12_CPU_DESCRIPTOR_HANDLE rtvStartHandle = GetCPUDescriptorHandle(descriptorHeap, descriptorSize, 0);

    for (uint32_t i = 0; i < rtvHandlenum; ++i) {
        rtvHandles[i] = rtvStartHandle;

        ID3D12Resource* target = nullptr;
        if (i < 2) {
            target = dxCommon_->GetSwapChain()->GetBuffer(i).Get(); // 0, 1 ã¯ swapChain
        } else {
            target = renderTextureResource.Get(); // 2 ã¯ renderTexture
        }

        dxCommon_->GetDevice()->CreateRenderTargetView(target, &rtvDesc, rtvHandles[i]);
        rtvStartHandle.ptr += descriptorSize;
    }
}

void RtvManager::PreDrawRenderTexture() {
        // ãƒãƒªã‚¢: SRV â†’ RenderTarget
    if (renderTextureState != RenderTextureState::RenderTarget) {
        TransitionResource(
            renderTextureResource.Get(),
            D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE,
            D3D12_RESOURCE_STATE_RENDER_TARGET);
        renderTextureState = RenderTextureState::RenderTarget;
    }
}

void RtvManager::PostDrawRenderTexture() {
    // ã‚‚ã—ç¾åœ¨ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®çŠ¶æ…‹ãŒ PixelShaderResourceï¼ˆã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ï¼‰ã§ãªã„å ´åˆã€
    if (renderTextureState != RenderTextureState::PixelShaderResource) {
        TransitionResource(renderTextureResource.Get(), D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE);
        renderTextureState = RenderTextureState::PixelShaderResource;  // ç¾åœ¨ã®çŠ¶æ…‹ã‚’è¨˜éŒ²ã—ã¦ãŠãã€‚
    }
}


void RtvManager::TransitionResource(ID3D12Resource* resource, D3D12_RESOURCE_STATES beforeState, D3D12_RESOURCE_STATES afterState) {
    // ãƒãƒªã‚¢ã®è¨­å®š
    D3D12_RESOURCE_BARRIER barrier{};
    barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;                      // ä»Šå›žã®ãƒãƒªã‚¢ã¯Transition
    barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;                           // Noneã«ã—ã¦ãŠã 
    barrier.Transition.pResource = resource;                                    // ãƒãƒªã‚¢ã‚’å¼µã‚‹å¯¾è±¡ã®ãƒªã‚½ãƒ¼ã‚¹ã€‚
    barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;   // å…¨ã‚µãƒ–ãƒªã‚½ãƒ¼ã‚¹ã«å¯¾ã—ã¦ãƒãƒªã‚¢ã‚’å¼µã‚‹
    barrier.Transition.StateBefore = beforeState;                               // é·ç§»å‰ã®ResourceState
    barrier.Transition.StateAfter = afterState;                                 // TransitionBarrierã‚’å¼µã‚‹
    // ã‚³ãƒžãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«ãƒãƒªã‚¢ã‚’è¿½åŠ 
    dxCommon_->GetCommandList()->ResourceBarrier(1, &barrier);
}

============================================================
File Path: project/engine/base/ViewManager/RtvManager.h
============================================================
#pragma once
#include<DirectXCommon.h>

// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®çŠ¶æ…‹å¤‰ç•°
enum class RenderTextureState {
	RenderTarget,             // ç¾åœ¨ã€æç”»å…ˆï¼ˆRTVï¼‰ã¨ã—ã¦ä½¿ç”¨ä¸­
	PixelShaderResource       // ç¾åœ¨ã€SRVã¨ã—ã¦ã‚·ã‚§ãƒ¼ãƒ€ã‹ã‚‰èª­ã¿è¾¼ã¿å¯èƒ½
};

class RtvManager {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°

	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* directXCommon);
	
	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	void PreDrawRenderTexture();

	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æç”»å¾Œå‡¦ç†
	/// </summary>
	void PostDrawRenderTexture();

	// RTVã®ãƒãƒ³ãƒ‰ãƒ«å–å¾—ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æŒ‡å®šï¼‰
	D3D12_CPU_DESCRIPTOR_HANDLE GetRtvHandle(uint32_t index) const { return rtvHandles[index]; }
	
	// ãƒªã‚½ãƒ¼ã‚¹ã®çŠ¶æ…‹ã‚’é·ç§»
	void TransitionResource(ID3D12Resource* resource, D3D12_RESOURCE_STATES beforeState, D3D12_RESOURCE_STATES afterState);

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_ = nullptr;
	// RTVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> descriptorHeap;
	// RTVç”¨ã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	uint32_t descriptorSize;
	//RTVã®è¨­å®š
	D3D12_RENDER_TARGET_VIEW_DESC rtvDesc{};
	//ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å…ˆé ­ã‚’å–å¾—ã™ã‚‹
	D3D12_CPU_DESCRIPTOR_HANDLE rtvStartHandle;
	//RTVã‚’2ã¤ä½œã‚‹ã®ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’2ã¤ç”¨æ„
	const uint32_t rtvHandlenum = 3;
	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandles[3];
	// ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ç”¨ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£		
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®çŠ¶æ…‹å¤‰ç•°
	RenderTextureState renderTextureState = RenderTextureState::RenderTarget; // åˆæœŸçŠ¶æ…‹ã¯RenderTarget
	Microsoft::WRL::ComPtr<ID3D12Resource> renderTextureResource;              // ã‚«ã‚¹ã‚¿ãƒ RenderTargetç”¨ã®ãƒªã‚½ãƒ¼ã‚¹
	Vector4 kRenderTargetClearValue{};                                         // ã‚«ã‚¹ã‚¿ãƒ RenderTargetã®ãƒªã‚½ãƒ¼ã‚¹ã‚«ãƒ©ãƒ¼
	uint32_t srvIndexRenderTexture;                                            // ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
public:
    // ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—å–å¾—
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap>  GetHeap() const { return descriptorHeap; }	
	Microsoft::WRL::ComPtr <ID3D12Resource> GetrenderTextureResource() const { return renderTextureResource; }
	const Vector4 GetkRenderTargetClearValue() const { return kRenderTargetClearValue; }
};

============================================================
File Path: project/engine/base/ViewManager/SrvManager.cpp
============================================================
#include "SrvManager.h"

using namespace Microsoft::WRL;

const uint32_t 	SrvManager::kMaxSRVCount = 512;

void SrvManager::Initialize(DirectXCommon* directXCommon) {
	// å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
	this->directXCommon = directXCommon;

	// SRVç”¨ã®ãƒ’ãƒ¼ãƒ—ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ•°ã¯128.RTVã¯shaderå†…ã§è§¦ã‚‹ã‚‚ã®ãªã®ã§ã€ShaderVisibleã¯true
	descriptorHeap = directXCommon->CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, kMaxSRVCount, true);
	descriptorSize = directXCommon->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
}

uint32_t SrvManager::Allocate() {
	// NULLæ¤œå‡º
	assert(useIndex < kMaxSRVCount);
	// return ã™ã‚‹ç•ªå·ã‚’ä¸€æ—¦è¨˜éŒ²ã—ã¦ãŠã
	int index = useIndex;
	// æ¬¡å›žã®ãŸã‚ã«ç•ªå·ã‚’1é€²ã‚ã‚‹
	useIndex++;
	// ä¸Šã§è¨˜éŒ²ã—ãŸç•ªå·ã‚’return
	return index;
};

D3D12_CPU_DESCRIPTOR_HANDLE SrvManager::GetCPUDescriptorHandle(uint32_t index)
{
	D3D12_CPU_DESCRIPTOR_HANDLE handleCPU = descriptorHeap->GetCPUDescriptorHandleForHeapStart();
	handleCPU.ptr += (descriptorSize * index);
	return handleCPU;
}

D3D12_GPU_DESCRIPTOR_HANDLE SrvManager::GetGPUDescriptorHandle(uint32_t index)
{
	D3D12_GPU_DESCRIPTOR_HANDLE handleGPU = descriptorHeap->GetGPUDescriptorHandleForHeapStart();
	handleGPU.ptr += (descriptorSize * index);
	return handleGPU;
}

void SrvManager::CreateSRVforTexture2D(uint32_t srvIndex, ComPtr<ID3D12Resource> pResource, DXGI_FORMAT Format, UINT MipLevels, bool isCubemap) {
	// SRVã®è¨­å®š
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	if (isCubemap) { // metadataã‹ã‚‰Cubemapã‹ã©ã†ã‹ã‚’å–å¾—
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;
		srvDesc.TextureCube.MostDetailedMip = 0; // unionãŒTextureCudeã«ãªã£ãŸãŒã€å†…éƒ¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ„å‘³ã¯Texture2dã¨å¤‰ã‚ã‚‰ãªã„
		srvDesc.TextureCube.MipLevels = UINT_MAX;
		srvDesc.TextureCube.ResourceMinLODClamp = 0.0f;
	} else {
		// ä»Šã¾ã§é€šã‚Š2d,textureã®è¨­å®šã‚’è¡Œã†
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;  //2Dãƒ†ã‚¯ã‚¹ãƒãƒ£
		srvDesc.Texture2D.MipLevels = UINT(MipLevels);
	}
	// SRVã®ç”Ÿæˆ
	directXCommon->GetDevice()->CreateShaderResourceView(pResource.Get(), &srvDesc, GetCPUDescriptorHandle(srvIndex));
}

void SrvManager::CreateSRVforStructuredBuffer(uint32_t srvIndex, ComPtr<ID3D12Resource> pResource, UINT numElements, UINT structureByteStride) {
	// SRVã®è¨­å®š
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;  // ãƒãƒƒãƒ•ã‚¡
	srvDesc.Buffer.NumElements = numElements;
	srvDesc.Buffer.StructureByteStride = UINT(structureByteStride);
	// SRVã®ç”Ÿæˆ
	directXCommon->GetDevice()->CreateShaderResourceView(pResource.Get(), &srvDesc, GetCPUDescriptorHandle(srvIndex));
}

uint32_t  SrvManager::CreateSRVForRenderTexture(ComPtr<ID3D12Resource> resource) {
	uint32_t index = Allocate();
	// SRVã®è¨­å®š
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;
	// SRVã®ç”Ÿæˆ
	directXCommon->GetDevice()->CreateShaderResourceView(resource.Get(), &srvDesc, GetCPUDescriptorHandle(index));	
    return index; // ä½œã£ãŸSRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™ï¼
}

void SrvManager::PreDraw() {
	// æç”»ç”¨ã®DescriptorHeapã®è¨­å®š
	ID3D12DescriptorHeap* descriptorHeaps[] = { descriptorHeap.Get() };
	directXCommon->GetCommandList()->SetDescriptorHeaps(1, descriptorHeaps);
}

void SrvManager::SetGraphicsRootDescriptorTable(UINT RootParameterIndex, uint32_t srvIndex) {
	directXCommon->GetCommandList()->SetGraphicsRootDescriptorTable(RootParameterIndex, GetGPUDescriptorHandle(srvIndex));
}

bool SrvManager::TextureDataCheck() {
	if (useIndex < kMaxSRVCount) {
		return true;
	}
	// ç¢ºä¿ã—ã¦ã„ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚ˆã‚Šå¤§ãã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
	return false;
}

============================================================
File Path: project/engine/base/ViewManager/SrvManager.h
============================================================
#pragma once
#include"DirectXCommon.h"

class SrvManager
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°

	// æœ€å¤§SRVæ•°(æœ€å¤§ãƒ†ã‚¯ã‚¹ãƒãƒ£æžšæ•°)
	static const uint32_t kMaxSRVCount;

	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* directXCommon);
	// SRVãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ç¢ºä¿
	uint32_t Allocate();
	// æç”»å‰ã®DescriptorHeapã®è¨­å®š
	void PreDraw();

	/// <summary>
	/// æŒ‡å®šç•ªå·ã®CPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(uint32_t index);
	/// <summary>
	/// æŒ‡å®šç•ªå·ã®GPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—ã‚’ã™ã‚‹
	/// </summary>
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(uint32_t index);

	// SRVç”Ÿæˆ (ãƒ†ã‚¯ã‚¹ãƒãƒ£)
	void CreateSRVforTexture2D(uint32_t srvIndex, Microsoft::WRL::ComPtr <ID3D12Resource> pResource, DXGI_FORMAT Format, UINT MipLevels, bool isCubemap);
	// SRVç”Ÿæˆ (Structured Bufferç”¨)
	void CreateSRVforStructuredBuffer(uint32_t srvIndex, Microsoft::WRL::ComPtr <ID3D12Resource> pResource, UINT numElements, UINT structureByteStride);
	// SRVç”Ÿæˆ(ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£)
	uint32_t  CreateSRVForRenderTexture(Microsoft::WRL::ComPtr <ID3D12Resource> resource);

	// æç”»ã®ã‚»ãƒƒãƒˆ
	void SetGraphicsRootDescriptorTable(UINT RootParameterIndex, uint32_t srvIndex);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç¢ºä¿ãŒå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
	bool TextureDataCheck();

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* directXCommon = nullptr;
	// SRVç”¨ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> descriptorHeap;
	// SRVç”¨ã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	uint32_t descriptorSize;
	// æ¬¡ã«ä½¿ç”¨ã™ã‚‹SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	uint32_t useIndex = 0;
public:
	// getter
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> GetDescriptorHeap() { return descriptorHeap; }
};

============================================================
File Path: project/engine/base/WinApp.cpp
============================================================
#include "WinApp.h"
#include"externals/imgui/imgui.h"
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
#pragma comment(lib,"winmm.lib")

// ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã¯ãªãMTAã§COMä½¿ç”¨
HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);

void WinApp::Initialize() {

    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£
    wc.lpfnWndProc = WindowProc;
    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹å
    wc.lpszClassName = L"CG2WindowClass";
    //ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«
    wc.hInstance = GetModuleHandle(nullptr);
    //ã‚«ãƒ¼ã‚½ãƒ«
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã‚’ç™»éŒ²ã™ã‚‹
    RegisterClass(&wc);
    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã‚’è¡¨ã™æ§‹é€ ä½“ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’å…¥ã‚Œã‚‹
    RECT wrc = { 0,0,kClientWidth,kClientHeight };
    //ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’å…ƒã«å®Ÿéš›ã®ã‚µã‚¤ã‚ºã«wrcã‚’å¤‰æ›´ã—ã¦ã‚‚ã‚‰ã†
    AdjustWindowRect(&wrc, WS_OVERLAPPEDWINDOW, false);

    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ç”Ÿæˆ
    hwnd = CreateWindow(
        wc.lpszClassName,        //åˆ©ç”¨ã™ã‚‹ã‚¯ãƒ©ã‚¹å
        windowTitle_.c_str(),    //ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ã®æ–‡å­—
        WS_OVERLAPPEDWINDOW,     //ã‚ˆãè¦‹ã‚‹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¹ã‚¿ã‚¤ãƒ«
        CW_USEDEFAULT,           //è¡¨ç¤ºXåº§æ¨™(Windowsã«ä»»ã›ã‚‹)
        CW_USEDEFAULT,           //è¡¨ç¤ºYåº§æ¨™(WindowsOSã«ä»»ã›ã‚‹)
        wrc.right - wrc.left,    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¨ªå¹…
        wrc.bottom - wrc.top,    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç¸¦å¹…
        nullptr,                 //è¦ªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
        nullptr,                 //ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ³ãƒ‰ãƒ«
        wc.hInstance,            //ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«
        nullptr);                //ã‚ªãƒ—ã‚·ãƒ§ãƒ³ 

    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã™ã‚‹
    ShowWindow(hwnd, SW_SHOW);
    // ã‚·ã‚¹ãƒ†ãƒ ã‚¿ã‚¤ãƒžãƒ¼ã®åˆ†è§£åº¦ã‚’ä¸Šã’ã‚‹
    timeBeginPeriod(1);
}

//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼
LRESULT CALLBACK WinApp::WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    //ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸äºŒå¿œã˜ã¦ã‚²ãƒ¼ãƒ å›ºæœ‰ã®å‡¦ç†ã‚’è¡Œã†
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam)) {
        return true;
    }

    switch (msg) {
        //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒç ´æ£„ã•ã‚ŒãŸ
    case WM_DESTROY:
        //OSã«å¯¾ã—ã¦ã€ã‚¢ãƒ—ãƒªã®çµ‚äº†ã‚’ä¼ãˆã‚‹
        PostQuitMessage(0);
        return 0;
    }
    //æ¨™æº–ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ã‚’è¡Œã†
    return DefWindowProc(hWnd, msg, wParam, lParam);
}

void WinApp::Finalize() {
    // CloseHandle(fenceEvent);
    CloseWindow(hwnd);
    ///COMã®çµ‚äº†
    CoUninitialize();
}

bool WinApp::ProcessMessage() {
    
    MSG msg{};

    // Windowã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ¥ã¦ã„ãŸã‚‰æœ€å„ªå…ˆã§å‡¦ç†ã•ã›ã‚‹
    if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE)) 
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    if (msg.message == WM_QUIT) 
    {  
        return true;
    }    
    return false;
}

void WinApp::SetWindowTitle(const std::wstring& title) {
    windowTitle_ = title;
}

============================================================
File Path: project/engine/base/WinApp.h
============================================================
#pragma once
#include<Windows.h>
#include<cstdint>
#include <string>

// WindowsAPI
class WinApp
{
public: // é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°
	static LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~WinApp() { Finalize(); }
	// åˆæœŸåŒ–
	void Initialize();
	// çµ‚äº†
	void Finalize();
	// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
	bool ProcessMessage();
public: // å®šæ•°
	//ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®ã‚µã‚¤ã‚º
	static const int32_t kClientWidth = 1280;
	static const int32_t kClientHeight = 720;
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
	HWND hwnd = nullptr;
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®è¨­å®š
	WNDCLASS wc{};
	std::wstring windowTitle_ = L"LE3B"; // â† ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
public:
	// getter
	HWND Gethwnd() const { return hwnd; }
	HINSTANCE GetHInstance() const { return wc.hInstance; }
	void SetWindowTitle(const std::wstring& title);
};

============================================================
File Path: project/engine/camera/Camera.cpp
============================================================
#include "Camera.h"
#include "MatrixVector.h"
#include "WinApp.h"
#include<ImGuiManager.h>

using namespace MatrixVector;

Camera::Camera()
	: transform({ {1.0f,1.0f,1.0f},{0.0f,0.0f,0.0f},{0.0f,0.0f,0.0f} })
	, fovY(0.45f)
	, aspectRatio(float(WinApp::kClientWidth) / float(WinApp::kClientHeight))
	, nearClip(0.1f)
	, farclip(100.0f)
	, worldMatrix(MakeAftineMatrix(transform.scale, transform.rotate, transform.translate))
	, viewMatrix(Inverse(worldMatrix))
	, projectionMatrix(MakePerspectiveFovMatrix(fovY, aspectRatio, nearClip, farclip))
	, ViewProjectionMatrix(Multiply(viewMatrix, projectionMatrix))
{
}

void Camera::Update() {
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®ä½œæˆ
	worldMatrix = MakeAftineMatrix(transform.scale, transform.rotate, transform.translate);
	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®è¨ˆç®—
	viewMatrix = Inverse(worldMatrix);
	// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã®è¨ˆç®—
	projectionMatrix = MakePerspectiveFovMatrix(fovY, aspectRatio, nearClip, farclip);
	// ãƒ“ãƒ¥ãƒ¼ãƒ»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã®è¨ˆç®—
	ViewProjectionMatrix = Multiply(viewMatrix, projectionMatrix);
}

void Camera::DebugUpdate() {
#ifdef USE_IMGUI
	// é–‹ç™ºç”¨UIã®å‡¦ç†
	ImGui::DragFloat3("Translate", &transform.translate.x, 0.01f);
	ImGui::DragFloat3("Rotate", &transform.rotate.x, 0.0001f);
#endif // USE_IMGUI
}

Vector3 Camera::GetForward() const {
    // å³æ‰‹åº§æ¨™ç³»ã€Zè»¸ãŒå‰æ–¹å‘ã®å ´åˆï¼ˆDirectXæ¨™æº–ã§ã¯ã‚«ãƒ¡ãƒ©ã®å‰ã¯ -Zæ–¹å‘ï¼‰
    // worldMatrix_ ã®ç¬¬3åˆ—ã¾ãŸã¯ç¬¬2åˆ—ãŒå‰æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¡¨ã™ã“ã¨ãŒå¤šã„

    // ä¾‹ãˆã°worldMatrix_ã®3åˆ—ç›®ï¼ˆZè»¸æ–¹å‘ï¼‰ã‚’å–å¾—ã—ã€å˜ä½åŒ–ã—ã¦è¿”ã™
    Vector3 forward = { worldMatrix.m[0][2], worldMatrix.m[1][2], worldMatrix.m[2][2] };

    // DirectXæ¨™æº–ã§ã¯ã‚«ãƒ¡ãƒ©ã®å‰æ–¹å‘ã¯ -Zãªã®ã§ç¬¦å·åè»¢ã™ã‚‹ã“ã¨ãŒå¤šã„
    forward = -forward;

    // æ­£è¦åŒ–
    forward = Normalize(forward);

    return forward;
}


============================================================
File Path: project/engine/camera/Camera.h
============================================================
#pragma once
#include"Transform.h"
#include"Matrix4x4.h"

// ã‚«ãƒ¡ãƒ©
class Camera
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚³ãƒ³ãƒˆãƒ©ã‚¯ã‚¿
	Camera();
	// æ›´æ–°å‡¦ç†
	void Update();
	// ImGuiã®æ›´æ–°
	void DebugUpdate();
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	Transform transform;
	Matrix4x4 worldMatrix;
	Matrix4x4 viewMatrix;
	Matrix4x4 projectionMatrix;
	Matrix4x4 ViewProjectionMatrix;

	float fovY; // æ°´å¹³æ–¹å‘è¦–é‡Žé‡Žè§’
	float aspectRatio; // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”
	float nearClip; // ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—è·é›¢
	float farclip; // ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—è·é›¢
public:
	// getter
	const Matrix4x4& GetWorldMatrix() const { return worldMatrix; }
	const Matrix4x4& GetViewMatrix() const { return viewMatrix; }
	const Matrix4x4& GetProjectionMatrix() const { return projectionMatrix; }
	const Matrix4x4& GetViewProjectionMatrix() const { return ViewProjectionMatrix; }
	const Vector3& GetRotate() const { return transform.rotate; }	
	Vector3& GetRotate() { return transform.rotate; }            // æ›¸ãæ›ãˆç”¨
	const Vector3& GetTranslate() const { return transform.translate; }		
	Vector3& GetTranslate() { return transform.translate; }            // æ›¸ãæ›ãˆç”¨
	Vector3 GetForward() const;
	// setter
	void SetRotate(const Vector3& rotate) { this->transform.rotate = rotate; }
	void SetTranslate(const Vector3& translate) { this->transform.translate = translate; }
	void SetFovY(const float& fovY) { this->fovY = fovY; }
	void SetAspectRatio(const float& aspectRatio) { this->aspectRatio = aspectRatio; }
	void SetNearClip(const float& nearClip) { this->nearClip = nearClip; }
	void Setfarclip(const float& farclip) { this->farclip = farclip; }
	void SetForward() const;
};

============================================================
File Path: project/engine/camera/CameraManager.cpp
============================================================
#include "CameraManager.h"
#include <Object3dCommon.h>
#include <ParticleCommon.h>
#include <MatrixVector.h>
#ifdef USE_IMGUI
#include <ImGuiManager.h>
#endif // USE_IMGUI

using namespace MatrixVector;

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<CameraManager> CameraManager::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
CameraManager* CameraManager::GetInstance() {
    if (!instance) {
        instance = std::make_unique<CameraManager>();
    }
    return instance.get();
}

// çµ‚äº†
void CameraManager::Finalize() {
    instance.reset();  // `delete` ä¸è¦
}

// åˆæœŸåŒ–
void CameraManager::Initialize(CameraTransform transform) {
    // å„æ§‹é€ ä½“ã®åˆæœŸåŒ–
    Typeview_ = ViewCameraType::Main;                     // ãƒ¡ã‚¤ãƒ³
    activeSceneCameraType_ = SceneCameraType::Title;      // ã‚¿ã‚¤ãƒˆãƒ«(ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã§ç®¡ç†ã•ã‚Œã¦ã„ã‚‹ãŸã‚å¤‰ãˆã‚‹å¿…è¦ãªã—)
    currentMode_ = CameraMode::Default;                   // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    switchType_ = CameraSwitchType::Instant;              // çž¬é–“çš„ã«åˆ‡ã‚Šæ›¿ã‚ã‚‹
    maintrans_ = transform;                               // å¼•æ•°ã‚’å…¥ã‚Œã‚‹
    // --- ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ã®ç”Ÿæˆã€åˆæœŸåŒ–--- //
    mainCamera_ = std::make_unique<Camera>();
    mainCamera_->SetTranslate(maintrans_.translate);
    mainCamera_->SetRotate(maintrans_.rotate);
    activeCamera_ = mainCamera_.get();  // åˆæœŸåŒ–æ™‚ã¯ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹

    // ã‚¿ã‚¤ãƒˆãƒ«ç”¨ã‚«ãƒ¡ãƒ©ã®ç”Ÿæˆã€åˆæœŸåŒ–
    title_ = std::make_unique<TitleCamera>();
    title_->Initialize();
    // ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ç”¨ã‚«ãƒ¡ãƒ©ã®ç”Ÿæˆã€åˆæœŸåŒ–
    gameplay_ = std::make_unique<GamePlayCamera>();
    gameplay_->Initialize();
    // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ç”¨ã‚«ãƒ¡ãƒ©ã®ç”Ÿæˆã€åˆæœŸåŒ–
    gameclear_ = std::make_unique<GameClearCamera>();
    gameclear_->Initialize();
    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”¨ã‚«ãƒ¡ãƒ©ã®ç”Ÿæˆã€åˆæœŸåŒ–
    gameover_ = std::make_unique<GameOverCamera>();
    gameover_->Initialize();


    // åˆæœŸã®ã‚·ãƒ¼ãƒ³ã¯ã‚¿ã‚¤ãƒˆãƒ«ã‚«ãƒ¡ãƒ©
    currentSceneCamera_ = title_.get();
    sceneCameraJustChanged_ = true;
}

// æ›´æ–°å‡¦ç†
void CameraManager::Update() {
    // ã‚·ãƒ¼ãƒ³ã‚«ãƒ¡ãƒ©ãŒå¤‰ã‚ã£ãŸã‚‰ä¸€åº¦ã ã‘Transformã¨ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚’åæ˜ 
    if (sceneCameraJustChanged_) {
        // å‰ã®ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚’ç ´æ£„
        subCamerasMap_.clear();
        // æ–°ã—ã„ã‚·ãƒ¼ãƒ³ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã¨ãã®ã¿ãƒ ãƒ¼ãƒ–
        if (currentSceneCamera_) { RegisterSubCameras(std::move(currentSceneCamera_->MoveSubCameras()), "SubCamera"); }
        sceneCameraJustChanged_ = false;
    }

    // ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
    if (currentSceneCamera_) { currentSceneCamera_->Update(); }

    // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ã«å€¤ã‚’åæ˜ 
    if (mainCamera_ && currentSceneCamera_) {
        maintrans_ = currentSceneCamera_->GetMainTransform();
        mainCamera_->SetTranslate(maintrans_.translate);
        mainCamera_->SetRotate(maintrans_.rotate);
        mainCamera_->Update();
    }

    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©æ›´æ–°
    for (std::pair<const std::string, std::unique_ptr<Camera>>& subcameras : subCamerasMap_) {
        subcameras.second->Update();
    }
    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ç™»éŒ²
    SetActiveCamera();
}

// ViewCameraType â†’ const char*
const char* ToString(CameraTypes::ViewCameraType type) {
    switch (type) {
    case CameraTypes::ViewCameraType::Main: return "Main";
    case CameraTypes::ViewCameraType::Sub: return "Sub";
    }
    return "Unknown";
}

// SceneCameraType â†’ const char*
const char* ToString(CameraTypes::SceneCameraType type) {
    switch (type) {
    case CameraTypes::SceneCameraType::Title: return "Title";
    case CameraTypes::SceneCameraType::Gameplay: return "Gameplay";
    case CameraTypes::SceneCameraType::GameClear: return "GameClear";
    case CameraTypes::SceneCameraType::GameOver: return "GameOver";
    }
    return "Unknown";
}

// CameraMode â†’ const char*
const char* ToString(CameraTypes::CameraMode mode) {
    switch (mode) {
    case CameraTypes::CameraMode::Default: return "Default";
    case CameraTypes::CameraMode::Follow: return "Follow";
    case CameraTypes::CameraMode::Event: return "Event";
    case CameraTypes::CameraMode::Transition: return "Transition";
    case CameraTypes::CameraMode::Debug: return "Debug";
    }
    return "Unknown";
}

// ImGuiæç”»
void CameraManager::DrawImGui() {
#ifdef USE_IMGUI
    ImGui::Begin("Camera Manager");

    // ================================================================
    // çŠ¶æ…‹ã‚’è¡¨ç¤ºï¼ˆå¤‰æ›´ä¸å¯ï¼‰
    // ================================================================
    ImGui::Text("=== Current Camera Status ===");

    ImGui::Text("Scene Camera Type : %s", ToString(activeSceneCameraType_));
    ImGui::Text("View Camera Type : %s", ToString(Typeview_));
    ImGui::Text("Camera Mode : %s", ToString(currentMode_));

    // ç¾åœ¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã‚’æ–‡å­—åˆ—ã§è¡¨ç¤º
    Camera* activeCam = GetActiveCamera();
    if (activeCam) {
        std::string activeCamName = "Main Camera";

        // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã«å«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
        for (auto& [name, cam] : subCamerasMap_) {
            if (cam.get() == activeCam) {
                activeCamName = name; // è¦‹ã¤ã‹ã£ãŸã‚‰åå‰ã‚’ã‚»ãƒƒãƒˆ
                break;
            }
        }

        ImGui::Text("Active Camera : %s", activeCamName.c_str());
    }

    // ä»Šã®ã‚·ãƒ¼ãƒ³ã«ã‚ã‚‹ãƒ¡ã‚¤ãƒ³ã¨ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®å€‹æ•°ã‚’è¡¨ç¤º
    ImGui::Text("Main Camera Count: %d", mainCamera_ ? 1 : 0);
    ImGui::Text("Sub Camera Count: %d", static_cast<int>(subCamerasMap_.size()));

    ImGui::Separator();

    // ================================================================
    // â‘  ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ç¨®åˆ¥ï¼ˆMain / Subï¼‰
    // ================================================================

    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©åˆ‡æ›¿ï¼ˆãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³å½¢å¼ï¼‰
    ImGui::Text("Active Camera");

    // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã®IDã‚’å‹•çš„ã«ç”Ÿæˆ
    int radioIdx = 0;

    // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©
    if (ImGui::RadioButton(("Main Camera##" + std::to_string(radioIdx++)).c_str(),
        Typeview_ == ViewCameraType::Main && activeSubCameraName_.empty()))
    {
        Typeview_ = ViewCameraType::Main;
        activeSubCameraName_.clear();
        SetActiveCamera();
    }
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ç¾¤
    if (!subCamerasMap_.empty()) {
        for (auto& [name, cam] : subCamerasMap_) {
            if (ImGui::RadioButton((name + "##" + std::to_string(radioIdx++)).c_str(),
                Typeview_ == ViewCameraType::Sub && activeSubCameraName_ == name))
            {
                Typeview_ = ViewCameraType::Sub;
                activeSubCameraName_ = name;
                SetActiveCamera();
            }
        }
    }

    ImGui::Separator();
    // ================================================================
    // â‘¡ å€‹ã€…ã®ã‚«ãƒ¡ãƒ© Debugï¼ˆtransform èª¿æ•´ UIï¼‰
    // ================================================================

    if (ImGui::TreeNode("Main Camera")) {
        maintrans_= currentSceneCamera_->GetMainTransform(); // åˆæœŸå€¤ã ã‘å–å¾—

        if (ImGui::DragFloat3("Position", &maintrans_.translate.x, 0.1f)) {
            mainCamera_->SetTranslate(maintrans_.translate);
            currentSceneCamera_->SetMainTranslate(maintrans_.translate); // æ–°è¦ã«ã‚»ãƒƒã‚¿ãƒ¼ã‚’ä½œã‚‹
        }
        if (ImGui::DragFloat3("Rotation", &maintrans_.rotate.x, 0.1f)) {
            mainCamera_->SetRotate(maintrans_.rotate);
            currentSceneCamera_->SetMainRotate(maintrans_.rotate); // æ–°è¦ã«ã‚»ãƒƒã‚¿ãƒ¼ã‚’ä½œã‚‹
        }
        ImGui::TreePop();
    }


    if (!subCamerasMap_.empty() && ImGui::TreeNode("Sub Cameras")) {
        int idx = 0;
        for (auto& [name, cam] : subCamerasMap_) {
            std::string label = name + "##" + std::to_string(idx++);
            if (ImGui::TreeNode(label.c_str())) {
                cam->DebugUpdate();
                ImGui::TreePop();
            }
        }
        ImGui::TreePop();
    }

    ImGui::End();
#endif
}

// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã‚’å–å¾—
Camera* CameraManager::GetActiveCamera() {  
    // Transitionä¸­ã¯å¸¸ã«ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ã‚’è¿”ã™
    if (currentMode_ == CameraMode::Transition) {
        return mainCamera_.get();
    }

    switch (Typeview_) {
    case ViewCameraType::Main:
        return mainCamera_.get();
    case ViewCameraType::Sub:
        if (!activeSubCameraName_.empty() && subCamerasMap_.count(activeSubCameraName_)) {
            return subCamerasMap_[activeSubCameraName_].get();
        }
        else if (!subCamerasMap_.empty()) {
            return subCamerasMap_.begin()->second.get(); // æœ€åˆã®ã‚µãƒ–ã‚«ãƒ¡ãƒ©
        }
        break;
    }
    return mainCamera_.get();
}

// ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰è¨­å®š
void CameraManager::SetCameraMode(CameraMode mode) {
    currentMode_ = mode;   // ãƒ¢ãƒ¼ãƒ‰ã‚’å¤‰æ›´
    SetActiveCamera();     // ã‚«ãƒ¡ãƒ©å…±é€šãƒªã‚½ãƒ¼ã‚¹ã¸åæ˜ 
}

// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã‚’å…±é€šãƒªã‚½ãƒ¼ã‚¹ã«è¨­å®š
void CameraManager::SetActiveCamera() { 
    activeCamera_ = GetActiveCamera(); // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã‚’å–å¾—
    // å…±é€šãƒªã‚½ãƒ¼ã‚¹ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    Object3dCommon::GetInstance()->SetDefaultCamera(activeCamera_);
    ParticleCommon::GetInstance()->SetDefaultCamera(activeCamera_);
}

// ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚’ä¸€æ‹¬ç™»éŒ²
void CameraManager::RegisterSubCameras(std::vector<std::unique_ptr<Camera>>&& cameras, const std::string& prefix) {
    subCamerasMap_.clear();    // æ—¢å­˜ã®ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã¯ç ´æ£„

    int idx = 0;
    for (std::unique_ptr<Camera>& cam : cameras) {
        std::string name = prefix + "_" + std::to_string(idx++);
        subCamerasMap_[name] = std::move(cam); // ãƒ ãƒ¼ãƒ–ã§ç™»éŒ²
    }
}

// å„ã‚·ãƒ¼ãƒ³ç”¨ã‚«ãƒ¡ãƒ©ã®åˆ‡æ›¿
void CameraManager::OnSceneChanged(SceneCameraType type) {
    activeSceneCameraType_ = type;
    // ã‚·ãƒ¼ãƒ³ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    switch (type) {
    case SceneCameraType::Title:
        currentSceneCamera_ = title_.get();
        break;
    case SceneCameraType::Gameplay:
        currentSceneCamera_ = gameplay_.get();
        break;
    case SceneCameraType::GameClear:
        currentSceneCamera_ = gameclear_.get();
        break;
    case SceneCameraType::GameOver:
        currentSceneCamera_ = gameover_.get();
        break;
    }
    // imguiã®ã‚µãƒ–ã‚«ãƒ¡ãƒ©é¸æŠžã‚’ãƒªã‚»ãƒƒãƒˆ
    Typeview_ = ViewCameraType::Main;  // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©ã«æˆ»ã™
    activeSubCameraName_.clear();
    sceneCameraJustChanged_ = true;
}

// ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‹ã‚‰ç¾åœ¨ã®ã‚·â€•ãƒ³ã‚’åˆ¤å®šã™ã‚‹
void CameraManager::NotifySceneChangedByName(const std::string& sceneName) {
    SceneCameraType newType;

    if (sceneName == "TITLE")     newType = SceneCameraType::Title;
    else if (sceneName == "GAMEPLAY")  newType = SceneCameraType::Gameplay;
    else if (sceneName == "GAMECLEAR") newType = SceneCameraType::GameClear;
    else if (sceneName == "GAMEOVER")  newType = SceneCameraType::GameOver;
    else newType = SceneCameraType::Title;

    // å¤‰æ›´ã‚’æ¤œçŸ¥ã—ã‚·ãƒ¼ãƒ³ãŒå¤‰ã‚ã£ãŸã‚‰å‡¦ç†
    if (newType != activeSceneCameraType_) {
        sceneCameraJustChanged_ = true;
        lastSceneCameraType_ = activeSceneCameraType_;
        activeSceneCameraType_ = newType;
        OnSceneChanged(newType);// å„ã‚·ãƒ¼ãƒ³ç”¨ã‚«ãƒ¡ãƒ©ã®åˆ‡æ›¿ã‚‚ã“ã“ã§åæ˜ ã™ã‚‹
    }
}

============================================================
File Path: project/engine/camera/CameraManager.h
============================================================
#pragma once
#include <Object3d.h>
#include<CameraTransform.h>
#include<CameraTypes.h>
#include<TitleCamera.h>
#include<GamePlayCamera.h>
#include<GameOverCamera.h>
#include<GameClearCamera.h>

using namespace CameraTypes;

// ã‚«ãƒ¡ãƒ©ãƒžãƒãƒ¼ã‚¸ãƒ£
class CameraManager {
private:
    static std::unique_ptr<CameraManager> instance;

    CameraManager(CameraManager&) = delete;
    CameraManager& operator=(CameraManager&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    CameraManager() = default;
    ~CameraManager() = default;
    // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
    static CameraManager* GetInstance();
    // çµ‚äº†
    void Finalize();
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize(CameraTransform Transform);
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary> 
    void Update();
    // ImGuiæç”»   
    void DrawImGui();
    // ã‚«ãƒ¡ãƒ©ãƒ¢ãƒ¼ãƒ‰è¨­å®š
    void SetCameraMode(CameraMode mode);
    // ã‚µãƒ–ã‚«ãƒ¡ãƒ©ã‚’ä¸€æ‹¬ç™»éŒ²
    void RegisterSubCameras(std::vector<std::unique_ptr<Camera>>&& cameras, const std::string& prefix);
    // ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‹ã‚‰ç¾åœ¨ã®ã‚·â€•ãƒ³ã‚’åˆ¤å®šã™ã‚‹
    void NotifySceneChangedByName(const std::string& sceneName);
    // å„ã‚·ãƒ¼ãƒ³ç”¨ã‚«ãƒ¡ãƒ©ã®åˆ‡æ›¿
    void OnSceneChanged(SceneCameraType type);


private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    ViewCameraType Typeview_;                                                  // ä½¿ç”¨ã™ã‚‹ã‚«ãƒ¡ãƒ©ã®ã‚¿ã‚¤ãƒ—  
    SceneCameraType activeSceneCameraType_;                                    // ã‚«ãƒ¡ãƒ©ãŒã©ã“ã®ã‚·ãƒ¼ãƒ³ã«ã‚ã‚‹ã‹
    CameraMode currentMode_;                                                   // ã‚«ãƒ¡ãƒ©ã®çŠ¶æ…‹ 
    CameraSwitchType switchType_ = CameraSwitchType::Instant;                  // ã‚«ãƒ¡ãƒ©ã®åˆ‡æ›¿æ–¹æ³•
    std::unique_ptr<Camera> mainCamera_;                                       //ã€€ãƒ¡ã‚¤ãƒ³ã‚«ãƒ¡ãƒ©(åŸºæœ¬1ã¤)
    CameraTransform maintrans_;                                                // ã‚«ãƒ¡ãƒ©ã®åº§æ¨™
    std::unordered_map<std::string, std::unique_ptr<Camera>> subCamerasMap_;   // ã‚µãƒ–ã‚«ãƒ¡ãƒ©(è¤‡æ•°ã®è¨­ç½®ã«å¯¾å¿œã§ãã‚‹)
    std::string activeSubCameraName_;                                          // ç™»éŒ²ã—ãŸã‚µãƒ–ã‚«ãƒ¡ãƒ©ã®åå‰
    Camera* activeCamera_ = nullptr;                                           // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ä¸­ã®ã‚«ãƒ¡ãƒ©
    // å„ã‚·ãƒ¼ãƒ³ç”¨ã‚«ãƒ¡ãƒ©ã‚¯ãƒ©ã‚¹
    std::unique_ptr<TitleCamera> title_;      // ã‚¿ã‚¤ãƒˆãƒ«
    std::unique_ptr<GamePlayCamera> gameplay_;        // ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤
    std::unique_ptr<GameClearCamera> gameclear_;  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
    std::unique_ptr<GameOverCamera> gameover_;    // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢


    SceneCameraBase* currentSceneCamera_;
    // å‰å›žã®ã‚·ãƒ¼ãƒ³ã‚«ãƒ¡ãƒ©ã‚¿ã‚¤ãƒ—
    SceneCameraType lastSceneCameraType_ = SceneCameraType::Title;
    // ã‚·ãƒ¼ãƒ³åˆ‡æ›¿ç›´å¾ŒUpdateæ™‚ã«ä¸€åº¦ã ã‘å„ã‚·ãƒ¼ãƒ³ç”¨ã‚«ãƒ¡ãƒ©ã®æƒ…å ±ã‚’åæ˜ 
    bool sceneCameraJustChanged_ = false;

public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚«ãƒ¡ãƒ©
    Camera* GetActiveCamera();
    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã‚’æ›´æ–°ã—ã€å…±é€šãƒªã‚½ãƒ¼ã‚¹ã«è¨­å®šã™ã‚‹
    void SetActiveCamera();

    ViewCameraType GetTypeview() const { return Typeview_; }
    void SetTypeview(ViewCameraType type) { Typeview_ = type; }
    CameraMode GetMode() const { return currentMode_; }
    void SetMode(CameraMode mode) { currentMode_ = mode; }
    GamePlayCamera* GetGameCamera() const { return gameplay_.get(); };
    // ã‚²ãƒ¼ãƒ ç”¨ã‚«ãƒ¡ãƒ©ï¼ˆGameCameraï¼‰ã‚’è¿”ã™ getter
    GamePlayCamera* GetGameplayCamera() const { return gameplay_.get(); }
    GameClearCamera* GetGameClearCamera() { return gameclear_.get(); }
    TitleCamera* GetTitleCamera() { return title_.get(); }

    SceneCameraType GetActiveSceneCamera() const{ return activeSceneCameraType_; }

    CameraSwitchType GetSwitchType() const { return switchType_; }
    void SetSwitchType(CameraSwitchType type) { switchType_ = type; }

    Camera* GetMainCamera() const {
        return mainCamera_.get();
    }

    const CameraTransform& GetMainCameraTransform() const {
        return maintrans_;
    }

    Camera* GetSubCamera(const std::string& name) {
        auto it = subCamerasMap_.find(name);
        if (it != subCamerasMap_.end()) {
            return it->second.get();
        }
        return nullptr;
    }

    const std::unordered_map<std::string, std::unique_ptr<Camera>>& GetSubCameraMap() const {
        return subCamerasMap_;
    }

    void SetGamecameraTarget(Object3d* target) {
        if (!gameplay_) return;
        gameplay_->SetFollowTarget(target);
    }
};

============================================================
File Path: project/engine/camera/CameraTransform.h
============================================================
#pragma once
#include <Vector3.h>

// ã‚«ãƒ¡ãƒ©ã®åŸºæœ¬æƒ…å ±
struct CameraTransform {
    Vector3 translate; // ã‚«ãƒ¡ãƒ©ä½ç½®
    Vector3 rotate;    // ã‚«ãƒ¡ãƒ©å›žè»¢
};

============================================================
File Path: project/engine/camera/CameraTypes.h
============================================================
#pragma once
#include <Vector3.h>

// ã‚«ãƒ¡ãƒ©ã¯ã®å„æƒ…å ±
namespace CameraTypes {
    // ã‚«ãƒ¡ãƒ©ã®ç¨®é¡ž
    enum class ViewCameraType {
        Main,      // ãƒ¡ã‚¤ãƒ³
        Sub,       // ã‚µãƒ–
        Debug,     // ãƒ‡ãƒãƒƒã‚¯
    };
    //  ã‚·ãƒ¼ãƒ³ã”ã¨ã®ã‚«ãƒ¡ãƒ©ã®ã‚¿ã‚¤ãƒ—
    enum class SceneCameraType {
        Title,         // ã‚¿ã‚¤ãƒˆãƒ«
        Gameplay,      // ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤
        GameClear,     // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢
        GameOver,      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
    };
    // ã‚«ãƒ¡ãƒ©ã®çŠ¶æ…‹
    enum class CameraMode {
        Default,      // æ‰‹å‹• or å›ºå®šè¦–ç‚¹ã‚«ãƒ¡ãƒ©
        Follow,       // è¿½å¾“ã‚«ãƒ¡ãƒ©ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãªã©ã‚’è¿½ã†ï¼‰
        Event,        // ã‚¤ãƒ™ãƒ³ãƒˆãƒ»æ¼”å‡ºç”¨ã‚«ãƒ¡ãƒ©
        Transition,   // åˆ‡æ›¿ä¸­
        Debug,        // ãƒ‡ãƒãƒƒã‚¯(ãƒ•ãƒªãƒ¼ç§»å‹•)
    };
    // åˆ‡ã‚Šæ›¿ãˆæ™‚ã®ç§»å‹•æ–¹æ³•
    enum class CameraSwitchType {
        Instant,   // çž¬é–“çš„ã«åˆ‡ã‚Šæ›¿ã‚ã‚‹
        Ease       // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã§ã®ç§»å‹•
    };
}

============================================================
File Path: project/engine/io/Controller.cpp
============================================================
#include "Controller.h"
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include <string>
#include <algorithm>

Controller* Controller::GetInstance() {
    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å–å¾—
    static Controller instance;
    return &instance;
}

void Controller::Update() {
    // å‰å›žã®çŠ¶æ…‹ã‚’ä¿å­˜
    previousState = currentState;

    // ç¾åœ¨ã®çŠ¶æ…‹ã‚’å–å¾—
    ZeroMemory(&currentState, sizeof(XINPUT_STATE));
    DWORD result = XInputGetState(0, &currentState);  // 0ç•ªç›®ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®çŠ¶æ…‹ã‚’å–å¾—

    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒæŽ¥ç¶šã•ã‚Œã¦ã„ãªã„å ´åˆã€çŠ¶æ…‹ã‚’ã‚¼ãƒ­ã‚¯ãƒªã‚¢
    if (result != ERROR_SUCCESS) {
        ZeroMemory(&currentState, sizeof(XINPUT_STATE));
        return; // â†ã“ã“ã§æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ã—ã¦OK
    }
}

bool Controller::IsPressed(WORD button) {
    return (currentState.Gamepad.wButtons & button) != 0;
}

bool Controller::IsTriggered(WORD button) {
    return !(previousState.Gamepad.wButtons & button) &&
        (currentState.Gamepad.wButtons & button);
}

void Controller::DrawImGui() {
#ifdef USE_IMGUI
    const XINPUT_GAMEPAD& pad = currentState.Gamepad;  // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã®ç¾åœ¨ã®çŠ¶æ…‹ã‚’å‚ç…§

    ImGui::Begin("Controller Debug");
    
    // ãƒˆãƒªã‚¬ãƒ¼ï¼ˆã‚¢ãƒŠãƒ­ã‚°ï¼‰
    float leftTrigger = pad.bLeftTrigger / 255.0f;
    float rightTrigger = pad.bRightTrigger / 255.0f;
    ImGui::Text("Left Trigger:  %.2f", leftTrigger);
    ImGui::ProgressBar(leftTrigger, ImVec2(300, 0));
    ImGui::Text("Right Trigger: %.2f", rightTrigger);
    ImGui::ProgressBar(rightTrigger, ImVec2(300, 0));

    // ã‚¹ãƒ†ã‚£ãƒƒã‚¯ï¼ˆã‚¢ãƒŠãƒ­ã‚°ï¼‰
    float lx = NormalizeThumbAxis(pad.sThumbLX, XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE);
    float ly = NormalizeThumbAxis(pad.sThumbLY, XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE);
    float rx = NormalizeThumbAxis(pad.sThumbRX, XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE);
    float ry = NormalizeThumbAxis(pad.sThumbRY, XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE);

    // ã‚¹ãƒ†ã‚£ãƒƒã‚¯åº§æ¨™ã‚’ãƒ†ã‚­ã‚¹ãƒˆã§è¡¨ç¤º
    ImGui::Separator();
    ImGui::Text("Left Stick:  (X = %.2f, Y = %.2f)", lx, ly);
    ImGui::Text("Right Stick: (X = %.2f, Y = %.2f)", rx, ry);

    // åå­—ã‚­ãƒ¼ã¨ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹
    ImGui::Separator();
    ImGui::Text("Buttons Pressed:");
    
    // ãƒœã‚¿ãƒ³ã®ãƒ“ãƒƒãƒˆãƒ•ãƒ©ã‚°
    struct ButtonInfo {
        WORD flag;
        const char* name;
    };

    static ButtonInfo buttons[] = {
        { XINPUT_GAMEPAD_A, "A" },
        { XINPUT_GAMEPAD_B, "B" },
        { XINPUT_GAMEPAD_X, "X" },
        { XINPUT_GAMEPAD_Y, "Y" },
        { XINPUT_GAMEPAD_DPAD_UP, "DPad Up" },
        { XINPUT_GAMEPAD_DPAD_DOWN, "DPad Down" },
        { XINPUT_GAMEPAD_DPAD_LEFT, "DPad Left" },
        { XINPUT_GAMEPAD_DPAD_RIGHT, "DPad Right" },
        { XINPUT_GAMEPAD_LEFT_SHOULDER, "L Shoulder" },
        { XINPUT_GAMEPAD_RIGHT_SHOULDER, "R Shoulder" },
        { XINPUT_GAMEPAD_START, "Start" },
        { XINPUT_GAMEPAD_BACK, "Back" },
        { XINPUT_GAMEPAD_LEFT_THUMB, "L Stick Press" },
        { XINPUT_GAMEPAD_RIGHT_THUMB, "R Stick Press" },
    };
    // å„ãƒœã‚¿ãƒ³ã«ã¤ã„ã¦ã€æŠ¼ã•ã‚Œã¦ã„ã‚Œã°è¡¨ç¤º
    for (const auto& b : buttons) {
        if (pad.wButtons & b.flag) {
            ImGui::SameLine(); // æ¨ªä¸¦ã³ã«è¡¨ç¤º
            ImGui::TextColored(ImVec4(0.2f, 1.0f, 0.2f, 1.0f), "[%s]", b.name);
        }
    }
    ImGui::End();
#endif // USE_IMGUI
}

float Controller::NormalizeThumbAxis(SHORT value, SHORT deadzone) {
    if (abs(value) < deadzone) {
        return 0.0f;
    }
    float norm = (float)value / 32767.0f;
    return std::clamp(norm, -1.0f, 1.0f);
}

============================================================
File Path: project/engine/io/Controller.h
============================================================
#pragma once
#define WIN32_LEAN_AND_MEAN // ä¸è¦ãªãƒ˜ãƒƒãƒ€ã‚’é™¤å¤–
#include <Windows.h>
#include <XInput.h>
#pragma comment(lib, "xinput.lib") // XInputãƒªãƒ³ã‚¯

// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
class Controller {
private:    
    // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    Controller() = default;
    ~Controller() = default;
public:
    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å–å¾—ï¼ˆã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ï¼‰
    static Controller* GetInstance();

    /// <summary>
    /// å…¥åŠ›çŠ¶æ…‹ã‚’æ›´æ–°
    /// </summary>
    void Update();
     
    /// <summary>
    /// æŒ‡å®šãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ï¼ˆæŠ¼ã•ã‚Œã¦ã‚‹é–“ trueï¼‰
    /// </summary>
    bool IsPressed(WORD button);
    /// <summary>
    /// æŒ‡å®šãƒœã‚¿ãƒ³ãŒæ–°ã—ãæŠ¼ã•ã‚ŒãŸã‹ã©ã†ã‹ï¼ˆæŠ¼ã•ã‚ŒãŸçž¬é–“ trueï¼‰
    /// </summary>
    bool IsTriggered(WORD button);

    // imgui
    void DrawImGui();
    // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ãƒ‡ãƒƒãƒˆã‚¾ãƒ¼ãƒ³å‡¦ç†
    float NormalizeThumbAxis(SHORT value, SHORT deadzone);
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
    XINPUT_STATE currentState{};     // ç¾åœ¨ã®ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã®çŠ¶æ…‹
    XINPUT_STATE previousState{};    // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã®çŠ¶æ…‹
};

============================================================
File Path: project/engine/io/Input.cpp
============================================================
#include "Input.h"
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#include<cassert>
#pragma comment(lib,"dinput8.lib")
#pragma comment(lib,"dxguid.lib")

Input* Input::instance = nullptr;

Input* Input::GetInstance() {
	if (instance == nullptr) {
		instance = new Input;
	}
	return instance;
}

void Input::Finalize() {
	delete instance;
	instance = nullptr;
}

void Input::Initialize(WinApp* winApp) {

	// å€Ÿã‚Šã¦ããŸwinAppã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¨˜éŒ²
	this->winApp_ = winApp;

	HRESULT result;
	// DirectInputã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆ
	result = DirectInput8Create(winApp->GetHInstance(), DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&dinput, nullptr);
	assert(SUCCEEDED(result));

	// ã‚­ãƒ¼ãƒœï¼ãƒ‰ãƒ‡ãƒã‚¤ã‚¹ç”Ÿæˆ
	result = dinput->CreateDevice(GUID_SysKeyboard, &keyboard, NULL);
	assert(SUCCEEDED(result));
	// å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetDataFormat(&c_dfDIKeyboard);
	assert(SUCCEEDED(result));
	// æŽ’ä»–åˆ¶å¾¡ãƒ¬ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetCooperativeLevel(winApp->Gethwnd(), DISCL_FOREGROUND | DISCL_NONEXCLUSIVE | DISCL_NOWINKEY);
	assert(SUCCEEDED(result));

	// ãƒžã‚¦ã‚¹ãƒ‡ãƒã‚¤ã‚¹ç”Ÿæˆ
	result = dinput->CreateDevice(GUID_SysMouse, &mouse, nullptr);
	assert(SUCCEEDED(result));
	// ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã®ã‚»ãƒƒãƒˆ
	result = mouse->SetDataFormat(&c_dfDIMouse);
	assert(SUCCEEDED(result));
	// æŽ’ä»–åˆ¶å¾¡ãƒ¬ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆ
	result = mouse->SetCooperativeLevel(winApp->Gethwnd(), DISCL_FOREGROUND | DISCL_NONEXCLUSIVE);
	assert(SUCCEEDED(result));
}

void Input::Update() {
	// å‰å›žã®ã‚­ãƒ¼å…¥åŠ›ã‚’ä¿å­˜
	memcpy(keyPre, key, sizeof(keyPre));
	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æƒ…å ±ã®å–å¾—é–‹å§‹
	keyboard->Acquire();
	// å…¨ã‚­-ã®å…¥åŠ›çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹
	keyboard->GetDeviceState(sizeof(key), key);

	// ãƒžã‚¦ã‚¹ã‚’
	if (useMouseInput_) {
		// ãƒžã‚¦ã‚¹å–å¾—
		mouse->Acquire();
		mouse->GetDeviceState(sizeof(mouseState), &mouseState);
		// ãƒžã‚¦ã‚¹åº§æ¨™ã‚’åŠ ç®—æ›´æ–°ï¼ˆç§»å‹•é‡ï¼‰
		mousePosition_.x += mouseState.lX;
		mousePosition_.y += mouseState.lY;
		// ç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†åˆ¶é™ï¼ˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å†…ã‚¯ãƒªãƒƒãƒ—ï¼‰
		mousePosition_.x = max(0, min(mousePosition_.x, (int)WinApp::kClientWidth));
		mousePosition_.y = max(0, min(mousePosition_.y, (int)WinApp::kClientHeight));
	}
}

bool Input::Pushkey(BYTE keyNumber)
{
	// æŒ‡å®šã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã„ã‚Œã°trueã‚’è¿”ã™
	if (key[keyNumber]) {
		return true;
	}
	// ãã†ã§ãªã‘ã‚Œã°falseã‚’è¿”ã™
	return false;
}

bool Input::Triggrkey(BYTE keyNumber)
{
	// å‰å›žã¯æŠ¼ã—ã¦ã„ãªã„,ä»Šå›žã¯æŠ¼ã—ã¦ã„ã‚‹ã®ã§ã‚ã‚Œã°trueã‚’è¿”ã™
	if (!keyPre[keyNumber] && key[keyNumber]) {
		return true;
	}
	// ãã†ã§ãªã‘ã‚Œã°falseã‚’è¿”ã™
	return false;
}

void Input::DrawImGui() {
#ifdef USE_IMGUI
	ImGui::Begin("Input Debug");

	// --- ãƒžã‚¦ã‚¹å…¥åŠ›ã®ON/OFFåˆ‡ã‚Šæ›¿ãˆ ---
	ImGui::Checkbox("Enable Mouse Input", &useMouseInput_);

	ImGui::Text("Mouse Position: (%d, %d)", mousePosition_.x, mousePosition_.y);  // ç¾åœ¨ã®ãƒžã‚¦ã‚¹åº§æ¨™ã‚’è¡¨ç¤º
	ImGui::Text("Mouse Delta:    (%ld, %ld)", mouseState.lX, mouseState.lY);      // ä»Šãƒ•ãƒ¬ãƒ¼ãƒ ã§ã®ãƒžã‚¦ã‚¹ã®ç§»å‹•é‡ã‚’è¡¨ç¤ºï¼ˆç›¸å¯¾å€¤ï¼‰

	ImGui::Separator();
	ImGui::Text("Mouse Buttons:"); // ãƒžã‚¦ã‚¹ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’è¡¨ç¤º
	for (int i = 0; i < 3; ++i) {
		if (mouseState.rgbButtons[i] & 0x80) {
			ImGui::SameLine();
			ImGui::TextColored(ImVec4(1, 1, 0, 1), "[Button %d]", i); // ãƒœã‚¿ãƒ³åã‚’é»„è‰²ã§è¡¨ç¤º
		}
	}
	ImGui::End();
#endif
}

============================================================
File Path: project/engine/io/Input.h
============================================================
#pragma once
#include<Windows.h>
#include<wrl.h>
#define DIRECTINPUT_VERSION   0x0800 // DirectInputã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®š
#include<dinput.h>
#include "WinApp.h"

// å…¥åŠ›
class Input
{
private:
	static Input* instance;

	Input() = default;
	~Input() = default;
	Input(Input&) = delete;
	Input& operator=(Input&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static Input* GetInstance();
	// çµ‚äº†
	void Finalize();

	// namespaceçœç•¥
	template <class T> using ComPtr = Microsoft::WRL::ComPtr<T>;

	// åˆæœŸåŒ–
	void Initialize(WinApp* winApp);
	// æ›´æ–°
	void Update();

	/// <summary>
	/// ã‚­ãƒ¼ã®æŠ¼ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="keyNumber"ã‚­ãƒ¼ç•ªå·( DIK_0 ç­‰)</param>
	bool Pushkey(BYTE keyNumber);

	/// <summary>
	/// ã‚­ãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="keyNumber"ã‚­ãƒ¼ç•ªå·( DIK_0 ç­‰)</param>
	/// <returns>ãƒˆãƒªã‚¬ãƒ¼ã‹</returns>
	bool Triggrkey(BYTE keyNumber);

	/// <summary>
	/// ãƒžã‚¦ã‚¹ã®åº§æ¨™ã‚’å–å¾—
	/// </summary>
    POINT GetMousePosition() const { return mousePosition_; }
    
	// ImGuiãƒ‡ãƒãƒƒã‚°æç”»
    void DrawImGui();
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°	
	// ãƒã‚¤ãƒ³ã‚¿
	WinApp* winApp_ = nullptr;	
	//ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã®ãƒ‡ãƒã‚¤ã‚¹
	ComPtr<IDirectInputDevice8> keyboard;
	// å…¨ã‚­ãƒ¼ã®çŠ¶æ…‹
	BYTE key[256] = {};
	// å‰å›žã®å…¨ã‚­ãƒ¼ã®çŠ¶æ…‹
	BYTE keyPre[256] = {};
	// DirectInputã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ç”Ÿæˆ
	ComPtr<IDirectInput8> dinput = nullptr;
	// ãƒžã‚¦ã‚¹ã®ãƒ‡ãƒã‚¤ã‚¹
    ComPtr<IDirectInputDevice8> mouse;
    // ãƒžã‚¦ã‚¹ã®çŠ¶æ…‹ï¼ˆDirectInput å°‚ç”¨æ§‹é€ ä½“ï¼‰
    DIMOUSESTATE mouseState = {};
    // ç”»é¢ä¸Šã®ãƒžã‚¦ã‚¹åº§æ¨™ï¼ˆç‹¬è‡ªã§ä¿æŒï¼‰
    POINT mousePosition_ = { 0, 0 };
	//ã€€ãƒžã‚¦ã‚¹ã‚’ä½¿ã†ã‹ã©ã†ã‹
	bool useMouseInput_ = false;
public: // getter setter
	bool GetMouseInput() { return useMouseInput_; }		
	void SetMouseInput(bool mouse) { useMouseInput_ = mouse; }
    const DIMOUSESTATE& GetMouseState() const { return mouseState; }
};

============================================================
File Path: project/engine/math/Collision/Collision.cpp
============================================================
#include "Collision.h"
#include <cmath>
#include <MatrixVector.h>

using namespace MatrixVector;

namespace Collision {

    bool Collision::IsOBBIntersect(const OBB& a, const OBB& b) {
        const float EPSILON = 1e-5f;
        Vector3 T = b.center - a.center;

        Vector3 A[3] = { a.axis[0], a.axis[1], a.axis[2] };
        Vector3 B[3] = { b.axis[0], b.axis[1], b.axis[2] };

        float R[3][3];
        float AbsR[3][3];

        // å›žè»¢è¡Œåˆ—
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                R[i][j] = Dot(A[i], B[j]);
                AbsR[i][j] = std::abs(R[i][j]) + EPSILON;
            }
        }

        // Tã‚’Aç©ºé–“ã«å¤‰æ›
        T = { Dot(T, A[0]), Dot(T, A[1]), Dot(T, A[2]) };

        // Aã®3è»¸
        for (int i = 0; i < 3; ++i) {
            float ra = a.halfSize[i];
            float rb =
                b.halfSize[0] * AbsR[i][0] +
                b.halfSize[1] * AbsR[i][1] +
                b.halfSize[2] * AbsR[i][2];
            if (std::abs(T[i]) > ra + rb) return false;
        }

        // Bã®3è»¸
        for (int i = 0; i < 3; ++i) {
            float ra =
                a.halfSize[0] * AbsR[0][i] +
                a.halfSize[1] * AbsR[1][i] +
                a.halfSize[2] * AbsR[2][i];
            float rb = b.halfSize[i];
            if (std::abs(T[0] * R[0][i] + T[1] * R[1][i] + T[2] * R[2][i]) > ra + rb) return false;
        }

        // ã‚¯ãƒ­ã‚¹ç©9è»¸
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                float ra =
                    a.halfSize[(i + 1) % 3] * AbsR[(i + 2) % 3][j] +
                    a.halfSize[(i + 2) % 3] * AbsR[(i + 1) % 3][j];

                float rb =
                    b.halfSize[(j + 1) % 3] * AbsR[i][(j + 2) % 3] +
                    b.halfSize[(j + 2) % 3] * AbsR[i][(j + 1) % 3];

                float t =
                    std::abs(T[(i + 2) % 3] * R[(i + 1) % 3][j] -
                        T[(i + 1) % 3] * R[(i + 2) % 3][j]);

                if (t > ra + rb) return false;
            }
        }

        return true;
    }

};

============================================================
File Path: project/engine/math/Collision/Collision.h
============================================================
#pragma once
#include "OBB.h"

namespace Collision {
    // OBB vs OBB
    bool IsOBBIntersect(const OBB& a, const OBB& b);




};

============================================================
File Path: project/engine/math/Collision/OBB.h
============================================================
#pragma once
#include <Vector3.h>

/// <summary>
/// OBBï¼ˆOriented Bounding Boxï¼‰æ§‹é€ ä½“
/// </summary>
struct OBB {
    Vector3 center;     // ä¸­å¿ƒä½ç½®ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰
    Vector3 halfSize;   // å„è»¸æ–¹å‘ã®åŠåˆ†ã‚µã‚¤ã‚ºï¼ˆã‚¹ã‚±ãƒ¼ãƒ«/2ï¼‰
    Vector3 axis[3];    // ãƒ­ãƒ¼ã‚«ãƒ«è»¸ï¼ˆå›žè»¢ã‚’åæ˜ ã—ãŸX,Y,Zå˜ä½ãƒ™ã‚¯ãƒˆãƒ«ï¼‰
};

============================================================
File Path: project/engine/math/Easing/Easing.cpp
============================================================
#include "Easing.h"
#include <cmath>

namespace Easing {

    // ============================================================
    //  å˜ä¸€ float ã®ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°
    //  t ã¯ 0.0f ï½ž 1.0f ã‚’æƒ³å®š
    // ============================================================

    // -------------------------
    //  EaseOut ç³»ï¼ˆçµ‚ã‚ã‚ŠãŒã‚†ã£ãã‚Šï¼‰
    // -------------------------

    float EaseOutSine(float t) {
        // ã‚µã‚¤ãƒ³æ³¢ã®çµ‚ã‚ã‚Šã‚’ä½¿ã£ã¦æ»‘ã‚‰ã‹ã«æ¸›é€Ÿ
        return sinf((t * 3.14159265f) / 2.0f);
    }

    float EaseOutCubic(float t) {
        // t ã‚’é€†å‘ã (1 - t) ã«ã—ã¦ç«‹ã¡ä¸ŠãŒã‚Šã‚¹ãƒ­ãƒ¼ã‚’ä½œã‚‹
        float k = 1.0f - t;
        return 1.0f - (k * k * k);
    }

    float EaseOutBack(float t) {
        // çµ‚ç‚¹ã§å°‘ã—ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆã™ã‚‹ Back åŠ¹æžœã‚«ãƒ¼ãƒ–
        const float c1 = 1.70158f;
        const float c3 = c1 + 1.0f;

        return 1.0f + c3 * powf(t - 1.0f, 3) + c1 * powf(t - 1.0f, 2);
    }

    float EaseOutQuad(float t) {
        return 1.0f - (1.0f - t) * (1.0f - t);
    }

    // -------------------------
    //  EaseIn ç³»ï¼ˆæœ€åˆãŒã‚†ã£ãã‚Šï¼‰
    // -------------------------

    float EaseInSine(float t) {
        return 1.0f - cosf((t * 3.14159265f) / 2.0f);
    }

    float EaseInCubic(float t) {
        return t * t * t;
    }

    float EaseInBack(float t) {
        const float c1 = 1.70158f;
        const float c3 = c1 + 1.0f;

        return c3 * t * t * t - c1 * t * t;
    }


    // -------------------------
    //  EaseInOut ç³»ï¼ˆä¸­å¤®ãŒé€Ÿã„ï¼‰
    // -------------------------

    float EaseInOutSine(float t) {
        return -(cosf(3.14159265f * t) - 1.0f) / 2.0f;
    }

    float EaseInOutCubic(float t) {
        return (t < 0.5f)
            ? 4.0f * t * t * t
            : 1.0f - powf(-2.0f * t + 2.0f, 3) / 2.0f;
    }

    float EaseInOutBack(float t) {
        const float c1 = 1.70158f;
        const float c2 = c1 * 1.525f;

        if (t < 0.5f) {
            return (powf(2.0f * t, 2) * ((c2 + 1.0f) * 2.0f * t - c2)) / 2.0f;
        } else {
            return (powf(2.0f * t - 2.0f, 2) * ((c2 + 1.0f) * (t * 2.0f - 2.0f) + c2) + 2.0f) / 2.0f;
        }
    }


    // ============================================================
    //  Vector3 ã®ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°è£œé–“
    // ============================================================

    Vector3 EaseVector3(const Vector3& start, const Vector3& end, float t, float(*easeFunc)(float)) {

        float e = easeFunc(t); // ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã§è£œé–“çŽ‡ã‚’ç®—å‡º

        return {
            start.x + (end.x - start.x) * e,
            start.y + (end.y - start.y) * e,
            start.z + (end.z - start.z) * e
        };
    }


    // ============================================================
    //  Vector3 ç·šå½¢è£œé–“ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ãªã—ï¼‰
    // ============================================================

    Vector3 Lerp(const Vector3& start, const Vector3& end, float t) {
        return {
            start.x + (end.x - start.x) * t,
            start.y + (end.y - start.y) * t,
            start.z + (end.z - start.z) * t
        };
    }

}

============================================================
File Path: project/engine/math/Easing/Easing.h
============================================================
#pragma once
#include "Vector3.h"

/// <summary>
///  ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚„è£œé–“å‡¦ç†ã§åˆ©ç”¨ã™ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ç¾¤
///  t ã¯ 0.0f ï½ž 1.0f ã®æ­£è¦åŒ–æ™‚é–“ã‚’æƒ³å®š
/// </summary>
namespace Easing {

    /// <summary> 
    ///  å˜ä¸€ã® float å€¤ã«å¯¾ã™ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°    
    ///  æˆ»ã‚Šå€¤ã¯ 0.0f ï½ž 1.0f ã®ç¯„å›²ã§è£œé–“çŽ‡ã‚’è¿”ã™
    /// </summary>

    // t : [0 â†’ 1] ãŒæ»‘ã‚‰ã‹ã«åŠ é€Ÿ â†’ æ¸›é€Ÿã—ãªãŒã‚‰å¤‰åŒ–ã™ã‚‹
    float EaseOutSine(float t);     // ã‚†ã£ãã‚Šçµ‚ã‚ã‚‹ã‚µã‚¤ãƒ³æ›²ç·š
    float EaseOutCubic(float t);    // éžå¸¸ã«æ»‘ã‚‰ã‹ã«çµ‚ç‚¹ã§æ¸›é€Ÿ
    float EaseOutBack(float t);     // çµ‚ç‚¹ã‚’å°‘ã—é€šã‚Šè¶Šã—ã¦æˆ»ã‚‹ï¼ˆ"Back" åŠ¹æžœï¼‰
    float EaseOutQuad(float t);

    float EaseInSine(float t);      // å§‹ç‚¹ãŒã‚†ã£ãã‚Š
    float EaseInCubic(float t);     // å§‹ç‚¹ãŒéžå¸¸ã«ã‚†ã£ãã‚Š
    float EaseInBack(float t);      // å§‹ç‚¹ã§å°‘ã—é€†æ–¹å‘ã®åå‹•

    float EaseInOutSine(float t);   // å…¨ä½“ãŒæ»‘ã‚‰ã‹ãªã‚µã‚¤ãƒ³ã‚«ãƒ¼ãƒ–
    float EaseInOutCubic(float t);  // å…¨ä½“ãŒå¼·ã‚ã«æ»‘ã‚‰ã‹
    float EaseInOutBack(float t);   // å§‹ç‚¹ã¨çµ‚ç‚¹ä¸¡æ–¹ã«åå‹•ã‚’æŒã¤

    /// <summary> 
    //  Vector3 ã®ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°è£œé–“
    /// </summary>
    Vector3 EaseVector3(const Vector3& start, const Vector3& end, float t, float(*easeFunc)(float));
    /// <summary>
    /// æ±Žç”¨ç·šå½¢è£œé–“ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ãªã—ã®åŸºæœ¬è£œé–“ï¼‰ 
    /// </summary>
    /// floatã®ç·šå½¢è£œé–“
    inline float Lerp(float a, float b, float t) { return a + (b - a) * t; }
    // Vector3ã®ç·šå½¢è£œé–“
    Vector3 Lerp(const Vector3& start, const Vector3& end, float t);
}

============================================================
File Path: project/engine/math/Light/DirectionalLight.h
============================================================
#pragma once
#include <Vector4.h>
#include <Vector3.h>

/// <summary>
/// å¹³è¡Œå…‰æºãƒ‡ãƒ¼ã‚¿
/// </summary>
struct DirectionalLight final {
	Vector4 color; //!< ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 direction; //!< ãƒ©ã‚¤ãƒˆã®å‘ã
	float intensity; //!< è¼åº¦
};

============================================================
File Path: project/engine/math/Light/PointLight.h
============================================================
#pragma once
#include<Vector4.h>
#include <Vector3.h>

/// <summary>
/// ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ
/// </summary>
struct PointLight final {
	Vector4 color; //!< ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 position; //!< ãƒ©ã‚¤ãƒˆã®ä½ç½®
	float intensity; //!< è¼åº¦
	float radius; //!< ãƒ©ã‚¤ãƒˆã®å±Šãæœ€å¤§è·é›¢
	float decay; //!< æ¸›è¡°çŽ‡
	float padding[2];
};

============================================================
File Path: project/engine/math/Light/SpotLight.h
============================================================
#pragma once
#include <Vector4.h>
#include <Vector3.h>

/// <summary>
/// ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆ
/// </summary>
struct SpotLight final {
	Vector4 color; //!< ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 position; //!< ãƒ©ã‚¤ãƒˆã®ä½ç½®
	float intensity; //!< è¼åº¦
	Vector3 direction; //!< ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®å‘ã
	float distance; //!< ãƒ©ã‚¤ãƒˆã®å±Šãæœ€å¤§è·é›¢
	float decay; //!< æ¸›è¡°çŽ‡
	float cosAngle;  //!< ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®ä½™å¼¦
	float cosFalloffStart;
	float padding[2];
};

============================================================
File Path: project/engine/math/MathUtil.cpp
============================================================
#include"MathUtil.h"
#include <algorithm>
#include <MatrixVector.h>

using namespace MatrixVector;

namespace MathUtil {
    ///====================================================
    /// çƒé¢ç·šå½¢è£œé–“ (Slerp)
    ///====================================================
    Vector3 Slerp(const Vector3& v0, const Vector3& v1, float t) {
        float dot = Dot(v0, v1);
        dot = std::clamp(dot, -1.0f, 1.0f); // å®‰å…¨ã‚¯ãƒ©ãƒ³ãƒ—

        float theta = acosf(dot) * t;
        Vector3 relative = Normalize(v1 - v0 * dot);
        return Normalize(v0 * cosf(theta) + relative * sinf(theta));
    }  
    ///====================================================
    /// LookAt ç”¨ã®å›žè»¢è¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰
    /// forward: å‘ããƒ™ã‚¯ãƒˆãƒ«
    ///====================================================
    Vector3 LookAtRotation(const Vector3& forward) {
        Vector3 rot;
        rot.y = atan2f(forward.x, forward.z); // Yaw
        rot.x = asinf(-forward.y);            // Pitch
        rot.z = 0.0f;                         // Roll
        return rot;
    }










}

============================================================
File Path: project/engine/math/MathUtil.h
============================================================
#pragma once
#include "Vector3.h"

namespace MathUtil {
   // float Clamp(float v, float min, float max);
   // Vector3 Lerp(const Vector3& a, const Vector3& b, float t);
    Vector3 Slerp(const Vector3& a, const Vector3& b, float t);
    Vector3 LookAtRotation(const Vector3& forward);

}

============================================================
File Path: project/engine/math/Matrix/Matrix3x3.h
============================================================
#pragma once  
#include <Vector3.h>  
#include <cmath>  
#include <corecrt_math_defines.h>

/// <summary>  
/// 3x3è¡Œåˆ—ã‚’è¡¨ã™ã‚¯ãƒ©ã‚¹  
/// </summary>  
class Matrix3x3 {  
public:  
  float m[3][3];  

  // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ï¼ˆã‚¼ãƒ­åˆæœŸåŒ–ï¼‰  
  Matrix3x3() {  
      for (int i = 0; i < 3; ++i)  
          for (int j = 0; j < 3; ++j)  
              m[i][j] = 0.0f;  
  }  

  /// <summary>  
  /// æŒ‡å®šã—ãŸåˆ—ã«ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨­å®šã™ã‚‹  
  /// </summary>  
  /// <param name="index">åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ0ï½ž2ï¼‰</param>  
  /// <param name="vec">è¨­å®šã™ã‚‹ãƒ™ã‚¯ãƒˆãƒ«</param>  
  void SetColumn(int index, const Vector3& vec) {  
      if (index < 0 || index > 2) return; // ç¯„å›²å¤–ãƒã‚§ãƒƒã‚¯  
      m[0][index] = vec.x;  
      m[1][index] = vec.y;  
      m[2][index] = vec.z;  
  }  

  /// <summary>  
  /// å›žè»¢è¡Œåˆ—ã‚’ã‚ªã‚¤ãƒ©ãƒ¼è§’ï¼ˆXYZé †ï¼‰ã«å¤‰æ›ã™ã‚‹  
  /// </summary>  
  /// <returns>ã‚ªã‚¤ãƒ©ãƒ¼è§’ã‚’è¡¨ã™Vector3</returns>  
  Vector3 ToEulerXYZ() const {  
      Vector3 euler;  
      if (m[2][0] < 1) {  
          if (m[2][0] > -1) {  
              euler.x = std::atan2(-m[2][1], m[2][2]);  
              euler.y = std::asin(m[2][0]);  
              euler.z = std::atan2(-m[1][0], m[0][0]);  
          } else {  
              // m[2][0] == -1  
              euler.x = std::atan2(m[0][1], m[1][1]);  
              euler.y = -M_PI / 2;  
              euler.z = 0;  
          }  
      } else {  
          // m[2][0] == 1  
          euler.x = std::atan2(m[0][1], m[1][1]);  
          euler.y = M_PI / 2;  
          euler.z = 0;  
      }  
      return euler;  
  }  
};

============================================================
File Path: project/engine/math/Matrix/Matrix4x4.h
============================================================
#pragma once

struct Matrix4x4 final {
    float m[4][4];

    Matrix4x4() {
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                m[i][j] = 0.0f;
    }
};

============================================================
File Path: project/engine/math/Matrix/TransformationMatrix.h
============================================================
#pragma once
#include <Matrix4x4.h>

/// <summary>
/// åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿
/// </summary>
struct TransformationMatrix final {
	Matrix4x4 WVP;
	Matrix4x4 World;
	Matrix4x4 WorldInverseTranspose;
};

============================================================
File Path: project/engine/math/MatrixVector.cpp
============================================================
#include"MatrixVector.h"
#include <corecrt_math_defines.h>
#include <corecrt_math.h>
#include<cmath>

namespace MatrixVector {

    // Dot product
   float Dot(const Vector3& a, const Vector3& b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
    }

    // å˜ä½è¡Œåˆ—ã®ä½œæˆ
    Matrix4x4 MakeIdentity4x4() {
        Matrix4x4 result;
        for (int i = 0; i < 4; ++i) {
            for (int v = 0; v < 4; ++v) {
                if (v == i) {
                    result.m[i][v] = 1;
                } else {
                    result.m[i][v] = 0;
                }
            }
        }
        return result;
    };

    //é•·ã•ï¼ˆãƒŽãƒ«ãƒ ï¼‰
    float Length(const Vector3& v) {
        float result;

        result = sqrtf(powf(v.x, 2) + powf(v.y, 2) + powf(v.z, 2));

        return result;
    };


    //æ­£è¦åŒ–
    Vector3  Normalize(const Vector3& v) {
        Vector3 result{};

        float length = Length(v);

        if (length != 0.0) {
            result.x = v.x / length;
            result.y = v.y / length;
            result.z = v.z / length;
        }

        return result;
    };


    // é€†è¡Œåˆ—
    Matrix4x4 Inverse(const Matrix4x4& matrix) {

        float det
            = matrix.m[0][0] * (matrix.m[1][1] * matrix.m[2][2] * matrix.m[3][3] + matrix.m[1][2] * matrix.m[2][3] * matrix.m[3][1] + matrix.m[1][3] * matrix.m[2][1] * matrix.m[3][2] - matrix.m[1][3] * matrix.m[2][2] * matrix.m[3][1] - matrix.m[1][2] * matrix.m[2][1] * matrix.m[3][3] - matrix.m[1][1] * matrix.m[2][3] * matrix.m[3][2])
            - matrix.m[0][1] * (matrix.m[1][0] * matrix.m[2][2] * matrix.m[3][3] + matrix.m[1][2] * matrix.m[2][3] * matrix.m[3][0] + matrix.m[1][3] * matrix.m[2][0] * matrix.m[3][2] - matrix.m[1][3] * matrix.m[2][2] * matrix.m[3][0] - matrix.m[1][2] * matrix.m[2][0] * matrix.m[3][3] - matrix.m[1][0] * matrix.m[2][3] * matrix.m[3][2])
            + matrix.m[0][2] * (matrix.m[1][0] * matrix.m[2][1] * matrix.m[3][3] + matrix.m[1][1] * matrix.m[2][3] * matrix.m[3][0] + matrix.m[1][3] * matrix.m[2][0] * matrix.m[3][1] - matrix.m[1][3] * matrix.m[2][1] * matrix.m[3][0] - matrix.m[1][1] * matrix.m[2][0] * matrix.m[3][3] - matrix.m[1][0] * matrix.m[2][3] * matrix.m[3][1])
            - matrix.m[0][3] * (matrix.m[1][0] * matrix.m[2][1] * matrix.m[3][2] + matrix.m[1][1] * matrix.m[2][2] * matrix.m[3][0] + matrix.m[1][2] * matrix.m[2][0] * matrix.m[3][1] - matrix.m[1][2] * matrix.m[2][1] * matrix.m[3][0] - matrix.m[1][1] * matrix.m[2][0] * matrix.m[3][2] - matrix.m[1][0] * matrix.m[2][2] * matrix.m[3][1]);


        Matrix4x4 result;
        result.m[0][0] = (matrix.m[1][1] * matrix.m[2][2] * matrix.m[3][3] + matrix.m[1][2] * matrix.m[2][3] * matrix.m[3][1] + matrix.m[1][3] * matrix.m[2][1] * matrix.m[3][2] - matrix.m[1][3] * matrix.m[2][2] * matrix.m[3][1] - matrix.m[1][2] * matrix.m[2][1] * matrix.m[3][3] - matrix.m[1][1] * matrix.m[2][3] * matrix.m[3][2]) / det;
        result.m[0][1] = (-matrix.m[0][1] * matrix.m[2][2] * matrix.m[3][3] - matrix.m[0][2] * matrix.m[2][3] * matrix.m[3][1] - matrix.m[0][3] * matrix.m[2][1] * matrix.m[3][2] + matrix.m[0][3] * matrix.m[2][2] * matrix.m[3][1] + matrix.m[0][2] * matrix.m[2][1] * matrix.m[3][3] + matrix.m[0][1] * matrix.m[2][3] * matrix.m[3][2]) / det;
        result.m[0][2] = (matrix.m[0][1] * matrix.m[1][2] * matrix.m[3][3] + matrix.m[0][2] * matrix.m[1][3] * matrix.m[3][1] + matrix.m[0][3] * matrix.m[1][1] * matrix.m[3][2] - matrix.m[0][3] * matrix.m[1][2] * matrix.m[3][1] - matrix.m[0][2] * matrix.m[1][1] * matrix.m[3][3] - matrix.m[0][1] * matrix.m[1][3] * matrix.m[3][2]) / det;
        result.m[0][3] = (-matrix.m[0][1] * matrix.m[1][2] * matrix.m[2][3] - matrix.m[0][2] * matrix.m[1][3] * matrix.m[2][1] - matrix.m[0][3] * matrix.m[1][1] * matrix.m[2][2] + matrix.m[0][3] * matrix.m[1][2] * matrix.m[2][1] + matrix.m[0][2] * matrix.m[1][1] * matrix.m[2][3] + matrix.m[0][1] * matrix.m[1][3] * matrix.m[2][2]) / det;

        result.m[1][0] = (-matrix.m[1][0] * matrix.m[2][2] * matrix.m[3][3] - matrix.m[1][2] * matrix.m[2][3] * matrix.m[3][0] - matrix.m[1][3] * matrix.m[2][0] * matrix.m[3][2] + matrix.m[1][3] * matrix.m[2][2] * matrix.m[3][0] + matrix.m[1][2] * matrix.m[2][0] * matrix.m[3][3] + matrix.m[1][0] * matrix.m[2][3] * matrix.m[3][2]) / det;
        result.m[1][1] = (matrix.m[0][0] * matrix.m[2][2] * matrix.m[3][3] + matrix.m[0][2] * matrix.m[2][3] * matrix.m[3][0] + matrix.m[0][3] * matrix.m[2][0] * matrix.m[3][2] - matrix.m[0][3] * matrix.m[2][2] * matrix.m[3][0] - matrix.m[0][2] * matrix.m[2][0] * matrix.m[3][3] - matrix.m[0][0] * matrix.m[2][3] * matrix.m[3][2]) / det;
        result.m[1][2] = (-matrix.m[0][0] * matrix.m[1][2] * matrix.m[3][3] - matrix.m[0][2] * matrix.m[1][3] * matrix.m[3][0] - matrix.m[0][3] * matrix.m[1][0] * matrix.m[3][2] + matrix.m[0][3] * matrix.m[1][2] * matrix.m[3][0] + matrix.m[0][2] * matrix.m[1][0] * matrix.m[3][3] + matrix.m[0][0] * matrix.m[1][3] * matrix.m[3][2]) / det;
        result.m[1][3] = (matrix.m[0][0] * matrix.m[1][2] * matrix.m[2][3] + matrix.m[0][2] * matrix.m[1][3] * matrix.m[2][0] + matrix.m[0][3] * matrix.m[1][0] * matrix.m[2][2] - matrix.m[0][3] * matrix.m[1][2] * matrix.m[2][0] - matrix.m[0][2] * matrix.m[1][0] * matrix.m[2][3] - matrix.m[0][0] * matrix.m[1][3] * matrix.m[2][2]) / det;

        result.m[2][0] = (matrix.m[1][0] * matrix.m[2][1] * matrix.m[3][3] + matrix.m[1][1] * matrix.m[2][3] * matrix.m[3][0] + matrix.m[1][3] * matrix.m[2][0] * matrix.m[3][1] - matrix.m[1][3] * matrix.m[2][1] * matrix.m[3][0] - matrix.m[1][1] * matrix.m[2][0] * matrix.m[3][3] - matrix.m[1][0] * matrix.m[2][3] * matrix.m[3][1]) / det;
        result.m[2][1] = (-matrix.m[0][0] * matrix.m[2][1] * matrix.m[3][3] - matrix.m[0][1] * matrix.m[2][3] * matrix.m[3][0] - matrix.m[0][3] * matrix.m[2][0] * matrix.m[3][1] + matrix.m[0][3] * matrix.m[2][1] * matrix.m[3][0] + matrix.m[0][1] * matrix.m[2][0] * matrix.m[3][3] + matrix.m[0][0] * matrix.m[2][3] * matrix.m[3][1]) / det;
        result.m[2][2] = (matrix.m[0][0] * matrix.m[1][1] * matrix.m[3][3] + matrix.m[0][1] * matrix.m[1][3] * matrix.m[3][0] + matrix.m[0][3] * matrix.m[1][0] * matrix.m[3][1] - matrix.m[0][3] * matrix.m[1][1] * matrix.m[3][0] - matrix.m[0][1] * matrix.m[1][0] * matrix.m[3][3] - matrix.m[0][0] * matrix.m[1][3] * matrix.m[3][1]) / det;
        result.m[2][3] = (-matrix.m[0][0] * matrix.m[1][1] * matrix.m[2][3] - matrix.m[0][1] * matrix.m[1][3] * matrix.m[2][0] - matrix.m[0][3] * matrix.m[1][0] * matrix.m[2][1] + matrix.m[0][3] * matrix.m[1][1] * matrix.m[2][0] + matrix.m[0][1] * matrix.m[1][0] * matrix.m[2][3] + matrix.m[0][0] * matrix.m[1][3] * matrix.m[2][1]) / det;

        result.m[3][0] = (-matrix.m[1][0] * matrix.m[2][1] * matrix.m[3][2] - matrix.m[1][1] * matrix.m[2][2] * matrix.m[3][0] - matrix.m[1][2] * matrix.m[2][0] * matrix.m[3][1] + matrix.m[1][2] * matrix.m[2][1] * matrix.m[3][0] + matrix.m[1][1] * matrix.m[2][0] * matrix.m[3][2] + matrix.m[1][0] * matrix.m[2][2] * matrix.m[3][1]) / det;
        result.m[3][1] = (matrix.m[0][0] * matrix.m[2][1] * matrix.m[3][2] + matrix.m[0][1] * matrix.m[2][2] * matrix.m[3][0] + matrix.m[0][2] * matrix.m[2][0] * matrix.m[3][1] - matrix.m[0][2] * matrix.m[2][1] * matrix.m[3][0] - matrix.m[0][1] * matrix.m[2][0] * matrix.m[3][2] - matrix.m[0][0] * matrix.m[2][2] * matrix.m[3][1]) / det;
        result.m[3][2] = (-matrix.m[0][0] * matrix.m[1][1] * matrix.m[3][2] - matrix.m[0][1] * matrix.m[1][2] * matrix.m[3][0] - matrix.m[0][2] * matrix.m[1][0] * matrix.m[3][1] + matrix.m[0][2] * matrix.m[1][1] * matrix.m[3][0] + matrix.m[0][1] * matrix.m[1][0] * matrix.m[3][2] + matrix.m[0][0] * matrix.m[1][2] * matrix.m[3][1]) / det;
        result.m[3][3] = (matrix.m[0][0] * matrix.m[1][1] * matrix.m[2][2] + matrix.m[0][1] * matrix.m[1][2] * matrix.m[2][0] + matrix.m[0][2] * matrix.m[1][0] * matrix.m[2][1] - matrix.m[0][2] * matrix.m[1][1] * matrix.m[2][0] - matrix.m[0][1] * matrix.m[1][0] * matrix.m[2][2] - matrix.m[0][0] * matrix.m[1][2] * matrix.m[2][1]) / det;

        return result;
    };


    //å¹³è¡Œç§»å‹•è¡Œåˆ—
    Matrix4x4 MakeTranslateMatrix(const Vector3& teanslate) {
        Matrix4x4 result;
        result.m[0][0] = 1.0f;
        result.m[0][1] = 0.0f;
        result.m[0][2] = 0.0f;
        result.m[0][3] = 0.0f;

        result.m[1][0] = 0.0f;
        result.m[1][1] = 1.0f;
        result.m[1][2] = 0.0f;
        result.m[1][3] = 0.0f;

        result.m[2][0] = 0.0f;
        result.m[2][1] = 0.0f;
        result.m[2][2] = 1.0f;
        result.m[2][3] = 0.0f;

        result.m[3][0] = teanslate.x;
        result.m[3][1] = teanslate.y;
        result.m[3][2] = teanslate.z;
        result.m[3][3] = 1.0f;


        return result;
    };


    // ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°è¡Œåˆ—
    Matrix4x4 MakeScaleMatrix(const Vector3& scale) {
        Matrix4x4 result;

        result.m[0][0] = scale.x; result.m[0][1] = 0.0f; result.m[0][2] = 0.0f; result.m[0][3] = 0.0f;
        result.m[1][0] = 0.0f; result.m[1][1] = scale.y; result.m[1][2] = 0.0f; result.m[1][3] = 0.0f;
        result.m[2][0] = 0.0f; result.m[2][1] = 0.0f; result.m[2][2] = scale.z; result.m[2][3] = 0.0f;
        result.m[3][0] = 0.0f; result.m[3][1] = 0.0f; result.m[3][2] = 0.0f; result.m[3][3] = 1.0f;

        return result;
    }


    // é€è¦–æŠ•å½±è¡Œåˆ—ã€€
    Matrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farclip) {
        Matrix4x4 result{};

        float f = 1.0f / tanf(fovY * 0.5f); // â† ãƒ©ã‚¸ã‚¢ãƒ³å‰æ
        float zn = nearClip;
        float zf = farclip;

        result.m[0][0] = f / aspectRatio;
        result.m[1][1] = f;
        result.m[2][2] = zf / (zf - zn);
        result.m[2][3] = 1.0f;
        result.m[3][2] = (-zn * zf) / (zf - zn);
        result.m[3][3] = 0.0f;

        return result;
    };


    // å¹³è¡ŒæŠ•å½±è¡Œåˆ—
    Matrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float facDlip) {
        Matrix4x4 result{};

        result.m[0][0] = 2.0f / (right - left); result.m[0][1] = 0; result.m[0][2] = 0; result.m[0][3] = 0;
        result.m[1][0] = 0; result.m[1][1] = 2.0f / (top - bottom); result.m[1][2] = 0; result.m[1][3] = 0;
        result.m[2][0] = 0; result.m[2][1] = 0.0f; result.m[2][2] = 1.0f / (facDlip - nearClip); result.m[2][3] = 0;
        result.m[3][0] = (left + right) / (left - right); result.m[3][1] = (top + bottom) / (bottom - top); result.m[3][2] = nearClip / (nearClip - facDlip); result.m[3][3] = 1.0f;

        return result;
    }

    // Xè»¸å›žè»¢è¡Œåˆ—
    Matrix4x4 MakeRotateXMatrix(float radian) {
        Matrix4x4 result{};
        float Ctheta = std::cos(radian);
        float Stheta = std::sin(radian);

        result.m[0][0] = 1.0f; result.m[0][1] = 0.0f;    result.m[0][2] = 0.0f;   result.m[0][3] = 0.0f;
        result.m[1][0] = 0.0f; result.m[1][1] = Ctheta;  result.m[1][2] = Stheta; result.m[1][3] = 0.0f;
        result.m[2][0] = 0.0f; result.m[2][1] = -Stheta; result.m[2][2] = Ctheta; result.m[2][3] = 0.0f;
        result.m[3][0] = 0.0f; result.m[3][1] = 0.0f;    result.m[3][2] = 0.0f;   result.m[3][3] = 1.0f;


        return result;
    }

    // Yè»¸å›žè»¢è¡Œåˆ—
    Matrix4x4 MakeRotateYMatrix(float radian) {
        Matrix4x4 result{};
        float Ctheta = std::cos(radian);
        float Stheta = std::sin(radian);

        result.m[0][0] = Ctheta; result.m[0][1] = 0.0f; result.m[0][2] = -Stheta; result.m[0][3] = 0.0f;
        result.m[1][0] = 0.0f;   result.m[1][1] = 1.0f; result.m[1][2] = 0.0f;    result.m[1][3] = 0.0f;
        result.m[2][0] = Stheta; result.m[2][1] = 0.0f; result.m[2][2] = Ctheta;  result.m[2][3] = 0.0f;
        result.m[3][0] = 0.0f;   result.m[3][1] = 0.0f; result.m[3][2] = 0.0f;    result.m[3][3] = 1.0f;

        return result;
    }

    // Zè»¸å›ž8;è»¢è¡Œåˆ—
    Matrix4x4 MakeRotateZMatrix(float radian) {
        Matrix4x4 result{};
        float Ctheta = std::cos(radian);
        float Stheta = std::sin(radian);

        result.m[0][0] = Ctheta;  result.m[0][1] = Stheta; result.m[0][2] = 0.0f; result.m[0][3] = 0.0f;
        result.m[1][0] = -Stheta; result.m[1][1] = Ctheta; result.m[1][2] = 0.0f; result.m[1][3] = 0.0f;
        result.m[2][0] = 0.0f;    result.m[2][1] = 0.0f;   result.m[2][2] = 1.0f; result.m[2][3] = 0.0f;
        result.m[3][0] = 0.0f;    result.m[3][1] = 0.0f;   result.m[3][2] = 0.0f; result.m[3][3] = 1.0f;

        return result;

    }

    // åˆæˆ
    Matrix4x4 Multiply(const Matrix4x4 m1, const Matrix4x4 m2) {

        Matrix4x4 result{};
        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                for (int k = 0; k < 4; k++)
                {
                    result.m[i][j] += m1.m[i][k] * m2.m[k][j];
                }
            }
        }

        return result;
    };
   
    Matrix4x4 MakeRotateMatrix(const Vector3& r) {
        // å„è»¸å›žè»¢è¡Œåˆ—ã‚’ç”Ÿæˆ
        Matrix4x4 rx = MakeRotateXMatrix(r.x);
        Matrix4x4 ry = MakeRotateYMatrix(r.y);
        Matrix4x4 rz = MakeRotateZMatrix(r.z);

        // XYZé †ï¼ˆä¸€èˆ¬çš„ã«ã¯ Zâ†’Xâ†’Y ãªã©ã‚‚ã‚ã‚Šã€‚å¿…è¦ã«å¿œã˜ã¦å¤‰ãˆã¦OKï¼‰
        return Multiply(rx, Multiply(ry, rz));
    }

    Vector4 MultiplyM4xV4(const Matrix4x4& m, const Vector4& v) {
        Vector4 result;
        result.x = m.m[0][0] * v.x + m.m[0][1] * v.y + m.m[0][2] * v.z + m.m[0][3] * v.w;
        result.y = m.m[1][0] * v.x + m.m[1][1] * v.y + m.m[1][2] * v.z + m.m[1][3] * v.w;
        result.z = m.m[2][0] * v.x + m.m[2][1] * v.y + m.m[2][2] * v.z + m.m[2][3] * v.w;
        result.w = m.m[3][0] * v.x + m.m[3][1] * v.y + m.m[3][2] * v.z + m.m[3][3] * v.w;
        return result;
    }

    // 3æ¬¡å…ƒã‚¢ãƒ•ã‚£ãƒ³å¤‰æ›
    Matrix4x4 MakeAftineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate) {
        Matrix4x4 result;
        Matrix4x4 rotateXMatrix = MakeRotateXMatrix(rotate.x);
        Matrix4x4 rotateYMatrix = MakeRotateYMatrix(rotate.y);
        Matrix4x4 rotateZMatrix = MakeRotateZMatrix(rotate.z);
        Matrix4x4 rotateRMatrix = Multiply(rotateXMatrix, Multiply(rotateYMatrix, rotateZMatrix));

        result.m[0][0] = scale.x * rotateRMatrix.m[0][0]; result.m[0][1] = scale.x * rotateRMatrix.m[0][1]; result.m[0][2] = scale.x * rotateRMatrix.m[0][2]; 	result.m[0][3] = 0.0f;
        result.m[1][0] = scale.y * rotateRMatrix.m[1][0]; result.m[1][1] = scale.y * rotateRMatrix.m[1][1]; result.m[1][2] = scale.y * rotateRMatrix.m[1][2]; result.m[1][3] = 0.0f;
        result.m[2][0] = scale.z * rotateRMatrix.m[2][0]; result.m[2][1] = scale.z * rotateRMatrix.m[2][1]; result.m[2][2] = scale.z * rotateRMatrix.m[2][2]; result.m[2][3] = 0.0f;
        result.m[3][0] = translate.x; result.m[3][1] = translate.y; result.m[3][2] = translate.z; result.m[3][3] = 1.0f;

        return result;
    };

    Matrix4x4 Transpose(const Matrix4x4& mat) {
        Matrix4x4 transposed;

        // å„è¦ç´ ã‚’è»¢ç½®
        transposed.m[0][0] = mat.m[0][0];
        transposed.m[0][1] = mat.m[1][0];
        transposed.m[0][2] = mat.m[2][0];
        transposed.m[0][3] = mat.m[3][0];

        transposed.m[1][0] = mat.m[0][1];
        transposed.m[1][1] = mat.m[1][1];
        transposed.m[1][2] = mat.m[2][1];
        transposed.m[1][3] = mat.m[3][1];

        transposed.m[2][0] = mat.m[0][2];
        transposed.m[2][1] = mat.m[1][2];
        transposed.m[2][2] = mat.m[2][2];
        transposed.m[2][3] = mat.m[3][2];

        transposed.m[3][0] = mat.m[0][3];
        transposed.m[3][1] = mat.m[1][3];
        transposed.m[3][2] = mat.m[2][3];
        transposed.m[3][3] = mat.m[3][3];

        return transposed;
    }

    Matrix4x4 InverseTranspose(const Matrix4x4& mat) {
        Matrix4x4 inverseMat = Inverse(mat); // é€†è¡Œåˆ—
        return Transpose(inverseMat);         // è»¢ç½®è¡Œåˆ—
    }

    Vector3 Cross(const Vector3& a, const Vector3& b) {
        return {
            a.y * b.z - a.z * b.y,
            a.z * b.x - a.x * b.z,
            a.x * b.y - a.y * b.x
        };
    }

    Vector3 RotateVector(const Vector3& vec, const Vector3& rotation) {
        // å›žè»¢è¡Œåˆ—ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã®ç°¡æ˜“çš„ãªå®Ÿè£…  
        // rotation.x, rotation.y, rotation.z ã¯ãã‚Œãžã‚Œã®è»¸ã®å›žè»¢è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰  
        float cosX = cos(rotation.x), sinX = sin(rotation.x);
        float cosY = cos(rotation.y), sinY = sin(rotation.y);
        float cosZ = cos(rotation.z), sinZ = sin(rotation.z);

        // Xè»¸å›žè»¢  
        Vector3 rotatedX = {
            vec.x,
            vec.y * cosX - vec.z * sinX,
            vec.y * sinX + vec.z * cosX
        };

        // Yè»¸å›žè»¢  
        Vector3 rotatedY = {
            rotatedX.x * cosY + rotatedX.z * sinY,
            rotatedX.y,
            -rotatedX.x * sinY + rotatedX.z * cosY
        };

        // Zè»¸å›žè»¢  
        Vector3 rotatedZ = {
            rotatedY.x * cosZ - rotatedY.y * sinZ,
            rotatedY.x * sinZ + rotatedY.y * cosZ,
            rotatedY.z
        };

        return rotatedZ;
    }


    Vector3 Multiply4x4x3(const Matrix4x4& mat, const Vector3& vec) {
        Vector3 result;
        result.x = vec.x * mat.m[0][0] + vec.y * mat.m[1][0] + vec.z * mat.m[2][0];
        result.y = vec.x * mat.m[0][1] + vec.y * mat.m[1][1] + vec.z * mat.m[2][1];
        result.z = vec.x * mat.m[0][2] + vec.y * mat.m[1][2] + vec.z * mat.m[2][2];
        return result;
    }

    // ã‚¢ãƒ•ã‚£ãƒ³è¡Œåˆ—ï¼ˆæœ€çµ‚çš„ãªçµ±åˆï¼‰
    Matrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate) {
        Matrix4x4 S = MakeScaleMatrix(scale);
        Matrix4x4 R = MakeRotateMatrix(rotate);
        Matrix4x4 T = MakeTranslateMatrix(translate);
        return Multiply(S, Multiply(R, T));  // S * R * T
    }

    Vector3 TransformPoint(const Vector3& v, const Matrix4x4& m) {
        Vector3 result;

        result.x =
            v.x * m.m[0][0] +
            v.y * m.m[1][0] +
            v.z * m.m[2][0] +
            1.0f * m.m[3][0];

        result.y =
            v.x * m.m[0][1] +
            v.y * m.m[1][1] +
            v.z * m.m[2][1] +
            1.0f * m.m[3][1];

        result.z =
            v.x * m.m[0][2] +
            v.y * m.m[1][2] +
            v.z * m.m[2][2] +
            1.0f * m.m[3][2];

        float w =
            v.x * m.m[0][3] +
            v.y * m.m[1][3] +
            v.z * m.m[2][3] +
            1.0f * m.m[3][3];

        if (w != 0.0f) {
            result.x /= w;
            result.y /= w;
            result.z /= w;
        }

        return result;
    }

};

============================================================
File Path: project/engine/math/MatrixVector.h
============================================================
#pragma once
#include"Vector2.h"
#include"Vector3.h"
#include"Vector4.h"
#include"Matrix4x4.h"

inline Vector4 operator*(const Matrix4x4& mat, const Vector4& vec) {
    Vector4 result;
    result.x = mat.m[0][0] * vec.x + mat.m[0][1] * vec.y + mat.m[0][2] * vec.z + mat.m[0][3] * vec.w;
    result.y = mat.m[1][0] * vec.x + mat.m[1][1] * vec.y + mat.m[1][2] * vec.z + mat.m[1][3] * vec.w;
    result.z = mat.m[2][0] * vec.x + mat.m[2][1] * vec.y + mat.m[2][2] * vec.z + mat.m[2][3] * vec.w;
    result.w = mat.m[3][0] * vec.x + mat.m[3][1] * vec.y + mat.m[3][2] * vec.z + mat.m[3][3] * vec.w;
    return result;
}

namespace MatrixVector
{
	 
	// Dot product
	float Dot(const Vector3& a, const Vector3& b);

	// å˜ä½è¡Œåˆ—ã®ä½œæˆ
	Matrix4x4 MakeIdentity4x4();

	//é•·ã•ï¼ˆãƒŽãƒ«ãƒ ï¼‰
	float Length(const Vector3& v);

	//æ­£è¦åŒ–
	Vector3  Normalize(const Vector3& v);

	// é€†è¡Œåˆ—
	Matrix4x4 Inverse(const Matrix4x4& matrix);

	//å¹³è¡Œç§»å‹•è¡Œåˆ—
	Matrix4x4 MakeTranslateMatrix(const Vector3& teanslate);

	// ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°è¡Œåˆ—
	Matrix4x4 MakeScaleMatrix(const Vector3& scale);

	// é€è¦–æŠ•å½±è¡Œåˆ—ã€€
	Matrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farclip);

	// å¹³è¡ŒæŠ•å½±è¡Œåˆ—
	Matrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float facDlip);

	// Xè»¸å›žè»¢è¡Œåˆ—
	Matrix4x4 MakeRotateXMatrix(float radian);

	// Yè»¸å›žè»¢è¡Œåˆ—
	Matrix4x4 MakeRotateYMatrix(float radian);

	// Zè»¸å›ž8;è»¢è¡Œåˆ—
	Matrix4x4 MakeRotateZMatrix(float radian);

	// åˆæˆ
	Matrix4x4 Multiply(const Matrix4x4 m1, const Matrix4x4 m2);
	
	Vector4 MultiplyM4xV4(const Matrix4x4& m, const Vector4& v);

	Vector3 Multiply4x4x3(const Matrix4x4& mat, const Vector3& vec);

	// 3æ¬¡å…ƒã‚¢ãƒ•ã‚£ãƒ³å¤‰æ›
	Matrix4x4 MakeAftineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate);

	Matrix4x4 Transpose(const Matrix4x4& mat);

	// é€†è¡Œåˆ—ã‚’è¨ˆç®—ã—ã¦è»¢ç½®ã™ã‚‹å‡¦ç†
	Matrix4x4 InverseTranspose(const Matrix4x4& mat);

	// ã‚¯ãƒ­ã‚¹ç©
	Vector3 Cross(const Vector3& a, const Vector3& b);

	// ãƒ™ã‚¯ãƒˆãƒ«ã‚’å›žè»¢ã•ã›ã‚‹é–¢æ•°ã‚’è¿½åŠ   
	Vector3 RotateVector(const Vector3& vec, const Vector3& rotation);

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—
	Matrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate);

	Matrix4x4 MakeRotateMatrix(const Vector3& r);
	
	Vector3 TransformPoint(const Vector3& v, const Matrix4x4& m);

};

============================================================
File Path: project/engine/math/Model/Material.h
============================================================
#pragma once
#include <Vector4.h>
#include <Matrix4x4.h>
#include <cstdint>

/// <summary>
/// ãƒžãƒ†ãƒªã‚¢ãƒ«
/// </summary>
struct Material final {
	Vector4 color;
	int32_t endbleLighting;
	float padding[3];
	Matrix4x4 uvTransform;
	float shinimess;
};

============================================================
File Path: project/engine/math/Model/MaterialDate.h
============================================================
#pragma once
#include <string>
#include <cstdint>

/// <summary>
/// 2æ¬¡å…ƒãƒžãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
/// </summary>
struct MaterialDate final  {
	std::string textureFilePath;
	uint32_t textureindex = 0;
};

============================================================
File Path: project/engine/math/Model/ModelDate.h
============================================================
#pragma once
#include <string>
#include <vector>
#include <fstream>
#include <Vertex.h>
#include <MaterialDate.h>

/// <summary>
/// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
/// </summary>
struct ModelDate final {
	std::vector<VertexData> vertices;
	MaterialDate material;
};

============================================================
File Path: project/engine/math/Model/Vertex.h
============================================================
#pragma once
#include "Vector2.h"
#include "Vector3.h"
#include "Vector4.h"

/// <summary>
/// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
/// </summary>
struct VertexData final {
    Vector4 position{};
    Vector2 texcoord{};
    Vector3 normal{};
};

============================================================
File Path: project/engine/math/ParticleData/InstanceData.h
============================================================
#pragma once
#include <Matrix4x4.h>
#include <Vector4.h>

// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ‡ãƒ¼ã‚¿
struct InstanceData
{
	Matrix4x4 WVP;
	Matrix4x4 World;
	Vector4 color;
};

============================================================
File Path: project/engine/math/ParticleData/Particle.h
============================================================
#pragma once
#include <Velocity.h>
#include <Transform.h>
#include <Vector4.h>

// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
struct Particle {
	Transform transform;
	Velocity Velocity;
	float lifetime;
	float currentTime;
	Vector4 color;
    Vector4 startColor; // â† è¿½åŠ ï¼šç™ºç”Ÿæ™‚ã®å…ƒè‰²ã‚’ä¿æŒã™ã‚‹

    // â˜… è¿½åŠ 
    bool useGravity = false;
};

============================================================
File Path: project/engine/math/ParticleData/ParticleGroup.h
============================================================
#pragma once
#include <MaterialDate.h>
#include<Particle.h>
#include<InstanceData.h>
#include <wrl/client.h>
#include <d3d12.h>
#include <list>
#include <memory>

// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—
struct ParticleGroup {
	std::unique_ptr<ParticleModel> model;                  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ¢ãƒ‡ãƒ«
	MaterialDate materialData;                             // ãƒžãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿(ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹)
	std::list<Particle> particles;                         // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒªã‚¹ãƒˆ
	uint32_t srvindex;                                     // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ç”¨SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> Resource;      // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒªã‚½ãƒ¼ã‚¹
	uint32_t kNumInstance;                                 // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°
	InstanceData* instanceData = nullptr;                  // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ãƒã‚¤ãƒ³ã‚¿
};

============================================================
File Path: project/engine/math/ParticleData/ParticleRandomData.h
============================================================
#pragma once
#include <Velocity.h>
#include <Vector4.h>

struct ParticleRandomData {
    Vector3 offset;
    Vector3 rotation;
    Vector3 scale;
    Velocity velocity;
    float lifetime;
    Vector4 color;
    Vector3 rotationSpeed;
    Vector3 scaleSpeed;
};

============================================================
File Path: project/engine/math/ParticleData/RandomParameter.h
============================================================
#pragma once
#include <Vector4.h>
#include <Velocity.h>
#ifdef USE_IMGUI
#include<ImGuiManager.h>
#endif // USE_IMGUI
#ifdef min
#undef min
#endif
#ifdef max
#undef max
#endif

struct RandomParameter {
    // ãƒ©ãƒ³ãƒ€ãƒ ãªé€Ÿåº¦ã®ç¯„å›²
    Vector3 offsetMin{ 0,0,0 };
    Vector3 offsetMax{ 0,0,0 };
    // ãƒ©ãƒ³ãƒ€ãƒ ãªå›žè»¢ã®ç¯„å›²
    Vector3 rotateMin{ 0,0,0 };
    Vector3 rotateMax{ 0,0,0 };
    // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¹ã‚±ãƒ¼ãƒ«ã®ç¯„å›²
    Vector3 scaleMin{ 0,0,0 };
    Vector3 scaleMax{ 0,0,0 };
    // ãƒ©ãƒ³ãƒ€ãƒ ãªè‰²ã®ç¯„å›²
    float colorMin = 0.0f; // æœ€å°å€¤
    float colorMax = 0.0f; // æœ€å¤§å€¤
    // ãƒ©ãƒ³ãƒ€ãƒ ãªå¯¿å‘½ã®ç¯„å›²ã‚’è¿½åŠ 
    float lifetimeMin = 0.0f;
    float lifetimeMax = 0.0f;
    // ãƒ©ãƒ³ãƒ€ãƒ ãªé€Ÿåº¦ã®ç¯„å›²ã‚’è¿½åŠ 
    Velocity velocityMin{};
    Velocity velocityMax{};

    // ---------- setter ----------
    RandomParameter& SetOffset(const Vector3& min, const Vector3& max) {
        offsetMin = min; offsetMax = max;
        return *this;
    }
    RandomParameter& SetRotate(const Vector3& min, const Vector3& max) {
        rotateMin = min; rotateMax = max;
        return *this;
    }
    RandomParameter& SetScale(const Vector3& min, const Vector3& max) {
        scaleMin = min; scaleMax = max;
        return *this;
    }
    RandomParameter& SetColor(float min, float max) {
        colorMin = min; colorMax = max;
        return *this;
    }
    RandomParameter& SetLifetime(float min, float max) {
        lifetimeMin = min; lifetimeMax = max;
        return *this;
    }
    RandomParameter& SetVelocity(const Velocity& min, const Velocity& max) {
        velocityMin = min; velocityMax = max;
        return *this;
    }

    // --- ä¾¿åˆ©ï¼šè»¸ã”ã¨ã«è¨­å®šã™ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆå¿…è¦ãªã‚‰è¿½åŠ ï¼‰ ---
    RandomParameter& SetRotateZ(float min, float max) {
        rotateMin.z = min; rotateMax.z = max;
        return *this;
    }


    // setters
    void DrawImGuiUI() {
#ifdef USE_IMGUI
        // Offset
        if (ImGui::TreeNode("Offset")) {
            ImGui::DragFloat3("Min", &offsetMin.x, 0.01f);
            ImGui::DragFloat3("Max", &offsetMax.x, 0.01f);
            // Min <= Max åˆ¶å¾¡
            offsetMin.x = std::min(offsetMin.x, offsetMax.x);
            offsetMin.y = std::min(offsetMin.y, offsetMax.y);
            offsetMin.z = std::min(offsetMin.z, offsetMax.z);
            offsetMax.x = std::max(offsetMax.x, offsetMin.x);
            offsetMax.y = std::max(offsetMax.y, offsetMin.y);
            offsetMax.z = std::max(offsetMax.z, offsetMin.z);
            ImGui::TreePop();
        }

        // Rotation
        if (ImGui::TreeNode("Rotation")) {
            ImGui::DragFloat3("Min", &rotateMin.x, 0.01f);
            ImGui::DragFloat3("Max", &rotateMax.x, 0.01f);
            rotateMin.x = std::min(rotateMin.x, rotateMax.x);
            rotateMin.y = std::min(rotateMin.y, rotateMax.y);
            rotateMin.z = std::min(rotateMin.z, rotateMax.z);
            rotateMax.x = std::max(rotateMax.x, rotateMin.x);
            rotateMax.y = std::max(rotateMax.y, rotateMin.y);
            rotateMax.z = std::max(rotateMax.z, rotateMin.z);
            ImGui::TreePop();
        }

        // Scale
        if (ImGui::TreeNode("Scale")) {
            ImGui::DragFloat3("Min", &scaleMin.x, 0.01f);
            ImGui::DragFloat3("Max", &scaleMax.x, 0.01f);
            scaleMin.x = std::min(scaleMin.x, scaleMax.x);
            scaleMin.y = std::min(scaleMin.y, scaleMax.y);
            scaleMin.z = std::min(scaleMin.z, scaleMax.z);
            scaleMax.x = std::max(scaleMax.x, scaleMin.x);
            scaleMax.y = std::max(scaleMax.y, scaleMin.y);
            scaleMax.z = std::max(scaleMax.z, scaleMin.z);
            ImGui::TreePop();
        }

        // Color
        if (ImGui::TreeNode("Color")) {
            ImGui::DragFloat("Min", &colorMin, 0.01f, 0.0f, 1.0f);
            ImGui::DragFloat("Max", &colorMax, 0.01f, 0.0f, 1.0f);
            colorMin = std::min(colorMin, colorMax);
            colorMax = std::max(colorMax, colorMin);
            ImGui::TreePop();
        }

        // Lifetime
        if (ImGui::TreeNode("Lifetime")) {
            ImGui::DragFloat("Min", &lifetimeMin, 0.01f, 0.0f, 10.0f);
            ImGui::DragFloat("Max", &lifetimeMax, 0.01f, 0.0f, 10.0f);
            lifetimeMin = std::min(lifetimeMin, lifetimeMax);
            lifetimeMax = std::max(lifetimeMax, lifetimeMin);
            ImGui::TreePop();
        }

        // Velocity
        if (ImGui::TreeNode("Velocity")) {
            ImGui::Text("Translate");
            ImGui::DragFloat3("Min Translate", &velocityMin.translate.x, 0.01f);
            ImGui::DragFloat3("Max Translate", &velocityMax.translate.x, 0.01f);
            velocityMin.translate.x = std::min(velocityMin.translate.x, velocityMax.translate.x);
            velocityMin.translate.y = std::min(velocityMin.translate.y, velocityMax.translate.y);
            velocityMin.translate.z = std::min(velocityMin.translate.z, velocityMax.translate.z);
            velocityMax.translate.x = std::max(velocityMax.translate.x, velocityMin.translate.x);
            velocityMax.translate.y = std::max(velocityMax.translate.y, velocityMin.translate.y);
            velocityMax.translate.z = std::max(velocityMax.translate.z, velocityMin.translate.z);

            ImGui::Text("Rotate");
            ImGui::DragFloat3("Min Rotate", &velocityMin.rotate.x, 0.01f);
            ImGui::DragFloat3("Max Rotate", &velocityMax.rotate.x, 0.01f);
            velocityMin.rotate.x = std::min(velocityMin.rotate.x, velocityMax.rotate.x);
            velocityMin.rotate.y = std::min(velocityMin.rotate.y, velocityMax.rotate.y);
            velocityMin.rotate.z = std::min(velocityMin.rotate.z, velocityMax.rotate.z);
            velocityMax.rotate.x = std::max(velocityMax.rotate.x, velocityMin.rotate.x);
            velocityMax.rotate.y = std::max(velocityMax.rotate.y, velocityMin.rotate.y);
            velocityMax.rotate.z = std::max(velocityMax.rotate.z, velocityMin.rotate.z);

            ImGui::Text("Scale");
            ImGui::DragFloat3("Min Scale", &velocityMin.scale.x, 0.01f);
            ImGui::DragFloat3("Max Scale", &velocityMax.scale.x, 0.01f);
            velocityMin.scale.x = std::min(velocityMin.scale.x, velocityMax.scale.x);
            velocityMin.scale.y = std::min(velocityMin.scale.y, velocityMax.scale.y);
            velocityMin.scale.z = std::min(velocityMin.scale.z, velocityMax.scale.z);
            velocityMax.scale.x = std::max(velocityMax.scale.x, velocityMin.scale.x);
            velocityMax.scale.y = std::max(velocityMax.scale.y, velocityMin.scale.y);
            velocityMax.scale.z = std::max(velocityMax.scale.z, velocityMin.scale.z);

            ImGui::TreePop();
        }

#endif // USE_IMGUI
    }
};

============================================================
File Path: project/engine/math/ParticleData/Velocity.h
============================================================
#pragma once
#include <Vector3.h>

struct Velocity {
    Vector3 translate;
    Vector3 rotate;
    Vector3 scale;
};

============================================================
File Path: project/engine/math/PrimitiveGenerator.cpp
============================================================
#include "PrimitiveGenerator.h"
#include <cmath>
#include <numbers>
#define _USE_MATH_DEFINES
#include <math.h>
#include <DirectXMath.h>
#include <MatrixVector.h>

using namespace MatrixVector;

namespace PrimitiveGenerator
{

    std::vector<VertexData> DrawRing(VertexData* vertexData, uint32_t KRingDivide, float KOuterRadius, float KInnerRadius) {
        const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(KRingDivide);

        for (uint32_t i = 0; i < KRingDivide; ++i) {
            float angle = i * radianPerDivide;
            float nextAngle = (i + 1) * radianPerDivide;

            float sin = std::sin(angle);
            float cos = std::cos(angle);
            float sinNext = std::sin(nextAngle);
            float cosNext = std::cos(nextAngle);

            float u = float(i) / float(KRingDivide);
            float uNext = float(i + 1) / float(KRingDivide);

            uint32_t index = i * 6;

            // XYå¹³é¢ï¼ˆZ = 0ï¼‰ã«ãƒªãƒ³ã‚°ã‚’æ§‹ç¯‰
            vertexData[index + 0].position = { cos * KOuterRadius, sin * KOuterRadius, 0.0f, 1.0f };
            vertexData[index + 1].position = { cosNext * KOuterRadius, sinNext * KOuterRadius, 0.0f, 1.0f };
            vertexData[index + 2].position = { cos * KInnerRadius, sin * KInnerRadius, 0.0f, 1.0f };

            vertexData[index + 3].position = { cosNext * KOuterRadius, sinNext * KOuterRadius, 0.0f, 1.0f };
            vertexData[index + 4].position = { cosNext * KInnerRadius, sinNext * KInnerRadius, 0.0f, 1.0f };
            vertexData[index + 5].position = { cos * KInnerRadius, sin * KInnerRadius, 0.0f, 1.0f };

            // ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ï¼ˆä»®ã®è¨­å®šã€‚å¿…è¦ãªã‚‰èª¿æ•´ï¼‰
            vertexData[index + 0].texcoord = { u, 0.0f };
            vertexData[index + 1].texcoord = { uNext, 0.0f };
            vertexData[index + 2].texcoord = { u, 1.0f };

            vertexData[index + 3].texcoord = { uNext, 0.0f };
            vertexData[index + 4].texcoord = { uNext, 1.0f };
            vertexData[index + 5].texcoord = { u, 1.0f };

            // æ³•ç·šã¯Z+æ–¹å‘ï¼ˆXYå¹³é¢ã®æ­£é¢ï¼‰
            for (int j = 0; j < 6; ++j) {
                vertexData[index + j].normal = { 0.0f, 0.0f, 1.0f };
            }
        }
        return std::vector<VertexData>(vertexData, vertexData + KRingDivide * 6);
    }

    std::vector<VertexData> DrawSphere(const uint32_t ksubdivision, VertexData* vertexdata) {
        // çƒã®é ‚ç‚¹æ•°ã‚’è¨ˆç®—ã™ã‚‹
        //çµŒåº¦åˆ†å‰²1ã¤åˆ†ã®è§’åº¦ 
        const float kLonEvery = (float)M_PI * 2.0f / float(ksubdivision);
        //ç·¯åº¦åˆ†å‰²1ã¤åˆ†ã®è§’åº¦ 
        const float kLatEvery = (float)M_PI / float(ksubdivision);
        //çµŒåº¦ã®æ–¹å‘ã«åˆ†å‰²
        for (uint32_t latIndex = 0; latIndex < ksubdivision; ++latIndex)
        {
            float lat = -(float)M_PI / 2.0f + kLatEvery * latIndex;	// Î¸
            //çµŒåº¦ã®æ–¹å‘ã«åˆ†å‰²ã—ãªãŒã‚‰ç·šã‚’æã
            for (uint32_t lonIndex = 0; lonIndex < ksubdivision; ++lonIndex)
            {
                float u = float(lonIndex) / float(ksubdivision);
                float v = 1.0f - float(latIndex) / float(ksubdivision);

                //é ‚ç‚¹ä½ç½®ã‚’è¨ˆç®—ã™ã‚‹
                uint32_t start = (latIndex * ksubdivision + lonIndex) * 6;
                float lon = lonIndex * kLonEvery;	// Î¦
                //é ‚ç‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›ã™ã‚‹ã€‚åŸºæº–ç‚¹ a
                vertexdata[start + 0].position = { cos(lat) * cos(lon) ,sin(lat) , cos(lat) * sin(lon) ,1.0f };
                vertexdata[start + 0].texcoord = { u,v };
                vertexdata[start + 0].normal.x = vertexdata[start + 0].position.x;
                vertexdata[start + 0].normal.y = vertexdata[start + 0].position.y;
                vertexdata[start + 0].normal.z = vertexdata[start + 0].position.z;

                //åŸºæº–ç‚¹ b
                vertexdata[start + 1].position = { cos(lat + kLatEvery) * cos(lon),sin(lat + kLatEvery),cos(lat + kLatEvery) * sin(lon) ,1.0f };
                vertexdata[start + 1].texcoord = { u ,v - 1.0f / float(ksubdivision) };
                vertexdata[start + 1].normal.x = vertexdata[start + 1].position.x;
                vertexdata[start + 1].normal.y = vertexdata[start + 1].position.y;
                vertexdata[start + 1].normal.z = vertexdata[start + 1].position.z;

                //åŸºæº–ç‚¹ c
                vertexdata[start + 2].position = { cos(lat) * cos(lon + kLonEvery),sin(lat), cos(lat) * sin(lon + kLonEvery) ,1.0f };
                vertexdata[start + 2].texcoord = { u + 1.0f / float(ksubdivision),v };
                vertexdata[start + 2].normal.x = vertexdata[start + 2].position.x;
                vertexdata[start + 2].normal.y = vertexdata[start + 2].position.y;
                vertexdata[start + 2].normal.z = vertexdata[start + 2].position.z;

                //åŸºæº–ç‚¹ d
                vertexdata[start + 3].position = { cos(lat + kLatEvery) * cos(lon + kLonEvery), sin(lat + kLatEvery) , cos(lat + kLatEvery) * sin(lon + kLonEvery) ,1.0f };
                vertexdata[start + 3].texcoord = { u + 1.0f / float(ksubdivision), v - 1.0f / float(ksubdivision) };
                vertexdata[start + 3].normal.x = vertexdata[start + 3].position.x;
                vertexdata[start + 3].normal.y = vertexdata[start + 3].position.y;
                vertexdata[start + 3].normal.z = vertexdata[start + 3].position.z;

                // é ‚ç‚¹4 (b, c, d)
                vertexdata[start + 4].position = { cos(lat) * cos(lon + kLonEvery),sin(lat),cos(lat) * sin(lon + kLonEvery),1.0f };
                vertexdata[start + 4].texcoord = { u + 1.0f / float(ksubdivision) ,v };
                vertexdata[start + 4].normal.x = vertexdata[start + 4].position.x;
                vertexdata[start + 4].normal.y = vertexdata[start + 4].position.y;
                vertexdata[start + 4].normal.z = vertexdata[start + 4].position.z;

                vertexdata[start + 5].position = { cos(lat + kLatEvery) * cos(lon),sin(lat + kLatEvery),cos(lat + kLatEvery) * sin(lon),1.0f };
                vertexdata[start + 5].texcoord = { u,v - 1.0f / float(ksubdivision) };
                vertexdata[start + 5].normal.x = vertexdata[start + 5].position.x;
                vertexdata[start + 5].normal.y = vertexdata[start + 5].position.y;
                vertexdata[start + 5].normal.z = vertexdata[start + 5].position.z;
            }
        }
        return std::vector<VertexData>(vertexdata, vertexdata + ksubdivision * 6);
    }

    std::vector<VertexData> PrimitiveGenerator::DrawCylinder(VertexData* vertexData, uint32_t kCylinderDivide, float kTopRadius, float kBottomRadius, float kHeight) {
        std::vector<VertexData> vertices;
        vertices.resize(kCylinderDivide * 6); // 1åŒºç”»6é ‚ç‚¹

        const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kCylinderDivide);

        for (uint32_t index = 0; index < kCylinderDivide; ++index) {
            float theta = index * radianPerDivide;
            float nextTheta = (index + 1) * radianPerDivide;

            float sin = std::sin(theta);
            float cos = std::cos(theta);
            float sinNext = std::sin(nextTheta);
            float cosNext = std::cos(nextTheta);

            float u = float(index) / float(kCylinderDivide);
            float uNext = float(index + 1) / float(kCylinderDivide);

            Vector4 top1 = { -sin * kTopRadius, kHeight, cos * kTopRadius, 1.0f };
            Vector4 top2 = { -sinNext * kTopRadius, kHeight, cosNext * kTopRadius, 1.0f };
            Vector4 bottom1 = { -sin * kBottomRadius, 0.0f, cos * kBottomRadius, 1.0f };
            Vector4 bottom2 = { -sinNext * kBottomRadius, 0.0f, cosNext * kBottomRadius, 1.0f };

            Vector3 normal1 = { -sin, 0.0f, cos };
            Vector3 normal2 = { -sinNext, 0.0f, cosNext };

            Vector2 uvTop = { u, 1.0f };
            Vector2 uvTopNext = { uNext, 1.0f };
            Vector2 uvBottom = { u, 0.0f };
            Vector2 uvBottomNext = { uNext, 0.0f };

            // 1åŒºç”»6é ‚ç‚¹ï¼ˆ2ä¸‰è§’å½¢ï¼‰
            vertices[index * 6 + 0] = { top1,     uvTop,       normal1 };
            vertices[index * 6 + 1] = { top2,     uvTopNext,   normal2 };
            vertices[index * 6 + 2] = { bottom1,  uvBottom,    normal1 };

            vertices[index * 6 + 3] = { bottom1,  uvBottom,    normal1 };
            vertices[index * 6 + 4] = { top2,     uvTopNext,   normal2 };
            vertices[index * 6 + 5] = { bottom2,  uvBottomNext,normal2 };
        }

        // vertexData ã«ã‚‚æ›¸ãè¾¼ã‚€ï¼ˆnullãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰
        if (vertexData) {
            std::memcpy(vertexData, vertices.data(), sizeof(VertexData) * vertices.size());
        }

        return vertices;
    }


    std::vector<VertexData> DrawStar(VertexData* vertexData, uint32_t kNumPoints, float kOuterRadius, float kInnerRadius) {
        const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kNumPoints * 2);

        for (uint32_t i = 0; i < kNumPoints; ++i) {
            float angleOuter0 = (2 * i) * radianPerDivide;       // å¤–å´é ‚ç‚¹ i
            float angleInner0 = (2 * i + 1) * radianPerDivide;   // å†…å´é ‚ç‚¹ i
            float angleOuter1 = (2 * i + 2) * radianPerDivide;   // å¤–å´é ‚ç‚¹ i+1

            float cosOuter0 = std::cos(angleOuter0);
            float sinOuter0 = std::sin(angleOuter0);
            float cosInner0 = std::cos(angleInner0);
            float sinInner0 = std::sin(angleInner0);
            float cosOuter1 = std::cos(angleOuter1);
            float sinOuter1 = std::sin(angleOuter1);

            uint32_t index = i * 6;

            // ä¸‰è§’å½¢1
            vertexData[index + 0].position = { cosOuter0 * kOuterRadius, sinOuter0 * kOuterRadius, 0.0f, 1.0f };
            vertexData[index + 1].position = { cosInner0 * kInnerRadius, sinInner0 * kInnerRadius, 0.0f, 1.0f };
            vertexData[index + 2].position = { cosOuter1 * kOuterRadius, sinOuter1 * kOuterRadius, 0.0f, 1.0f };

            // ä¸‰è§’å½¢2
            vertexData[index + 3].position = { cosOuter1 * kOuterRadius, sinOuter1 * kOuterRadius, 0.0f, 1.0f };
            vertexData[index + 4].position = { cosInner0 * kInnerRadius, sinInner0 * kInnerRadius, 0.0f, 1.0f };
            vertexData[index + 5].position = { std::cos(angleOuter1 + radianPerDivide) * kInnerRadius, std::sin(angleOuter1 + radianPerDivide) * kInnerRadius, 0.0f, 1.0f };

            // ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ï¼ˆå˜ç´”ã«0ï½ž1ã§å‰²ã‚Šå½“ã¦ä¾‹ï¼‰
            float u0 = (cosOuter0 * 0.5f) + 0.5f;
            float v0 = (sinOuter0 * 0.5f) + 0.5f;
            float u1 = (cosInner0 * 0.5f) + 0.5f;
            float v1 = (sinInner0 * 0.5f) + 0.5f;
            float u2 = (cosOuter1 * 0.5f) + 0.5f;
            float v2 = (sinOuter1 * 0.5f) + 0.5f;
            float u3 = (std::cos(angleOuter1 + radianPerDivide) * 0.5f) + 0.5f;
            float v3 = (std::sin(angleOuter1 + radianPerDivide) * 0.5f) + 0.5f;

            vertexData[index + 0].texcoord = { u0, v0 };
            vertexData[index + 1].texcoord = { u1, v1 };
            vertexData[index + 2].texcoord = { u2, v2 };
            vertexData[index + 3].texcoord = { u2, v2 };
            vertexData[index + 4].texcoord = { u1, v1 };
            vertexData[index + 5].texcoord = { u3, v3 };

            // æ³•ç·šã¯Z+æ–¹å‘ï¼ˆXYå¹³é¢ã®æ­£é¢ï¼‰
            for (int j = 0; j < 6; ++j) {
                vertexData[index + j].normal = { 0.0f, 0.0f, 1.0f };
            }
        }

        return std::vector<VertexData>(vertexData, vertexData + kNumPoints * 6);
    }

    void DrawSpiral(uint32_t kSpiralDiv, float spiralRadius, float spiralHeight, uint32_t spiralTurn, VertexData* vertexData) {
        for (uint32_t i = 0; i <= kSpiralDiv; ++i) {
            float t = static_cast<float>(i) / static_cast<float>(kSpiralDiv);
            float angle = t * spiralTurn * 2.0f * std::numbers::pi_v<float>;
            float height = t * spiralHeight;

            float x = std::cos(angle) * spiralRadius;
            float y = height;
            float z = std::sin(angle) * spiralRadius;

            vertexData[i].position = { x, y, z, 1.0f };
            vertexData[i].texcoord = { t, 0.0f }; // ä»®ã§æµã™
            vertexData[i].normal = { 0.0f, 1.0f, 0.0f }; // ä»®ã®æ³•ç·š
        }
    }
    std::vector<VertexData> DrawCircle(VertexData* vertexData, uint32_t segmentCount, float radius) {
        std::vector<VertexData> vertices;
        vertices.reserve(segmentCount + 1); // æœ€å¾Œã«å§‹ç‚¹ã¨çµã¶ãŸã‚ã« +1

        for (uint32_t i = 0; i <= segmentCount; ++i) {
            float angle = static_cast<float>(i) / segmentCount * 2.0f * float(M_PI);
            float x = std::cos(angle) * radius;
            float z = std::sin(angle) * radius;

            VertexData v{};
            v.position = { x, 0.0f, z, 1.0f };  // w=1.0 ã®ä½ç½®ãƒ™ã‚¯ãƒˆãƒ«
            v.texcoord = { static_cast<float>(i) / segmentCount, 0.0f };  // ä»»æ„ã§è¨­å®š
            v.normal = { 0.0f, 1.0f, 0.0f };  // ä¸Šæ–¹å‘ã‚’å‘ã„ã¦ã„ã‚‹æƒ³å®š

            vertices.push_back(v);
        }

        // GPUç”¨ã®ãƒãƒƒãƒ•ã‚¡ã«ã‚³ãƒ”ãƒ¼
        std::memcpy(vertexData, vertices.data(), sizeof(VertexData) * vertices.size());

        return vertices;
    }

    std::vector<VertexData> DrawBox(VertexData* vertexData) {
        std::vector<VertexData> vertices(36);

        const float size = 0.5f;

        Vector3 p[8] = {
            {-size, -size, -size},
            { size, -size, -size},
            { size,  size, -size},
            {-size,  size, -size},
            {-size, -size,  size},
            { size, -size,  size},
            { size,  size,  size},
            {-size,  size,  size},
        };

        uint32_t indices[] = {
            4, 5, 6, 4, 6, 7,
            1, 0, 3, 1, 3, 2,
            0, 4, 7, 0, 7, 3,
            5, 1, 2, 5, 2, 6,
            3, 7, 6, 3, 6, 2,
            0, 1, 5, 0, 5, 4,
        };

        Vector3 faceNormals[] = {
            {0, 0, 1},
            {0, 0, -1},
            {-1, 0, 0},
            {1, 0, 0},
            {0, 1, 0},
            {0, -1, 0},
        };

        for (int face = 0; face < 6; ++face) {
            for (int i = 0; i < 6; ++i) {
                int vertexIndex = face * 6 + i;
                Vector3 pos = p[indices[vertexIndex]];

                vertices[vertexIndex].position.x = pos.x;
                vertices[vertexIndex].position.y = pos.y;
                vertices[vertexIndex].position.z = pos.z;
                vertices[vertexIndex].position.w = 1.0f;

                vertices[vertexIndex].normal = faceNormals[face];

                // ã“ã“ã§UVã‚’å‰²ã‚Šå½“ã¦ãŸã„å ´åˆã¯é©å®œèª¿æ•´
                vertices[vertexIndex].texcoord = { 0.0f, 0.0f };
            }
        }

        if (vertexData) {
            std::memcpy(vertexData, vertices.data(), sizeof(VertexData) * vertices.size());
        }

        return vertices;
    }

    std::vector<VertexData> GenerateCircle(float cx, float cy, float cz, float radius, int segments) {
        std::vector<VertexData> vertices;
        for (int i = 0; i < segments; ++i) {
            float theta0 = 2.0f * 3.1415926f * i / segments;
            float theta1 = 2.0f * 3.1415926f * (i + 1) / segments;

            Vector4 center = { cx, cy, cz, 1.0f };
            Vector4 p0 = { cx + cosf(theta0) * radius, cy + sinf(theta0) * radius, cz, 1.0f };
            Vector4 p1 = { cx + cosf(theta1) * radius, cy + sinf(theta1) * radius, cz, 1.0f };

            VertexData v0{ center, {0.5f, 0.5f}, {0.0f, 0.0f, 1.0f} };
            VertexData v1{ p0, {0.0f, 0.0f}, {0.0f, 0.0f, 1.0f} };
            VertexData v2{ p1, {1.0f, 0.0f}, {0.0f, 0.0f, 1.0f} };

            vertices.push_back(v0);
            vertices.push_back(v1);
            vertices.push_back(v2);
        }
        return vertices;
    }


}

============================================================
File Path: project/engine/math/PrimitiveGenerator.h
============================================================
#pragma once
#include<Vertex.h>
#include<Material.h>
#include<MaterialDate.h>
#include<ModelDate.h>

namespace PrimitiveGenerator
{
 
	// ãƒªãƒ³ã‚°ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
	std::vector<VertexData> DrawRing(VertexData* vertexData, uint32_t KRingDivide, float KOuterRadius, float KInnerRadius);

	// çƒã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
	std::vector<VertexData> DrawSphere(const uint32_t ksubdivision, VertexData* vertexdata);

    // å††æŸ±ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
    std::vector<VertexData> DrawCylinder(VertexData* vertexData, uint32_t kCylinderDivide, float kTopRadius, float kBottomRadius, float kHeight);

	// æ˜Ÿå½¢ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
	std::vector<VertexData> DrawStar(VertexData* vertexData, uint32_t kNumPoints, float kOuterRadius, float kInnerRadius);

	// ã‚¹ãƒ‘ã‚¤ãƒ©ãƒ«çŠ¶ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
	void DrawSpiral(uint32_t kSpiralDiv, float spiralRadius, float spiralHeight, uint32_t spiralTurn, VertexData* vertexData);
	
	// ã‚µãƒ¼ã‚¯ãƒ«ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹é–¢æ•°
	std::vector<VertexData> DrawCircle(VertexData* vertexData, uint32_t segmentCount, float radius);
	
	// æ­£æ–¹å½¢ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹é–¢æ•°
	std::vector<VertexData> DrawBox(VertexData* vertexData);

	std::vector<VertexData> GenerateCircle(float cx, float cy, float cz, float radius, int segments);


};


============================================================
File Path: project/engine/math/Quaternion.h
============================================================
#pragma once
#include <Vector3.h>
#include <cmath>

///====================================================
/// ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³æ§‹é€ ä½“ï¼ˆç°¡æ˜“ç‰ˆï¼‰
///====================================================
struct Quaternion {
    float w, x, y, z;

    static Quaternion FromEuler(const Vector3& euler) {
        float cy = cosf(euler.y * 0.5f);
        float sy = sinf(euler.y * 0.5f);
        float cp = cosf(euler.x * 0.5f);
        float sp = sinf(euler.x * 0.5f);
        float cr = cosf(euler.z * 0.5f);
        float sr = sinf(euler.z * 0.5f);

        Quaternion q;
        q.w = cr * cp * cy + sr * sp * sy;
        q.x = sr * cp * cy - cr * sp * sy;
        q.y = cr * sp * cy + sr * cp * sy;
        q.z = cr * cp * sy - sr * sp * cy;
        return q;
    }

    Vector3 ToEuler() const {
       Vector3 euler;

       float sinr_cosp = 2 * (w * x + y * z);
       float cosr_cosp = 1 - 2 * (x * x + y * y);
       euler.z = static_cast<float>(std::atan2(sinr_cosp, cosr_cosp)); // Roll, cast to float to avoid C4244

       float sinp = 2 * (w * y - z * x);
       if (fabs(sinp) >= 1)
           euler.x = std::copysign(3.14159265f / 2, sinp); // Pitch
       else
           euler.x = std::asin(sinp);

       float siny_cosp = 2 * (w * z + x * y);
       float cosy_cosp = 1 - 2 * (y * y + z * z);
       euler.y = static_cast<float>(std::atan2(siny_cosp, cosy_cosp)); // Yaw, cast to float to avoid C4244

       return euler;
    }

    static Quaternion Slerp(const Quaternion& q1, const Quaternion& q2, float t) {
        float dot = q1.w * q2.w + q1.x * q2.x + q1.y * q2.y + q1.z * q2.z;
        Quaternion q2b = q2;

        // åè»¢é˜²æ­¢
        if (dot < 0.0f) {
            q2b.w = -q2b.w;
            q2b.x = -q2b.x;
            q2b.y = -q2b.y;
            q2b.z = -q2b.z;
            dot = -dot;
        }

        if (dot > 0.9995f) {
            // ç·šå½¢è£œé–“ã§ååˆ†
            Quaternion result = {
                q1.w + t * (q2b.w - q1.w),
                q1.x + t * (q2b.x - q1.x),
                q1.y + t * (q2b.y - q1.y),
                q1.z + t * (q2b.z - q1.z)
            };
            return Normalize(result);
        }

        float theta_0 = acosf(dot);
        float theta = theta_0 * t;

        float sin_theta = sinf(theta);
        float sin_theta_0 = sinf(theta_0);

        float s0 = cosf(theta) - dot * sin_theta / sin_theta_0;
        float s1 = sin_theta / sin_theta_0;

        Quaternion result = {
            s0 * q1.w + s1 * q2b.w,
            s0 * q1.x + s1 * q2b.x,
            s0 * q1.y + s1 * q2b.y,
            s0 * q1.z + s1 * q2b.z
        };
        return Normalize(result);
    }

    static Quaternion Normalize(const Quaternion& q) {
        float len = sqrtf(q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z);
        return { q.w / len, q.x / len, q.y / len, q.z / len };
    }

    static Vector3 QuaternionToForward(const Quaternion& q) {
        // ãƒ¯ãƒ¼ãƒ«ãƒ‰Z+æ–¹å‘ã‚’ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã§å›žè»¢ã•ã›ãŸçµæžœ
        return Vector3{
            2.0f * (q.x * q.z + q.w * q.y), // X
            2.0f * (q.y * q.z - q.w * q.x), // Y
            1.0f - 2.0f * (q.x * q.x + q.y * q.y) // Z
        };
    }
};


============================================================
File Path: project/engine/math/Vector/Transform.h
============================================================
#pragma once
#include"Vector3.h"

///====================================================
/// <summary>
/// Transformæ§‹é€ ä½“
/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¤‰æ›æƒ…å ±ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ãƒ»å›žè»¢ãƒ»ä½ç½®ï¼‰ã‚’ã¾ã¨ã‚ã¦ç®¡ç†ã™ã‚‹æ§‹é€ ä½“ã€‚
/// </summary>
///====================================================
struct Transform {
    Vector3 scale;     /// ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆæ‹¡å¤§çŽ‡ï¼‰
    Vector3 rotate;    /// å›žè»¢è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ã¾ãŸã¯åº¦æ•°æ³•ï¼‰
    Vector3 translate; /// å¹³è¡Œç§»å‹•ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ä¸Šã®ä½ç½®ï¼‰
};

============================================================
File Path: project/engine/math/Vector/Vector2.h
============================================================
#pragma once
/// <summary>
/// 2æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«
/// </summary>
struct Vector2 final {
	float x;
	float y;
    
    Vector2 operator*(float scalar) const {
        return { x * scalar, y * scalar };
    }

    Vector2& operator*=(float scalar) {
        x *= scalar;
        y *= scalar;
        return *this;
    }
};

============================================================
File Path: project/engine/math/Vector/Vector3.h
============================================================
#pragma once
#include <cassert>

/// <summary>
/// 3æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«
/// </summary>
struct Vector3 final {
    float x, y, z;

    // æ·»å­—æ¼”ç®—å­ï¼ˆæ›¸ãè¾¼ã¿å¯ï¼‰
    float& operator[](size_t i) {
        assert(i < 3);
        return *(&x + i);
    }
    // æ·»å­—æ¼”ç®—å­ï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰
    const float& operator[](size_t i) const {
        assert(i < 3);
        return *(&x + i);
    }
    ///====================================================
    /// è¶³ã—ç®— å¼•ãç®— 
    ///====================================================
    // (å¼•æ•°ãŒfloat)
    Vector3 operator+(const Vector3& other) const { return { x + other.x, y + other.y, z + other.z }; }
    Vector3 operator-(const Vector3& other) const { return { x - other.x, y - other.y, z - other.z }; }
    Vector3& operator+=(const Vector3& other) { x += other.x; y += other.y; z += other.z; return *this; }
    ///====================================================
    /// ã‚¹ã‚«ãƒ©ãƒ¼æ¼”ç®—  
    ///====================================================
    // (å¼•æ•°ãŒfloat)
    Vector3 operator*(float scalar) const { return { x * scalar, y * scalar, z * scalar }; }
    Vector3 operator/(float scalar) const { return { x / scalar, y / scalar, z / scalar }; }
    Vector3& operator*=(float scalar) { x *= scalar; y *= scalar; z *= scalar; return *this; }
    Vector3& operator/=(float scalar) { x /= scalar; y /= scalar; z /= scalar; return *this; }
    // (å¼•æ•°ãŒVector3) 
    friend Vector3 operator*(float scalar, const Vector3& vec) { return { scalar * vec.x, scalar * vec.y, scalar * vec.z }; }
    Vector3 operator/(const Vector3& other) const { return { x / other.x, y / other.y, z / other.z }; }
    ///====================================================
    /// æ¯”è¼ƒ
    ///====================================================
    // (å¼•æ•°ãŒVector3) 
    bool operator==(const Vector3& other) const { return x == other.x && y == other.y && z == other.z; }
    bool operator!=(const Vector3& other) const { return !(*this == other); }
    ///====================================================
    /// å˜é …ãƒžã‚¤ãƒŠã‚¹
    ///====================================================
    Vector3 operator-() const { return { -x, -y, -z }; }
    /// <summary>  
    /// ç·šå½¢è£œé–“ (Lerp) é–¢æ•° (é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã«å¤‰æ›´)  
    /// </summary>  
    /// <param name="start">é–‹å§‹ãƒ™ã‚¯ãƒˆãƒ«</param>  
    /// <param name="end">çµ‚äº†ãƒ™ã‚¯ãƒˆãƒ«</param>  
    /// <param name="t">è£œé–“ä¿‚æ•° (0.0f ï½ž 1.0f)</param>  
    /// <returns>è£œé–“ã•ã‚ŒãŸãƒ™ã‚¯ãƒˆãƒ«</returns>  
    static Vector3 Lerp(const Vector3& start, const Vector3& end, float t) {
        return start + (end - start) * t;
    }

    Vector3& operator-=(const Vector3& other) {
        x -= other.x;
        y -= other.y;
        z -= other.z;
        return *this;
    }

};

============================================================
File Path: project/engine/math/Vector/Vector4.h
============================================================
#pragma once

/// <summary>
/// 4æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«
/// </summary>
struct Vector4 final {
    float x, y, z, w;

    Vector4() : x(0), y(0), z(0), w(0) {}
    Vector4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) {}
};

============================================================
File Path: project/engine/resource/D3DResourceLeakChecker.cpp
============================================================
#include"D3DResourceLeakChecker.h"
#include<dxgidebug.h>
#include<d3d12.h>
#include<dxgi1_6.h>
#include<wrl.h>

D3DResourceLeakChecker::~D3DResourceLeakChecker() {

	//ãƒªã‚½ãƒ¼ã‚¹ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚¯
	Microsoft::WRL::ComPtr<IDXGIDebug1> debug;
	if (SUCCEEDED(DXGIGetDebugInterface1(0, IID_PPV_ARGS(&debug)))) {
		debug->ReportLiveObjects(DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_ALL);
		debug->ReportLiveObjects(DXGI_DEBUG_APP, DXGI_DEBUG_RLO_ALL);
		debug->ReportLiveObjects(DXGI_DEBUG_D3D12, DXGI_DEBUG_RLO_ALL);
	}

}

============================================================
File Path: project/engine/resource/D3DResourceLeakChecker.h
============================================================
#pragma once

class D3DResourceLeakChecker {

public:
	/// <summary>
	///  ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~D3DResourceLeakChecker();
};

============================================================
File Path: project/engine/resource/ModelManager.cpp
============================================================
#include "ModelManager.h"

ModelManager* ModelManager::instance = nullptr;

ModelManager* ModelManager::GetInstance() {
	if (instance == nullptr) {
		instance = new ModelManager;
	}
	return instance;
}

void ModelManager::Finalize() {
	delete instance;
	instance = nullptr;
}

void ModelManager::Initialize(DirectXCommon* dxCommon) {
	// NULLæ¤œå‡º
	assert(dxCommon);
	// 3Dãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨ã®åˆæœŸåŒ–
	// ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²
	modelCommon = new ModelCommon;
	modelCommon->Initialize(dxCommon);
}

void ModelManager::LoadModel(const std::string& filePath) {
	//  èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
	if (models.contains(filePath)) {
		// èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰æ—©æœŸreturn
		return;
	}

	// Resources/ ã‚’å‰ã«è¿½åŠ 
	std::string fullPath = "Resources/" + filePath;

	// ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒ•ã‚¡ã‚¤ãƒ«åã‚’åˆ†å‰²
	size_t lastSlash = filePath.find_last_of("/\\");
	std::string directory;
	std::string filename;

	if (lastSlash != std::string::npos) {
		directory = "Resources/" + filePath.substr(0, lastSlash);
		filename = filePath.substr(lastSlash + 1);
	} else {
		directory = "Resources";
		filename = filePath;
	}
	
	// ãƒ¢ãƒ‡ãƒ«ã®ç”Ÿæˆã¨ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿,åˆæœŸåŒ–
	std::unique_ptr<Model> model = std::make_unique<Model>();
	model->Initialize(modelCommon, directory, filename);
	// ãƒ¢ãƒ‡ãƒ«ã‚’mapã‚³ãƒ³ãƒ†ãƒŠã«æ ¼ç´ã™ã‚‹
	models.insert(std::make_pair(filePath, std::move(model)));
}

Model* ModelManager::FindModel(const std::string& filePath) {
	//  èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
	if (models.contains(filePath)) {
		// èª­ã¿è¾¼ã¿ãƒ¢ãƒ‡ãƒ«ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¦return
		return  models.at(filePath).get();
	}
	// ãƒ•ã‚¡ã‚¤ãƒ«åä¸€è‡´ãªã— -> ä¾‹å¤–ã‚’æŠ•ã’ã¦ã‚¨ãƒ©ãƒ¼ã«ã™ã‚‹
    throw std::runtime_error("Model not found: " + filePath);
};

============================================================
File Path: project/engine/resource/ModelManager.h
============================================================
#pragma once
#include <map>
#include "ModelCommon.h"
#include "Model.h"

// ãƒ¢ãƒ‡ãƒ«ãƒžãƒãƒ¼ã‚¸ãƒ£
class ModelManager
{
private:

	static ModelManager* instance;

	ModelManager() = default;
	~ModelManager() = default;
	ModelManager(ModelManager&) = delete;
	ModelManager& operator=(ModelManager&) = delete;
public:// ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static ModelManager* GetInstance();
	// çµ‚äº†
	void Finalize();
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* dxCommon);

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>	/// <param name="filePath"ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹></param>
	void LoadModel(const std::string& filePath);

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œç´¢
	/// </summary>	/// <param name="filePath"ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹></param>
	/// <returns>ãƒ¢ãƒ‡ãƒ«</returns>
	Model* FindModel(const std::string& filePath);

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	std::map<std::string, std::unique_ptr<Model>> models;
	// ãƒã‚¤ãƒ³ã‚¿
	ModelCommon* modelCommon = nullptr;
public:
	// getter
	ModelCommon* GetModelCommon() const { return modelCommon; }
};

============================================================
File Path: project/engine/resource/ResourceFactory.cpp
============================================================
#include "ResourceFactory.h"
#include <dxgi1_6.h>

using namespace Microsoft::WRL;

namespace ResourceFactory {

    ComPtr<ID3D12Resource> CreateDepthStencilTextureResource(const ComPtr <ID3D12Device>& device, int32_t width, int32_t heigth) {
        // ç”Ÿæˆã™ã‚‹Resourceã®è¨­å®š
        D3D12_RESOURCE_DESC resourceDesc{};
        resourceDesc.Width = width; // Textureã®å¹…
        resourceDesc.Height = heigth; // Textureã®é«˜ã•
        resourceDesc.MipLevels = 1; // mipmapã®æ•°
        resourceDesc.DepthOrArraySize = 1; // å¥¥è¡Œã€€or é…åˆ—ã®Textureé…åˆ—æ•°
        resourceDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT; // DepthStencilã¨ã—ã¦åˆ©ç”¨å¯èƒ½ãªãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆ
        resourceDesc.SampleDesc.Count = 1; // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆ 1å›ºå®š
        resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D; // 2æ¬¡å…ƒ
        resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL; // DepthStencilã¨ã—ã¦ä½¿ã†é€šçŸ¥

        // åˆ©ç”¨Heapã®è¨­å®š
        D3D12_HEAP_PROPERTIES heapProperies{};
        heapProperies.Type = D3D12_HEAP_TYPE_DEFAULT; // VRAWä¸Šã«ä½œã‚‹

        // æ·±åº¦å€¤ã®ã‚¯ãƒªã‚¢è¨­å®š
        D3D12_CLEAR_VALUE depthClearValue{};
        depthClearValue.DepthStencil.Depth = 1.0f; // 1.0f (æœ€å¤§å€¤)ã§ã‚¯ãƒªã‚¢
        depthClearValue.Format = DXGI_FORMAT_D24_UNORM_S8_UINT; // ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã€‚ Resourceã¨åˆã‚ã›ã‚‹


        //3. Resourceã‚’ç”Ÿæˆã™ã‚‹
        ComPtr <ID3D12Resource> resource = nullptr;
        HRESULT hr = device->CreateCommittedResource(
            &heapProperies, //Heapã®è¨­å®š
            D3D12_HEAP_FLAG_NONE, //Heapã®ç‰¹æ®Šãªè¨­å®šã€‚ç‰¹ã«ãªã—ã€‚
            &resourceDesc, //Resourceã®è¨­å®š
            D3D12_RESOURCE_STATE_DEPTH_WRITE, //æ·±åº¦å€¤ã‚’æ›¸ãè¾¼ã‚€çŠ¶æ…‹ã«ã—ã¦ãŠã
            &depthClearValue, //Clearæœ€é©å€¤
            IID_PPV_ARGS(&resource)); //ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
        assert(SUCCEEDED(hr));
        return resource;
    }

    //DirectX12ã®TextureResourceã‚’ä½œã‚‹
    ComPtr <ID3D12Resource> CreateTextureResource(const ComPtr <ID3D12Device>& device, const DirectX::TexMetadata& metadata)
    {
        //1. metadataã‚’åŸºã«Resourceã®è¨­å®š
        D3D12_RESOURCE_DESC resourceDesc{};
        resourceDesc.Width = UINT(metadata.width);									//Textureã®å¹…
        resourceDesc.Height = UINT(metadata.height);								//Textureã®é«˜ã•
        resourceDesc.MipLevels = UINT16(metadata.mipLevels);						//mipmapã®æ•°
        resourceDesc.DepthOrArraySize = UINT16(metadata.arraySize);					//å¥¥è¡Œ or é…åˆ—Textureã®é…åˆ—è¡Œæ•°
        resourceDesc.Format = metadata.format;										//Textureã®Format
        resourceDesc.SampleDesc.Count = 1;											//ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆã€‚1å›ºå®š
        resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION(metadata.dimension);		//Textureã®æ¬¡å…ƒæ•°ã€‚æ™®æ®µä½¿ã£ã¦ã„ã‚‹ã®ã¯äºŒæ¬¡å…ƒ

        //2. åˆ©ç”¨ã™ã‚‹Heapã®è¨­å®šã€‚éžå¸¸ã«ç‰¹æ®Šãªé‹ç”¨ã€‚02_04exã§ä¸€èˆ¬çš„ãªã‚±ãƒ¼ã‚¹ç‰ˆãŒã‚ã‚‹
        D3D12_HEAP_PROPERTIES heapProperties{};
        heapProperties.Type = D3D12_HEAP_TYPE_CUSTOM;								//ç´°ã‹ã„è¨­å®šã‚’è¡Œã†
        heapProperties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_WRITE_BACK;		//WriteBackãƒãƒªã‚·ãƒ¼ã§CPUã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
        heapProperties.MemoryPoolPreference = D3D12_MEMORY_POOL_L0;					//ãƒ—ãƒ­ã‚»ãƒƒã‚µã®è¿‘ãã«é…è†³

        //3. Resourceã‚’ç”Ÿæˆã™ã‚‹
        ComPtr <ID3D12Resource> resource = nullptr;
        HRESULT hr = device->CreateCommittedResource(
            &heapProperties,														//Heapã®è¨­å®š
            D3D12_HEAP_FLAG_NONE,													//Heapã®ç‰¹æ®Šãªè¨­å®šã€‚ç‰¹ã«ãªã—ã€‚
            &resourceDesc,															///Resourceã®è¨­å®š
            D3D12_RESOURCE_STATE_GENERIC_READ,										//åˆå›žã®ResourceStateã€‚Textureã¯åŸºæœ¬èª­ã‚€ã ã‘
            nullptr,																//Clearæœ€é©å€¤ã€‚ä½¿ã‚ãªã„ã®ã§nullptr
            IID_PPV_ARGS(&resource));												//ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
        assert(SUCCEEDED(hr));
        return resource;
    }


    ComPtr <ID3D12Resource> CreateRenderTextureResource(ComPtr <ID3D12Device> device, uint32_t width, uint32_t height, DXGI_FORMAT format, const Vector4& clearColor) {
        //1. metadataã‚’åŸºã«Resourceã®è¨­å®š
        D3D12_RESOURCE_DESC resourceDesc{};
        resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
        resourceDesc.Alignment = 0;
        resourceDesc.Width = width;
        resourceDesc.Height = height;
        resourceDesc.DepthOrArraySize = 1;
        resourceDesc.MipLevels = 1;
        resourceDesc.Format = format;
        resourceDesc.SampleDesc.Count = 1;
        resourceDesc.SampleDesc.Quality = 0;
        resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
        resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;

        //2. åˆ©ç”¨ã™ã‚‹Heapã®è¨­å®šã€‚éžå¸¸ã«ç‰¹æ®Šãªé‹ç”¨ã€‚02_04exã§ä¸€èˆ¬çš„ãªã‚±ãƒ¼ã‚¹ç‰ˆãŒã‚ã‚‹
        D3D12_HEAP_PROPERTIES heapProperties{};
        heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT;								// å½“ç„¶VRAMä¸Šã«ä½œã‚‹

        D3D12_CLEAR_VALUE clearValue;
        clearValue.Format = format;
        clearValue.Color[0] = clearColor.x;
        clearValue.Color[1] = clearColor.y;
        clearValue.Color[2] = clearColor.z;
        clearValue.Color[3] = clearColor.w;

        //3. Resourceã‚’ç”Ÿæˆã™ã‚‹
        ComPtr <ID3D12Resource> resource = nullptr;
        HRESULT hr = device->CreateCommittedResource(
            &heapProperties,														//Heapã®è¨­å®š
            D3D12_HEAP_FLAG_NONE,													//Heapã®ç‰¹æ®Šãªè¨­å®šã€‚ç‰¹ã«ãªã—ã€‚
            &resourceDesc,															///Resourceã®è¨­å®š
            D3D12_RESOURCE_STATE_RENDER_TARGET,										//ã“ã‚Œã‹ã‚‰æç”»ã™ã‚‹ã“ã¨ã‚’å‰æã¨ã—ãŸTextureãªã®ã§RenderTargetã¨ã—ã¦ä½¿ã†ã“ã¨ã‹ã‚‰å§‹ã‚ã‚‹
            &clearValue,															//Clearæœ€é©åœ°,ClearRenderTargetã‚’ã“ã®è‰²ã§Clearã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚æœ€é©åŒ–ã•ã‚Œã‚Œã„ã‚‹ã®ã§é«˜é€Ÿã§ã‚ã‚‹
            IID_PPV_ARGS(&resource));												//ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
        assert(SUCCEEDED(hr));
        return resource;
    }

    // Resourceã®é–¢æ•°åŒ–
    ComPtr <ID3D12Resource> CreateBufferResource(const ComPtr <ID3D12Device>& device,size_t sizeInBytes) {
        //IDXGIã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ç”Ÿæˆ
        ComPtr <IDXGIFactory7> dxgiFactory = nullptr;
        HRESULT hr = CreateDXGIFactory(IID_PPV_ARGS(&dxgiFactory));
        //é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ç”¨ã®ãƒ’ãƒ¼ãƒ—ã®è¨­å®š
        D3D12_HEAP_PROPERTIES uploadHeapProperties{};
        uploadHeapProperties.Type = D3D12_HEAP_TYPE_UPLOAD;
        //é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã®è¨­å®š
        D3D12_RESOURCE_DESC vertexResourceDesc{};
        //ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å ´åˆã¯ã¾ãŸåˆ¥ã®è¨­å®šã‚’ã™ã‚‹
        vertexResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
        vertexResourceDesc.Width = sizeInBytes;
        //ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã‚‰ã¯ï¼‘ã«ã™ã‚‹
        vertexResourceDesc.Height = 1;
        vertexResourceDesc.DepthOrArraySize = 1;
        vertexResourceDesc.MipLevels = 1;
        vertexResourceDesc.SampleDesc.Count = 1;
        //ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã«ã™ã‚‹
        vertexResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
        //å®Ÿéš›ã«é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
        ComPtr <ID3D12Resource> Resource = nullptr;
        hr = device->CreateCommittedResource(&uploadHeapProperties, D3D12_HEAP_FLAG_NONE,
            &vertexResourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr, IID_PPV_ARGS(&Resource));
        assert(SUCCEEDED(hr));
        return Resource;
    };
}

============================================================
File Path: project/engine/resource/ResourceFactory.h
============================================================
#pragma once
#include<d3d12.h>
#include<wrl.h>
#include <cstdint>
#include <Vector4.h>
#include <externals/DirectXTex/DirectXTex.h>
#pragma comment(lib,"dxcompiler.lib")

namespace  ResourceFactory {
	/// <summary>
	/// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateBufferResource(const Microsoft::WRL::ComPtr <ID3D12Device>& device, size_t sizeInBytes);

	/// <summary>
	/// æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr <ID3D12Resource> CreateDepthStencilTextureResource(const Microsoft::WRL::ComPtr <ID3D12Device>& device, int32_t width, int32_t heigth);


	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr <ID3D12Resource> CreateTextureResource(const Microsoft::WRL::ComPtr <ID3D12Device>& device, const DirectX::TexMetadata& metadata);

	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç”Ÿæˆ
	/// </summar
	Microsoft::WRL::ComPtr <ID3D12Resource> CreateRenderTextureResource(Microsoft::WRL::ComPtr <ID3D12Device> device, uint32_t width, uint32_t height, DXGI_FORMAT format, const Vector4& clearColor);
};

============================================================
File Path: project/engine/resource/ResourceObject.h
============================================================
#pragma once
#include<d3d12.h>
#include<wrl.h>

class ResourceObject
{
public:
	ResourceObject(Microsoft::WRL::ComPtr <ID3D12Resource> resource)
		:resource_(resource)
	{}
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å¯¿å‘½ãŒå°½ããŸæ™‚ã«å‘¼ã°ã‚Œã‚‹
	~ResourceObject() {
		// ã“ã“ã§ã€Resourceã‚’å‘¼ã¹ã°ã„è‰¯ã„
		if (resource_) {
			resource_->Release();
		}
	}

	Microsoft::WRL::ComPtr <ID3D12Resource> Get() { return resource_; }

private:
	Microsoft::WRL::ComPtr<ID3D12Resource> resource_;
};

============================================================
File Path: project/engine/resource/TextureManager.cpp
============================================================
#include "TextureManager.h"
#include <Logger.h>
#include <StringUtility.h>
#include <ResourceFactory.h>

using namespace Microsoft::WRL;
using namespace ResourceFactory;

// ImGuiã§0ç•ªç›®ã«ä½¿ç”¨ã™ã‚‹ãŸã‚ã€1ç•ªã‹ã‚‰ä½¿ç”¨
uint32_t TextureManager::KSRVIndexTop = 1;

TextureManager* TextureManager::instance = nullptr;

TextureManager* TextureManager::GetInstance() {
	if (instance == nullptr) {
		instance = new TextureManager;
	}
	return instance;
}

void TextureManager::Finalize() {
	delete instance;
	instance = nullptr;
}

void TextureManager::Initialize(DirectXCommon* birectxcommon, SrvManager* srvmanager) {
	// NULLæ¤œå‡º
	assert(birectxcommon);
	// ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²
	this->dxCommon_ = birectxcommon;
	this->srvmanager_ = srvmanager;
	// SRVã®æ•°ã¨åŒæ•°
	textureDatas.reserve(SrvManager::kMaxSRVCount);
}

void TextureManager::LoadTexture(const std::string& filePath) {	
	HRESULT hr;
	std::string fullPath;

	// æ—¢ã« Resources/ ã‹ã‚‰å§‹ã¾ã£ã¦ã„ã‚‹ãªã‚‰ãã®ã¾ã¾ä½¿ã†ï¼ˆmodelèª­ã¿è¾¼ã¿æ™‚ãªã©ï¼‰
	if (filePath.starts_with("Resources/")) {
		fullPath = filePath;
	} else {
		fullPath = "Resources/" + filePath ;
	}

	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æ¤œç´¢
	if (textureDatas.contains(fullPath)) {
		return; // èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰æ—©æœŸreturn
	}
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£æžšæ•°ä¸Šé™ãƒã‚§ãƒƒã‚¯
	assert(srvmanager_->TextureDataCheck());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹
	DirectX::ScratchImage image{};
	std::wstring filePathW = StringUtility::ConvertString(fullPath);
	if (filePathW.ends_with(L".dds")) { // .ddsã§çµ‚ã‚ã£ã¦ã„ãŸã‚‰ddsã¨ã¿ãªã™ã€‚ã‚ˆã‚Šå®‰å…¨ãªæ–¹æ³•ã¯ã„ãã‚‰ã§ã‚‚ã‚ã‚‹ã®ã§ä½™è£•ãŒã‚ã‚Œã°å¯¾å¿œã™ã‚‹ã¨è‰¯ã„
		hr = DirectX::LoadFromDDSFile(filePathW.c_str(), DirectX::DDS_FLAGS_NONE, nullptr, image);
	} else {
		hr = DirectX::LoadFromWICFile(filePathW.c_str(), DirectX::WIC_FLAGS_FORCE_SRGB, nullptr, image);
	}
	assert(SUCCEEDED(hr));

	//ãƒŸãƒƒãƒ—ãƒžãƒƒãƒ—ã®ä½œæˆ
	DirectX::ScratchImage mipImages{};
	if (DirectX::IsCompressed(image.GetMetadata().format)) { // åœ§ç¸®ã™ã‚‹ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã‹ã©ã†ã‹èª¿ã¹ã‚‹
		mipImages = std::move(image); // åœ§ç¸®ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆãªã‚‰ãã®ã¾ã¾ä½¿ã†ã®ã§moveã™ã‚‹
	} else {
		hr = DirectX::GenerateMipMaps(image.GetImages(), image.GetImageCount(), image.GetMetadata(), DirectX::TEX_FILTER_SRGB, 4, mipImages);
		assert(SUCCEEDED(hr));
	}

	// è¿½åŠ ã—ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®å‚ç…§ã‚’å–å¾—ã™ã‚‹
	TextureData& textureData = textureDatas[fullPath];
	textureData.metadata = mipImages.GetMetadata();
	textureData.resource = CreateTextureResource(dxCommon_->GetDevice(), textureData.metadata);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è»¢é€
	UploadTextureData(textureData.resource, mipImages);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è¦ç´ æ•°ç•ªå·ã‚’SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ã™ã‚‹
	textureData.srvIndex = srvmanager_->Allocate();
	textureData.srvHandleCPU = srvmanager_->GetCPUDescriptorHandle(textureData.srvIndex);
	textureData.srvHandleGPU = srvmanager_->GetGPUDescriptorHandle(textureData.srvIndex);

	// metaDataã‚’åŸºã«SRVã®è¨­å®š
srvmanager_->CreateSRVforTexture2D(textureData.srvIndex, textureData.resource.Get(), textureData.metadata.format, (UINT)textureData.metadata.mipLevels, textureData.metadata.IsCubemap());
}

const DirectX::TexMetadata& TextureManager::GetMetaData(const std::string& filepath)
{
	// ç¯„å›²å¤–æŒ‡å®šé•åãƒã‚§ãƒƒã‚¯
	assert(textureDatas.size() + KSRVIndexTop < SrvManager::kMaxSRVCount);
	TextureData& textureData = textureDatas[filepath];
	return textureData.metadata;
}

// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å–å¾—
uint32_t TextureManager::GetSrvIndex(const std::string& filePath) {
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æ¤œç´¢
	if (textureDatas.contains(filePath)) {
		return textureDatas[filePath].srvIndex;
	}
	assert(0);
	return 0;
}

D3D12_GPU_DESCRIPTOR_HANDLE TextureManager::GetSrvHandleGPU(const std::string& filepath)
{
	// ç¯„å›²å¤–æŒ‡å®šé•åãƒã‚§ãƒƒã‚¯
	assert(textureDatas.size() + KSRVIndexTop < SrvManager::kMaxSRVCount);
	return textureDatas.at(filepath).srvHandleGPU;
}

void TextureManager::UploadTextureData(ComPtr<ID3D12Resource>& texture, const DirectX::ScratchImage& mipImages)
{
    const DirectX::TexMetadata& metadata = mipImages.GetMetadata();

    if (metadata.IsCubemap() || metadata.arraySize > 1) {
        // ã‚­ãƒ¥ãƒ¼ãƒ–ãƒžãƒƒãƒ—ã‚„é…åˆ—ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å ´åˆ
        size_t subresourceIndex = 0;
        for (size_t arraySlice = 0; arraySlice < metadata.arraySize; ++arraySlice) {
            for (size_t mipLevel = 0; mipLevel < metadata.mipLevels; ++mipLevel) {
                const DirectX::Image* img = mipImages.GetImage(mipLevel, arraySlice, 0);
                HRESULT hr = texture->WriteToSubresource(
                    UINT(subresourceIndex),
                    nullptr,
                    img->pixels,
                    UINT(img->rowPitch),
                    UINT(img->slicePitch)
                );
                assert(SUCCEEDED(hr));
                subresourceIndex++;
            }
        }
    }
    else {
        // é€šå¸¸ã®2Dãƒ†ã‚¯ã‚¹ãƒãƒ£
        for (size_t mipLevel = 0; mipLevel < metadata.mipLevels; ++mipLevel)
        {
            const DirectX::Image* img = mipImages.GetImage(mipLevel, 0, 0);
            HRESULT hr = texture->WriteToSubresource(
                UINT(mipLevel),
                nullptr,
                img->pixels,
                UINT(img->rowPitch),
                UINT(img->slicePitch)
            );
            assert(SUCCEEDED(hr));
        }
    }
}

============================================================
File Path: project/engine/resource/TextureManager.h
============================================================
#pragma once
#include <string>
#include "externals/DirectXTex/DirectXTex.h"
#include<wrl.h>
#include<d3d12.h>
#include "DirectXCommon.h"
#include "SrvManager.h"
#include <unordered_map>

// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒžãƒãƒ¼ã‚¸ãƒ£ãƒ¼
class TextureManager
{
private:
	static TextureManager* instance;

	TextureManager() = default;
	~TextureManager() = default;
	TextureManager(TextureManager&) = delete;
	TextureManager& operator=(TextureManager&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static TextureManager* GetInstance();
	// çµ‚äº†
	void Finalize();
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* birectxcommon, SrvManager* srvmanager);

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>	/// <param name="filePath"ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹></param>
	void LoadTexture(const std::string& filePath);

	// ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	const DirectX::TexMetadata& GetMetaData(const std::string& filepath);
	// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å–å¾—
	uint32_t GetSrvIndex(const std::string& filePath);
	// CPUãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	D3D12_GPU_DESCRIPTOR_HANDLE GetSrvHandleGPU(const std::string& filepath);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒã™ã§ã«ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
	bool IsTextureLoaded(const std::string& filepath) const {
		// textures ãƒžãƒƒãƒ—ã«ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
		return textureDatas.find(filepath) != textureDatas.end();
	}
	
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è¼¸é€
	/// </summary>
	/// <param name="texture"></param>
	/// <param name="mipImages"></param>
	void UploadTextureData(Microsoft::WRL::ComPtr <ID3D12Resource>& texture, const DirectX::ScratchImage& mipImages);

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£1æžšåˆ†ã®ãƒ‡ãƒ¼ã‚¿
	struct TextureData {
		DirectX::TexMetadata metadata;
		Microsoft::WRL::ComPtr<ID3D12Resource> resource;
		uint32_t srvIndex;
		D3D12_CPU_DESCRIPTOR_HANDLE srvHandleCPU;
		D3D12_GPU_DESCRIPTOR_HANDLE srvHandleGPU;
	};
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿
	std::unordered_map<std::string, TextureData> textureDatas;
	// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å›žç‰ˆç•ªå·
	static uint32_t KSRVIndexTop;
	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—
	DirectXCommon* dxCommon_;
	SrvManager* srvmanager_;
};

============================================================
File Path: project/engine/scene/AbstractSceneFactory.h
============================================================
#pragma once
#include<BaseScene.h>
#include <string>

/// <summary>
/// ã‚·ãƒ¼ãƒ³å·¥å ´(æ¦‚å¿µ)
/// </summary>
class AbstractSceneFactory
{
public:
	/// ä»®æƒ³ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	virtual ~AbstractSceneFactory() = default;
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	virtual BaseScene* CreateScene(const std::string& sceneName) = 0;
};

============================================================
File Path: project/engine/scene/BaseScene.cpp
============================================================
#include<BaseScene.h>

============================================================
File Path: project/engine/scene/BaseScene.h
============================================================
#pragma once
#include <string>

// å‰æ–¹å®£è¨€ 
class SceneManager;

// ã‚·ãƒ¼ãƒ³åŸºåº•ã‚¯ãƒ©ã‚¹
class BaseScene
{
public:// ãƒ¡ãƒ³ãƒé–¢æ•°
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	virtual ~BaseScene() = default;

	// åˆæœŸåŒ–
	virtual void Initialize() = 0;
	// çµ‚äº†
	virtual void Finalize() = 0;
	// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°
	virtual void Update() = 0;
	// æç”»
	virtual void Draw() = 0;
private:
	// ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ï¼ˆå€Ÿã‚Šã¦ãã‚‹ï¼‰
	SceneManager* sceneManeger_ = nullptr;	
	// ã‚·ãƒ¼ãƒ³å
    std::string sceneName_;
public:// ãƒ¡ãƒ³ãƒé–¢æ•°
	virtual void SetSceneManeger(SceneManager* sceneManeger) { sceneManeger_ = sceneManeger; }
	SceneManager* GetSceneManeger() { return sceneManeger_; }
    void SetSceneName(const std::string& name) { sceneName_ = name; }
    const std::string& GetSceneName() const { return sceneName_; }
};

============================================================
File Path: project/engine/scene/MyGame.cpp
============================================================
#include "MyGame.h"
#include<SceneFactory.h>

void MyGame::Finalize() {
    // åŸºåº•ã‚¯ãƒ©ã‚¹ã®çµ‚äº†å‡¦ç†
    Framework::Finalize();
}

void MyGame::Initialize() {
    // åŸºåº•ã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–å‡¦ç†
    Framework::Initialize();
    // ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªã‚’ç”Ÿæˆã—ã€ãƒžãƒãƒ¼ã‚¸ãƒ£ã«ã‚»ãƒƒãƒˆ
    sceneFactory_ = std::make_unique<SceneFactory>();
    SceneManager::GetInstance()->SetSceneFactory(sceneFactory_.get());
    // ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã«æœ€åˆã®ã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆã—ãŸ

    // TITLE              ã‚¿ã‚¤ãƒˆãƒ«
	// GAMEPLAY           ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤
	// GAMECLEAR          ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢
    // GAMEOVER           ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
    SceneManager::GetInstance()->ChangeScene("TITLE");
}

void MyGame::Update() {
    // åŸºåº•ã‚¯ãƒ©ã‚¹ã®æ›´æ–°å‡¦ç†
    Framework::Update();
}

void MyGame::Draw() {
    // æç”»å‡¦ç†
    Framework::Draw(); 
    // ãƒ‡ãƒãƒƒã‚¯ãƒ†ã‚­ã‚¹ãƒˆæç”»
    ImGuiManager::GetInstance()->Draw();
    // æç”»å¾Œå‡¦ç†
    Framework::GetDirectXCommon()->PostDrow();
}

============================================================
File Path: project/engine/scene/MyGame.h
============================================================
#pragma once
#include<Framework.h>

// ã‚²ãƒ¼ãƒ 
class MyGame : public Framework
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
    // åˆæœŸåŒ–
    void Initialize() override;
    // çµ‚äº†
    void Finalize() override;
    // æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°
    void Update() override;
    // æç”»
    void Draw() override;
};

============================================================
File Path: project/engine/scene/SceneFactory.cpp
============================================================
#include "SceneFactory.h"
#include<TitleScene.h>
#include<GamePlayScene.h>
#include<GameClearScene.h>
#include<GameOverScene.h>

BaseScene* SceneFactory::CreateScene(const std::string& sceneName) {
	// æ¬¡ã®ã‚·ãƒ¼ãƒ³ã®ç”Ÿæˆ
	BaseScene* newScene = nullptr;

	if (sceneName == "TITLE") {
		newScene = new TitleScene();
	} else if (sceneName == "GAMEPLAY") {
		newScene = new GamePlayScene();
	}else if (sceneName == "GAMECLEAR") {
		newScene = new GameClearScene();
	}else if (sceneName == "GAMEOVER") {
		newScene = new GameOverScene();
	}
	
	// ã‚·ãƒ¼ãƒ³åã‚’ç™»éŒ²ã—ã¦ãŠã
	if (newScene) {
		newScene->SetSceneName(sceneName);
	}
	return newScene;
}

============================================================
File Path: project/engine/scene/SceneFactory.h
============================================================
#pragma once
#include"AbstractSceneFactory.h"

// ã“ã®ã‚²ãƒ¼ãƒ ç”¨ã®ã‚·ãƒ¼ãƒ³å·¥å ´
class SceneFactory : public AbstractSceneFactory
{
public:
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	/// </summary>
	/// <param name="sceneName">ã‚·ãƒ¼ãƒ³å</param>
	/// <returns>ç”Ÿæˆã—ãŸã‚·ãƒ¼ãƒ³</returns>
	virtual BaseScene* CreateScene(const std::string& sceneName) override;
};

============================================================
File Path: project/engine/scene/SceneManager.cpp
============================================================
#include "SceneManager.h"
#include <cassert>
#include<CameraManager.h>

// é™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®å®šç¾©
std::unique_ptr<SceneManager> SceneManager::instance = nullptr;

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
SceneManager* SceneManager::GetInstance() {
	if (!instance) {
		instance = std::make_unique<SceneManager>();
	}
	return instance.get();
}

// çµ‚äº†
void SceneManager::Finalize() {
	// æœ€å¾Œã®ã‚·ãƒ¼ãƒ³ã®çµ‚äº†ã¨è§£æ”¾
	if (scene_) {
		scene_->Finalize();
		scene_ = nullptr;
	}
	// ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è§£æ”¾
	instance.reset();
}

void SceneManager::Update() {
	// TODO:ã‚·ãƒ¼ãƒ³ã®åˆ‡ã‚Šæ›¿ãˆæ©Ÿæ§‹


	// æ¬¡ã®ã‚·ãƒ¼ãƒ³ã®äºˆç´„ãŒã‚ã‚‹ãªã‚‰
	if (nextScene_) {
		// æ—§ã‚·ãƒ¼ãƒ³ã®çµ‚äº†
		if (scene_) {
			scene_->Finalize();
		}

		// ã‚·ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
		scene_ = std::move(nextScene_); // æ‰€æœ‰æ¨©ã‚’ç§»å‹•
		nextScene_ = nullptr;
		// ã‚·ãƒ¼ãƒ³ãƒžãƒãƒ¼ã‚¸ãƒ£ã‚’ã‚»ãƒƒãƒˆ 
		scene_->SetSceneManeger(this);
		// æ¬¡ã®ã‚·ãƒ¼ãƒ³ã‚’åˆæœŸåŒ–ã™ã‚‹
		scene_->Initialize();

		// ---- ã‚·ãƒ¼ãƒ³å¤‰æ›´é€šçŸ¥ã‚’ã‚«ãƒ¡ãƒ©ã¸ ----
		CameraManager::GetInstance()->NotifySceneChangedByName(scene_->GetSceneName());
	}

	// å®Ÿè¡Œä¸­ã‚·ãƒ¼ãƒ³ã‚’æ›´æ–°ã™ã‚‹
	scene_->Update();
}

void SceneManager::Draw() {
	scene_->Draw();
}

void SceneManager::ChangeScene(const std::string& sceneName) {
	assert(sceneFactory_);
	assert(nextScene_ == nullptr);

	//æ¬¡ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	nextScene_ = std::unique_ptr<BaseScene>(sceneFactory_->CreateScene(sceneName));
}

============================================================
File Path: project/engine/scene/SceneManager.h
============================================================
#pragma once
#include<BaseScene.h>
#include<AbstractSceneFactory.h>
#include <memory>
#include <unordered_map>

// ã‚·ãƒ¼ãƒ³ç®¡ç†
class SceneManager
{
private:
	static std::unique_ptr<SceneManager> instance;

	SceneManager(SceneManager&) = delete;
	SceneManager& operator=(SceneManager&) = delete;
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	SceneManager() = default;
	~SceneManager() = default;

	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	static SceneManager* GetInstance();
	// çµ‚äº†
	void Finalize();
	// æ¯Žãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°
	void Update();
	// æç”»
	void Draw();
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ä»Šã®ã‚·ãƒ¼ãƒ³(å®Ÿè¡Œä¸­ã‚·ãƒ¼ãƒ³)
	std::unique_ptr<BaseScene> scene_ = nullptr;
	// æ¬¡ã®ã‚·ãƒ¼ãƒ³
	std::unique_ptr<BaseScene> nextScene_ = nullptr;
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼(å€Ÿã‚Šã¦ãã‚‹)
	AbstractSceneFactory* sceneFactory_ = nullptr;
	// ã‚·ãƒ¼ãƒ³åˆ°é”ãƒ•ãƒ©ã‚°ã®ãƒžãƒƒãƒ—
    std::unordered_map<std::string, bool> sceneReachedFlags_;
public:
	/// <summary>
	/// æ¬¡ã‚·ãƒ¼ãƒ³äºˆç´„
	/// </summary>
	/// <param name="sceneName">ã‚·ãƒ¼ãƒ³å</param>
	void ChangeScene(const std::string& sceneName);
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã«setter
	void SetSceneFactory(AbstractSceneFactory* SceneFactory) { sceneFactory_ = SceneFactory; }
    // ã‚·ãƒ¼ãƒ³åˆ°é”ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
    void SetSceneReached(const std::string& sceneName, bool reached = true) {
        sceneReachedFlags_[sceneName] = reached;
    }

    // ã‚·ãƒ¼ãƒ³ã«ä¸€åº¦ã§ã‚‚åˆ°é”ã—ãŸã‹ï¼Ÿ
    bool HasReachedScene(const std::string& sceneName) const {
        auto it = sceneReachedFlags_.find(sceneName);
        return it != sceneReachedFlags_.end() && it->second;
    }

    // ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã‚’å–å¾—ã™ã‚‹ getter
    BaseScene* GetCurrentScene() const {
        return scene_.get();
    }
	
	// ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ãŒã€Œåˆ°é”æ¸ˆã¿ã€ãƒ•ãƒ©ã‚°ã‚’æŒã£ã¦ã„ã‚‹ã‹ï¼Ÿ
	bool IsCurrentSceneReached() const {
		if (!scene_) { return false; }

		// BaseScene å´ã§ã‚·ãƒ¼ãƒ³åã‚’æŒã£ã¦ã„ã‚‹å‰æ
		const std::string& currentSceneName = scene_->GetSceneName();

		auto it = sceneReachedFlags_.find(currentSceneName);
		return it != sceneReachedFlags_.end() && it->second;
	}
};

============================================================
File Path: project/externals/assimp/include/assimp/AssertHandler.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2020, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Provides facilities to replace the default assert handler. */

#ifndef INCLUDED_AI_ASSERTHANDLER_H
#define INCLUDED_AI_ASSERTHANDLER_H

#include <assimp/ai_assert.h>
#include <assimp/defs.h>

namespace Assimp {

// ---------------------------------------------------------------------------
/**
 *  @brief  Signature of functions which handle assert violations.
 */
using AiAssertHandler = void (*)(const char* failedExpression, const char* file, int line);

// ---------------------------------------------------------------------------
/**
 *  @brief  Set the assert handler.
 */
ASSIMP_API void setAiAssertHandler(AiAssertHandler handler);

// ---------------------------------------------------------------------------
/** The assert handler which is set by default.
 *
 *  @brief  This issues a message to stderr and calls abort.
 */
AI_WONT_RETURN ASSIMP_API void defaultAiAssertHandler(const char* failedExpression, const char* file, int line) AI_WONT_RETURN_SUFFIX;

// ---------------------------------------------------------------------------
/**
 *  @brief  Dispatches an assert violation to the assert handler.
 */
ASSIMP_API void aiAssertViolation(const char* failedExpression, const char* file, int line);

} // end of namespace Assimp

#endif // INCLUDED_AI_ASSERTHANDLER_H


============================================================
File Path: project/externals/assimp/include/assimp/Base64.hpp
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

#pragma once
#ifndef AI_BASE64_HPP_INC
#define AI_BASE64_HPP_INC

#include <assimp/defs.h>

#include <stdint.h>
#include <vector>
#include <string>

namespace Assimp {
namespace Base64 {

/// @brief Will encode the given character buffer from UTF64 to ASCII
/// @param in           The UTF-64 buffer.
/// @param inLength     The size of the buffer
/// @param out          The encoded ASCII string.
ASSIMP_API void Encode(const uint8_t *in, size_t inLength, std::string &out);

/// @brief Will encode the given character buffer from UTF64 to ASCII.
/// @param in   A vector, which contains the buffer for encoding.
/// @param out  The encoded ASCII string.
ASSIMP_API void Encode(const std::vector<uint8_t> &in, std::string &out);

/// @brief Will encode the given character buffer from UTF64 to ASCII.
/// @param in   A vector, which contains the buffer for encoding.
/// @return The encoded ASCII string.
ASSIMP_API std::string Encode(const std::vector<uint8_t> &in);

/// @brief Will decode the given character buffer from ASCII to UTF64.
/// @param in           The ASCII buffer to decode.
/// @param inLength     The size of the buffer.
/// @param out          The decoded buffer.
/// @return The new buffer size.
ASSIMP_API size_t Decode(const char *in, size_t inLength, uint8_t *&out);

/// @brief Will decode the given character buffer from ASCII to UTF64.
/// @param in   The ASCII buffer to decode as a std::string.
/// @param out  The decoded buffer.
/// @return The new buffer size.
ASSIMP_API size_t Decode(const std::string &in, std::vector<uint8_t> &out);

/// @brief Will decode the given character buffer from ASCII to UTF64.
/// @param in   The ASCII string.
/// @return The decoded buffer in a vector.
ASSIMP_API std::vector<uint8_t> Decode(const std::string &in);

} // namespace Base64
} // namespace Assimp

#endif // AI_BASE64_HPP_INC


============================================================
File Path: project/externals/assimp/include/assimp/BaseImporter.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/// @file Definition of the base class for all importer worker classes.

#pragma once
#ifndef INCLUDED_AI_BASEIMPORTER_H
#define INCLUDED_AI_BASEIMPORTER_H

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include "Exceptional.h"

#include <assimp/types.h>
#include <assimp/ProgressHandler.hpp>
#include <exception>
#include <set>
#include <vector>
#include <memory>

struct aiScene;
struct aiImporterDesc;

namespace Assimp {

class Importer;
class IOSystem;
class BaseProcess;
class SharedPostProcessInfo;
class IOStream;

// utility to do char4 to uint32 in a portable manner
#define AI_MAKE_MAGIC(string) ((uint32_t)((string[0] << 24) + \
                                          (string[1] << 16) + (string[2] << 8) + string[3]))

// ---------------------------------------------------------------------------
/** FOR IMPORTER PLUGINS ONLY: The BaseImporter defines a common interface
 *  for all importer worker classes.
 *
 * The interface defines two functions: CanRead() is used to check if the
 * importer can handle the format of the given file. If an implementation of
 * this function returns true, the importer then calls ReadFile() which
 * imports the given file. ReadFile is not overridable, it just calls
 * InternReadFile() and catches any ImportErrorException that might occur.
 */
class ASSIMP_API BaseImporter {
    friend class Importer;

public:
    /** Constructor to be privately used by #Importer */
    BaseImporter() AI_NO_EXCEPT;

    /** Destructor, private as well */
    virtual ~BaseImporter();

    // -------------------------------------------------------------------
    /** Returns whether the class can handle the format of the given file.
     *
     * The implementation is expected to perform a full check of the file
     * structure, possibly searching the first bytes of the file for magic
     * identifiers or keywords.
     *
     * @param pFile Path and file name of the file to be examined.
     * @param pIOHandler The IO handler to use for accessing any file.
     * @param checkSig Legacy; do not use.
     * @return true if the class can read this file, false if not or if
     * unsure.
     */
    virtual bool CanRead(
            const std::string &pFile,
            IOSystem *pIOHandler,
            bool checkSig) const = 0;

    // -------------------------------------------------------------------
    /** Imports the given file and returns the imported data.
     * If the import succeeds, ownership of the data is transferred to
     * the caller. If the import fails, nullptr is returned. The function
     * takes care that any partially constructed data is destroyed
     * beforehand.
     *
     * @param pImp #Importer object hosting this loader.
     * @param pFile Path of the file to be imported.
     * @param pIOHandler IO-Handler used to open this and possible other files.
     * @return The imported data or nullptr if failed. If it failed a
     * human-readable error description can be retrieved by calling
     * GetErrorText()
     *
     * @note This function is not intended to be overridden. Implement
     * InternReadFile() to do the import. If an exception is thrown somewhere
     * in InternReadFile(), this function will catch it and transform it into
     *  a suitable response to the caller.
     */
    aiScene *ReadFile(
            Importer *pImp,
            const std::string &pFile,
            IOSystem *pIOHandler);

    // -------------------------------------------------------------------
    /** Returns the error description of the last error that occurred.
     * If the error is due to a std::exception, this will return the message.
     * Exceptions can also be accessed with GetException().
     * @return A description of the last error that occurred. An empty
     * string if there was no error.
     */
    const std::string &GetErrorText() const {
        return m_ErrorText;
    }

    // -------------------------------------------------------------------
    /** Returns the exception of the last exception that occurred.
     * Note: Exceptions are not the only source of error details, so GetErrorText
     * should be consulted too.
     * @return The last exception that occurred.
     */
    const std::exception_ptr& GetException() const {
        return m_Exception;
    }

    // -------------------------------------------------------------------
    /** Called prior to ReadFile().
     * The function is a request to the importer to update its configuration
     * basing on the Importer's configuration property list.
     * @param pImp Importer instance
     */
    virtual void SetupProperties(
            const Importer *pImp);

    // -------------------------------------------------------------------
    /** Called by #Importer::GetImporterInfo to get a description of
     *  some loader features. Importers must provide this information. */
    virtual const aiImporterDesc *GetInfo() const = 0;

    /**
     * Will be called only by scale process when scaling is requested.
     */
    void SetFileScale(double scale) {
        fileScale = scale;
    }

    // -------------------------------------------------------------------
    /** Called by #Importer::GetExtensionList for each loaded importer.
     *  Take the extension list contained in the structure returned by
     *  #GetInfo and insert all file extensions into the given set.
     *  @param extension set to collect file extensions in*/
    void GetExtensionList(std::set<std::string> &extensions);

protected:
    double importerScale = 1.0;
    double fileScale = 1.0;

    // -------------------------------------------------------------------
    /** Imports the given file into the given scene structure. The
     * function is expected to throw an ImportErrorException if there is
     * an error. If it terminates normally, the data in aiScene is
     * expected to be correct. Override this function to implement the
     * actual importing.
     * <br>
     *  The output scene must meet the following requirements:<br>
     * <ul>
     * <li>At least a root node must be there, even if its only purpose
     *     is to reference one mesh.</li>
     * <li>aiMesh::mPrimitiveTypes may be 0. The types of primitives
     *   in the mesh are determined automatically in this case.</li>
     * <li>the vertex data is stored in a pseudo-indexed "verbose" format.
     *   In fact this means that every vertex that is referenced by
     *   a face is unique. Or the other way round: a vertex index may
     *   not occur twice in a single aiMesh.</li>
     * <li>aiAnimation::mDuration may be -1. Assimp determines the length
     *   of the animation automatically in this case as the length of
     *   the longest animation channel.</li>
     * <li>aiMesh::mBitangents may be nullptr if tangents and normals are
     *   given. In this case bitangents are computed as the cross product
     *   between normal and tangent.</li>
     * <li>There needn't be a material. If none is there a default material
     *   is generated. However, it is recommended practice for loaders
     *   to generate a default material for yourself that matches the
     *   default material setting for the file format better than Assimp's
     *   generic default material. Note that default materials *should*
     *   be named AI_DEFAULT_MATERIAL_NAME if they're just color-shaded
     *   or AI_DEFAULT_TEXTURED_MATERIAL_NAME if they define a (dummy)
     *   texture. </li>
     * </ul>
     * If the AI_SCENE_FLAGS_INCOMPLETE-Flag is <b>not</b> set:<ul>
     * <li> at least one mesh must be there</li>
     * <li> there may be no meshes with 0 vertices or faces</li>
     * </ul>
     * This won't be checked (except by the validation step): Assimp will
     * crash if one of the conditions is not met!
     *
     * @param pFile Path of the file to be imported.
     * @param pScene The scene object to hold the imported data.
     * nullptr is not a valid parameter.
     * @param pIOHandler The IO handler to use for any file access.
     * nullptr is not a valid parameter. */
    virtual void InternReadFile(
            const std::string &pFile,
            aiScene *pScene,
            IOSystem *pIOHandler) = 0;

public: // static utilities
    // -------------------------------------------------------------------
    /** A utility for CanRead().
     *
     *  The function searches the header of a file for a specific token
     *  and returns true if this token is found. This works for text
     *  files only. There is a rudimentary handling of UNICODE files.
     *  The comparison is case independent.
     *
     *  @param pIOSystem IO System to work with
     *  @param file File name of the file
     *  @param tokens List of tokens to search for
     *  @param numTokens Size of the token array
     *  @param searchBytes Number of bytes to be searched for the tokens.
     */
    static bool SearchFileHeaderForToken(
            IOSystem *pIOSystem,
            const std::string &file,
            const char **tokens,
            std::size_t numTokens,
            unsigned int searchBytes = 200,
            bool tokensSol = false,
            bool noGraphBeforeTokens = false);

    // -------------------------------------------------------------------
    /** @brief Check whether a file has a specific file extension
     *  @param pFile Input file
     *  @param ext0 Extension to check for. Lowercase characters only, no dot!
     *  @param ext1 Optional second extension
     *  @param ext2 Optional third extension
     *  @note Case-insensitive
     */
    static bool SimpleExtensionCheck(
            const std::string &pFile,
            const char *ext0,
            const char *ext1 = nullptr,
            const char *ext2 = nullptr);

    // -------------------------------------------------------------------
    /** @brief Check whether a file has one of the passed file extensions
     *  @param pFile Input file
     *  @param extensions Extensions to check for. Lowercase characters only, no dot!
     *  @note Case-insensitive
     */
    static bool HasExtension(
            const std::string &pFile,
            const std::set<std::string> &extensions);

    // -------------------------------------------------------------------
    /** @brief Extract file extension from a string
     *  @param pFile Input file
     *  @return Extension without trailing dot, all lowercase
     */
    static std::string GetExtension(
            const std::string &pFile);

    // -------------------------------------------------------------------
    /** @brief Check whether a file starts with one or more magic tokens
     *  @param pFile Input file
     *  @param pIOHandler IO system to be used
     *  @param magic n magic tokens
     *  @params num Size of magic
     *  @param offset Offset from file start where tokens are located
     *  @param Size of one token, in bytes. Maximally 16 bytes.
     *  @return true if one of the given tokens was found
     *
     *  @note For convenience, the check is also performed for the
     *  byte-swapped variant of all tokens (big endian). Only for
     *  tokens of size 2,4.
     */
    static bool CheckMagicToken(
            IOSystem *pIOHandler,
            const std::string &pFile,
            const void *magic,
            std::size_t num,
            unsigned int offset = 0,
            unsigned int size = 4);

    // -------------------------------------------------------------------
    /** An utility for all text file loaders. It converts a file to our
     *   UTF8 character set. Errors are reported, but ignored.
     *
     *  @param data File buffer to be converted to UTF8 data. The buffer
     *  is resized as appropriate. */
    static void ConvertToUTF8(
            std::vector<char> &data);

    // -------------------------------------------------------------------
    /** An utility for all text file loaders. It converts a file from our
     *   UTF8 character set back to ISO-8859-1. Errors are reported, but ignored.
     *
     *  @param data File buffer to be converted from UTF8 to ISO-8859-1. The buffer
     *  is resized as appropriate. */
    static void ConvertUTF8toISO8859_1(
            std::string &data);

    // -------------------------------------------------------------------
    /// @brief  Enum to define, if empty files are ok or not.
    enum TextFileMode {
        ALLOW_EMPTY,
        FORBID_EMPTY
    };

    // -------------------------------------------------------------------
    /** Utility for text file loaders which copies the contents of the
     *  file into a memory buffer and converts it to our UTF8
     *  representation.
     *  @param stream Stream to read from.
     *  @param data Output buffer to be resized and filled with the
     *   converted text file data. The buffer is terminated with
     *   a binary 0.
     *  @param mode Whether it is OK to load empty text files. */
    static void TextFileToBuffer(
            IOStream *stream,
            std::vector<char> &data,
            TextFileMode mode = FORBID_EMPTY);

    // -------------------------------------------------------------------
    /** Utility function to move a std::vector into a aiScene array
    *  @param vec The vector to be moved
    *  @param out The output pointer to the allocated array.
    *  @param numOut The output count of elements copied. */
    template <typename T>
    AI_FORCE_INLINE static void CopyVector(
            std::vector<T> &vec,
            T *&out,
            unsigned int &outLength) {
        outLength = unsigned(vec.size());
        if (outLength) {
            out = new T[outLength];
            std::swap_ranges(vec.begin(), vec.end(), out);
        }
    }

    // -------------------------------------------------------------------
    /** Utility function to move a std::vector of unique_ptrs into a aiScene array
    *  @param vec The vector of unique_ptrs to be moved
    *  @param out The output pointer to the allocated array.
    *  @param numOut The output count of elements copied. */
    template <typename T>
    AI_FORCE_INLINE static void CopyVector(
            std::vector<std::unique_ptr<T> > &vec,
            T **&out,
            unsigned int &outLength) {
        outLength = unsigned(vec.size());
        if (outLength) {
            out = new T*[outLength];
            T** outPtr = out;
            std::for_each(vec.begin(), vec.end(), [&outPtr](std::unique_ptr<T>& uPtr){*outPtr = uPtr.release(); ++outPtr; });
        }
    }

private:
    /* Pushes state into importer for the importer scale */
    void UpdateImporterScale(Importer *pImp);

protected:
    /// Error description in case there was one.
    std::string m_ErrorText;
    /// The exception, in case there was one.
    std::exception_ptr m_Exception;
    /// Currently set progress handler.
    ProgressHandler *m_progress;
};

} // end of namespace Assimp

#endif // AI_BASEIMPORTER_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/Bitmap.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Bitmap.h
 *  @brief Defines bitmap format helper for textures
 *
 * Used for file formats which embed their textures into the model file.
 */
#pragma once
#ifndef AI_BITMAP_H_INC
#define AI_BITMAP_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include "defs.h"
#include <cstdint>
#include <cstddef>

struct aiTexture;

namespace Assimp {

class IOStream;

// ---------------------------------------------------------------------------
/**
 *  This class is used to store and write bitmap information.
 */
class ASSIMP_API Bitmap {
protected:

    struct Header {
        uint16_t type;
        uint32_t size;
        uint16_t reserved1;
        uint16_t reserved2;
        uint32_t offset;

        // We define the struct size because sizeof(Header) might return a wrong result because of structure padding.
        static constexpr std::size_t header_size =
            sizeof(uint16_t) +
            sizeof(uint32_t) +
            sizeof(uint16_t) +
            sizeof(uint16_t) +
            sizeof(uint32_t);
    };

    struct DIB {
        uint32_t size;
        int32_t width;
        int32_t height;
        uint16_t planes;
        uint16_t bits_per_pixel;
        uint32_t compression;
        uint32_t image_size;
        int32_t x_resolution;
        int32_t y_resolution;
        uint32_t nb_colors;
        uint32_t nb_important_colors;

        // We define the struct size because sizeof(DIB) might return a wrong result because of structure padding.
        static constexpr std::size_t dib_size =
            sizeof(uint32_t) +
            sizeof(int32_t) +
            sizeof(int32_t) +
            sizeof(uint16_t) +
            sizeof(uint16_t) +
            sizeof(uint32_t) +
            sizeof(uint32_t) +
            sizeof(int32_t) +
            sizeof(int32_t) +
            sizeof(uint32_t) +
            sizeof(uint32_t);
    };

    static constexpr std::size_t mBytesPerPixel = 4;

public:
    /// @brief  Will save an aiTexture instance as a bitmap.
    /// @param texture  The pointer to the texture instance
    /// @param file     The filename to save into.
    /// @return true if successfully saved, false if not.
    static bool Save(aiTexture* texture, IOStream* file);

protected:
    static void WriteHeader(Header& header, IOStream* file);
    static void WriteDIB(DIB& dib, IOStream* file);
    static void WriteData(aiTexture* texture, IOStream* file);
};

}

#endif // AI_BITMAP_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/BlobIOSystem.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Provides cheat implementations for IOSystem and IOStream to
 *  redirect exporter output to a blob chain.*/

#pragma once
#ifndef AI_BLOBIOSYSTEM_H_INCLUDED
#define AI_BLOBIOSYSTEM_H_INCLUDED

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/cexport.h>
#include <assimp/DefaultLogger.hpp>
#include <assimp/IOStream.hpp>
#include <assimp/IOSystem.hpp>
#include <cstdint>
#include <set>
#include <vector>

namespace Assimp {
class BlobIOSystem;

// --------------------------------------------------------------------------------------------
/** Redirect IOStream to a blob */
// --------------------------------------------------------------------------------------------
class BlobIOStream : public IOStream {
public:
    /// @brief The class constructor with all needed parameters
    /// @param creator  Pointer to the creator instance
    /// @param file     The filename
    /// @param initial  The initial size
    BlobIOStream(BlobIOSystem *creator, const std::string &file, size_t initial = 4096) :
            buffer(),
            cur_size(),
            file_size(),
            cursor(),
            initial(initial),
            file(file),
            creator(creator) {
        // empty
    }

    ///	@brief  The class destructor.
    ~BlobIOStream() override;

public:
    // -------------------------------------------------------------------
    aiExportDataBlob *GetBlob() {
        aiExportDataBlob *blob = new aiExportDataBlob();
        blob->size = file_size;
        blob->data = buffer;

        buffer = nullptr;

        return blob;
    }

    // -------------------------------------------------------------------
    size_t Read(void *, size_t, size_t) override {
        return 0;
    }

    // -------------------------------------------------------------------
    size_t Write(const void *pvBuffer, size_t pSize, size_t pCount) override {
        pSize *= pCount;
        if (cursor + pSize > cur_size) {
            Grow(cursor + pSize);
        }

        memcpy(buffer + cursor, pvBuffer, pSize);
        cursor += pSize;

        file_size = std::max(file_size, cursor);
        return pCount;
    }

    // -------------------------------------------------------------------
    aiReturn Seek(size_t pOffset, aiOrigin pOrigin) override {
        switch (pOrigin) {
            case aiOrigin_CUR:
                cursor += pOffset;
                break;

            case aiOrigin_END:
                cursor = file_size - pOffset;
                break;

            case aiOrigin_SET:
                cursor = pOffset;
                break;

            default:
                return AI_FAILURE;
        }

        if (cursor > file_size) {
            Grow(cursor);
        }

        file_size = std::max(cursor, file_size);

        return AI_SUCCESS;
    }

    // -------------------------------------------------------------------
    size_t Tell() const override {
        return cursor;
    }

    // -------------------------------------------------------------------
    size_t FileSize() const override {
        return file_size;
    }

    // -------------------------------------------------------------------
    void Flush() override {
        // ignore
    }

private:
    // -------------------------------------------------------------------
    void Grow(size_t need = 0) {
        // 1.5 and phi are very heap-friendly growth factors (the first
        // allows for frequent re-use of heap blocks, the second
        // forms a fibonacci sequence with similar characteristics -
        // since this heavily depends on the heap implementation
        // and other factors as well, i'll just go with 1.5 since
        // it is quicker to compute).
        size_t new_size = std::max(initial, std::max(need, cur_size + (cur_size >> 1)));

        const uint8_t *const old = buffer;
        buffer = new uint8_t[new_size];

        if (old) {
            memcpy(buffer, old, cur_size);
            delete[] old;
        }

        cur_size = new_size;
    }

private:
    uint8_t *buffer;
    size_t cur_size, file_size, cursor, initial;

    const std::string file;
    BlobIOSystem *const creator;
};

#define AI_BLOBIO_MAGIC "$blobfile"

// --------------------------------------------------------------------------------------------
/** Redirect IOSystem to a blob */
// --------------------------------------------------------------------------------------------
class BlobIOSystem : public IOSystem {

    friend class BlobIOStream;
    typedef std::pair<std::string, aiExportDataBlob *> BlobEntry;


public:
    /// @brief The default class constructor.
    BlobIOSystem() :
            baseName{AI_BLOBIO_MAGIC} {
    }

    ///	@brief  The class constructor with the base name.
    /// @param baseName     The base name.
    BlobIOSystem(const std::string &baseName) :
            baseName(baseName) {
        // empty
    }

    ~BlobIOSystem() override {
        for (BlobEntry &blobby : blobs) {
            delete blobby.second;
        }
    }

public:
    // -------------------------------------------------------------------
    const char *GetMagicFileName() const {
        return baseName.c_str();
    }

    // -------------------------------------------------------------------
    aiExportDataBlob *GetBlobChain() {
        const auto magicName = std::string(this->GetMagicFileName());
        const bool hasBaseName = baseName != AI_BLOBIO_MAGIC;

        // one must be the master
        aiExportDataBlob *master = nullptr, *cur;

        for (const BlobEntry &blobby : blobs) {
            if (blobby.first == magicName) {
                master = blobby.second;
                master->name.Set(hasBaseName ? blobby.first : "");
                break;
            }
        }

        if (!master) {
            ASSIMP_LOG_ERROR("BlobIOSystem: no data written or master file was not closed properly.");
            return nullptr;
        }

        cur = master;

        for (const BlobEntry &blobby : blobs) {
            if (blobby.second == master) {
                continue;
            }

            cur->next = blobby.second;
            cur = cur->next;

            if (hasBaseName) {
                cur->name.Set(blobby.first);
            } else {
                // extract the file extension from the file written
                const std::string::size_type s = blobby.first.find_first_of('.');
                cur->name.Set(s == std::string::npos ? blobby.first : blobby.first.substr(s + 1));
            }
        }

        // give up blob ownership
        blobs.clear();
        return master;
    }

public:
    // -------------------------------------------------------------------
    bool Exists(const char *pFile) const override {
        return created.find(std::string(pFile)) != created.end();
    }

    // -------------------------------------------------------------------
    char getOsSeparator() const override {
        return '/';
    }

    // -------------------------------------------------------------------
    IOStream *Open(const char *pFile, const char *pMode) override {
        if (pMode[0] != 'w') {
            return nullptr;
        }

        created.insert(std::string(pFile));
        return new BlobIOStream(this, std::string(pFile));
    }

    // -------------------------------------------------------------------
    void Close(IOStream *pFile) override {
        delete pFile;
    }

private:
    // -------------------------------------------------------------------
    void OnDestruct(const std::string &filename, BlobIOStream *child) {
        // we don't know in which the files are closed, so we
        // can't reliably say that the first must be the master
        // file ...
        blobs.emplace_back(filename, child->GetBlob());
    }

private:
    std::string baseName;
    std::set<std::string> created;
    std::vector<BlobEntry> blobs;
};

// --------------------------------------------------------------------------------------------
BlobIOStream::~BlobIOStream() {
    if (nullptr != creator) {
        creator->OnDestruct(file, this);
    }
    delete[] buffer;
}

} // namespace Assimp

#endif


============================================================
File Path: project/externals/assimp/include/assimp/ByteSwapper.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Helper class tp perform various byte order swappings
   (e.g. little to big endian) */
#pragma once
#ifndef AI_BYTESWAPPER_H_INC
#define AI_BYTESWAPPER_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/ai_assert.h>
#include <assimp/types.h>
#include <cstdint>

#if _MSC_VER >= 1400
#include <cstdlib>
#endif

namespace Assimp    {
// --------------------------------------------------------------------------------------
/** Defines some useful byte order swap routines.
 *
 * This is required to read big-endian model formats on little-endian machines,
 * and vice versa. Direct use of this class is DEPRECATED. Use #StreamReader instead. */
// --------------------------------------------------------------------------------------
class ByteSwap {
    ByteSwap() AI_NO_EXCEPT {}

public:

    // ----------------------------------------------------------------------
    /** Swap two bytes of data
     *  @param[inout] _szOut A void* to save the reintcasts for the caller. */
    static inline void Swap2(void* _szOut)
    {
        ai_assert(_szOut);

#if _MSC_VER >= 1400
        uint16_t* const szOut = reinterpret_cast<uint16_t*>(_szOut);
        *szOut = _byteswap_ushort(*szOut);
#else
        uint8_t* const szOut = reinterpret_cast<uint8_t*>(_szOut);
        std::swap(szOut[0],szOut[1]);
#endif
    }

    // ----------------------------------------------------------------------
    /** Swap four bytes of data
     *  @param[inout] _szOut A void* to save the reintcasts for the caller. */
    static inline void Swap4(void* _szOut)
    {
        ai_assert(_szOut);

#if _MSC_VER >= 1400
        uint32_t* const szOut = reinterpret_cast<uint32_t*>(_szOut);
        *szOut = _byteswap_ulong(*szOut);
#else
        uint8_t* const szOut = reinterpret_cast<uint8_t*>(_szOut);
        std::swap(szOut[0],szOut[3]);
        std::swap(szOut[1],szOut[2]);
#endif
    }

    // ----------------------------------------------------------------------
    /** Swap eight bytes of data
     *  @param[inout] _szOut A void* to save the reintcasts for the caller. */
    static inline void Swap8(void* _szOut)
    {
    ai_assert(_szOut);

#if _MSC_VER >= 1400
        uint64_t* const szOut = reinterpret_cast<uint64_t*>(_szOut);
        *szOut = _byteswap_uint64(*szOut);
#else
        uint8_t* const szOut = reinterpret_cast<uint8_t*>(_szOut);
        std::swap(szOut[0],szOut[7]);
        std::swap(szOut[1],szOut[6]);
        std::swap(szOut[2],szOut[5]);
        std::swap(szOut[3],szOut[4]);
#endif
    }

    // ----------------------------------------------------------------------
    /** ByteSwap a float. Not a joke.
     *  @param[inout] fOut ehm. .. */
    static inline void Swap(float* fOut) {
        Swap4(fOut);
    }

    // ----------------------------------------------------------------------
    /** ByteSwap a double. Not a joke.
     *  @param[inout] fOut ehm. .. */
    static inline void Swap(double* fOut) {
        Swap8(fOut);
    }


    // ----------------------------------------------------------------------
    /** ByteSwap an int16t. Not a joke.
     *  @param[inout] fOut ehm. .. */
    static inline void Swap(int16_t* fOut) {
        Swap2(fOut);
    }

    static inline void Swap(uint16_t* fOut) {
        Swap2(fOut);
    }

    // ----------------------------------------------------------------------
    /** ByteSwap an int32t. Not a joke.
     *  @param[inout] fOut ehm. .. */
    static inline void Swap(int32_t* fOut){
        Swap4(fOut);
    }

    static inline void Swap(uint32_t* fOut){
        Swap4(fOut);
    }

    // ----------------------------------------------------------------------
    /** ByteSwap an int64t. Not a joke.
     *  @param[inout] fOut ehm. .. */
    static inline void Swap(int64_t* fOut) {
        Swap8(fOut);
    }

    static inline void Swap(uint64_t* fOut) {
        Swap8(fOut);
    }

    // ----------------------------------------------------------------------
    //! Templatized ByteSwap
    //! \returns param tOut as swapped
    template<typename Type>
    static inline Type Swapped(Type tOut)
    {
        return _swapper<Type,sizeof(Type)>()(tOut);
    }

private:

    template <typename T, size_t size> struct _swapper;
};

template <typename T> struct ByteSwap::_swapper<T,2> {
    T operator() (T tOut) {
        Swap2(&tOut);
        return tOut;
    }
};

template <typename T> struct ByteSwap::_swapper<T,4> {
    T operator() (T tOut) {
        Swap4(&tOut);
        return tOut;
    }
};

template <typename T> struct ByteSwap::_swapper<T,8> {
    T operator() (T tOut) {
        Swap8(&tOut);
        return tOut;
    }
};


// --------------------------------------------------------------------------------------
// ByteSwap macros for BigEndian/LittleEndian support
// --------------------------------------------------------------------------------------
#if (defined AI_BUILD_BIG_ENDIAN)
#   define AI_LE(t) (t)
#   define AI_BE(t) Assimp::ByteSwap::Swapped(t)
#   define AI_LSWAP2(p)
#   define AI_LSWAP4(p)
#   define AI_LSWAP8(p)
#   define AI_LSWAP2P(p)
#   define AI_LSWAP4P(p)
#   define AI_LSWAP8P(p)
#   define LE_NCONST const
#   define AI_SWAP2(p) Assimp::ByteSwap::Swap2(&(p))
#   define AI_SWAP4(p) Assimp::ByteSwap::Swap4(&(p))
#   define AI_SWAP8(p) Assimp::ByteSwap::Swap8(&(p))
#   define AI_SWAP2P(p) Assimp::ByteSwap::Swap2((p))
#   define AI_SWAP4P(p) Assimp::ByteSwap::Swap4((p))
#   define AI_SWAP8P(p) Assimp::ByteSwap::Swap8((p))
#   define BE_NCONST
#else
#   define AI_BE(t) (t)
#   define AI_LE(t) Assimp::ByteSwap::Swapped(t)
#   define AI_SWAP2(p)
#   define AI_SWAP4(p)
#   define AI_SWAP8(p)
#   define AI_SWAP2P(p)
#   define AI_SWAP4P(p)
#   define AI_SWAP8P(p)
#   define BE_NCONST const
#   define AI_LSWAP2(p)     Assimp::ByteSwap::Swap2(&(p))
#   define AI_LSWAP4(p)     Assimp::ByteSwap::Swap4(&(p))
#   define AI_LSWAP8(p)     Assimp::ByteSwap::Swap8(&(p))
#   define AI_LSWAP2P(p)    Assimp::ByteSwap::Swap2((p))
#   define AI_LSWAP4P(p)    Assimp::ByteSwap::Swap4((p))
#   define AI_LSWAP8P(p)    Assimp::ByteSwap::Swap8((p))
#   define LE_NCONST
#endif


namespace Intern {

// --------------------------------------------------------------------------------------------
template <typename T, bool doit>
struct ByteSwapper  {
    void operator() (T* inout) {
        ByteSwap::Swap(inout);
    }
};

template <typename T>
struct ByteSwapper<T,false> {
    void operator() (T*) {
    }
};

// --------------------------------------------------------------------------------------------
template <bool SwapEndianess, typename T, bool RuntimeSwitch>
struct Getter {
    void operator() (T* inout, bool le) {
#ifdef AI_BUILD_BIG_ENDIAN
        le =  le;
#else
        le =  !le;
#endif
        if (le) {
            ByteSwapper<T,(sizeof(T)>1?true:false)> () (inout);
        }
        else ByteSwapper<T,false> () (inout);
    }
};

template <bool SwapEndianess, typename T>
struct Getter<SwapEndianess,T,false> {

    void operator() (T* inout, bool /*le*/) {
        // static branch
        ByteSwapper<T,(SwapEndianess && sizeof(T)>1)> () (inout);
    }
};
} // end Intern
} // end Assimp

#endif //!! AI_BYTESWAPPER_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/ColladaMetaData.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file ColladaMetaData.h
 * Declares common metadata constants used by Collada files
 */
#pragma once
#ifndef AI_COLLADAMETADATA_H_INC
#define AI_COLLADAMETADATA_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#define AI_METADATA_COLLADA_ID "Collada_id"
#define AI_METADATA_COLLADA_SID "Collada_sid"

#endif


============================================================
File Path: project/externals/assimp/include/assimp/Compiler/poppack1.h
============================================================

// ===============================================================================
// May be included multiple times - resets structure packing to the defaults
// for all supported compilers. Reverts the changes made by #include <pushpack1.h>
//
// Currently this works on the following compilers:
// MSVC 7,8,9
// GCC
// BORLAND (complains about 'pack state changed but not reverted', but works)
// ===============================================================================

#ifndef AI_PUSHPACK_IS_DEFINED
#	error pushpack1.h must be included after poppack1.h
#endif

// reset packing to the original value
#if (defined(_MSC_VER) && !defined(__clang__)) ||  defined(__BORLANDC__) || defined (__BCPLUSPLUS__)
#	pragma pack( pop )
#endif
#undef PACK_STRUCT

#undef AI_PUSHPACK_IS_DEFINED


============================================================
File Path: project/externals/assimp/include/assimp/Compiler/pstdint.h
============================================================
/*  A portable stdint.h
 ****************************************************************************
 *  BSD License:
 ****************************************************************************
 *
 *  Copyright (c) 2005-2016 Paul Hsieh
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************
 *
 *  Version 0.1.15.4
 *
 *  The ANSI C standard committee, for the C99 standard, specified the
 *  inclusion of a new standard include file called stdint.h.  This is
 *  a very useful and long desired include file which contains several
 *  very precise definitions for integer scalar types that is
 *  critically important for making portable several classes of
 *  applications including cryptography, hashing, variable length
 *  integer libraries and so on.  But for most developers its likely
 *  useful just for programming sanity.
 *
 *  The problem is that some compiler vendors chose to ignore the C99
 *  standard and some older compilers have no opportunity to be updated.
 *  Because of this situation, simply including stdint.h in your code
 *  makes it unportable.
 *
 *  So that's what this file is all about.  Its an attempt to build a
 *  single universal include file that works on as many platforms as
 *  possible to deliver what stdint.h is supposed to.  Even compilers
 *  that already come with stdint.h can use this file instead without
 *  any loss of functionality.  A few things that should be noted about
 *  this file:
 *
 *    1) It is not guaranteed to be portable and/or present an identical
 *       interface on all platforms.  The extreme variability of the
 *       ANSI C standard makes this an impossibility right from the
 *       very get go. Its really only meant to be useful for the vast
 *       majority of platforms that possess the capability of
 *       implementing usefully and precisely defined, standard sized
 *       integer scalars.  Systems which are not intrinsically 2s
 *       complement may produce invalid constants.
 *
 *    2) There is an unavoidable use of non-reserved symbols.
 *
 *    3) Other standard include files are invoked.
 *
 *    4) This file may come in conflict with future platforms that do
 *       include stdint.h.  The hope is that one or the other can be
 *       used with no real difference.
 *
 *    5) In the current version, if your platform can't represent
 *       int32_t, int16_t and int8_t, it just dumps out with a compiler
 *       error.
 *
 *    6) 64 bit integers may or may not be defined.  Test for their
 *       presence with the test: #ifdef INT64_MAX or #ifdef UINT64_MAX.
 *       Note that this is different from the C99 specification which
 *       requires the existence of 64 bit support in the compiler.  If
 *       this is not defined for your platform, yet it is capable of
 *       dealing with 64 bits then it is because this file has not yet
 *       been extended to cover all of your system's capabilities.
 *
 *    7) (u)intptr_t may or may not be defined.  Test for its presence
 *       with the test: #ifdef PTRDIFF_MAX.  If this is not defined
 *       for your platform, then it is because this file has not yet
 *       been extended to cover all of your system's capabilities, not
 *       because its optional.
 *
 *    8) The following might not been defined even if your platform is
 *       capable of defining it:
 *
 *       WCHAR_MIN
 *       WCHAR_MAX
 *       (u)int64_t
 *       PTRDIFF_MIN
 *       PTRDIFF_MAX
 *       (u)intptr_t
 *
 *    9) The following have not been defined:
 *
 *       WINT_MIN
 *       WINT_MAX
 *
 *   10) The criteria for defining (u)int_least(*)_t isn't clear,
 *       except for systems which don't have a type that precisely
 *       defined 8, 16, or 32 bit types (which this include file does
 *       not support anyways). Default definitions have been given.
 *
 *   11) The criteria for defining (u)int_fast(*)_t isn't something I
 *       would trust to any particular compiler vendor or the ANSI C
 *       committee.  It is well known that "compatible systems" are
 *       commonly created that have very different performance
 *       characteristics from the systems they are compatible with,
 *       especially those whose vendors make both the compiler and the
 *       system.  Default definitions have been given, but its strongly
 *       recommended that users never use these definitions for any
 *       reason (they do *NOT* deliver any serious guarantee of
 *       improved performance -- not in this file, nor any vendor's
 *       stdint.h).
 *
 *   12) The following macros:
 *
 *       PRINTF_INTMAX_MODIFIER
 *       PRINTF_INT64_MODIFIER
 *       PRINTF_INT32_MODIFIER
 *       PRINTF_INT16_MODIFIER
 *       PRINTF_LEAST64_MODIFIER
 *       PRINTF_LEAST32_MODIFIER
 *       PRINTF_LEAST16_MODIFIER
 *       PRINTF_INTPTR_MODIFIER
 *
 *       are strings which have been defined as the modifiers required
 *       for the "d", "u" and "x" printf formats to correctly output
 *       (u)intmax_t, (u)int64_t, (u)int32_t, (u)int16_t, (u)least64_t,
 *       (u)least32_t, (u)least16_t and (u)intptr_t types respectively.
 *       PRINTF_INTPTR_MODIFIER is not defined for some systems which
 *       provide their own stdint.h.  PRINTF_INT64_MODIFIER is not
 *       defined if INT64_MAX is not defined.  These are an extension
 *       beyond what C99 specifies must be in stdint.h.
 *
 *       In addition, the following macros are defined:
 *
 *       PRINTF_INTMAX_HEX_WIDTH
 *       PRINTF_INT64_HEX_WIDTH
 *       PRINTF_INT32_HEX_WIDTH
 *       PRINTF_INT16_HEX_WIDTH
 *       PRINTF_INT8_HEX_WIDTH
 *       PRINTF_INTMAX_DEC_WIDTH
 *       PRINTF_INT64_DEC_WIDTH
 *       PRINTF_INT32_DEC_WIDTH
 *       PRINTF_INT16_DEC_WIDTH
 *       PRINTF_UINT8_DEC_WIDTH
 *       PRINTF_UINTMAX_DEC_WIDTH
 *       PRINTF_UINT64_DEC_WIDTH
 *       PRINTF_UINT32_DEC_WIDTH
 *       PRINTF_UINT16_DEC_WIDTH
 *       PRINTF_UINT8_DEC_WIDTH
 *
 *       Which specifies the maximum number of characters required to
 *       print the number of that type in either hexadecimal or decimal.
 *       These are an extension beyond what C99 specifies must be in
 *       stdint.h.
 *
 *  Compilers tested (all with 0 warnings at their highest respective
 *  settings): Borland Turbo C 2.0, WATCOM C/C++ 11.0 (16 bits and 32
 *  bits), Microsoft Visual C++ 6.0 (32 bit), Microsoft Visual Studio
 *  .net (VC7), Intel C++ 4.0, GNU gcc v3.3.3
 *
 *  This file should be considered a work in progress.  Suggestions for
 *  improvements, especially those which increase coverage are strongly
 *  encouraged.
 *
 *  Acknowledgements
 *
 *  The following people have made significant contributions to the
 *  development and testing of this file:
 *
 *  Chris Howie
 *  John Steele Scott
 *  Dave Thorup
 *  John Dill
 *  Florian Wobbe
 *  Christopher Sean Morrison
 *  Mikkel Fahnoe Jorgensen
 *
 */

#include <stddef.h>
#include <limits.h>
#include <signal.h>

/*
 *  For gcc with _STDINT_H, fill in the PRINTF_INT*_MODIFIER macros, and
 *  do nothing else.  On the Mac OS X version of gcc this is _STDINT_H_.
 */

#if ((defined(__SUNPRO_C) && __SUNPRO_C >= 0x570) || (defined(_MSC_VER) && _MSC_VER >= 1600) || (defined(__STDC__) && __STDC__ && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || (defined (__WATCOMC__) && (defined (_STDINT_H_INCLUDED) || __WATCOMC__ >= 1250)) || (defined(__GNUC__) && (__GNUC__ > 3 || defined(_STDINT_H) || defined(_STDINT_H_) || defined (__UINT_FAST64_TYPE__)) )) && !defined (_PSTDINT_H_INCLUDED)
#include <stdint.h>
#define _PSTDINT_H_INCLUDED
# if defined(__GNUC__) && (defined(__x86_64__) || defined(__ppc64__)) && !(defined(__APPLE__) && defined(__MACH__))
#  ifndef PRINTF_INT64_MODIFIER
#   define PRINTF_INT64_MODIFIER "l"
#  endif
#  ifndef PRINTF_INT32_MODIFIER
#   define PRINTF_INT32_MODIFIER ""
#  endif
# else
#  ifndef PRINTF_INT64_MODIFIER
#   define PRINTF_INT64_MODIFIER "ll"
#  endif
#  ifndef PRINTF_INT32_MODIFIER
#   if (UINT_MAX == UINT32_MAX)
#    define PRINTF_INT32_MODIFIER ""
#   else
#    define PRINTF_INT32_MODIFIER "l"
#   endif
#  endif
# endif
# ifndef PRINTF_INT16_MODIFIER
#  define PRINTF_INT16_MODIFIER "h"
# endif
# ifndef PRINTF_INTMAX_MODIFIER
#  define PRINTF_INTMAX_MODIFIER PRINTF_INT64_MODIFIER
# endif
# ifndef PRINTF_INT64_HEX_WIDTH
#  define PRINTF_INT64_HEX_WIDTH "16"
# endif
# ifndef PRINTF_UINT64_HEX_WIDTH
#  define PRINTF_UINT64_HEX_WIDTH "16"
# endif
# ifndef PRINTF_INT32_HEX_WIDTH
#  define PRINTF_INT32_HEX_WIDTH "8"
# endif
# ifndef PRINTF_UINT32_HEX_WIDTH
#  define PRINTF_UINT32_HEX_WIDTH "8"
# endif
# ifndef PRINTF_INT16_HEX_WIDTH
#  define PRINTF_INT16_HEX_WIDTH "4"
# endif
# ifndef PRINTF_UINT16_HEX_WIDTH
#  define PRINTF_UINT16_HEX_WIDTH "4"
# endif
# ifndef PRINTF_INT8_HEX_WIDTH
#  define PRINTF_INT8_HEX_WIDTH "2"
# endif
# ifndef PRINTF_UINT8_HEX_WIDTH
#  define PRINTF_UINT8_HEX_WIDTH "2"
# endif
# ifndef PRINTF_INT64_DEC_WIDTH
#  define PRINTF_INT64_DEC_WIDTH "19"
# endif
# ifndef PRINTF_UINT64_DEC_WIDTH
#  define PRINTF_UINT64_DEC_WIDTH "20"
# endif
# ifndef PRINTF_INT32_DEC_WIDTH
#  define PRINTF_INT32_DEC_WIDTH "10"
# endif
# ifndef PRINTF_UINT32_DEC_WIDTH
#  define PRINTF_UINT32_DEC_WIDTH "10"
# endif
# ifndef PRINTF_INT16_DEC_WIDTH
#  define PRINTF_INT16_DEC_WIDTH "5"
# endif
# ifndef PRINTF_UINT16_DEC_WIDTH
#  define PRINTF_UINT16_DEC_WIDTH "5"
# endif
# ifndef PRINTF_INT8_DEC_WIDTH
#  define PRINTF_INT8_DEC_WIDTH "3"
# endif
# ifndef PRINTF_UINT8_DEC_WIDTH
#  define PRINTF_UINT8_DEC_WIDTH "3"
# endif
# ifndef PRINTF_INTMAX_HEX_WIDTH
#  define PRINTF_INTMAX_HEX_WIDTH PRINTF_UINT64_HEX_WIDTH
# endif
# ifndef PRINTF_UINTMAX_HEX_WIDTH
#  define PRINTF_UINTMAX_HEX_WIDTH PRINTF_UINT64_HEX_WIDTH
# endif
# ifndef PRINTF_INTMAX_DEC_WIDTH
#  define PRINTF_INTMAX_DEC_WIDTH PRINTF_UINT64_DEC_WIDTH
# endif
# ifndef PRINTF_UINTMAX_DEC_WIDTH
#  define PRINTF_UINTMAX_DEC_WIDTH PRINTF_UINT64_DEC_WIDTH
# endif

/*
 *  Something really weird is going on with Open Watcom.  Just pull some of
 *  these duplicated definitions from Open Watcom's stdint.h file for now.
 */

# if defined (__WATCOMC__) && __WATCOMC__ >= 1250
#  if !defined (INT64_C)
#   define INT64_C(x)   (x + (INT64_MAX - INT64_MAX))
#  endif
#  if !defined (UINT64_C)
#   define UINT64_C(x)  (x + (UINT64_MAX - UINT64_MAX))
#  endif
#  if !defined (INT32_C)
#   define INT32_C(x)   (x + (INT32_MAX - INT32_MAX))
#  endif
#  if !defined (UINT32_C)
#   define UINT32_C(x)  (x + (UINT32_MAX - UINT32_MAX))
#  endif
#  if !defined (INT16_C)
#   define INT16_C(x)   (x)
#  endif
#  if !defined (UINT16_C)
#   define UINT16_C(x)  (x)
#  endif
#  if !defined (INT8_C)
#   define INT8_C(x)   (x)
#  endif
#  if !defined (UINT8_C)
#   define UINT8_C(x)  (x)
#  endif
#  if !defined (UINT64_MAX)
#   define UINT64_MAX  18446744073709551615ULL
#  endif
#  if !defined (INT64_MAX)
#   define INT64_MAX  9223372036854775807LL
#  endif
#  if !defined (UINT32_MAX)
#   define UINT32_MAX  4294967295UL
#  endif
#  if !defined (INT32_MAX)
#   define INT32_MAX  2147483647L
#  endif
#  if !defined (INTMAX_MAX)
#   define INTMAX_MAX INT64_MAX
#  endif
#  if !defined (INTMAX_MIN)
#   define INTMAX_MIN INT64_MIN
#  endif
# endif
#endif

/*
 *  I have no idea what is the truly correct thing to do on older Solaris.
 *  From some online discussions, this seems to be what is being
 *  recommended.  For people who actually are developing on older Solaris,
 *  what I would like to know is, does this define all of the relevant
 *  macros of a complete stdint.h?  Remember, in pstdint.h 64 bit is
 *  considered optional.
 */

#if (defined(__SUNPRO_C) && __SUNPRO_C >= 0x420) && !defined(_PSTDINT_H_INCLUDED)
#include <sys/inttypes.h>
#define _PSTDINT_H_INCLUDED
#endif

#ifndef _PSTDINT_H_INCLUDED
#define _PSTDINT_H_INCLUDED

#ifndef SIZE_MAX
# define SIZE_MAX (~(size_t)0)
#endif

/*
 *  Deduce the type assignments from limits.h under the assumption that
 *  integer sizes in bits are powers of 2, and follow the ANSI
 *  definitions.
 */

#ifndef UINT8_MAX
# define UINT8_MAX 0xff
#endif
#if !defined(uint8_t) && !defined(_UINT8_T) && !defined(vxWorks)
# if (UCHAR_MAX == UINT8_MAX) || defined (S_SPLINT_S)
    typedef unsigned char uint8_t;
#   define UINT8_C(v) ((uint8_t) v)
# else
#   error "Platform not supported"
# endif
#endif

#ifndef INT8_MAX
# define INT8_MAX 0x7f
#endif
#ifndef INT8_MIN
# define INT8_MIN INT8_C(0x80)
#endif
#if !defined(int8_t) && !defined(_INT8_T) && !defined(vxWorks)
# if (SCHAR_MAX == INT8_MAX) || defined (S_SPLINT_S)
    typedef signed char int8_t;
#   define INT8_C(v) ((int8_t) v)
# else
#   error "Platform not supported"
# endif
#endif

#ifndef UINT16_MAX
# define UINT16_MAX 0xffff
#endif
#if !defined(uint16_t) && !defined(_UINT16_T) && !defined(vxWorks)
#if (UINT_MAX == UINT16_MAX) || defined (S_SPLINT_S)
  typedef unsigned int uint16_t;
# ifndef PRINTF_INT16_MODIFIER
#  define PRINTF_INT16_MODIFIER ""
# endif
# define UINT16_C(v) ((uint16_t) (v))
#elif (USHRT_MAX == UINT16_MAX)
  typedef unsigned short uint16_t;
# define UINT16_C(v) ((uint16_t) (v))
# ifndef PRINTF_INT16_MODIFIER
#  define PRINTF_INT16_MODIFIER "h"
# endif
#else
#error "Platform not supported"
#endif
#endif

#ifndef INT16_MAX
# define INT16_MAX 0x7fff
#endif
#ifndef INT16_MIN
# define INT16_MIN INT16_C(0x8000)
#endif
#if !defined(int16_t) && !defined(_INT16_T) && !defined(vxWorks)
#if (INT_MAX == INT16_MAX) || defined (S_SPLINT_S)
  typedef signed int int16_t;
# define INT16_C(v) ((int16_t) (v))
# ifndef PRINTF_INT16_MODIFIER
#  define PRINTF_INT16_MODIFIER ""
# endif
#elif (SHRT_MAX == INT16_MAX)
  typedef signed short int16_t;
# define INT16_C(v) ((int16_t) (v))
# ifndef PRINTF_INT16_MODIFIER
#  define PRINTF_INT16_MODIFIER "h"
# endif
#else
#error "Platform not supported"
#endif
#endif

#ifndef UINT32_MAX
# define UINT32_MAX (0xffffffffUL)
#endif
#if !defined(uint32_t) && !defined(_UINT32_T) && !defined(vxWorks)
#if (ULONG_MAX == UINT32_MAX) || defined (S_SPLINT_S)
  typedef unsigned long uint32_t;
# define UINT32_C(v) v ## UL
# ifndef PRINTF_INT32_MODIFIER
#  define PRINTF_INT32_MODIFIER "l"
# endif
#elif (UINT_MAX == UINT32_MAX)
  typedef unsigned int uint32_t;
# ifndef PRINTF_INT32_MODIFIER
#  define PRINTF_INT32_MODIFIER ""
# endif
# define UINT32_C(v) v ## U
#elif (USHRT_MAX == UINT32_MAX)
  typedef unsigned short uint32_t;
# define UINT32_C(v) ((unsigned short) (v))
# ifndef PRINTF_INT32_MODIFIER
#  define PRINTF_INT32_MODIFIER ""
# endif
#else
#error "Platform not supported"
#endif
#endif

#ifndef INT32_MAX
# define INT32_MAX (0x7fffffffL)
#endif
#ifndef INT32_MIN
# define INT32_MIN INT32_C(0x80000000)
#endif
#if !defined(int32_t) && !defined(_INT32_T) && !defined(vxWorks)
#if (LONG_MAX == INT32_MAX) || defined (S_SPLINT_S)
  typedef signed long int32_t;
# define INT32_C(v) v ## L
# ifndef PRINTF_INT32_MODIFIER
#  define PRINTF_INT32_MODIFIER "l"
# endif
#elif (INT_MAX == INT32_MAX)
  typedef signed int int32_t;
# define INT32_C(v) v
# ifndef PRINTF_INT32_MODIFIER
#  define PRINTF_INT32_MODIFIER ""
# endif
#elif (SHRT_MAX == INT32_MAX)
  typedef signed short int32_t;
# define INT32_C(v) ((short) (v))
# ifndef PRINTF_INT32_MODIFIER
#  define PRINTF_INT32_MODIFIER ""
# endif
#else
#error "Platform not supported"
#endif
#endif

/*
 *  The macro stdint_int64_defined is temporarily used to record
 *  whether or not 64 integer support is available.  It must be
 *  defined for any 64 integer extensions for new platforms that are
 *  added.
 */

#undef stdint_int64_defined
#if (defined(__STDC__) && defined(__STDC_VERSION__)) || defined (S_SPLINT_S)
# if (__STDC__ && __STDC_VERSION__ >= 199901L) || defined (S_SPLINT_S)
#  define stdint_int64_defined
   typedef long long int64_t;
   typedef unsigned long long uint64_t;
#  define UINT64_C(v) v ## ULL
#  define  INT64_C(v) v ## LL
#  ifndef PRINTF_INT64_MODIFIER
#   define PRINTF_INT64_MODIFIER "ll"
#  endif
# endif
#endif

#if !defined (stdint_int64_defined)
# if defined(__GNUC__) && !defined(vxWorks)
#  define stdint_int64_defined
   __extension__ typedef long long int64_t;
   __extension__ typedef unsigned long long uint64_t;
#  define UINT64_C(v) v ## ULL
#  define  INT64_C(v) v ## LL
#  ifndef PRINTF_INT64_MODIFIER
#   define PRINTF_INT64_MODIFIER "ll"
#  endif
# elif defined(__MWERKS__) || defined (__SUNPRO_C) || defined (__SUNPRO_CC) || defined (__APPLE_CC__) || defined (_LONG_LONG) || defined (_CRAYC) || defined (S_SPLINT_S)
#  define stdint_int64_defined
   typedef long long int64_t;
   typedef unsigned long long uint64_t;
#  define UINT64_C(v) v ## ULL
#  define  INT64_C(v) v ## LL
#  ifndef PRINTF_INT64_MODIFIER
#   define PRINTF_INT64_MODIFIER "ll"
#  endif
# elif (defined(__WATCOMC__) && defined(__WATCOM_INT64__)) || (defined(_MSC_VER) && _INTEGRAL_MAX_BITS >= 64) || (defined (__BORLANDC__) && __BORLANDC__ > 0x460) || defined (__alpha) || defined (__DECC)
#  define stdint_int64_defined
   typedef __int64 int64_t;
   typedef unsigned __int64 uint64_t;
#  define UINT64_C(v) v ## UI64
#  define  INT64_C(v) v ## I64
#  ifndef PRINTF_INT64_MODIFIER
#   define PRINTF_INT64_MODIFIER "I64"
#  endif
# endif
#endif

#if !defined (LONG_LONG_MAX) && defined (INT64_C)
# define LONG_LONG_MAX INT64_C (9223372036854775807)
#endif
#ifndef ULONG_LONG_MAX
# define ULONG_LONG_MAX UINT64_C (18446744073709551615)
#endif

#if !defined (INT64_MAX) && defined (INT64_C)
# define INT64_MAX INT64_C (9223372036854775807)
#endif
#if !defined (INT64_MIN) && defined (INT64_C)
# define INT64_MIN INT64_C (-9223372036854775808)
#endif
#if !defined (UINT64_MAX) && defined (INT64_C)
# define UINT64_MAX UINT64_C (18446744073709551615)
#endif

/*
 *  Width of hexadecimal for number field.
 */

#ifndef PRINTF_INT64_HEX_WIDTH
# define PRINTF_INT64_HEX_WIDTH "16"
#endif
#ifndef PRINTF_INT32_HEX_WIDTH
# define PRINTF_INT32_HEX_WIDTH "8"
#endif
#ifndef PRINTF_INT16_HEX_WIDTH
# define PRINTF_INT16_HEX_WIDTH "4"
#endif
#ifndef PRINTF_INT8_HEX_WIDTH
# define PRINTF_INT8_HEX_WIDTH "2"
#endif
#ifndef PRINTF_INT64_DEC_WIDTH
# define PRINTF_INT64_DEC_WIDTH "19"
#endif
#ifndef PRINTF_INT32_DEC_WIDTH
# define PRINTF_INT32_DEC_WIDTH "10"
#endif
#ifndef PRINTF_INT16_DEC_WIDTH
# define PRINTF_INT16_DEC_WIDTH "5"
#endif
#ifndef PRINTF_INT8_DEC_WIDTH
# define PRINTF_INT8_DEC_WIDTH "3"
#endif
#ifndef PRINTF_UINT64_DEC_WIDTH
# define PRINTF_UINT64_DEC_WIDTH "20"
#endif
#ifndef PRINTF_UINT32_DEC_WIDTH
# define PRINTF_UINT32_DEC_WIDTH "10"
#endif
#ifndef PRINTF_UINT16_DEC_WIDTH
# define PRINTF_UINT16_DEC_WIDTH "5"
#endif
#ifndef PRINTF_UINT8_DEC_WIDTH
# define PRINTF_UINT8_DEC_WIDTH "3"
#endif

/*
 *  Ok, lets not worry about 128 bit integers for now.  Moore's law says
 *  we don't need to worry about that until about 2040 at which point
 *  we'll have bigger things to worry about.
 */

#ifdef stdint_int64_defined
  typedef int64_t intmax_t;
  typedef uint64_t uintmax_t;
# define  INTMAX_MAX   INT64_MAX
# define  INTMAX_MIN   INT64_MIN
# define UINTMAX_MAX  UINT64_MAX
# define UINTMAX_C(v) UINT64_C(v)
# define  INTMAX_C(v)  INT64_C(v)
# ifndef PRINTF_INTMAX_MODIFIER
#   define PRINTF_INTMAX_MODIFIER PRINTF_INT64_MODIFIER
# endif
# ifndef PRINTF_INTMAX_HEX_WIDTH
#  define PRINTF_INTMAX_HEX_WIDTH PRINTF_INT64_HEX_WIDTH
# endif
# ifndef PRINTF_INTMAX_DEC_WIDTH
#  define PRINTF_INTMAX_DEC_WIDTH PRINTF_INT64_DEC_WIDTH
# endif
#else
  typedef int32_t intmax_t;
  typedef uint32_t uintmax_t;
# define  INTMAX_MAX   INT32_MAX
# define UINTMAX_MAX  UINT32_MAX
# define UINTMAX_C(v) UINT32_C(v)
# define  INTMAX_C(v)  INT32_C(v)
# ifndef PRINTF_INTMAX_MODIFIER
#   define PRINTF_INTMAX_MODIFIER PRINTF_INT32_MODIFIER
# endif
# ifndef PRINTF_INTMAX_HEX_WIDTH
#  define PRINTF_INTMAX_HEX_WIDTH PRINTF_INT32_HEX_WIDTH
# endif
# ifndef PRINTF_INTMAX_DEC_WIDTH
#  define PRINTF_INTMAX_DEC_WIDTH PRINTF_INT32_DEC_WIDTH
# endif
#endif

/*
 *  Because this file currently only supports platforms which have
 *  precise powers of 2 as bit sizes for the default integers, the
 *  least definitions are all trivial.  Its possible that a future
 *  version of this file could have different definitions.
 */

#ifndef stdint_least_defined
  typedef   int8_t   int_least8_t;
  typedef  uint8_t  uint_least8_t;
  typedef  int16_t  int_least16_t;
  typedef uint16_t uint_least16_t;
  typedef  int32_t  int_least32_t;
  typedef uint32_t uint_least32_t;
# define PRINTF_LEAST32_MODIFIER PRINTF_INT32_MODIFIER
# define PRINTF_LEAST16_MODIFIER PRINTF_INT16_MODIFIER
# define  UINT_LEAST8_MAX  UINT8_MAX
# define   INT_LEAST8_MAX   INT8_MAX
# define UINT_LEAST16_MAX UINT16_MAX
# define  INT_LEAST16_MAX  INT16_MAX
# define UINT_LEAST32_MAX UINT32_MAX
# define  INT_LEAST32_MAX  INT32_MAX
# define   INT_LEAST8_MIN   INT8_MIN
# define  INT_LEAST16_MIN  INT16_MIN
# define  INT_LEAST32_MIN  INT32_MIN
# ifdef stdint_int64_defined
    typedef  int64_t  int_least64_t;
    typedef uint64_t uint_least64_t;
#   define PRINTF_LEAST64_MODIFIER PRINTF_INT64_MODIFIER
#   define UINT_LEAST64_MAX UINT64_MAX
#   define  INT_LEAST64_MAX  INT64_MAX
#   define  INT_LEAST64_MIN  INT64_MIN
# endif
#endif
#undef stdint_least_defined

/*
 *  The ANSI C committee pretending to know or specify anything about
 *  performance is the epitome of misguided arrogance.  The mandate of
 *  this file is to *ONLY* ever support that absolute minimum
 *  definition of the fast integer types, for compatibility purposes.
 *  No extensions, and no attempt to suggest what may or may not be a
 *  faster integer type will ever be made in this file.  Developers are
 *  warned to stay away from these types when using this or any other
 *  stdint.h.
 */

typedef   int_least8_t   int_fast8_t;
typedef  uint_least8_t  uint_fast8_t;
typedef  int_least16_t  int_fast16_t;
typedef uint_least16_t uint_fast16_t;
typedef  int_least32_t  int_fast32_t;
typedef uint_least32_t uint_fast32_t;
#define  UINT_FAST8_MAX  UINT_LEAST8_MAX
#define   INT_FAST8_MAX   INT_LEAST8_MAX
#define UINT_FAST16_MAX UINT_LEAST16_MAX
#define  INT_FAST16_MAX  INT_LEAST16_MAX
#define UINT_FAST32_MAX UINT_LEAST32_MAX
#define  INT_FAST32_MAX  INT_LEAST32_MAX
#define   INT_FAST8_MIN   INT_LEAST8_MIN
#define  INT_FAST16_MIN  INT_LEAST16_MIN
#define  INT_FAST32_MIN  INT_LEAST32_MIN
#ifdef stdint_int64_defined
  typedef  int_least64_t  int_fast64_t;
  typedef uint_least64_t uint_fast64_t;
# define UINT_FAST64_MAX UINT_LEAST64_MAX
# define  INT_FAST64_MAX  INT_LEAST64_MAX
# define  INT_FAST64_MIN  INT_LEAST64_MIN
#endif

#undef stdint_int64_defined

/*
 *  Whatever piecemeal, per compiler thing we can do about the wchar_t
 *  type limits.
 */

#if defined(__WATCOMC__) || defined(_MSC_VER) || defined (__GNUC__) && !defined(vxWorks)
# include <wchar.h>
# ifndef WCHAR_MIN
#  define WCHAR_MIN 0
# endif
# ifndef WCHAR_MAX
#  define WCHAR_MAX ((wchar_t)-1)
# endif
#endif

/*
 *  Whatever piecemeal, per compiler/platform thing we can do about the
 *  (u)intptr_t types and limits.
 */

#if (defined (_MSC_VER) && defined (_UINTPTR_T_DEFINED)) || defined (_UINTPTR_T)
# define STDINT_H_UINTPTR_T_DEFINED
#endif

#ifndef STDINT_H_UINTPTR_T_DEFINED
# if defined (__alpha__) || defined (__ia64__) || defined (__x86_64__) || defined (_WIN64) || defined (__ppc64__)
#  define stdint_intptr_bits 64
# elif defined (__WATCOMC__) || defined (__TURBOC__)
#  if defined(__TINY__) || defined(__SMALL__) || defined(__MEDIUM__)
#    define stdint_intptr_bits 16
#  else
#    define stdint_intptr_bits 32
#  endif
# elif defined (__i386__) || defined (_WIN32) || defined (WIN32) || defined (__ppc64__)
#  define stdint_intptr_bits 32
# elif defined (__INTEL_COMPILER)
/* TODO -- what did Intel do about x86-64? */
# else
/* #error "This platform might not be supported yet" */
# endif

# ifdef stdint_intptr_bits
#  define stdint_intptr_glue3_i(a,b,c)  a##b##c
#  define stdint_intptr_glue3(a,b,c)    stdint_intptr_glue3_i(a,b,c)
#  ifndef PRINTF_INTPTR_MODIFIER
#    define PRINTF_INTPTR_MODIFIER      stdint_intptr_glue3(PRINTF_INT,stdint_intptr_bits,_MODIFIER)
#  endif
#  ifndef PTRDIFF_MAX
#    define PTRDIFF_MAX                 stdint_intptr_glue3(INT,stdint_intptr_bits,_MAX)
#  endif
#  ifndef PTRDIFF_MIN
#    define PTRDIFF_MIN                 stdint_intptr_glue3(INT,stdint_intptr_bits,_MIN)
#  endif
#  ifndef UINTPTR_MAX
#    define UINTPTR_MAX                 stdint_intptr_glue3(UINT,stdint_intptr_bits,_MAX)
#  endif
#  ifndef INTPTR_MAX
#    define INTPTR_MAX                  stdint_intptr_glue3(INT,stdint_intptr_bits,_MAX)
#  endif
#  ifndef INTPTR_MIN
#    define INTPTR_MIN                  stdint_intptr_glue3(INT,stdint_intptr_bits,_MIN)
#  endif
#  ifndef INTPTR_C
#    define INTPTR_C(x)                 stdint_intptr_glue3(INT,stdint_intptr_bits,_C)(x)
#  endif
#  ifndef UINTPTR_C
#    define UINTPTR_C(x)                stdint_intptr_glue3(UINT,stdint_intptr_bits,_C)(x)
#  endif
  typedef stdint_intptr_glue3(uint,stdint_intptr_bits,_t) uintptr_t;
  typedef stdint_intptr_glue3( int,stdint_intptr_bits,_t)  intptr_t;
# else
/* TODO -- This following is likely wrong for some platforms, and does
   nothing for the definition of uintptr_t. */
  typedef ptrdiff_t intptr_t;
# endif
# define STDINT_H_UINTPTR_T_DEFINED
#endif

/*
 *  Assumes sig_atomic_t is signed and we have a 2s complement machine.
 */

#ifndef SIG_ATOMIC_MAX
# define SIG_ATOMIC_MAX ((((sig_atomic_t) 1) << (sizeof (sig_atomic_t)*CHAR_BIT-1)) - 1)
#endif

#endif

#if defined (__TEST_PSTDINT_FOR_CORRECTNESS)

/*
 *  Please compile with the maximum warning settings to make sure macros are
 *  not defined more than once.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define glue3_aux(x,y,z) x ## y ## z
#define glue3(x,y,z) glue3_aux(x,y,z)

#define DECLU(bits) glue3(uint,bits,_t) glue3(u,bits,) = glue3(UINT,bits,_C) (0);
#define DECLI(bits) glue3(int,bits,_t) glue3(i,bits,) = glue3(INT,bits,_C) (0);

#define DECL(us,bits) glue3(DECL,us,) (bits)

#define TESTUMAX(bits) glue3(u,bits,) = ~glue3(u,bits,); if (glue3(UINT,bits,_MAX) != glue3(u,bits,)) printf ("Something wrong with UINT%d_MAX\n", bits)

#define REPORTERROR(msg) { err_n++; if (err_first <= 0) err_first = __LINE__; printf msg; }

int main () {
	int err_n = 0;
	int err_first = 0;
	DECL(I,8)
	DECL(U,8)
	DECL(I,16)
	DECL(U,16)
	DECL(I,32)
	DECL(U,32)
#ifdef INT64_MAX
	DECL(I,64)
	DECL(U,64)
#endif
	intmax_t imax = INTMAX_C(0);
	uintmax_t umax = UINTMAX_C(0);
	char str0[256], str1[256];

	sprintf (str0, "%" PRINTF_INT32_MODIFIER "d", INT32_C(2147483647));
	if (0 != strcmp (str0, "2147483647")) REPORTERROR (("Something wrong with PRINTF_INT32_MODIFIER : %s\n", str0));
	if (atoi(PRINTF_INT32_DEC_WIDTH) != (int) strlen(str0)) REPORTERROR (("Something wrong with PRINTF_INT32_DEC_WIDTH : %s\n", PRINTF_INT32_DEC_WIDTH));
	sprintf (str0, "%" PRINTF_INT32_MODIFIER "u", UINT32_C(4294967295));
	if (0 != strcmp (str0, "4294967295")) REPORTERROR (("Something wrong with PRINTF_INT32_MODIFIER : %s\n", str0));
	if (atoi(PRINTF_UINT32_DEC_WIDTH) != (int) strlen(str0)) REPORTERROR (("Something wrong with PRINTF_UINT32_DEC_WIDTH : %s\n", PRINTF_UINT32_DEC_WIDTH));
#ifdef INT64_MAX
	sprintf (str1, "%" PRINTF_INT64_MODIFIER "d", INT64_C(9223372036854775807));
	if (0 != strcmp (str1, "9223372036854775807")) REPORTERROR (("Something wrong with PRINTF_INT32_MODIFIER : %s\n", str1));
	if (atoi(PRINTF_INT64_DEC_WIDTH) != (int) strlen(str1)) REPORTERROR (("Something wrong with PRINTF_INT64_DEC_WIDTH : %s, %d\n", PRINTF_INT64_DEC_WIDTH, (int) strlen(str1)));
	sprintf (str1, "%" PRINTF_INT64_MODIFIER "u", UINT64_C(18446744073709550591));
	if (0 != strcmp (str1, "18446744073709550591")) REPORTERROR (("Something wrong with PRINTF_INT32_MODIFIER : %s\n", str1));
	if (atoi(PRINTF_UINT64_DEC_WIDTH) != (int) strlen(str1)) REPORTERROR (("Something wrong with PRINTF_UINT64_DEC_WIDTH : %s, %d\n", PRINTF_UINT64_DEC_WIDTH, (int) strlen(str1)));
#endif

	sprintf (str0, "%d %x\n", 0, ~0);

	sprintf (str1, "%d %x\n",  i8, ~0);
	if (0 != strcmp (str0, str1)) REPORTERROR (("Something wrong with i8 : %s\n", str1));
	sprintf (str1, "%u %x\n",  u8, ~0);
	if (0 != strcmp (str0, str1)) REPORTERROR (("Something wrong with u8 : %s\n", str1));
	sprintf (str1, "%d %x\n",  i16, ~0);
	if (0 != strcmp (str0, str1)) REPORTERROR (("Something wrong with i16 : %s\n", str1));
	sprintf (str1, "%u %x\n",  u16, ~0);
	if (0 != strcmp (str0, str1)) REPORTERROR (("Something wrong with u16 : %s\n", str1));
	sprintf (str1, "%" PRINTF_INT32_MODIFIER "d %x\n",  i32, ~0);
	if (0 != strcmp (str0, str1)) REPORTERROR (("Something wrong with i32 : %s\n", str1));
	sprintf (str1, "%" PRINTF_INT32_MODIFIER "u %x\n",  u32, ~0);
	if (0 != strcmp (str0, str1)) REPORTERROR (("Something wrong with u32 : %s\n", str1));
#ifdef INT64_MAX
	sprintf (str1, "%" PRINTF_INT64_MODIFIER "d %x\n",  i64, ~0);
	if (0 != strcmp (str0, str1)) REPORTERROR (("Something wrong with i64 : %s\n", str1));
#endif
	sprintf (str1, "%" PRINTF_INTMAX_MODIFIER "d %x\n",  imax, ~0);
	if (0 != strcmp (str0, str1)) REPORTERROR (("Something wrong with imax : %s\n", str1));
	sprintf (str1, "%" PRINTF_INTMAX_MODIFIER "u %x\n",  umax, ~0);
	if (0 != strcmp (str0, str1)) REPORTERROR (("Something wrong with umax : %s\n", str1));

	TESTUMAX(8);
	TESTUMAX(16);
	TESTUMAX(32);
#ifdef INT64_MAX
	TESTUMAX(64);
#endif

#define STR(v) #v
#define Q(v) printf ("sizeof " STR(v) " = %u\n", (unsigned) sizeof (v));
	if (err_n) {
		printf ("pstdint.h is not correct.  Please use sizes below to correct it:\n");
	}

	Q(int)
	Q(unsigned)
	Q(long int)
	Q(short int)
	Q(int8_t)
	Q(int16_t)
	Q(int32_t)
#ifdef INT64_MAX
	Q(int64_t)
#endif

	return EXIT_SUCCESS;
}

#endif


============================================================
File Path: project/externals/assimp/include/assimp/Compiler/pushpack1.h
============================================================


// ===============================================================================
// May be included multiple times - sets structure packing to 1
// for all supported compilers. #include <poppack1.h> reverts the changes.
//
// Currently this works on the following compilers:
// MSVC 7,8,9
// GCC
// BORLAND (complains about 'pack state changed but not reverted', but works)
// Clang
//
//
// USAGE:
//
// struct StructToBePacked {
// } PACK_STRUCT;
//
// ===============================================================================

#ifdef AI_PUSHPACK_IS_DEFINED
#	error poppack1.h must be included after pushpack1.h
#endif

#if (defined(_MSC_VER) && !defined(__clang__)) ||  defined(__BORLANDC__) ||	defined (__BCPLUSPLUS__)
#	pragma pack(push,1)
#	define PACK_STRUCT
#elif defined( __GNUC__ ) || defined(__clang__)
#	if !defined(HOST_MINGW)
#		define PACK_STRUCT	__attribute__((__packed__))
#	else
#		define PACK_STRUCT	__attribute__((gcc_struct, __packed__))
#	endif
#else
#	error Compiler not supported
#endif

#if defined(_MSC_VER)
// C4103: Packing was changed after the inclusion of the header, probably missing #pragma pop
#	pragma warning (disable : 4103)
#endif

#define AI_PUSHPACK_IS_DEFINED


============================================================
File Path: project/externals/assimp/include/assimp/CreateAnimMesh.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file CreateAnimMesh.h
 *  Create AnimMesh from Mesh
 */
#pragma once
#ifndef INCLUDED_AI_CREATE_ANIM_MESH_H
#define INCLUDED_AI_CREATE_ANIM_MESH_H

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/mesh.h>

namespace Assimp {

/**
 *  Create aiAnimMesh from aiMesh.
 *  @param  mesh            The input mesh to create an animated mesh from.
 *  @param  needPositions   If true, positions will be copied from.
 *  @param  needNormals     If true, normals will be copied from.
 *  @param  needTangents    If true, tangents and bitangents will be copied from.
 *  @param  needColors      If true, colors will be copied from.
 *  @param  needTexCoords   If true, texCoords will be copied from.
 *  @return The new created animated mesh.
 */
ASSIMP_API aiAnimMesh *aiCreateAnimMesh(const aiMesh *mesh,
                                        bool needPositions = true,
                                        bool needNormals = true,
                                        bool needTangents = true,
                                        bool needColors = true,
                                        bool needTexCoords = true);

} // end of namespace Assimp

#endif // INCLUDED_AI_CREATE_ANIM_MESH_H



============================================================
File Path: project/externals/assimp/include/assimp/DefaultIOStream.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/**
 *  @file
 *  @brief Default file I/O using fXXX()-family of functions
 */
#pragma once
#ifndef AI_DEFAULTIOSTREAM_H_INC
#define AI_DEFAULTIOSTREAM_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <cstdio>
#include <assimp/IOStream.hpp>
#include <assimp/importerdesc.h>

namespace Assimp {

// ----------------------------------------------------------------------------------
//! @class  DefaultIOStream
//! @brief  Default IO implementation, use standard IO operations
//! @note   An instance of this class can exist without a valid file handle
//!         attached to it. All calls fail, but the instance can nevertheless be
//!         used with no restrictions.
class ASSIMP_API DefaultIOStream : public IOStream {
    friend class DefaultIOSystem;
#if __ANDROID__
# if __ANDROID_API__ > 9
#  if defined(AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT)
    friend class AndroidJNIIOSystem;
#  endif // defined(AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT)
# endif // __ANDROID_API__ > 9
#endif // __ANDROID__

protected:
    /// @brief
    DefaultIOStream() AI_NO_EXCEPT;

    /// @brief The class constructor with the file name and the stream.
    /// @param pFile        The file-streaam
    /// @param strFilename  The file name
    DefaultIOStream(FILE* pFile, const std::string &strFilename);

public:
    /** Destructor public to allow simple deletion to close the file. */
    ~DefaultIOStream () override;

    // -------------------------------------------------------------------
    /// Read from stream
    size_t Read(void* pvBuffer, size_t pSize, size_t pCount) override;

    // -------------------------------------------------------------------
    /// Write to stream
    size_t Write(const void* pvBuffer, size_t pSize, size_t pCount) override;

    // -------------------------------------------------------------------
    /// Seek specific position
    aiReturn Seek(size_t pOffset, aiOrigin pOrigin) override;

    // -------------------------------------------------------------------
    /// Get current seek position
    size_t Tell() const override;

    // -------------------------------------------------------------------
    /// Get size of file
    size_t FileSize() const override;

    // -------------------------------------------------------------------
    /// Flush file contents
    void Flush() override;

private:
    FILE* mFile;
    std::string mFilename;
    mutable size_t mCachedSize;
};

// ----------------------------------------------------------------------------------
AI_FORCE_INLINE DefaultIOStream::DefaultIOStream() AI_NO_EXCEPT :
        mFile(nullptr),
        mFilename(),
        mCachedSize(SIZE_MAX) {
    // empty
}

// ----------------------------------------------------------------------------------
AI_FORCE_INLINE DefaultIOStream::DefaultIOStream (FILE* pFile, const std::string &strFilename) :
        mFile(pFile),
        mFilename(strFilename),
        mCachedSize(SIZE_MAX) {
    // empty
}

// ----------------------------------------------------------------------------------

} // ns assimp

#endif //!!AI_DEFAULTIOSTREAM_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/DefaultIOSystem.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/**
 *  @file Default implementation of IOSystem using the standard C file functions
 */
#pragma once
#ifndef AI_DEFAULTIOSYSTEM_H_INC
#define AI_DEFAULTIOSYSTEM_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/IOSystem.hpp>

namespace Assimp    {

// ---------------------------------------------------------------------------
/** Default implementation of IOSystem using the standard C file functions */
class ASSIMP_API DefaultIOSystem : public IOSystem {
public:
    // -------------------------------------------------------------------
    /** Tests for the existence of a file at the given path. */
    bool Exists( const char* pFile) const override;

    // -------------------------------------------------------------------
    /** Returns the directory separator. */
    char getOsSeparator() const override;

    // -------------------------------------------------------------------
    /** Open a new file with a given path. */
    IOStream* Open( const char* pFile, const char* pMode = "rb") override;

    // -------------------------------------------------------------------
    /** Closes the given file and releases all resources associated with it. */
    void Close( IOStream* pFile) override;

    // -------------------------------------------------------------------
    /** Compare two paths */
    bool ComparePaths (const char* one, const char* second) const override;

    /** @brief get the file name of a full filepath
     * example: /tmp/archive.tar.gz -> archive.tar.gz
     */
    static std::string fileName( const std::string &path );

    /** @brief get the complete base name of a full filepath
     * example: /tmp/archive.tar.gz -> archive.tar
     */
    static std::string completeBaseName( const std::string &path);

    /** @brief get the path of a full filepath
     * example: /tmp/archive.tar.gz -> /tmp/
     */
    static std::string absolutePath( const std::string &path);
};

} //!ns Assimp

#endif //AI_DEFAULTIOSYSTEM_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/DefaultLogger.hpp
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/**
 *  @file DefaultLogger.hpp
 */

#pragma once
#ifndef INCLUDED_AI_DEFAULTLOGGER
#define INCLUDED_AI_DEFAULTLOGGER

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include "LogStream.hpp"
#include "Logger.hpp"
#include "NullLogger.hpp"
#include <vector>

namespace Assimp {
// ------------------------------------------------------------------------------------
class IOStream;
struct LogStreamInfo;

/** default name of log-file */
#define ASSIMP_DEFAULT_LOG_NAME "AssimpLog.txt"

// ------------------------------------------------------------------------------------
/** @brief CPP-API: Primary logging facility of Assimp.
 *
 *  The library stores its primary #Logger as a static member of this class.
 *  #get() returns this primary logger. By default the underlying implementation is
 *  just a #NullLogger which rejects all log messages. By calling #create(), logging
 *  is turned on. To capture the log output multiple log streams (#LogStream) can be
 *  attach to the logger. Some default streams for common streaming locations (such as
 *  a file, std::cout, OutputDebugString()) are also provided.
 *
 *  If you wish to customize the logging at an even deeper level supply your own
 *  implementation of #Logger to #set().
 *  @note The whole logging stuff causes a small extra overhead for all imports. */
class ASSIMP_API DefaultLogger : public Logger {
public:
    // ----------------------------------------------------------------------
    /** @brief Creates a logging instance.
     *  @param name Name for log file. Only valid in combination
     *    with the aiDefaultLogStream_FILE flag.
     *  @param severity Log severity, DEBUG turns on debug messages and VERBOSE turns on all messages.
     *  @param defStreams  Default log streams to be attached. Any bitwise
     *    combination of the aiDefaultLogStream enumerated values.
     *    If #aiDefaultLogStream_FILE is specified but an empty string is
     *    passed for 'name', no log file is created at all.
     *  @param  io IOSystem to be used to open external files (such as the
     *   log file). Pass nullptr to rely on the default implementation.
     *  This replaces the default #NullLogger with a #DefaultLogger instance. */
    static Logger *create(const char *name = ASSIMP_DEFAULT_LOG_NAME,
            LogSeverity severity = NORMAL,
            unsigned int defStreams = aiDefaultLogStream_DEBUGGER | aiDefaultLogStream_FILE,
            IOSystem *io = nullptr);

    // ----------------------------------------------------------------------
    /** @brief Setup a custom #Logger implementation.
     *
     *  Use this if the provided #DefaultLogger class doesn't fit into
     *  your needs. If the provided message formatting is OK for you,
     *  it's much easier to use #create() and to attach your own custom
     *  output streams to it.
     *  @param logger Pass NULL to setup a default NullLogger*/
    static void set(Logger *logger);

    // ----------------------------------------------------------------------
    /** @brief  Getter for singleton instance
     *   @return Only instance. This is never null, but it could be a
     *  NullLogger. Use isNullLogger to check this.*/
    static Logger *get();

    // ----------------------------------------------------------------------
    /** @brief  Return whether a #NullLogger is currently active
     *  @return true if the current logger is a #NullLogger.
     *  Use create() or set() to setup a logger that does actually do
     *  something else than just rejecting all log messages. */
    static bool isNullLogger();

    // ----------------------------------------------------------------------
    /** @brief  Kills the current singleton logger and replaces it with a
     *  #NullLogger instance. */
    static void kill();

    // ----------------------------------------------------------------------
    /** @copydoc Logger::attachStream   */
    bool attachStream(LogStream *pStream, unsigned int severity) override;

    // ----------------------------------------------------------------------
    /** @copydoc Logger::detachStream */
    bool detachStream(LogStream *pStream, unsigned int severity) override;

private:
    // ----------------------------------------------------------------------
    /** @briefPrivate construction for internal use by create().
     *  @param severity Logging granularity  */
    explicit DefaultLogger(LogSeverity severity);

    // ----------------------------------------------------------------------
    /** @briefDestructor    */
    ~DefaultLogger() override;

    /** @brief  Logs debug infos, only been written when severity level DEBUG or higher is set */
    void OnDebug(const char *message) override;

    /** @brief  Logs debug infos, only been written when severity level VERBOSE is set */
    void OnVerboseDebug(const char *message) override;

    /** @brief  Logs an info message */
    void OnInfo(const char *message) override;

    /** @brief  Logs a warning message */
    void OnWarn(const char *message) override;

    /** @brief  Logs an error message */
    void OnError(const char *message) override;

    // ----------------------------------------------------------------------
    /** @brief Writes a message to all streams */
    void WriteToStreams(const char *message, ErrorSeverity ErrorSev);

    // ----------------------------------------------------------------------
    /** @brief Returns the thread id.
     *  @note This is an OS specific feature, if not supported, a
     *    zero will be returned.
     */
    unsigned int GetThreadID();

private:
    //  Aliases for stream container
    using StreamArray = std::vector<LogStreamInfo *>;
    using StreamIt = std::vector<LogStreamInfo *>::iterator;
    using ConstStreamIt = std::vector<LogStreamInfo *>::const_iterator;

    //! only logging instance
    static Logger *m_pLogger;
    static NullLogger s_pNullLogger;

    //! Attached streams
    StreamArray m_StreamArray;

    bool noRepeatMsg;
    char lastMsg[MAX_LOG_MESSAGE_LENGTH * 2];
    size_t lastLen;
};

// ------------------------------------------------------------------------------------

} // Namespace Assimp

#endif // !! INCLUDED_AI_DEFAULTLOGGER


============================================================
File Path: project/externals/assimp/include/assimp/Exceptional.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

#pragma once
#ifndef AI_INCLUDED_EXCEPTIONAL_H
#define AI_INCLUDED_EXCEPTIONAL_H

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/DefaultIOStream.h>
#include <assimp/TinyFormatter.h>
#include <stdexcept>

using std::runtime_error;

#ifdef _MSC_VER
#pragma warning(disable : 4275)
#endif

// ---------------------------------------------------------------------------
/**
 *  The base-class for all other exceptions
 */
class ASSIMP_API DeadlyErrorBase : public runtime_error {
protected:
    /// @brief The class constructor with the formatter.
    /// @param f    The formatter.
    DeadlyErrorBase(Assimp::Formatter::format f);

    /// @brief The class constructor with the parameter ellipse.
    /// @tparam ...T    The type for the ellipse
    /// @tparam U       The other type
    /// @param f        The formatter
    /// @param u        One parameter
    /// @param ...args  The rest
    template<typename... T, typename U>
    DeadlyErrorBase(Assimp::Formatter::format f, U&& u, T&&... args) :
            DeadlyErrorBase(std::move(f << std::forward<U>(u)), std::forward<T>(args)...) {}
};

// ---------------------------------------------------------------------------
/** FOR IMPORTER PLUGINS ONLY: Simple exception class to be thrown if an
 *  unrecoverable error occurs while importing. Loading APIs return
 *  nullptr instead of a valid aiScene then.  */
class ASSIMP_API DeadlyImportError : public DeadlyErrorBase {
public:
    /// @brief The class constructor with the message.
    /// @param message  The message
    DeadlyImportError(const char *message) :
            DeadlyErrorBase(Assimp::Formatter::format(), std::forward<const char*>(message)) {
        // empty
    }

    /// @brief The class constructor with the parameter ellipse.
    /// @tparam ...T    The type for the ellipse
    /// @param ...args  The args
    template<typename... T>
    explicit DeadlyImportError(T&&... args) :
            DeadlyErrorBase(Assimp::Formatter::format(), std::forward<T>(args)...) {
        // empty
    }
};

// ---------------------------------------------------------------------------
/** FOR EXPORTER PLUGINS ONLY: Simple exception class to be thrown if an
 *  unrecoverable error occurs while exporting. Exporting APIs return
 *  nullptr instead of a valid aiScene then.  */
class ASSIMP_API DeadlyExportError : public DeadlyErrorBase {
public:
    /** Constructor with arguments */
    template<typename... T>
    explicit DeadlyExportError(T&&... args) :
            DeadlyErrorBase(Assimp::Formatter::format(), std::forward<T>(args)...) {}
};

#ifdef _MSC_VER
#pragma warning(default : 4275)
#endif

// ---------------------------------------------------------------------------
template <typename T>
struct ExceptionSwallower {
    T operator()() const {
        return T();
    }
};

// ---------------------------------------------------------------------------
template <typename T>
struct ExceptionSwallower<T *> {
    T *operator()() const {
        return nullptr;
    }
};

// ---------------------------------------------------------------------------
template <>
struct ExceptionSwallower<aiReturn> {
    aiReturn operator()() const {
        try {
            throw;
        } catch (std::bad_alloc &) {
            return aiReturn_OUTOFMEMORY;
        } catch (...) {
            return aiReturn_FAILURE;
        }
    }
};

// ---------------------------------------------------------------------------
template <>
struct ExceptionSwallower<void> {
    void operator()() const {
        return;
    }
};

#define ASSIMP_BEGIN_EXCEPTION_REGION() \
    {                                   \
        try {

#define ASSIMP_END_EXCEPTION_REGION_WITH_ERROR_STRING(type, ASSIMP_END_EXCEPTION_REGION_errorString, ASSIMP_END_EXCEPTION_REGION_exception)     \
    }                                                                                                                                           \
    catch (const DeadlyImportError &e) {                                                                                                        \
        ASSIMP_END_EXCEPTION_REGION_errorString = e.what();                                                                                     \
        ASSIMP_END_EXCEPTION_REGION_exception = std::current_exception();                                                                       \
        return ExceptionSwallower<type>()();                                                                                                    \
    }                                                                                                                                           \
    catch (...) {                                                                                                                               \
        ASSIMP_END_EXCEPTION_REGION_errorString = "Unknown exception";                                                                          \
        ASSIMP_END_EXCEPTION_REGION_exception = std::current_exception();                                                                       \
        return ExceptionSwallower<type>()();                                                                                                    \
    }                                                                                                                                           \
}

#define ASSIMP_END_EXCEPTION_REGION(type)    \
    }                                        \
    catch (...) {                            \
        return ExceptionSwallower<type>()(); \
    }                                        \
    }

#endif // AI_INCLUDED_EXCEPTIONAL_H


============================================================
File Path: project/externals/assimp/include/assimp/Exporter.hpp
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
copyright notice, this list of conditions and the
following disclaimer.

* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the
following disclaimer in the documentation and/or other
materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
contributors may be used to endorse or promote products
derived from this software without specific prior
written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  Exporter.hpp
*  @brief Defines the CPP-API for the Assimp export interface
*/
#pragma once
#ifndef AI_EXPORT_HPP_INC
#define AI_EXPORT_HPP_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#ifndef ASSIMP_BUILD_NO_EXPORT

#include "cexport.h"
#include <map>
#include <functional>

namespace Assimp {

class ExporterPimpl;
class IOSystem;
class ProgressHandler;

// ----------------------------------------------------------------------------------
/** CPP-API: The Exporter class forms an C++ interface to the export functionality
 * of the Open Asset Import Library. Note that the export interface is available
 * only if Assimp has been built with ASSIMP_BUILD_NO_EXPORT not defined.
 *
 * The interface is modeled after the importer interface and mostly
 * symmetric. The same rules for threading etc. apply.
 *
 * In a nutshell, there are two export interfaces: #Export, which writes the
 * output file(s) either to the regular file system or to a user-supplied
 * #IOSystem, and #ExportToBlob which returns a linked list of memory
 * buffers (blob), each referring to one output file (in most cases
 * there will be only one output file of course, but this extra complexity is
 * needed since Assimp aims at supporting a wide range of file formats).
 *
 * #ExportToBlob is especially useful if you intend to work
 * with the data in-memory.
*/
class ASSIMP_API ExportProperties;

class ASSIMP_API Exporter {
public:
    /** Function pointer type of a Export worker function */
    typedef void (*fpExportFunc)(const char *, IOSystem *, const aiScene *, const ExportProperties *);

    /** Internal description of an Assimp export format option */
    struct ExportFormatEntry {
        /// Public description structure to be returned by aiGetExportFormatDescription()
        aiExportFormatDesc mDescription;

        // Worker function to do the actual exporting
        fpExportFunc mExportFunction;

        // Post-processing steps to be executed PRIOR to invoking mExportFunction
        unsigned int mEnforcePP;

        // Constructor to fill all entries
        ExportFormatEntry(const char *pId, const char *pDesc, const char *pExtension, fpExportFunc pFunction, unsigned int pEnforcePP = 0u) {
            mDescription.id = pId;
            mDescription.description = pDesc;
            mDescription.fileExtension = pExtension;
            mExportFunction = pFunction;
            mEnforcePP = pEnforcePP;
        }

        ExportFormatEntry() :
                mExportFunction(),
                mEnforcePP() {
            mDescription.id = nullptr;
            mDescription.description = nullptr;
            mDescription.fileExtension = nullptr;
        }
    };

    /**
     *  @brief  The class constructor.
     */
    Exporter();

    /**
    *  @brief  The class destructor.
    */
    ~Exporter();

    // -------------------------------------------------------------------
    /** Supplies a custom IO handler to the exporter to use to open and
     * access files.
     *
     * If you need #Export to use custom IO logic to access the files,
     * you need to supply a custom implementation of IOSystem and
     * IOFile to the exporter.
     *
     * #Exporter takes ownership of the object and will destroy it
     * afterwards. The previously assigned handler will be deleted.
     * Pass NULL to take again ownership of your IOSystem and reset Assimp
     * to use its default implementation, which uses plain file IO.
     *
     * @param pIOHandler The IO handler to be used in all file accesses
     *   of the Importer. */
    void SetIOHandler(IOSystem *pIOHandler);

    // -------------------------------------------------------------------
    /** Retrieves the IO handler that is currently set.
     * You can use #IsDefaultIOHandler() to check whether the returned
     * interface is the default IO handler provided by ASSIMP. The default
     * handler is active as long the application doesn't supply its own
     * custom IO handler via #SetIOHandler().
     * @return A valid IOSystem interface, never NULL. */
    IOSystem *GetIOHandler() const;

    // -------------------------------------------------------------------
    /** Checks whether a default IO handler is active
     * A default handler is active as long the application doesn't
     * supply its own custom IO handler via #SetIOHandler().
     * @return true by default */
    bool IsDefaultIOHandler() const;

    // -------------------------------------------------------------------
    /** Supplies a custom progress handler to the exporter. This
     *  interface exposes an #Update() callback, which is called
     *  more or less periodically (please don't sue us if it
     *  isn't as periodically as you'd like it to have ...).
     *  This can be used to implement progress bars and loading
     *  timeouts.
     *  @param pHandler Progress callback interface. Pass nullptr to
     *    disable progress reporting.
     *  @note Progress handlers can be used to abort the loading
     *    at almost any time.*/
    void SetProgressHandler(ProgressHandler *pHandler);

    // -------------------------------------------------------------------
    /** Exports the given scene to a chosen file format. Returns the exported
    * data as a binary blob which you can write into a file or something.
    * When you're done with the data, simply let the #Exporter instance go
    * out of scope to have it released automatically.
    * @param pScene The scene to export. Stays in possession of the caller,
    *   is not changed by the function.
    * @param pFormatId ID string to specify to which format you want to
    *   export to. Use
    * #GetExportFormatCount / #GetExportFormatDescription to learn which
    *   export formats are available.
    * @param pPreprocessing See the documentation for #Export
    * @return the exported data or nullptr in case of error.
    * @note If the Exporter instance did already hold a blob from
    *   a previous call to #ExportToBlob, it will be disposed.
    *   Any IO handlers set via #SetIOHandler are ignored here.
    * @note Use aiCopyScene() to get a modifiable copy of a previously
    *   imported scene. */
    const aiExportDataBlob *ExportToBlob(const aiScene *pScene, const char *pFormatId,
            unsigned int pPreprocessing = 0u, const ExportProperties *pProperties = nullptr);
    const aiExportDataBlob *ExportToBlob(const aiScene *pScene, const std::string &pFormatId,
            unsigned int pPreprocessing = 0u, const ExportProperties *pProperties = nullptr);

    // -------------------------------------------------------------------
    /** Convenience function to export directly to a file. Use
     *  #SetIOSystem to supply a custom IOSystem to gain fine-grained control
     *  about the output data flow of the export process.
     * @param pBlob A data blob obtained from a previous call to #aiExportScene. Must not be nullptr.
     * @param pPath Full target file name. Target must be accessible.
     * @param pPreprocessing Accepts any choice of the #aiPostProcessSteps enumerated
     *   flags, but in reality only a subset of them makes sense here. Specifying
     *   'preprocessing' flags is useful if the input scene does not conform to
     *   Assimp's default conventions as specified in the @link data Data Structures Page @endlink.
     *   In short, this means the geometry data should use a right-handed coordinate systems, face
     *   winding should be counter-clockwise and the UV coordinate origin is assumed to be in
     *   the upper left. The #aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
     *   #aiProcess_FlipWindingOrder flags are used in the import side to allow users
     *   to have those defaults automatically adapted to their conventions. Specifying those flags
     *   for exporting has the opposite effect, respectively. Some other of the
     *   #aiPostProcessSteps enumerated values may be useful as well, but you'll need
     *   to try out what their effect on the exported file is. Many formats impose
     *   their own restrictions on the structure of the geometry stored therein,
     *   so some preprocessing may have little or no effect at all, or may be
     *   redundant as exporters would apply them anyhow. A good example
     *   is triangulation - whilst you can enforce it by specifying
     *   the #aiProcess_Triangulate flag, most export formats support only
     *   triangulate data so they would run the step even if it wasn't requested.
     *
     *   If assimp detects that the input scene was directly taken from the importer side of
     *   the library (i.e. not copied using aiCopyScene and potentially modified afterwards),
     *   any post-processing steps already applied to the scene will not be applied again, unless
     *   they show non-idempotent behavior (#aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
     *   #aiProcess_FlipWindingOrder).
     * @return AI_SUCCESS if everything was fine.
     * @note Use aiCopyScene() to get a modifiable copy of a previously
     *   imported scene.*/
    aiReturn Export(const aiScene *pScene, const char *pFormatId, const char *pPath,
            unsigned int pPreprocessing = 0u, const ExportProperties *pProperties = nullptr);
    aiReturn Export(const aiScene *pScene, const std::string &pFormatId, const std::string &pPath,
            unsigned int pPreprocessing = 0u, const ExportProperties *pProperties = nullptr);

    // -------------------------------------------------------------------
    /** Returns an error description of an error that occurred in #Export
     *    or #ExportToBlob
     *
     * Returns an empty string if no error occurred.
     * @return A description of the last error, an empty string if no
     *   error occurred. The string is never nullptr.
     *
     * @note The returned function remains valid until one of the
     * following methods is called: #Export, #ExportToBlob, #FreeBlob */
    const char *GetErrorString() const;

    // -------------------------------------------------------------------
    /** Return the blob obtained from the last call to #ExportToBlob */
    const aiExportDataBlob *GetBlob() const;

    // -------------------------------------------------------------------
    /** Orphan the blob from the last call to #ExportToBlob. This means
     *  the caller takes ownership and is thus responsible for calling
     *  the C API function #aiReleaseExportBlob to release it. */
    const aiExportDataBlob *GetOrphanedBlob() const;

    // -------------------------------------------------------------------
    /** Frees the current blob.
     *
     *  The function does nothing if no blob has previously been
     *  previously produced via #ExportToBlob. #FreeBlob is called
     *  automatically by the destructor. The only reason to call
     *  it manually would be to reclaim as much storage as possible
     *  without giving up the #Exporter instance yet. */
    void FreeBlob();

    // -------------------------------------------------------------------
    /** Returns the number of export file formats available in the current
     *  Assimp build. Use #Exporter::GetExportFormatDescription to
     *  retrieve infos of a specific export format.
     *
     *  This includes built-in exporters as well as exporters registered
     *  using #RegisterExporter.
     **/
    size_t GetExportFormatCount() const;

    // -------------------------------------------------------------------
    /** Returns a description of the nth export file format. Use #
     *  #Exporter::GetExportFormatCount to learn how many export
     *  formats are supported.
     *
     * The returned pointer is of static storage duration if the
     * pIndex pertains to a built-in exporter (i.e. one not registered
     * via #RegistrerExporter). It is restricted to the life-time of the
     * #Exporter instance otherwise.
     *
     * @param pIndex Index of the export format to retrieve information
     *  for. Valid range is 0 to #Exporter::GetExportFormatCount
     * @return A description of that specific export format.
     *  NULL if pIndex is out of range. */
    const aiExportFormatDesc *GetExportFormatDescription(size_t pIndex) const;

    // -------------------------------------------------------------------
    /** Register a custom exporter. Custom export formats are limited to
     *    to the current #Exporter instance and do not affect the
     *    library globally. The indexes under which the format's
     *    export format description can be queried are assigned
     *    monotonously.
     *  @param desc Exporter description.
     *  @return aiReturn_SUCCESS if the export format was successfully
     *    registered. A common cause that would prevent an exporter
     *    from being registered is that its format id is already
     *    occupied by another format. */
    aiReturn RegisterExporter(const ExportFormatEntry &desc);

    // -------------------------------------------------------------------
    /** Remove an export format previously registered with #RegisterExporter
     *  from the #Exporter instance (this can also be used to drop
     *  built-in exporters because those are implicitly registered
     *  using #RegisterExporter).
     *  @param id Format id to be unregistered, this refers to the
     *    'id' field of #aiExportFormatDesc.
     *  @note Calling this method on a format description not yet registered
     *    has no effect.*/
    void UnregisterExporter(const char *id);

protected:
    // Just because we don't want you to know how we're hacking around.
    ExporterPimpl *pimpl;
};

class ASSIMP_API ExportProperties {
public:
    // Data type to store the key hash
    typedef unsigned int KeyType;

    // typedefs for our four configuration maps.
    // We don't need more, so there is no need for a generic solution
    typedef std::map<KeyType, int> IntPropertyMap;
    typedef std::map<KeyType, ai_real> FloatPropertyMap;
    typedef std::map<KeyType, std::string> StringPropertyMap;
    typedef std::map<KeyType, aiMatrix4x4> MatrixPropertyMap;
    typedef std::map<KeyType, std::function<void *(void *)>> CallbackPropertyMap;

public:
    /** Standard constructor
    * @see ExportProperties()
    */
    ExportProperties();

    // -------------------------------------------------------------------
    /** Copy constructor.
     *
     * This copies the configuration properties of another ExportProperties.
     * @see ExportProperties(const ExportProperties& other)
     */
    ExportProperties(const ExportProperties &other);

    // -------------------------------------------------------------------
    /** Set an integer configuration property.
     * @param szName Name of the property. All supported properties
     *   are defined in the aiConfig.g header (all constants share the
     *   prefix AI_CONFIG_XXX and are simple strings).
     * @param iValue New value of the property
     * @return true if the property was set before. The new value replaces
     *   the previous value in this case.
     * @note Property of different types (float, int, string ..) are kept
     *   on different stacks, so calling SetPropertyInteger() for a
     *   floating-point property has no effect - the loader will call
     *   GetPropertyFloat() to read the property, but it won't be there.
     */
    bool SetPropertyInteger(const char *szName, int iValue);

    // -------------------------------------------------------------------
    /** Set a boolean configuration property. Boolean properties
     *  are stored on the integer stack internally so it's possible
     *  to set them via #SetPropertyBool and query them with
     *  #GetPropertyBool and vice versa.
     * @see SetPropertyInteger()
     */
    bool SetPropertyBool(const char *szName, bool value) {
        return SetPropertyInteger(szName, value);
    }

    // -------------------------------------------------------------------
    /** Set a floating-point configuration property.
     * @see SetPropertyInteger()
     */
    bool SetPropertyFloat(const char *szName, ai_real fValue);

    // -------------------------------------------------------------------
    /** Set a string configuration property.
     * @see SetPropertyInteger()
     */
    bool SetPropertyString(const char *szName, const std::string &sValue);

    // -------------------------------------------------------------------
    /** Set a matrix configuration property.
     * @see SetPropertyInteger()
     */
    bool SetPropertyMatrix(const char *szName, const aiMatrix4x4 &sValue);

    bool SetPropertyCallback(const char *szName, const std::function<void *(void *)> &f);

    // -------------------------------------------------------------------
    /** Get a configuration property.
     * @param szName Name of the property. All supported properties
     *   are defined in the aiConfig.g header (all constants share the
     *   prefix AI_CONFIG_XXX).
     * @param iErrorReturn Value that is returned if the property
     *   is not found.
     * @return Current value of the property
     * @note Property of different types (float, int, string ..) are kept
     *   on different lists, so calling SetPropertyInteger() for a
     *   floating-point property has no effect - the loader will call
     *   GetPropertyFloat() to read the property, but it won't be there.
     */
    int GetPropertyInteger(const char *szName,
            int iErrorReturn = 0xffffffff) const;

    // -------------------------------------------------------------------
    /** Get a boolean configuration property. Boolean properties
     *  are stored on the integer stack internally so it's possible
     *  to set them via #SetPropertyBool and query them with
     *  #GetPropertyBool and vice versa.
     * @see GetPropertyInteger()
     */
    bool GetPropertyBool(const char *szName, bool bErrorReturn = false) const {
        return GetPropertyInteger(szName, bErrorReturn) != 0;
    }

    // -------------------------------------------------------------------
    /** Get a floating-point configuration property
     * @see GetPropertyInteger()
     */
    ai_real GetPropertyFloat(const char *szName,
            ai_real fErrorReturn = 10e10f) const;

    // -------------------------------------------------------------------
    /** Get a string configuration property
     *
     *  The return value remains valid until the property is modified.
     * @see GetPropertyInteger()
     */
    const std::string GetPropertyString(const char *szName,
            const std::string &sErrorReturn = "") const;

    // -------------------------------------------------------------------
    /** Get a matrix configuration property
     *
     *  The return value remains valid until the property is modified.
     * @see GetPropertyInteger()
     */
    const aiMatrix4x4 GetPropertyMatrix(const char *szName,
            const aiMatrix4x4 &sErrorReturn = aiMatrix4x4()) const;

    std::function<void *(void *)> GetPropertyCallback(const char* szName) const;

    // -------------------------------------------------------------------
    /** Determine a integer configuration property has been set.
    * @see HasPropertyInteger()
     */
    bool HasPropertyInteger(const char *szName) const;

    /** Determine a boolean configuration property has been set.
    * @see HasPropertyBool()
     */
    bool HasPropertyBool(const char *szName) const;

    /** Determine a boolean configuration property has been set.
    * @see HasPropertyFloat()
     */
    bool HasPropertyFloat(const char *szName) const;

    /** Determine a String configuration property has been set.
    * @see HasPropertyString()
     */
    bool HasPropertyString(const char *szName) const;

    /** Determine a Matrix configuration property has been set.
    * @see HasPropertyMatrix()
     */
    bool HasPropertyMatrix(const char *szName) const;

    bool HasPropertyCallback(const char *szName) const;

    /** List of integer properties */
    IntPropertyMap mIntProperties;

    /** List of floating-point properties */
    FloatPropertyMap mFloatProperties;

    /** List of string properties */
    StringPropertyMap mStringProperties;

    /** List of Matrix properties */
    MatrixPropertyMap mMatrixProperties;

    CallbackPropertyMap mCallbackProperties;
};

// ----------------------------------------------------------------------------------
inline const aiExportDataBlob *Exporter::ExportToBlob(const aiScene *pScene, const std::string &pFormatId,
        unsigned int pPreprocessing, const ExportProperties *pProperties) {
    return ExportToBlob(pScene, pFormatId.c_str(), pPreprocessing, pProperties);
}

// ----------------------------------------------------------------------------------
inline aiReturn Exporter ::Export(const aiScene *pScene, const std::string &pFormatId,
        const std::string &pPath, unsigned int pPreprocessing,
        const ExportProperties *pProperties) {
    return Export(pScene, pFormatId.c_str(), pPath.c_str(), pPreprocessing, pProperties);
}

} // namespace Assimp

#endif // ASSIMP_BUILD_NO_EXPORT
#endif // AI_EXPORT_HPP_INC


============================================================
File Path: project/externals/assimp/include/assimp/GenericProperty.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

#pragma once
#ifndef AI_GENERIC_PROPERTY_H_INCLUDED
#define AI_GENERIC_PROPERTY_H_INCLUDED

#ifdef __GNUC__
#    pragma GCC system_header
#endif

#include <assimp/Hash.h>
#include <assimp/ai_assert.h>
#include <assimp/Importer.hpp>

#include <map>

// ------------------------------------------------------------------------------------------------
template <class T>
inline bool SetGenericProperty(std::map<unsigned int, T> &list,
        const char *szName, const T &value) {
    ai_assert(nullptr != szName);
    const uint32_t hash = SuperFastHash(szName);

    typename std::map<unsigned int, T>::iterator it = list.find(hash);
    if (it == list.end()) {
        list.insert(std::pair<unsigned int, T>(hash, value));
        return false;
    }
    (*it).second = value;

    return true;
}

// ------------------------------------------------------------------------------------------------
template <class T>
inline const T &GetGenericProperty(const std::map<unsigned int, T> &list,
        const char *szName, const T &errorReturn) {
    ai_assert(nullptr != szName);
    const uint32_t hash = SuperFastHash(szName);

    typename std::map<unsigned int, T>::const_iterator it = list.find(hash);
    if (it == list.end()) {
        return errorReturn;
    }

    return (*it).second;
}

// ------------------------------------------------------------------------------------------------
// Special version for pointer types - they will be deleted when replaced with another value
// passing nullptr removes the whole property
template <class T>
inline void SetGenericPropertyPtr(std::map<unsigned int, T *> &list,
        const char *szName, T *value, bool *bWasExisting = nullptr) {
    ai_assert(nullptr != szName);
    const uint32_t hash = SuperFastHash(szName);

    typename std::map<unsigned int, T *>::iterator it = list.find(hash);
    if (it == list.end()) {
        if (bWasExisting) {
            *bWasExisting = false;
        }

        list.insert(std::pair<unsigned int, T *>(hash, value));
        return;
    }
    if ((*it).second != value) {
        delete (*it).second;
        (*it).second = value;
    }
    if (!value) {
        list.erase(it);
    }
    if (bWasExisting) {
        *bWasExisting = true;
    }
}

// ------------------------------------------------------------------------------------------------
template <class T>
inline bool HasGenericProperty(const std::map<unsigned int, T> &list,
        const char *szName) {
    ai_assert(nullptr != szName);
    const uint32_t hash = SuperFastHash(szName);

    typename std::map<unsigned int, T>::const_iterator it = list.find(hash);
    if (it == list.end()) {
        return false;
    }

    return true;
}

#endif // !! AI_GENERIC_PROPERTY_H_INCLUDED


============================================================
File Path: project/externals/assimp/include/assimp/GltfMaterial.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file GltfMaterial.h
 *  @brief glTF-specific material macros
 *  These will be made generic at some future date
 */

#ifndef AI_GLTFMATERIAL_H_INC
#define AI_GLTFMATERIAL_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/material.h>

#define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLICROUGHNESS_TEXTURE aiTextureType_UNKNOWN, 0
#define AI_MATKEY_GLTF_ALPHAMODE "$mat.gltf.alphaMode", 0, 0
#define AI_MATKEY_GLTF_ALPHACUTOFF "$mat.gltf.alphaCutoff", 0, 0

#define _AI_MATKEY_GLTF_MAPPINGNAME_BASE "$tex.mappingname"
#define _AI_MATKEY_GLTF_MAPPINGID_BASE "$tex.mappingid"
#define _AI_MATKEY_GLTF_MAPPINGFILTER_MAG_BASE "$tex.mappingfiltermag"
#define _AI_MATKEY_GLTF_MAPPINGFILTER_MIN_BASE "$tex.mappingfiltermin"
#define _AI_MATKEY_GLTF_SCALE_BASE "$tex.scale"
#define _AI_MATKEY_GLTF_STRENGTH_BASE "$tex.strength"

#define AI_MATKEY_GLTF_MAPPINGNAME(type, N) _AI_MATKEY_GLTF_MAPPINGNAME_BASE, type, N
#define AI_MATKEY_GLTF_MAPPINGID(type, N) _AI_MATKEY_GLTF_MAPPINGID_BASE, type, N
#define AI_MATKEY_GLTF_MAPPINGFILTER_MAG(type, N) _AI_MATKEY_GLTF_MAPPINGFILTER_MAG_BASE, type, N
#define AI_MATKEY_GLTF_MAPPINGFILTER_MIN(type, N) _AI_MATKEY_GLTF_MAPPINGFILTER_MIN_BASE, type, N
#define AI_MATKEY_GLTF_TEXTURE_SCALE(type, N) _AI_MATKEY_GLTF_SCALE_BASE, type, N
#define AI_MATKEY_GLTF_TEXTURE_STRENGTH(type, N) _AI_MATKEY_GLTF_STRENGTH_BASE, type, N

#endif


============================================================
File Path: project/externals/assimp/include/assimp/Hash.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/
#pragma once
#ifndef AI_HASH_H_INCLUDED
#define AI_HASH_H_INCLUDED

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <cmath>

// ------------------------------------------------------------------------------------------------
// Hashing function taken from
// http://www.azillionmonkeys.com/qed/hash.html
// (incremental version)
//
// This code is Copyright 2004-2008 by Paul Hsieh. It is used here in the belief that
// Assimp's license is considered compatible with Pauls's derivative license as specified
// on his web page.
//
// (stdint.h should have been been included here)
// ------------------------------------------------------------------------------------------------
#undef get16bits
#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__) \
  || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)
#  define get16bits(d) (*((const uint16_t *) (d)))
#endif

#if !defined (get16bits)
#  define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)\
                       +(uint32_t)(((const uint8_t *)(d))[0]) )
#endif

// ------------------------------------------------------------------------------------------------
inline uint32_t SuperFastHash (const char * data, uint32_t len = 0, uint32_t hash = 0) {
    uint32_t tmp;
    int rem;

    if (data == NULL) return 0;
    if (len == 0)len = (uint32_t)::strlen(data);

    rem = len & 3;
    len >>= 2;

    /* Main loop */
    for (;len > 0; len--) {
        hash  += get16bits (data);
        tmp    = (get16bits (data+2) << 11) ^ hash;
        hash   = (hash << 16) ^ tmp;
        data  += 2*sizeof (uint16_t);
        hash  += hash >> 11;
    }

    /* Handle end cases */
    switch (rem) {
        case 3: hash += get16bits (data);
                hash ^= hash << 16;
                hash ^= abs(data[sizeof(uint16_t)]) << 18;
                hash += hash >> 11;
                break;
        case 2: hash += get16bits (data);
                hash ^= hash << 11;
                hash += hash >> 17;
                break;
        case 1: hash += *data;
                hash ^= hash << 10;
                hash += hash >> 1;
    }

    /* Force "avalanching" of final 127 bits */
    hash ^= hash << 3;
    hash += hash >> 5;
    hash ^= hash << 4;
    hash += hash >> 17;
    hash ^= hash << 25;
    hash += hash >> 6;

    return hash;
}

#endif // !! AI_HASH_H_INCLUDED


============================================================
File Path: project/externals/assimp/include/assimp/IOStream.hpp
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/
/** @file IOStream.hpp
 *  @brief File I/O wrappers for C++.
 */

#pragma once
#ifndef AI_IOSTREAM_H_INC
#define AI_IOSTREAM_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/types.h>

#ifndef __cplusplus
#   error This header requires C++ to be used. aiFileIO.h is the \
    corresponding C interface.
#endif

namespace Assimp {

// ----------------------------------------------------------------------------------
/** @brief CPP-API: Class to handle file I/O for C++
 *
 *  Derive an own implementation from this interface to provide custom IO handling
 *  to the Importer. If you implement this interface, be sure to also provide an
 *  implementation for IOSystem that creates instances of your custom IO class.
*/
class ASSIMP_API IOStream
#ifndef SWIG
    : public Intern::AllocateFromAssimpHeap
#endif
{
protected:
    /** Constructor protected, use IOSystem::Open() to create an instance. */
    IOStream() AI_NO_EXCEPT;

public:
    // -------------------------------------------------------------------
    /** @brief Destructor. Deleting the object closes the underlying file,
     * alternatively you may use IOSystem::Close() to release the file.
     */
    virtual ~IOStream();

    // -------------------------------------------------------------------
    /** @brief Read from the file
     *
     * See fread() for more details
     * This fails for write-only files */
    virtual size_t Read(void* pvBuffer,
        size_t pSize,
        size_t pCount) = 0;

    // -------------------------------------------------------------------
    /** @brief Write to the file
    *
    * See fwrite() for more details
    * This fails for read-only files */
    virtual size_t Write(const void* pvBuffer,
        size_t pSize,
        size_t pCount) = 0;

    // -------------------------------------------------------------------
    /** @brief Set the read/write cursor of the file
     *
     * Note that the offset is _negative_ for aiOrigin_END.
     * See fseek() for more details */
    virtual aiReturn Seek(size_t pOffset,
        aiOrigin pOrigin) = 0;

    // -------------------------------------------------------------------
    /** @brief Get the current position of the read/write cursor
     *
     * See ftell() for more details */
    virtual size_t Tell() const = 0;

    // -------------------------------------------------------------------
    /** @brief Returns filesize
     *  Returns the filesize. */
    virtual size_t FileSize() const = 0;

    // -------------------------------------------------------------------
    /** @brief Flush the contents of the file buffer (for writers)
     *  See fflush() for more details.
     */
    virtual void Flush() = 0;
}; //! class IOStream

// ----------------------------------------------------------------------------------
AI_FORCE_INLINE
IOStream::IOStream() AI_NO_EXCEPT = default;

// ----------------------------------------------------------------------------------
AI_FORCE_INLINE
IOStream::~IOStream() = default;
// ----------------------------------------------------------------------------------

} //!namespace Assimp

#endif //!!AI_IOSTREAM_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/IOStreamBuffer.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
copyright notice, this list of conditions and the
following disclaimer.

* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the
following disclaimer in the documentation and/or other
materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
contributors may be used to endorse or promote products
derived from this software without specific prior
written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

#pragma once
#ifndef AI_IOSTREAMBUFFER_H_INC
#define AI_IOSTREAMBUFFER_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/ParsingUtils.h>
#include <assimp/types.h>
#include <assimp/IOStream.hpp>

#include <vector>

namespace Assimp {

// ---------------------------------------------------------------------------
/**
 *  Implementation of a cached stream buffer.
 */
template <class T>
class IOStreamBuffer {
public:
    /// @brief  The class constructor.
    IOStreamBuffer(size_t cache = 4096 * 4096);

    /// @brief  The class destructor.
    ~IOStreamBuffer();

    /// @brief  Will open the cached access for a given stream.
    /// @param  stream      The stream to cache.
    /// @return true if successful.
    bool open(IOStream *stream);

    /// @brief  Will close the cached access.
    /// @return true if successful.
    bool close();

    /// @brief  Returns the file-size.
    /// @return The file-size.
    size_t size() const;

    /// @brief  Returns the cache size.
    /// @return The cache size.
    size_t cacheSize() const;

    /// @brief  Will read the next block.
    /// @return true if successful.
    bool readNextBlock();

    /// @brief  Returns the number of blocks to read.
    /// @return The number of blocks.
    size_t getNumBlocks() const;

    /// @brief  Returns the current block index.
    /// @return The current block index.
    size_t getCurrentBlockIndex() const;

    /// @brief  Returns the current file pos.
    /// @return The current file pos.
    size_t getFilePos() const;

    /// @brief  Will read the next line.
    /// @param  buffer      The buffer for the next line.
    /// @return true if successful.
    bool getNextDataLine(std::vector<T> &buffer, T continuationToken);

    /// @brief  Will read the next line ascii or binary end line char.
    /// @param  buffer      The buffer for the next line.
    /// @return true if successful.
    bool getNextLine(std::vector<T> &buffer);

    /// @brief  Will read the next block.
    /// @param  buffer      The buffer for the next block.
    /// @return true if successful.
    bool getNextBlock(std::vector<T> &buffer);

private:
    IOStream *m_stream;
    size_t m_filesize;
    size_t m_cacheSize;
    size_t m_numBlocks;
    size_t m_blockIdx;
    std::vector<T> m_cache;
    size_t m_cachePos;
    size_t m_filePos;
};

template <class T>
AI_FORCE_INLINE IOStreamBuffer<T>::IOStreamBuffer(size_t cache) :
        m_stream(nullptr),
        m_filesize(0),
        m_cacheSize(cache),
        m_numBlocks(0),
        m_blockIdx(0),
        m_cachePos(0),
        m_filePos(0) {
    m_cache.resize(cache);
    std::fill(m_cache.begin(), m_cache.end(), '\n');
}

template <class T>
AI_FORCE_INLINE IOStreamBuffer<T>::~IOStreamBuffer() = default;

template <class T>
AI_FORCE_INLINE bool IOStreamBuffer<T>::open(IOStream *stream) {
    //  file still opened!
    if (nullptr != m_stream) {
        return false;
    }

    //  Invalid stream pointer
    if (nullptr == stream) {
        return false;
    }

    m_stream = stream;
    m_filesize = m_stream->FileSize();
    if (m_filesize == 0) {
        return false;
    }
    if (m_filesize < m_cacheSize) {
        m_cacheSize = m_filesize;
    }

    m_numBlocks = m_filesize / m_cacheSize;
    if ((m_filesize % m_cacheSize) > 0) {
        m_numBlocks++;
    }

    return true;
}

template <class T>
AI_FORCE_INLINE bool IOStreamBuffer<T>::close() {
    if (nullptr == m_stream) {
        return false;
    }

    // init counters and state vars
    m_stream = nullptr;
    m_filesize = 0;
    m_numBlocks = 0;
    m_blockIdx = 0;
    m_cachePos = 0;
    m_filePos = 0;

    return true;
}

template <class T>
AI_FORCE_INLINE
        size_t
        IOStreamBuffer<T>::size() const {
    return m_filesize;
}

template <class T>
AI_FORCE_INLINE
        size_t
        IOStreamBuffer<T>::cacheSize() const {
    return m_cacheSize;
}

template <class T>
AI_FORCE_INLINE bool IOStreamBuffer<T>::readNextBlock() {
    m_stream->Seek(m_filePos, aiOrigin_SET);
    size_t readLen = m_stream->Read(&m_cache[0], sizeof(T), m_cacheSize);
    if (readLen == 0) {
        return false;
    }
    if (readLen < m_cacheSize) {
        m_cacheSize = readLen;
    }
    m_filePos += m_cacheSize;
    m_cachePos = 0;
    m_blockIdx++;

    return true;
}

template <class T>
AI_FORCE_INLINE size_t IOStreamBuffer<T>::getNumBlocks() const {
    return m_numBlocks;
}

template <class T>
AI_FORCE_INLINE size_t IOStreamBuffer<T>::getCurrentBlockIndex() const {
    return m_blockIdx;
}

template <class T>
AI_FORCE_INLINE size_t IOStreamBuffer<T>::getFilePos() const {
    return m_filePos;
}

template <class T>
AI_FORCE_INLINE bool IOStreamBuffer<T>::getNextDataLine(std::vector<T> &buffer, T continuationToken) {
    buffer.resize(m_cacheSize);
    if (m_cachePos >= m_cacheSize || 0 == m_filePos) {
        if (!readNextBlock()) {
            return false;
        }
    }

    size_t i = 0;
    for (;;) {
        if (continuationToken == m_cache[m_cachePos] && IsLineEnd(m_cache[m_cachePos + 1])) {
            ++m_cachePos;
            while (m_cache[m_cachePos] != '\n') {
                ++m_cachePos;
            }
            ++m_cachePos;
        } else if (IsLineEnd(m_cache[m_cachePos])) {
            break;
        }

        buffer[i] = m_cache[m_cachePos];
        ++m_cachePos;
        ++i;

        if(i == buffer.size()) {
            buffer.resize(buffer.size() * 2);
        }

        if (m_cachePos >= size()) {
            break;
        }
        if (m_cachePos >= m_cacheSize) {
            if (!readNextBlock()) {
                return false;
            }
        }
    }

    buffer[i] = '\n';
    ++m_cachePos;

    return true;
}

static AI_FORCE_INLINE bool isEndOfCache(size_t pos, size_t cacheSize) {
    return (pos == cacheSize);
}

template <class T>
AI_FORCE_INLINE bool IOStreamBuffer<T>::getNextLine(std::vector<T> &buffer) {
    buffer.resize(m_cacheSize);
    if (isEndOfCache(m_cachePos, m_cacheSize) || 0 == m_filePos) {
        if (!readNextBlock()) {
            return false;
        }
    }

    if (IsLineEnd(m_cache[m_cachePos])) {
        // skip line end
        while (m_cache[m_cachePos] != '\n') {
            ++m_cachePos;
        }
        ++m_cachePos;
        if (isEndOfCache(m_cachePos, m_cacheSize)) {
            if (!readNextBlock()) {
                return false;
            }
        }
    }

    size_t i(0);
    while (!IsLineEnd(m_cache[m_cachePos])) {
        buffer[i] = m_cache[m_cachePos];
        ++m_cachePos;
        ++i;

        if(i == buffer.size()) {
            buffer.resize(buffer.size() * 2);
        }

        if (m_cachePos >= m_cacheSize) {
            if (!readNextBlock()) {
                return false;
            }
        }
    }
    buffer[i] = '\n';
    while (m_cachePos < m_cacheSize && (m_cache[m_cachePos] == '\r' || m_cache[m_cachePos] == '\n')) {
        ++m_cachePos;
    }

    return true;
}

template <class T>
AI_FORCE_INLINE bool IOStreamBuffer<T>::getNextBlock(std::vector<T> &buffer) {
    // Return the last block-value if getNextLine was used before
    if (0 != m_cachePos) {
        buffer = std::vector<T>(m_cache.begin() + m_cachePos, m_cache.end());
        m_cachePos = 0;
    } else {
        if (!readNextBlock()) {
            return false;
        }

        buffer = std::vector<T>(m_cache.begin(), m_cache.end());
    }

    return true;
}

} // namespace Assimp

#endif // AI_IOSTREAMBUFFER_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/IOSystem.hpp
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file IOSystem.hpp
 *  @brief File system wrapper for C++. Inherit this class to supply
 *  custom file handling logic to the Import library.
*/

#pragma once
#ifndef AI_IOSYSTEM_H_INC
#define AI_IOSYSTEM_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#ifndef __cplusplus
#   error This header requires C++ to be used. aiFileIO.h is the \
    corresponding C interface.
#endif

#include "types.h"

#ifdef _WIN32
#   include <direct.h>
#   include <cstdlib>
#   include <cstdio>
#else
#   include <sys/stat.h>
#   include <sys/types.h>
#   include <unistd.h>
#endif // _WIN32

#include <vector>

namespace Assimp    {

class IOStream;

// ---------------------------------------------------------------------------
/** @brief CPP-API: Interface to the file system.
 *
 *  Derive an own implementation from this interface to supply custom file handling
 *  to the importer library. If you implement this interface, you also want to
 *  supply a custom implementation for IOStream.
 *
 *  @see Importer::SetIOHandler()
 */
class ASSIMP_API IOSystem
#ifndef SWIG
    : public Intern::AllocateFromAssimpHeap
#endif
{
public:

    // -------------------------------------------------------------------
    /** @brief Default constructor.
     *
     *  Create an instance of your derived class and assign it to an
     *  #Assimp::Importer instance by calling Importer::SetIOHandler().
     */
    IOSystem() AI_NO_EXCEPT;

    // -------------------------------------------------------------------
    /** @brief Virtual destructor.
     *
     *  It is safe to be called from within DLL Assimp, we're constructed
     *  on Assimp's heap.
     */
    virtual ~IOSystem();

    // -------------------------------------------------------------------
    /** @brief For backward compatibility
     *  @see Exists(const char*)
     */
    AI_FORCE_INLINE bool Exists( const std::string& pFile) const;

    // -------------------------------------------------------------------
    /** @brief Tests for the existence of a file at the given path.
     *
     * @param pFile Path to the file
     * @return true if there is a file with this path, else false.
     */
    virtual bool Exists( const char* pFile) const = 0;

    // -------------------------------------------------------------------
    /** @brief Returns the system specific directory separator
     *  @return System specific directory separator
     */
    virtual char getOsSeparator() const = 0;

    // -------------------------------------------------------------------
    /** @brief Open a new file with a given path.
     *
     *  When the access to the file is finished, call Close() to release
     *  all associated resources (or the virtual dtor of the IOStream).
     *
     *  @param pFile Path to the file
     *  @param pMode Desired file I/O mode. Required are: "wb", "w", "wt",
     *         "rb", "r", "rt".
     *
     *  @return New IOStream interface allowing the lib to access
     *         the underlying file.
     *  @note When implementing this class to provide custom IO handling,
     *  you probably have to supply an own implementation of IOStream as well.
     */
    virtual IOStream* Open(const char* pFile,
        const char* pMode = "rb") = 0;

    // -------------------------------------------------------------------
    /** @brief For backward compatibility
     *  @see Open(const char*, const char*)
     */
    inline IOStream* Open(const std::string& pFile,
        const std::string& pMode = std::string("rb"));

    // -------------------------------------------------------------------
    /** @brief Closes the given file and releases all resources
     *    associated with it.
     *  @param pFile The file instance previously created by Open().
     */
    virtual void Close( IOStream* pFile) = 0;

    // -------------------------------------------------------------------
    /** @brief Compares two paths and check whether the point to
     *         identical files.
     *
     * The dummy implementation of this virtual member performs a
     * case-insensitive comparison of the given strings. The default IO
     * system implementation uses OS mechanisms to convert relative into
     * absolute paths, so the result can be trusted.
     * @param one First file
     * @param second Second file
     * @return true if the paths point to the same file. The file needn't
     *   be existing, however.
     */
    virtual bool ComparePaths (const char* one,
        const char* second) const;

    // -------------------------------------------------------------------
    /** @brief For backward compatibility
     *  @see ComparePaths(const char*, const char*)
     */
    inline bool ComparePaths (const std::string& one,
        const std::string& second) const;

    // -------------------------------------------------------------------
    /** @brief Pushes a new directory onto the directory stack.
     *  @param path Path to push onto the stack.
     *  @return True, when push was successful, false if path is empty.
     */
    virtual bool PushDirectory( const std::string &path );

    // -------------------------------------------------------------------
    /** @brief Returns the top directory from the stack.
     *  @return The directory on the top of the stack.
     *          Returns empty when no directory was pushed to the stack.
     */
    virtual const std::string &CurrentDirectory() const;

    // -------------------------------------------------------------------
    /** @brief Returns the number of directories stored on the stack.
     *  @return The number of directories of the stack.
     */
    virtual size_t StackSize() const;

    // -------------------------------------------------------------------
    /** @brief Pops the top directory from the stack.
     *  @return True, when a directory was on the stack. False if no
     *          directory was on the stack.
     */
    virtual bool PopDirectory();

    // -------------------------------------------------------------------
    /** @brief CReates an new directory at the given path.
     *  @param  path    [in] The path to create.
     *  @return True, when a directory was created. False if the directory
     *           cannot be created.
     */
    virtual bool CreateDirectory( const std::string &path );

    // -------------------------------------------------------------------
    /** @brief Will change the current directory to the given path.
     *  @param path     [in] The path to change to.
     *  @return True, when the directory has changed successfully.
     */
    virtual bool ChangeDirectory( const std::string &path );

    // -------------------------------------------------------------------
    /**
     *  @brief  Will delete the given file.
     *  @param file     [in] The filename
     *  @return true, if the file wase deleted, false if not.
     */
    virtual bool DeleteFile(const std::string &file);

private:
    std::vector<std::string> m_pathStack;
};

// ----------------------------------------------------------------------------
AI_FORCE_INLINE IOSystem::IOSystem() AI_NO_EXCEPT = default;

// ----------------------------------------------------------------------------
AI_FORCE_INLINE IOSystem::~IOSystem() = default;

// ----------------------------------------------------------------------------
// For compatibility, the interface of some functions taking a std::string was
// changed to const char* to avoid crashes between binary incompatible STL
// versions. This code her is inlined,  so it shouldn't cause any problems.
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
AI_FORCE_INLINE IOStream* IOSystem::Open(const std::string& pFile, const std::string& pMode) {
    // NOTE:
    // For compatibility, interface was changed to const char* to
    // avoid crashes between binary incompatible STL versions
    return Open(pFile.c_str(),pMode.c_str());
}

// ----------------------------------------------------------------------------
AI_FORCE_INLINE bool IOSystem::Exists( const std::string& pFile) const {
    // NOTE:
    // For compatibility, interface was changed to const char* to
    // avoid crashes between binary incompatible STL versions
    return Exists(pFile.c_str());
}

// ----------------------------------------------------------------------------
AI_FORCE_INLINE bool IOSystem::ComparePaths(const std::string& one, const std::string& second) const {
    // NOTE:
    // For compatibility, interface was changed to const char* to
    // avoid crashes between binary incompatible STL versions
    return ComparePaths(one.c_str(),second.c_str());
}

// ----------------------------------------------------------------------------
AI_FORCE_INLINE bool IOSystem::PushDirectory( const std::string &path ) {
    if ( path.empty() ) {
        return false;
    }

    m_pathStack.push_back( path );

    return true;
}

// ----------------------------------------------------------------------------
AI_FORCE_INLINE size_t IOSystem::StackSize() const {
    return m_pathStack.size();
}

// ----------------------------------------------------------------------------
AI_FORCE_INLINE bool IOSystem::PopDirectory() {
    if ( m_pathStack.empty() ) {
        return false;
    }

    m_pathStack.pop_back();

    return true;
}

// ----------------------------------------------------------------------------
AI_FORCE_INLINE bool IOSystem::CreateDirectory( const std::string &path ) {
    if ( path.empty() ) {
        return false;
    }

#ifdef _WIN32
    return 0 != ::_mkdir( path.c_str() );
#else
    return 0 != ::mkdir( path.c_str(), 0777 );
#endif // _WIN32
}

// ----------------------------------------------------------------------------
AI_FORCE_INLINE bool IOSystem::ChangeDirectory( const std::string &path ) {
    if ( path.empty() ) {
        return false;
    }

#ifdef _WIN32
    return 0 != ::_chdir( path.c_str() );
#else
    return 0 != ::chdir( path.c_str() );
#endif // _WIN32
}


// ----------------------------------------------------------------------------
AI_FORCE_INLINE bool IOSystem::DeleteFile( const std::string &file ) {
    if ( file.empty() ) {
        return false;
    }
    const int retCode( ::remove( file.c_str() ) );
    return ( 0 == retCode );
}
} //!ns Assimp

#endif //AI_IOSYSTEM_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/Importer.hpp
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team



All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  Importer.hpp
 *  @brief Defines the C++-API to the Open Asset Import Library.
 */
#pragma once
#ifndef AI_ASSIMP_HPP_INC
#define AI_ASSIMP_HPP_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#ifndef __cplusplus
#error This header requires C++ to be used. Use assimp.h for plain C.
#endif // __cplusplus

// Public ASSIMP data structures
#include <assimp/types.h>

#include <exception>

namespace Assimp {
// =======================================================================
// Public interface to Assimp
class Importer;
class IOStream;
class IOSystem;
class ProgressHandler;

// =======================================================================
// Plugin development
//
// Include the following headers for the declarations:
// BaseImporter.h
// BaseProcess.h
class BaseImporter;
class BaseProcess;
class SharedPostProcessInfo;
class BatchLoader;

// =======================================================================
// Holy stuff, only for members of the high council of the Jedi.
class ImporterPimpl;
} // namespace Assimp

#define AI_PROPERTY_WAS_NOT_EXISTING 0xffffffff

struct aiScene;

// importerdesc.h
struct aiImporterDesc;

/** @namespace Assimp Assimp's CPP-API and all internal APIs */
namespace Assimp {

// ----------------------------------------------------------------------------------
/** CPP-API: The Importer class forms an C++ interface to the functionality of the
*   Open Asset Import Library.
*
* Create an object of this class and call ReadFile() to import a file.
* If the import succeeds, the function returns a pointer to the imported data.
* The data remains property of the object, it is intended to be accessed
* read-only. The imported data will be destroyed along with the Importer
* object. If the import fails, ReadFile() returns a nullptr pointer. In this
* case you can retrieve a human-readable error description be calling
* GetErrorString(). You can call ReadFile() multiple times with a single Importer
* instance. Actually, constructing Importer objects involves quite many
* allocations and may take some time, so it's better to reuse them as often as
* possible.
*
* If you need the Importer to do custom file handling to access the files,
* implement IOSystem and IOStream and supply an instance of your custom
* IOSystem implementation by calling SetIOHandler() before calling ReadFile().
* If you do not assign a custom IO handler, a default handler using the
* standard C++ IO logic will be used.
*
* @note One Importer instance is not thread-safe. If you use multiple
* threads for loading, each thread should maintain its own Importer instance.
*/
class ASSIMP_API Importer {
public:
    /**
     *  @brief The upper limit for hints.
     */
    static const unsigned int MaxLenHint = 200;

public:
    // -------------------------------------------------------------------
    /** Constructor. Creates an empty importer object.
     *
     * Call ReadFile() to start the import process. The configuration
     * property table is initially empty.
     */
    Importer();

    // -------------------------------------------------------------------
    /** Copy constructor.
     *
     * This copies the configuration properties of another Importer.
     * If this Importer owns a scene it won't be copied.
     * Call ReadFile() to start the import process.
     */
    Importer(const Importer &other) = delete;

    // -------------------------------------------------------------------
    /** Assignment operator has been deleted
     */
    Importer &operator=(const Importer &) = delete;

    // -------------------------------------------------------------------
    /** Destructor. The object kept ownership of the imported data,
     * which now will be destroyed along with the object.
     */
    ~Importer();

    // -------------------------------------------------------------------
    /** Registers a new loader.
     *
     * @param pImp Importer to be added. The Importer instance takes
     *   ownership of the pointer, so it will be automatically deleted
     *   with the Importer instance.
     * @return AI_SUCCESS if the loader has been added. The registration
     *   fails if there is already a loader for a specific file extension.
     */
    aiReturn RegisterLoader(BaseImporter *pImp);

    // -------------------------------------------------------------------
    /** Unregisters a loader.
     *
     * @param pImp Importer to be unregistered.
     * @return AI_SUCCESS if the loader has been removed. The function
     *   fails if the loader is currently in use (this could happen
     *   if the #Importer instance is used by more than one thread) or
     *   if it has not yet been registered.
     */
    aiReturn UnregisterLoader(BaseImporter *pImp);

    // -------------------------------------------------------------------
    /** Registers a new post-process step.
     *
     * At the moment, there's a small limitation: new post processing
     * steps are added to end of the list, or in other words, executed
     * last, after all built-in steps.
     * @param pImp Post-process step to be added. The Importer instance
     *   takes ownership of the pointer, so it will be automatically
     *   deleted with the Importer instance.
     * @return AI_SUCCESS if the step has been added correctly.
     */
    aiReturn RegisterPPStep(BaseProcess *pImp);

    // -------------------------------------------------------------------
    /** Unregisters a post-process step.
     *
     * @param pImp Step to be unregistered.
     * @return AI_SUCCESS if the step has been removed. The function
     *   fails if the step is currently in use (this could happen
     *   if the #Importer instance is used by more than one thread) or
     *   if it has not yet been registered.
     */
    aiReturn UnregisterPPStep(BaseProcess *pImp);

    // -------------------------------------------------------------------
    /** Set an integer configuration property.
     * @param szName Name of the property. All supported properties
     *   are defined in the aiConfig.g header (all constants share the
     *   prefix AI_CONFIG_XXX and are simple strings).
     * @param iValue New value of the property
     * @return true if the property was set before. The new value replaces
     *   the previous value in this case.
     * @note Property of different types (float, int, string ..) are kept
     *   on different stacks, so calling SetPropertyInteger() for a
     *   floating-point property has no effect - the loader will call
     *   GetPropertyFloat() to read the property, but it won't be there.
     */
    bool SetPropertyInteger(const char *szName, int iValue);

    // -------------------------------------------------------------------
    /** Set a boolean configuration property. Boolean properties
     *  are stored on the integer stack internally so it's possible
     *  to set them via #SetPropertyBool and query them with
     *  #GetPropertyBool and vice versa.
     * @see SetPropertyInteger()
     */
    bool SetPropertyBool(const char *szName, bool value) {
        return SetPropertyInteger(szName, value);
    }

    // -------------------------------------------------------------------
    /** Set a floating-point configuration property.
     * @see SetPropertyInteger()
     */
    bool SetPropertyFloat(const char *szName, ai_real fValue);

    // -------------------------------------------------------------------
    /** Set a string configuration property.
     * @see SetPropertyInteger()
     */
    bool SetPropertyString(const char *szName, const std::string &sValue);

    // -------------------------------------------------------------------
    /** Set a matrix configuration property.
     * @see SetPropertyInteger()
     */
    bool SetPropertyMatrix(const char *szName, const aiMatrix4x4 &sValue);

    // -------------------------------------------------------------------
    /** Set a pointer configuration property.
     * @see SetPropertyInteger()
     */
    bool SetPropertyPointer(const char *szName, void *sValue);

    // -------------------------------------------------------------------
    /** Get a configuration property.
     * @param szName Name of the property. All supported properties
     *   are defined in the aiConfig.g header (all constants share the
     *   prefix AI_CONFIG_XXX).
     * @param iErrorReturn Value that is returned if the property
     *   is not found.
     * @return Current value of the property
     * @note Property of different types (float, int, string ..) are kept
     *   on different lists, so calling SetPropertyInteger() for a
     *   floating-point property has no effect - the loader will call
     *   GetPropertyFloat() to read the property, but it won't be there.
     */
    int GetPropertyInteger(const char *szName,
            int iErrorReturn = 0xffffffff) const;

    // -------------------------------------------------------------------
    /** Get a boolean configuration property. Boolean properties
     *  are stored on the integer stack internally so it's possible
     *  to set them via #SetPropertyBool and query them with
     *  #GetPropertyBool and vice versa.
     * @see GetPropertyInteger()
     */
    bool GetPropertyBool(const char *szName, bool bErrorReturn = false) const {
        return GetPropertyInteger(szName, bErrorReturn) != 0;
    }

    // -------------------------------------------------------------------
    /** Get a floating-point configuration property
     * @see GetPropertyInteger()
     */
    ai_real GetPropertyFloat(const char *szName,
            ai_real fErrorReturn = 10e10) const;

    // -------------------------------------------------------------------
    /** Get a string configuration property
     *
     *  The return value remains valid until the property is modified.
     * @see GetPropertyInteger()
     */
    std::string GetPropertyString(const char *szName,
            const std::string &sErrorReturn = std::string()) const;

    // -------------------------------------------------------------------
    /** Get a matrix configuration property
     *
     *  The return value remains valid until the property is modified.
     * @see GetPropertyInteger()
     */
    aiMatrix4x4 GetPropertyMatrix(const char *szName,
            const aiMatrix4x4 &sErrorReturn = aiMatrix4x4()) const;

    // -------------------------------------------------------------------
    /** Get a pointer configuration property
     *
     *  The return value remains valid until the property is modified.
     * @see GetPropertyInteger()
     */
    void* GetPropertyPointer(const char *szName,
        void *sErrorReturn = nullptr) const;

    // -------------------------------------------------------------------
    /** Supplies a custom IO handler to the importer to use to open and
     * access files. If you need the importer to use custom IO logic to
     * access the files, you need to provide a custom implementation of
     * IOSystem and IOFile to the importer. Then create an instance of
     * your custom IOSystem implementation and supply it by this function.
     *
     * The Importer takes ownership of the object and will destroy it
     * afterwards. The previously assigned handler will be deleted.
     * Pass nullptr to take again ownership of your IOSystem and reset Assimp
     * to use its default implementation.
     *
     * @param pIOHandler The IO handler to be used in all file accesses
     *   of the Importer.
     */
    void SetIOHandler(IOSystem *pIOHandler);

    // -------------------------------------------------------------------
    /** Retrieves the IO handler that is currently set.
     * You can use #IsDefaultIOHandler() to check whether the returned
     * interface is the default IO handler provided by ASSIMP. The default
     * handler is active as long the application doesn't supply its own
     * custom IO handler via #SetIOHandler().
     * @return A valid IOSystem interface, never nullptr.
     */
    IOSystem *GetIOHandler() const;

    // -------------------------------------------------------------------
    /** Checks whether a default IO handler is active
     * A default handler is active as long the application doesn't
     * supply its own custom IO handler via #SetIOHandler().
     * @return true by default
     */
    bool IsDefaultIOHandler() const;

    // -------------------------------------------------------------------
    /** Supplies a custom progress handler to the importer. This
     *  interface exposes an #Update() callback, which is called
     *  more or less periodically (please don't sue us if it
     *  isn't as periodically as you'd like it to have ...).
     *  This can be used to implement progress bars and loading
     *  timeouts.
     *  @param pHandler Progress callback interface. Pass nullptr to
     *    disable progress reporting.
     *  @note Progress handlers can be used to abort the loading
     *    at almost any time.*/
    void SetProgressHandler(ProgressHandler *pHandler);

    // -------------------------------------------------------------------
    /** Retrieves the progress handler that is currently set.
     * You can use #IsDefaultProgressHandler() to check whether the returned
     * interface is the default handler provided by ASSIMP. The default
     * handler is active as long the application doesn't supply its own
     * custom handler via #SetProgressHandler().
     * @return A valid ProgressHandler interface, never nullptr.
     */
    ProgressHandler *GetProgressHandler() const;

    // -------------------------------------------------------------------
    /** Checks whether a default progress handler is active
     * A default handler is active as long the application doesn't
     * supply its own custom progress handler via #SetProgressHandler().
     * @return true by default
     */
    bool IsDefaultProgressHandler() const;

    // -------------------------------------------------------------------
    /** @brief Check whether a given set of post-processing flags
     *  is supported.
     *
     *  Some flags are mutually exclusive, others are probably
     *  not available because your excluded them from your
     *  Assimp builds. Calling this function is recommended if
     *  you're unsure.
     *
     *  @param pFlags Bitwise combination of the aiPostProcess flags.
     *  @return true if this flag combination is fine.
     */
    bool ValidateFlags(unsigned int pFlags) const;

    // -------------------------------------------------------------------
    /** Reads the given file and returns its contents if successful.
     *
     * If the call succeeds, the contents of the file are returned as a
     * pointer to an aiScene object. The returned data is intended to be
     * read-only, the importer object keeps ownership of the data and will
     * destroy it upon destruction. If the import fails, nullptr is returned.
     * A human-readable error description can be retrieved by calling
     * GetErrorString(). The previous scene will be deleted during this call.
     * @param pFile Path and filename to the file to be imported.
     * @param pFlags Optional post processing steps to be executed after
     *   a successful import. Provide a bitwise combination of the
     *   #aiPostProcessSteps flags. If you wish to inspect the imported
     *   scene first in order to fine-tune your post-processing setup,
     *   consider to use #ApplyPostProcessing().
     * @return A pointer to the imported data, nullptr if the import failed.
     *   The pointer to the scene remains in possession of the Importer
     *   instance. Use GetOrphanedScene() to take ownership of it.
     *
     * @note Assimp is able to determine the file format of a file
     * automatically.
     */
    const aiScene *ReadFile(
            const char *pFile,
            unsigned int pFlags);

    // -------------------------------------------------------------------
    /** Reads the given file from a memory buffer and returns its
     *  contents if successful.
     *
     * If the call succeeds, the contents of the file are returned as a
     * pointer to an aiScene object. The returned data is intended to be
     * read-only, the importer object keeps ownership of the data and will
     * destroy it upon destruction. If the import fails, nullptr is returned.
     * A human-readable error description can be retrieved by calling
     * GetErrorString(). The previous scene will be deleted during this call.
     * Calling this method doesn't affect the active IOSystem.
     * @param pBuffer Pointer to the file data
     * @param pLength Length of pBuffer, in bytes
     * @param pFlags Optional post processing steps to be executed after
     *   a successful import. Provide a bitwise combination of the
     *   #aiPostProcessSteps flags. If you wish to inspect the imported
     *   scene first in order to fine-tune your post-processing setup,
     *   consider to use #ApplyPostProcessing().
     * @param pHint An additional hint to the library. If this is a non
     *   empty string, the library looks for a loader to support
     *   the file extension specified by pHint and passes the file to
     *   the first matching loader. If this loader is unable to completely
     *   the request, the library continues and tries to determine the
     *   file format on its own, a task that may or may not be successful.
     *   Check the return value, and you'll know ...
     * @return A pointer to the imported data, nullptr if the import failed.
     *   The pointer to the scene remains in possession of the Importer
     *   instance. Use GetOrphanedScene() to take ownership of it.
     *
     * @note This is a straightforward way to decode models from memory
     * buffers, but it doesn't handle model formats that spread their
     * data across multiple files or even directories. Examples include
     * OBJ or MD3, which outsource parts of their material info into
     * external scripts. If you need full functionality, provide
     * a custom IOSystem to make Assimp find these files and use
     * the regular ReadFile() API.
     */
    const aiScene *ReadFileFromMemory(
            const void *pBuffer,
            size_t pLength,
            unsigned int pFlags,
            const char *pHint = "");

    // -------------------------------------------------------------------
    /** Apply post-processing to an already-imported scene.
     *
     *  This is strictly equivalent to calling #ReadFile() with the same
     *  flags. However, you can use this separate function to inspect
     *  the imported scene first to fine-tune your post-processing setup.
     *  @param pFlags Provide a bitwise combination of the
     *   #aiPostProcessSteps flags.
     *  @return A pointer to the post-processed data. This is still the
     *   same as the pointer returned by #ReadFile(). However, if
     *   post-processing fails, the scene could now be nullptr.
     *   That's quite a rare case, post processing steps are not really
     *   designed to 'fail'. To be exact, the #aiProcess_ValidateDS
     *   flag is currently the only post processing step which can actually
     *   cause the scene to be reset to nullptr.
     *
     *  @note The method does nothing if no scene is currently bound
     *    to the #Importer instance.  */
    const aiScene *ApplyPostProcessing(unsigned int pFlags);

    const aiScene *ApplyCustomizedPostProcessing(BaseProcess *rootProcess, bool requestValidation);

    // -------------------------------------------------------------------
    /** @brief Reads the given file and returns its contents if successful.
     *
     * This function is provided for backward compatibility.
     * See the const char* version for detailed docs.
     * @see ReadFile(const char*, pFlags)  */
    const aiScene *ReadFile(
            const std::string &pFile,
            unsigned int pFlags);

    // -------------------------------------------------------------------
    /** Frees the current scene.
     *
     *  The function does nothing if no scene has previously been
     *  read via ReadFile(). FreeScene() is called automatically by the
     *  destructor and ReadFile() itself.  */
    void FreeScene();

    // -------------------------------------------------------------------
    /** Returns an error description of an error that occurred in ReadFile().
     *
     * Returns an empty string if no error occurred.
     * @return A description of the last error, an empty string if no
     *   error occurred. The string is never nullptr.
     *
     * @note The returned function remains valid until one of the
     * following methods is called: #ReadFile(), #FreeScene(). */
    const char *GetErrorString() const;

    // -------------------------------------------------------------------
    /** Returns an exception if one occurred during import.
     *
     * @return The last exception which occurred.
     *
     * @note The returned value remains valid until one of the
     * following methods is called: #ReadFile(), #FreeScene(). */
    const std::exception_ptr& GetException() const;

    // -------------------------------------------------------------------
    /** Returns the scene loaded by the last successful call to ReadFile()
     *
     * @return Current scene or nullptr if there is currently no scene loaded */
    const aiScene *GetScene() const;

    // -------------------------------------------------------------------
    /** Returns the scene loaded by the last successful call to ReadFile()
     *  and releases the scene from the ownership of the Importer
     *  instance. The application is now responsible for deleting the
     *  scene. Any further calls to GetScene() or GetOrphanedScene()
     *  will return nullptr - until a new scene has been loaded via ReadFile().
     *
     * @return Current scene or nullptr if there is currently no scene loaded
     * @note Use this method with maximal caution, and only if you have to.
     *   By design, aiScene's are exclusively maintained, allocated and
     *   deallocated by Assimp and no one else. The reasoning behind this
     *   is the golden rule that deallocations should always be done
     *   by the module that did the original allocation because heaps
     *   are not necessarily shared. GetOrphanedScene() enforces you
     *   to delete the returned scene by yourself, but this will only
     *   be fine if and only if you're using the same heap as assimp.
     *   On Windows, it's typically fine provided everything is linked
     *   against the multithreaded-dll version of the runtime library.
     *   It will work as well for static linkage with Assimp.*/
    aiScene *GetOrphanedScene();

    // -------------------------------------------------------------------
    /** Returns whether a given file extension is supported by ASSIMP.
     *
     * @param szExtension Extension to be checked.
     *   Must include a trailing dot '.'. Example: ".3ds", ".md3".
     *   Cases-insensitive.
     * @return true if the extension is supported, false otherwise */
    bool IsExtensionSupported(const char *szExtension) const;

    // -------------------------------------------------------------------
    /** @brief Returns whether a given file extension is supported by ASSIMP.
     *
     * This function is provided for backward compatibility.
     * See the const char* version for detailed and up-to-date docs.
     * @see IsExtensionSupported(const char*) */
    inline bool IsExtensionSupported(const std::string &szExtension) const;

    // -------------------------------------------------------------------
    /** Get a full list of all file extensions supported by ASSIMP.
     *
     * If a file extension is contained in the list this does of course not
     * mean that ASSIMP is able to load all files with this extension ---
     * it simply means there is an importer loaded which claims to handle
     * files with this file extension.
     * @param szOut String to receive the extension list.
     *   Format of the list: "*.3ds;*.obj;*.dae". This is useful for
     *   use with the WinAPI call GetOpenFileName(Ex). */
    void GetExtensionList(aiString &szOut) const;

    // -------------------------------------------------------------------
    /** @brief Get a full list of all file extensions supported by ASSIMP.
     *
     * This function is provided for backward compatibility.
     * See the aiString version for detailed and up-to-date docs.
     * @see GetExtensionList(aiString&)*/
    inline void GetExtensionList(std::string &szOut) const;

    // -------------------------------------------------------------------
    /** Get the number of importers currently registered with Assimp. */
    size_t GetImporterCount() const;

    // -------------------------------------------------------------------
    /** Get meta data for the importer corresponding to a specific index..
    *
    *  For the declaration of #aiImporterDesc, include <assimp/importerdesc.h>.
    *  @param index Index to query, must be within [0,GetImporterCount())
    *  @return Importer meta data structure, nullptr if the index does not
    *     exist or if the importer doesn't offer meta information (
    *     importers may do this at the cost of being hated by their peers).*/
    const aiImporterDesc *GetImporterInfo(size_t index) const;

    // -------------------------------------------------------------------
    /** Find the importer corresponding to a specific index.
    *
    *  @param index Index to query, must be within [0,GetImporterCount())
    *  @return Importer instance. nullptr if the index does not
    *     exist. */
    BaseImporter *GetImporter(size_t index) const;

    // -------------------------------------------------------------------
    /** Find the importer corresponding to a specific file extension.
    *
    *  This is quite similar to #IsExtensionSupported except a
    *  BaseImporter instance is returned.
    *  @param szExtension Extension to check for. The following formats
    *    are recognized (BAH being the file extension): "BAH" (comparison
    *    is case-insensitive), ".bah", "*.bah" (wild card and dot
    *    characters at the beginning of the extension are skipped).
    *  @return nullptr if no importer is found*/
    BaseImporter *GetImporter(const char *szExtension) const;

    // -------------------------------------------------------------------
    /** Find the importer index corresponding to a specific file extension.
    *
    *  @param szExtension Extension to check for. The following formats
    *    are recognized (BAH being the file extension): "BAH" (comparison
    *    is case-insensitive), ".bah", "*.bah" (wild card and dot
    *    characters at the beginning of the extension are skipped).
    *  @return (size_t)-1 if no importer is found */
    size_t GetImporterIndex(const char *szExtension) const;

    // -------------------------------------------------------------------
    /** Returns the storage allocated by ASSIMP to hold the scene data
     * in memory.
     *
     * This refers to the currently loaded file, see #ReadFile().
     * @param in Data structure to be filled.
     * @note The returned memory statistics refer to the actual
     *   size of the use data of the aiScene. Heap-related overhead
     *   is (naturally) not included.*/
    void GetMemoryRequirements(aiMemoryInfo &in) const;

    // -------------------------------------------------------------------
    /** Enables "extra verbose" mode.
     *
     * 'Extra verbose' means the data structure is validated after *every*
     * single post processing step to make sure everyone modifies the data
     * structure in a well-defined manner. This is a debug feature and not
     * intended for use in production environments. */
    void SetExtraVerbose(bool bDo);

    // -------------------------------------------------------------------
    /** Private, do not use. */
    ImporterPimpl *Pimpl() { return pimpl; }
    const ImporterPimpl *Pimpl() const { return pimpl; }

protected:
    // Just because we don't want you to know how we're hacking around.
    ImporterPimpl *pimpl;
}; //! class Importer

// ----------------------------------------------------------------------------
// For compatibility, the interface of some functions taking a std::string was
// changed to const char* to avoid crashes between binary incompatible STL
// versions. This code her is inlined,  so it shouldn't cause any problems.
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
AI_FORCE_INLINE const aiScene *Importer::ReadFile(const std::string &pFile, unsigned int pFlags) {
    return ReadFile(pFile.c_str(), pFlags);
}
// ----------------------------------------------------------------------------
AI_FORCE_INLINE void Importer::GetExtensionList(std::string &szOut) const {
    aiString s;
    GetExtensionList(s);
    szOut = s.data;
}
// ----------------------------------------------------------------------------
AI_FORCE_INLINE bool Importer::IsExtensionSupported(const std::string &szExtension) const {
    return IsExtensionSupported(szExtension.c_str());
}

} // namespace Assimp

#endif // AI_ASSIMP_HPP_INC


============================================================
File Path: project/externals/assimp/include/assimp/LineSplitter.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  LineSplitter.h
 *  @brief LineSplitter, a helper class to iterate through all lines
 *    of a file easily. Works with StreamReader.
 */
#pragma once
#ifndef INCLUDED_LINE_SPLITTER_H
#define INCLUDED_LINE_SPLITTER_H

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <stdexcept>
#include <assimp/StreamReader.h>
#include <assimp/ParsingUtils.h>

namespace Assimp {

// ------------------------------------------------------------------------------------------------
/** Usage:
@code
for(LineSplitter splitter(stream);splitter;++splitter) {

    if (*splitter == "hi!") {
       ...
    }
    else if (splitter->substr(0,5) == "hello") {
       ...
       // access the third token in the line (tokens are space-separated)
       if (strtol(splitter[2]) > 5) { .. }
    }

    ASSIMP_LOG_VERBOSE_DEBUG("Current line is: ", splitter.get_index());
}
@endcode
*/
// ------------------------------------------------------------------------------------------------
class LineSplitter {
public:
    typedef size_t line_idx;

    // -----------------------------------------
    /** construct from existing stream reader
    note: trim is *always* assumed true if skyp_empty_lines==true
    */
    LineSplitter(StreamReaderLE& stream, bool skip_empty_lines = true, bool trim = true);

    ~LineSplitter();

    // -----------------------------------------
    /** pseudo-iterator increment */
    LineSplitter& operator++();

    // -----------------------------------------
    LineSplitter& operator++(int);

    // -----------------------------------------
    /** get a pointer to the beginning of a particular token */
    const char* operator[] (size_t idx) const;

    // -----------------------------------------
    /** extract the start positions of N tokens from the current line*/
    template <size_t N>
    void get_tokens(const char* (&tokens)[N]) const;

    // -----------------------------------------
    /** member access */
    const std::string* operator -> () const;

    std::string operator* () const;

    // -----------------------------------------
    /** boolean context */
    operator bool() const;

    // -----------------------------------------
    /** line indices are zero-based, empty lines are included */
    operator line_idx() const;

    line_idx get_index() const;

    // -----------------------------------------
    /** access the underlying stream object */
    StreamReaderLE& get_stream();

    // -----------------------------------------
    /** !strcmp((*this)->substr(0,strlen(check)),check) */
    bool match_start(const char* check);

    // -----------------------------------------
    /** swallow the next call to ++, return the previous value. */
    void swallow_next_increment();

    LineSplitter( const LineSplitter & ) = delete;
    LineSplitter(LineSplitter &&) = delete;
    LineSplitter &operator = ( const LineSplitter & ) = delete;

private:
    line_idx mIdx;
    std::string mCur;
    StreamReaderLE& mStream;
    bool mSwallow, mSkip_empty_lines, mTrim;
};

AI_FORCE_INLINE LineSplitter::LineSplitter(StreamReaderLE& stream, bool skip_empty_lines, bool trim ) :
        mIdx(0),
        mStream(stream),
        mSwallow(),
        mSkip_empty_lines(skip_empty_lines),
        mTrim(trim) {
    mCur.reserve(1024);
    operator++();
    mIdx = 0;
}

AI_FORCE_INLINE LineSplitter::~LineSplitter() = default;

AI_FORCE_INLINE LineSplitter& LineSplitter::operator++() {
    if (mSwallow) {
        mSwallow = false;
        return *this;
    }

    if (!*this) {
        throw std::logic_error("End of file, no more lines to be retrieved.");
    }

    char s;
    mCur.clear();
    while (mStream.GetRemainingSize() && (s = mStream.GetI1(), 1)) {
        if (s == '\n' || s == '\r') {
            if (mSkip_empty_lines) {
                while (mStream.GetRemainingSize() && ((s = mStream.GetI1()) == ' ' || s == '\r' || s == '\n'));
                if (mStream.GetRemainingSize()) {
                    mStream.IncPtr(-1);
                }
            } else {
                // skip both potential line terminators but don't read past this line.
                if (mStream.GetRemainingSize() && (s == '\r' && mStream.GetI1() != '\n')) {
                    mStream.IncPtr(-1);
                }
                if (mTrim) {
                    while (mStream.GetRemainingSize() && ((s = mStream.GetI1()) == ' ' || s == '\t'));
                    if (mStream.GetRemainingSize()) {
                        mStream.IncPtr(-1);
                    }
                }
            }
            break;
        }
        mCur += s;
    }
    ++mIdx;

    return *this;
}

AI_FORCE_INLINE LineSplitter &LineSplitter::operator++(int) {
    return ++(*this);
}

AI_FORCE_INLINE const char *LineSplitter::operator[] (size_t idx) const {
    const char* s = operator->()->c_str();

    SkipSpaces(&s);
    for (size_t i = 0; i < idx; ++i) {
        for (; !IsSpace(*s); ++s) {
            if (IsLineEnd(*s)) {
                throw std::range_error("Token index out of range, EOL reached");
            }
        }
        SkipSpaces(&s);
    }
    return s;
}

template <size_t N>
AI_FORCE_INLINE void LineSplitter::get_tokens(const char* (&tokens)[N]) const {
    const char* s = operator->()->c_str();

    SkipSpaces(&s);
    for (size_t i = 0; i < N; ++i) {
        if (IsLineEnd(*s)) {
            throw std::range_error("Token count out of range, EOL reached");
        }
        tokens[i] = s;

        for (; *s && !IsSpace(*s); ++s);
        SkipSpaces(&s);
    }
}

AI_FORCE_INLINE const std::string* LineSplitter::operator -> () const {
    return &mCur;
}

AI_FORCE_INLINE std::string LineSplitter::operator* () const {
    return mCur;
}

AI_FORCE_INLINE LineSplitter::operator bool() const {
    return mStream.GetRemainingSize() > 0;
}

AI_FORCE_INLINE LineSplitter::operator line_idx() const {
    return mIdx;
}

AI_FORCE_INLINE LineSplitter::line_idx LineSplitter::get_index() const {
    return mIdx;
}

AI_FORCE_INLINE StreamReaderLE &LineSplitter::get_stream() {
    return mStream;
}

AI_FORCE_INLINE bool LineSplitter::match_start(const char* check) {
    const size_t len = ::strlen(check);

    return len <= mCur.length() && std::equal(check, check + len, mCur.begin());
}

AI_FORCE_INLINE void LineSplitter::swallow_next_increment() {
    mSwallow = true;
}

} // Namespace Assimp

#endif // INCLUDED_LINE_SPLITTER_H


============================================================
File Path: project/externals/assimp/include/assimp/LogAux.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  LogAux.h
 *  @brief Common logging usage patterns for importer implementations
 */
#pragma once
#ifndef INCLUDED_AI_LOGAUX_H
#define INCLUDED_AI_LOGAUX_H

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/TinyFormatter.h>
#include <assimp/Exceptional.h>
#include <assimp/DefaultLogger.hpp>

namespace Assimp {

/// @brief Logger class, which will extend the class by log-functions.
/// @tparam TDeriving
template<class TDeriving>
class LogFunctions {
public:
    // ------------------------------------------------------------------------------------------------
    template<typename... T>
    static void ThrowException(T&&... args)
    {
        throw DeadlyImportError(Prefix(), std::forward<T>(args)...);
    }

    // ------------------------------------------------------------------------------------------------
    template<typename... T>
    static void LogWarn(T&&... args) {
        if (!DefaultLogger::isNullLogger()) {
            ASSIMP_LOG_WARN(Prefix(), std::forward<T>(args)...);
        }
    }

    // ------------------------------------------------------------------------------------------------
    template<typename... T>
    static void LogError(T&&... args)  {
        if (!DefaultLogger::isNullLogger()) {
            ASSIMP_LOG_ERROR(Prefix(), std::forward<T>(args)...);
        }
    }

    // ------------------------------------------------------------------------------------------------
    template<typename... T>
    static void LogInfo(T&&... args)  {
        if (!DefaultLogger::isNullLogger()) {
            ASSIMP_LOG_INFO(Prefix(), std::forward<T>(args)...);
        }
    }

    // ------------------------------------------------------------------------------------------------
    template<typename... T>
    static void LogDebug(T&&... args)  {
        if (!DefaultLogger::isNullLogger()) {
            ASSIMP_LOG_DEBUG(Prefix(), std::forward<T>(args)...);
        }
    }

    // ------------------------------------------------------------------------------------------------
    template<typename... T>
    static void LogVerboseDebug(T&&... args)  {
        if (!DefaultLogger::isNullLogger()) {
            ASSIMP_LOG_VERBOSE_DEBUG(Prefix(), std::forward<T>(args)...);
        }
    }

private:
    static const char* Prefix();
};

} // ! Assimp

#endif // INCLUDED_AI_LOGAUX_H


============================================================
File Path: project/externals/assimp/include/assimp/LogStream.hpp
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file LogStream.hpp
 *  @brief Abstract base class 'LogStream', representing an output log stream.
 */
#pragma once
#ifndef INCLUDED_AI_LOGSTREAM_H
#define INCLUDED_AI_LOGSTREAM_H

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include "types.h"

namespace Assimp {

class IOSystem;

// ------------------------------------------------------------------------------------
/** @brief CPP-API: Abstract interface for log stream implementations.
 *
 *  Several default implementations are provided, see #aiDefaultLogStream for more
 *  details. Writing your own implementation of LogStream is just necessary if these
 *  are not enough for your purpose. */
class ASSIMP_API LogStream
#ifndef SWIG
        : public Intern::AllocateFromAssimpHeap
#endif
{
protected:
    /** @brief  Default constructor */
    LogStream() AI_NO_EXCEPT;

public:
    /** @brief  Virtual destructor  */
    virtual ~LogStream();

    // -------------------------------------------------------------------
    /** @brief  Overwrite this for your own output methods
     *
     *  Log messages *may* consist of multiple lines and you shouldn't
     *  expect a consistent formatting. If you want custom formatting
     *  (e.g. generate HTML), supply a custom instance of Logger to
     *  #DefaultLogger:set(). Usually you can *expect* that a log message
     *  is exactly one line and terminated with a single \n character.
     *  @param message Message to be written */
    virtual void write(const char *message) = 0;

    // -------------------------------------------------------------------
    /** @brief Creates a default log stream
     *  @param streams Type of the default stream
     *  @param name For aiDefaultLogStream_FILE: name of the output file
     *  @param io For aiDefaultLogStream_FILE: IOSystem to be used to open the output
     *   file. Pass nullptr for the default implementation.
     *  @return New LogStream instance.  */
    static LogStream *createDefaultStream(aiDefaultLogStream stream,
            const char *name = "AssimpLog.txt",
            IOSystem *io = nullptr);

}; // !class LogStream

inline LogStream::LogStream() AI_NO_EXCEPT = default;

inline LogStream::~LogStream() = default;

} // Namespace Assimp

#endif // INCLUDED_AI_LOGSTREAM_H


============================================================
File Path: project/externals/assimp/include/assimp/Logger.hpp
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Logger.hpp
 *  @brief Abstract base class 'Logger', base of the logging system.
 */
#pragma once
#ifndef INCLUDED_AI_LOGGER_H
#define INCLUDED_AI_LOGGER_H

#include <assimp/types.h>
#include <assimp/TinyFormatter.h>

namespace Assimp {

class LogStream;

// Maximum length of a log message. Longer messages are rejected.
#define MAX_LOG_MESSAGE_LENGTH 1024u

// ----------------------------------------------------------------------------------
/** @brief CPP-API: Abstract interface for logger implementations.
 *  Assimp provides a default implementation and uses it for almost all
 *  logging stuff ('DefaultLogger'). This class defines just basic logging
 *  behavior and is not of interest for you. Instead, take a look at #DefaultLogger. */
class ASSIMP_API Logger
#ifndef SWIG
    : public Intern::AllocateFromAssimpHeap
#endif
{
public:

    // ----------------------------------------------------------------------
    /** @enum   LogSeverity
     *  @brief  Log severity to describe the granularity of logging.
     */
    enum LogSeverity {
        NORMAL,     ///< Normal granularity of logging
        DEBUGGING,  ///< Debug messages will be logged, but not verbose debug messages.
        VERBOSE     ///< All messages will be logged
    };

    // ----------------------------------------------------------------------
    /** @enum   ErrorSeverity
     *  @brief  Description for severity of a log message.
     *
     *  Every LogStream has a bitwise combination of these flags.
     *  A LogStream doesn't receive any messages of a specific type
     *  if it doesn't specify the corresponding ErrorSeverity flag.
     */
    enum ErrorSeverity {
        Debugging   = 1,    //!< Debug log message
        Info        = 2,    //!< Info log message
        Warn        = 4,    //!< Warn log message
        Err         = 8     //!< Error log message
    };

    /** @brief  Virtual destructor */
    virtual ~Logger();

    // ----------------------------------------------------------------------
    /** @brief  Writes a debug message
     *  @param  message Debug message*/
    void debug(const char* message);

    template<typename... T>
    void debug(T&&... args) {
        debug(formatMessage(std::forward<T>(args)...).c_str());
    }

    // ----------------------------------------------------------------------
    /** @brief  Writes a debug message
     *   @param message Debug message*/
    void verboseDebug(const char* message);

    template<typename... T>
    void verboseDebug(T&&... args) {
        verboseDebug(formatMessage(std::forward<T>(args)...).c_str());
    }

    // ----------------------------------------------------------------------
    /** @brief  Writes a info message
     *  @param  message Info message*/
    void info(const char* message);

    template<typename... T>
    void info(T&&... args) {
        info(formatMessage(std::forward<T>(args)...).c_str());
    }

    // ----------------------------------------------------------------------
    /** @brief  Writes a warning message
     *  @param  message Warn message*/
    void warn(const char* message);

    template<typename... T>
    void warn(T&&... args) {
        warn(formatMessage(std::forward<T>(args)...).c_str());
    }

    // ----------------------------------------------------------------------
    /** @brief  Writes an error message
     *  @param  message Error message*/
    void error(const char* message);

    template<typename... T>
    void error(T&&... args) {
        error(formatMessage(std::forward<T>(args)...).c_str());
    }

    // ----------------------------------------------------------------------
    /** @brief  Set a new log severity.
     *  @param  log_severity New severity for logging*/
    void setLogSeverity(LogSeverity log_severity);

    // ----------------------------------------------------------------------
    /** @brief Get the current log severity*/
    LogSeverity getLogSeverity() const;

    // ----------------------------------------------------------------------
    /** @brief  Attach a new log-stream
     *
     *  The logger takes ownership of the stream and is responsible
     *  for its destruction (which is done using ::delete when the logger
     *  itself is destroyed). Call detachStream to detach a stream and to
     *  gain ownership of it again.
     *   @param pStream  Log-stream to attach
     *  @param severity  Message filter, specified which types of log
     *    messages are dispatched to the stream. Provide a bitwise
     *    combination of the ErrorSeverity flags.
     *  @return true if the stream has been attached, false otherwise.*/
    virtual bool attachStream(LogStream *pStream,
        unsigned int severity = Debugging | Err | Warn | Info) = 0;

    // ----------------------------------------------------------------------
    /** @brief  Detach a still attached stream from the logger (or
     *          modify the filter flags bits)
     *   @param pStream Log-stream instance for detaching
     *  @param severity Provide a bitwise combination of the ErrorSeverity
     *    flags. This value is &~ed with the current flags of the stream,
     *    if the result is 0 the stream is detached from the Logger and
     *    the caller retakes the possession of the stream.
     *  @return true if the stream has been detached, false otherwise.*/
    virtual bool detachStream(LogStream *pStream,
        unsigned int severity = Debugging | Err | Warn | Info) = 0;

protected:
    /**
     *  Default constructor
     */
    Logger() AI_NO_EXCEPT;

    /**
     *  Construction with a given log severity
     */
    explicit Logger(LogSeverity severity);

    // ----------------------------------------------------------------------
    /**
     *  @brief Called as a request to write a specific debug message
     *  @param  message Debug message. Never longer than
     *    MAX_LOG_MESSAGE_LENGTH characters (excluding the '0').
     *  @note  The message string is only valid until the scope of
     *    the function is left.
     */
    virtual void OnDebug(const char* message)= 0;

    // ----------------------------------------------------------------------
	/**
     *  @brief Called as a request to write a specific verbose debug message
     *  @param  message Debug message. Never longer than
     *    MAX_LOG_MESSAGE_LENGTH characters (excluding the '0').
     *  @note  The message string is only valid until the scope of
     *    the function is left.
     */
	virtual void OnVerboseDebug(const char *message) = 0;

    // ----------------------------------------------------------------------
    /**
     *  @brief Called as a request to write a specific info message
     *  @param  message Info message. Never longer than
     *    MAX_LOG_MESSAGE_LENGTH characters (ecxluding the '0').
     *  @note  The message string is only valid until the scope of
     *    the function is left.
     */
    virtual void OnInfo(const char* message) = 0;

    // ----------------------------------------------------------------------
    /**
     *  @brief Called as a request to write a specific warn message
     *  @param  message Warn message. Never longer than
     *    MAX_LOG_MESSAGE_LENGTH characters (exluding the '0').
     *  @note  The message string is only valid until the scope of
     *    the function is left.
     */
    virtual void OnWarn(const char* essage) = 0;

    // ----------------------------------------------------------------------
    /**
     *  @brief Called as a request to write a specific error message
     *  @param  message Error message. Never longer than
     *    MAX_LOG_MESSAGE_LENGTH characters (exluding the '0').
     *  @note  The message string is only valid until the scope of
     *    the function is left.
     */
    virtual void OnError(const char* message) = 0;
protected:
    std::string formatMessage(Assimp::Formatter::format f) {
        return f;
    }

    template<typename... T, typename U>
    std::string formatMessage(Assimp::Formatter::format f, U&& u, T&&... args) {
        return formatMessage(std::move(f << std::forward<U>(u)), std::forward<T>(args)...);
    }

protected:
    LogSeverity m_Severity;
};

// ----------------------------------------------------------------------------------
inline Logger::Logger() AI_NO_EXCEPT :
        m_Severity(NORMAL) {
    // empty
}

// ----------------------------------------------------------------------------------
inline Logger::~Logger() = default;

// ----------------------------------------------------------------------------------
inline Logger::Logger(LogSeverity severity) :
        m_Severity(severity) {
    // empty
}

// ----------------------------------------------------------------------------------
inline void Logger::setLogSeverity(LogSeverity log_severity){
    m_Severity = log_severity;
}

// ----------------------------------------------------------------------------------
// Log severity getter
inline Logger::LogSeverity Logger::getLogSeverity() const {
    return m_Severity;
}

} // Namespace Assimp

// ------------------------------------------------------------------------------------------------
#define ASSIMP_LOG_WARN(...) \
	Assimp::DefaultLogger::get()->warn(__VA_ARGS__)

#define ASSIMP_LOG_ERROR(...) \
	Assimp::DefaultLogger::get()->error(__VA_ARGS__)

#define ASSIMP_LOG_DEBUG(...) \
	Assimp::DefaultLogger::get()->debug(__VA_ARGS__)

#define ASSIMP_LOG_VERBOSE_DEBUG(...) \
	Assimp::DefaultLogger::get()->verboseDebug(__VA_ARGS__)

#define ASSIMP_LOG_INFO(...) \
	Assimp::DefaultLogger::get()->info(__VA_ARGS__)

#endif // !! INCLUDED_AI_LOGGER_H


============================================================
File Path: project/externals/assimp/include/assimp/MathFunctions.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

#pragma once

#ifdef __GNUC__
#   pragma GCC system_header
#endif

/** @file  MathFunctions.h
*  @brief Implementation of math utility functions.
 *
*/

#include <limits>

namespace Assimp {
namespace Math {

/// @brief  Will return the greatest common divisor.
/// @param  a   [in] Value a.
/// @param  b   [in] Value b.
/// @return The greatest common divisor.
template <typename IntegerType>
inline IntegerType gcd( IntegerType a, IntegerType b ) {
	const IntegerType zero = (IntegerType)0;
	while ( true ) {
		if ( a == zero ) {
			return b;
        }
		b %= a;

		if ( b == zero ) {
			return a;
        }
		a %= b;
	}
}

/// @brief  Will return the greatest common divisor.
/// @param  a   [in] Value a.
/// @param  b   [in] Value b.
/// @return The greatest common divisor.
template < typename IntegerType >
inline IntegerType lcm( IntegerType a, IntegerType b ) {
	const IntegerType t = gcd (a,b);
	if (!t) {
        return t;
    }
	return a / t * b;
}
/// @brief  Will return the smallest epsilon-value for the requested type.
/// @return The numercical limit epsilon depending on its type.
template<class T>
inline T getEpsilon() {
    return std::numeric_limits<T>::epsilon();
}

/// @brief  Will return the constant PI for the requested type.
/// @return Pi
template<class T>
inline T aiPi() {
    return static_cast<T>(3.14159265358979323846);
}

} // namespace Math
} // namespace Assimp


============================================================
File Path: project/externals/assimp/include/assimp/MemoryIOWrapper.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file MemoryIOWrapper.h
 *  Handy IOStream/IOSystem implementation to read directly from a memory buffer */
#pragma once
#ifndef AI_MEMORYIOSTREAM_H_INC
#define AI_MEMORYIOSTREAM_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/IOStream.hpp>
#include <assimp/IOSystem.hpp>
#include <assimp/ai_assert.h>

#include <stdint.h>

namespace Assimp    {

#define AI_MEMORYIO_MAGIC_FILENAME "$$$___magic___$$$"
#define AI_MEMORYIO_MAGIC_FILENAME_LENGTH 17

// ----------------------------------------------------------------------------------
/** Implementation of IOStream to read directly from a memory buffer */
// ----------------------------------------------------------------------------------
class MemoryIOStream : public IOStream {
public:
    MemoryIOStream (const uint8_t* buff, size_t len, bool own = false) :
            buffer (buff),
            length(len),
            pos(static_cast<size_t>(0)),
            own(own) {
        // empty
    }

    ~MemoryIOStream() override  {
        if(own) {
            delete[] buffer;
        }
    }

    size_t Read(void* pvBuffer, size_t pSize, size_t pCount) override {
        ai_assert(nullptr != pvBuffer);
        ai_assert(0 != pSize);

        const size_t cnt = std::min( pCount, (length-pos) / pSize);
        const size_t ofs = pSize * cnt;

        ::memcpy(pvBuffer,buffer+pos,ofs);
        pos += ofs;

        return cnt;
    }

    size_t Write(const void*, size_t, size_t ) override {
        ai_assert(false); // won't be needed
        return 0;
    }

    aiReturn Seek(size_t pOffset, aiOrigin pOrigin) override {
        if (aiOrigin_SET == pOrigin) {
            if (pOffset > length) {
                return AI_FAILURE;
            }
            pos = pOffset;
        } else if (aiOrigin_END == pOrigin) {
            if (pOffset > length) {
                return AI_FAILURE;
            }
            pos = length-pOffset;
        } else {
            if (pOffset+pos > length) {
                return AI_FAILURE;
            }
            pos += pOffset;
        }
        return AI_SUCCESS;
    }

    size_t Tell() const override {
        return pos;
    }

    size_t FileSize() const override {
        return length;
    }

    void Flush() override{
        ai_assert(false); // won't be needed
    }

private:
    const uint8_t* buffer;
    size_t length,pos;
    bool own;
};

// ---------------------------------------------------------------------------
/// @brief Dummy IO system to read from a memory buffer.
class MemoryIOSystem : public IOSystem {
public:
    /// @brief Constructor.
    MemoryIOSystem(const uint8_t* buff, size_t len, IOSystem* io) : buffer(buff), length(len), existing_io(io) {
        // empty
    }

    /// @brief Destructor.
    ~MemoryIOSystem() override = default;

    // -------------------------------------------------------------------
    /// @brief Tests for the existence of a file at the given path.
    bool Exists(const char* pFile) const override {
        if (0 == strncmp( pFile, AI_MEMORYIO_MAGIC_FILENAME, AI_MEMORYIO_MAGIC_FILENAME_LENGTH ) ) {
            return true;
        }
        return existing_io ? existing_io->Exists(pFile) : false;
    }

    // -------------------------------------------------------------------
    /// @brief Returns the directory separator.
    char getOsSeparator() const override {
        return existing_io ? existing_io->getOsSeparator()
                           : '/';  // why not? it doesn't care
    }

    // -------------------------------------------------------------------
    /// @brief Open a new file with a given path.
    IOStream* Open(const char* pFile, const char* pMode = "rb") override {
        if ( 0 == strncmp( pFile, AI_MEMORYIO_MAGIC_FILENAME, AI_MEMORYIO_MAGIC_FILENAME_LENGTH ) ) {
            created_streams.emplace_back(new MemoryIOStream(buffer, length));
            return created_streams.back();
        }
        return existing_io ? existing_io->Open(pFile, pMode) : nullptr;
    }

    // -------------------------------------------------------------------
    /// @brief Closes the given file and releases all resources associated with it.
    void Close( IOStream* pFile) override {
        auto it = std::find(created_streams.begin(), created_streams.end(), pFile);
        if (it != created_streams.end()) {
            delete pFile;
            created_streams.erase(it);
        } else if (existing_io) {
            existing_io->Close(pFile);
        }
    }

    // -------------------------------------------------------------------
    /// @brief Compare two paths
    bool ComparePaths(const char* one, const char* second) const override {
        return existing_io ? existing_io->ComparePaths(one, second) : false;
    }

    /// @brief Will push the directory.
    bool PushDirectory( const std::string &path ) override {
        return existing_io ? existing_io->PushDirectory(path) : false;
    }

    /// @brief Will return the current directory from the stack top.
    const std::string &CurrentDirectory() const override {
        static std::string empty;
        return existing_io ? existing_io->CurrentDirectory() : empty;
    }

    /// @brief Returns the stack size.
    size_t StackSize() const override {
        return existing_io ? existing_io->StackSize() : 0;
    }

    /// @brief Will pop the upper directory.
    bool PopDirectory() override {
        return existing_io ? existing_io->PopDirectory() : false;
    }

    /// @brief Will create the directory.
    bool CreateDirectory( const std::string &path ) override {
        return existing_io ? existing_io->CreateDirectory(path) : false;
    }

    /// @brief Will change the directory.
    bool ChangeDirectory( const std::string &path ) override {
        return existing_io ? existing_io->ChangeDirectory(path) : false;
    }

    /// @brief Will delete the file.
    bool DeleteFile( const std::string &file ) override {
        return existing_io ? existing_io->DeleteFile(file) : false;
    }

private:
    const uint8_t* buffer;
    size_t length;
    IOSystem* existing_io;
    std::vector<IOStream*> created_streams;
};

} // end namespace Assimp

#endif // AI_MEMORYIOSTREAM_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/NullLogger.hpp
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  NullLogger.hpp
 *  @brief Dummy logger
*/

#pragma once
#ifndef INCLUDED_AI_NULLLOGGER_H
#define INCLUDED_AI_NULLLOGGER_H

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include "Logger.hpp"

namespace Assimp {

// ---------------------------------------------------------------------------
/** @brief CPP-API: Empty logging implementation.
 *
 * Does nothing! Used by default if the application hasn't requested a
 * custom logger via #DefaultLogger::set() or #DefaultLogger::create(); */
class ASSIMP_API NullLogger
    : public Logger {

public:

    /** @brief  Logs a debug message */
    void OnDebug(const char* message) {
        (void)message; //this avoids compiler warnings
    }

    /** @brief  Logs a verbose debug message */
	void OnVerboseDebug(const char *message) {
		(void)message; //this avoids compiler warnings
	}

    /** @brief  Logs an info message */
    void OnInfo(const char* message) {
        (void)message; //this avoids compiler warnings
    }

    /** @brief  Logs a warning message */
    void OnWarn(const char* message) {
        (void)message; //this avoids compiler warnings
    }

    /** @brief  Logs an error message */
    void OnError(const char* message) {
        (void)message; //this avoids compiler warnings
    }

    /** @brief  Detach a still attached stream from logger */
    bool attachStream(LogStream *pStream, unsigned int severity) {
        (void)pStream; (void)severity; //this avoids compiler warnings
        return false;
    }

    /** @brief  Detach a still attached stream from logger */
    bool detachStream(LogStream *pStream, unsigned int severity) {
        (void)pStream; (void)severity; //this avoids compiler warnings
        return false;
    }

private:
};
}
#endif // !! AI_NULLLOGGER_H_INCLUDED


============================================================
File Path: project/externals/assimp/include/assimp/ObjMaterial.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file OBJMATERIAL.h
 *  @brief Obj-specific material macros
 *
 */

#ifndef AI_OBJMATERIAL_H_INC
#define AI_OBJMATERIAL_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/material.h>

// ---------------------------------------------------------------------------

// the original illum property
#define AI_MATKEY_OBJ_ILLUM "$mat.illum", 0, 0

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// Pure key names for all obj texture-related properties
//! @cond MATS_DOC_FULL

// support for bump -bm
#define _AI_MATKEY_OBJ_BUMPMULT_BASE "$tex.bumpmult"
//! @endcond

// ---------------------------------------------------------------------------
#define AI_MATKEY_OBJ_BUMPMULT(type, N) _AI_MATKEY_OBJ_BUMPMULT_BASE, type, N

//! @cond MATS_DOC_FULL
#define AI_MATKEY_OBJ_BUMPMULT_NORMALS(N) \
    AI_MATKEY_OBJ_BUMPMULT(aiTextureType_NORMALS, N)

#define AI_MATKEY_OBJ_BUMPMULT_HEIGHT(N) \
    AI_MATKEY_OBJ_BUMPMULT(aiTextureType_HEIGHT, N)

//! @endcond


#endif


============================================================
File Path: project/externals/assimp/include/assimp/ParsingUtils.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file ParsingUtils.h
 *  @brief Defines helper functions for text parsing
 */
#pragma once
#ifndef AI_PARSING_UTILS_H_INC
#define AI_PARSING_UTILS_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/StringComparison.h>
#include <assimp/StringUtils.h>
#include <assimp/defs.h>

#include <vector>
#include <algorithm>

namespace Assimp {

// NOTE: the functions below are mostly intended as replacement for
// std::upper, std::lower, std::isupper, std::islower, std::isspace.
// we don't bother of locales. We don't want them. We want reliable
// (i.e. identical) results across all locales.

// The functions below accept any character type, but know only
// about ASCII. However, UTF-32 is the only safe ASCII superset to
// use since it doesn't have multi-byte sequences.

static const unsigned int BufferSize = 4096;


// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool IsUpper(char_t in) {
    return (in >= (char_t)'A' && in <= (char_t)'Z');
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool IsLower(char_t in) {
    return (in >= (char_t)'a' && in <= (char_t)'z');
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool IsSpace(char_t in) {
    return (in == (char_t)' ' || in == (char_t)'\t');
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool IsLineEnd(char_t in) {
    return (in == (char_t)'\r' || in == (char_t)'\n' || in == (char_t)'\0' || in == (char_t)'\f');
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool IsSpaceOrNewLine(char_t in) {
    return IsSpace<char_t>(in) || IsLineEnd<char_t>(in);
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool SkipSpaces(const char_t *in, const char_t **out) {
    while (*in == (char_t)' ' || *in == (char_t)'\t') {
        ++in;
    }
    *out = in;
    return !IsLineEnd<char_t>(*in);
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool SkipSpaces(const char_t **inout) {
    return SkipSpaces<char_t>(*inout, inout);
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool SkipLine(const char_t *in, const char_t **out) {
    while (*in != (char_t)'\r' && *in != (char_t)'\n' && *in != (char_t)'\0') {
        ++in;
    }

    // files are opened in binary mode. Ergo there are both NL and CR
    while (*in == (char_t)'\r' || *in == (char_t)'\n') {
        ++in;
    }
    *out = in;
    return *in != (char_t)'\0';
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool SkipLine(const char_t **inout) {
    return SkipLine<char_t>(*inout, inout);
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool SkipSpacesAndLineEnd(const char_t *in, const char_t **out) {
    while (*in == (char_t)' ' || *in == (char_t)'\t' || *in == (char_t)'\r' || *in == (char_t)'\n') {
        ++in;
    }
    *out = in;
    return *in != '\0';
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool SkipSpacesAndLineEnd(const char_t **inout) {
    return SkipSpacesAndLineEnd<char_t>(*inout, inout);
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool GetNextLine(const char_t *&buffer, char_t out[BufferSize]) {
    if ((char_t)'\0' == *buffer) {
        return false;
    }

    char *_out = out;
    char *const end = _out + BufferSize;
    while (!IsLineEnd(*buffer) && _out < end) {
        *_out++ = *buffer++;
    }
    *_out = (char_t)'\0';

    while (IsLineEnd(*buffer) && '\0' != *buffer) {
        ++buffer;
    }

    return true;
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool IsNumeric(char_t in) {
    return (in >= '0' && in <= '9') || '-' == in || '+' == in;
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE bool TokenMatch(char_t *&in, const char *token, unsigned int len) {
    if (!::strncmp(token, in, len) && IsSpaceOrNewLine(in[len])) {
        if (in[len] != '\0') {
            in += len + 1;
        } else {
            // If EOF after the token make sure we don't go past end of buffer
            in += len;
        }
        return true;
    }

    return false;
}
// ---------------------------------------------------------------------------------
/** @brief Case-ignoring version of TokenMatch
 *  @param in Input
 *  @param token Token to check for
 *  @param len Number of characters to check
 */
AI_FORCE_INLINE bool TokenMatchI(const char *&in, const char *token, unsigned int len) {
    if (!ASSIMP_strincmp(token, in, len) && IsSpaceOrNewLine(in[len])) {
        in += len + 1;
        return true;
    }
    return false;
}

// ---------------------------------------------------------------------------------
AI_FORCE_INLINE void SkipToken(const char *&in) {
    SkipSpaces(&in);
    while (!IsSpaceOrNewLine(*in)) {
        ++in;
    }
}

// ---------------------------------------------------------------------------------
AI_FORCE_INLINE std::string GetNextToken(const char *&in) {
    SkipSpacesAndLineEnd(&in);
    const char *cur = in;
    while (!IsSpaceOrNewLine(*in)) {
        ++in;
    }
    return std::string(cur, (size_t)(in - cur));
}

// ---------------------------------------------------------------------------------
/** @brief  Will perform a simple tokenize.
 *  @param  str         String to tokenize.
 *  @param  tokens      Array with tokens, will be empty if no token was found.
 *  @param  delimiters  Delimiter for tokenize.
 *  @return Number of found token.
 */
template <class string_type>
AI_FORCE_INLINE unsigned int tokenize(const string_type &str, std::vector<string_type> &tokens,
        const string_type &delimiters) {
    // Skip delimiters at beginning.
    typename string_type::size_type lastPos = str.find_first_not_of(delimiters, 0);

    // Find first "non-delimiter".
    typename string_type::size_type pos = str.find_first_of(delimiters, lastPos);
    while (string_type::npos != pos || string_type::npos != lastPos) {
        // Found a token, add it to the vector.
        string_type tmp = str.substr(lastPos, pos - lastPos);
        if (!tmp.empty() && ' ' != tmp[0])
            tokens.push_back(tmp);

        // Skip delimiters.  Note the "not_of"
        lastPos = str.find_first_not_of(delimiters, pos);

        // Find next "non-delimiter"
        pos = str.find_first_of(delimiters, lastPos);
    }

    return static_cast<unsigned int>(tokens.size());
}

inline std::string ai_stdStrToLower(const std::string &str) {
    std::string out(str);
    for (size_t i = 0; i < str.size(); ++i) {
        out[i] = (char) tolower((unsigned char)out[i]);
    }
    return out;
}

} // namespace Assimp

#endif // ! AI_PARSING_UTILS_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/Profiler.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Profiler.h
 *  @brief Utility to measure the respective runtime of each import step
 */
#pragma once
#ifndef AI_INCLUDED_PROFILER_H
#define AI_INCLUDED_PROFILER_H

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <chrono>
#include <assimp/DefaultLogger.hpp>
#include <assimp/TinyFormatter.h>

#include <map>

namespace Assimp {
namespace Profiling {

using namespace Formatter;

// ------------------------------------------------------------------------------------------------
/** Simple wrapper around boost::timer to simplify reporting. Timings are automatically
 *  dumped to the log file.
 */
class Profiler {
public:
    Profiler() = default;


    /** Start a named timer */
    void BeginRegion(const std::string& region) {
        regions[region] = std::chrono::system_clock::now();
        ASSIMP_LOG_DEBUG("START `",region,"`");
    }


    /** End a specific named timer and write its end time to the log */
    void EndRegion(const std::string& region) {
        RegionMap::const_iterator it = regions.find(region);
        if (it == regions.end()) {
            return;
        }

        std::chrono::duration<double> elapsedSeconds = std::chrono::system_clock::now() - regions[region];
        ASSIMP_LOG_DEBUG("END   `",region,"`, dt= ", elapsedSeconds.count()," s");
    }

private:
    typedef std::map<std::string,std::chrono::time_point<std::chrono::system_clock>> RegionMap;
    RegionMap regions;
};

}
}

#endif // AI_INCLUDED_PROFILER_H



============================================================
File Path: project/externals/assimp/include/assimp/ProgressHandler.hpp
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file ProgressHandler.hpp
 *  @brief Abstract base class 'ProgressHandler'.
 */
#pragma once
#ifndef AI_PROGRESSHANDLER_H_INC
#define AI_PROGRESSHANDLER_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/types.h>

namespace Assimp {

// ------------------------------------------------------------------------------------
/** @brief CPP-API: Abstract interface for custom progress report receivers.
 *
 *  Each #Importer instance maintains its own #ProgressHandler. The default
 *  implementation provided by Assimp doesn't do anything at all. */
class ASSIMP_API ProgressHandler
#ifndef SWIG
    : public Intern::AllocateFromAssimpHeap
#endif
{
protected:
    /// @brief  Default constructor
    ProgressHandler () AI_NO_EXCEPT = default;

public:
    /// @brief  Virtual destructor.
    virtual ~ProgressHandler () = default;

    // -------------------------------------------------------------------
    /** @brief Progress callback.
     *  @param percentage An estimate of the current loading progress,
     *    in percent. Or -1.f if such an estimate is not available.
     *
     *  There are restriction on what you may do from within your
     *  implementation of this method: no exceptions may be thrown and no
     *  non-const #Importer methods may be called. It is
     *  not generally possible to predict the number of callbacks
     *  fired during a single import.
     *
     *  @return Return false to abort loading at the next possible
     *   occasion (loaders and Assimp are generally allowed to perform
     *   all needed cleanup tasks prior to returning control to the
     *   caller). If the loading is aborted, #Importer::ReadFile()
     *   returns always nullptr.
     *   */
    virtual bool Update(float percentage = -1.f) = 0;

    // -------------------------------------------------------------------
    /** @brief Progress callback for file loading steps
     *  @param numberOfSteps The number of total post-processing
     *   steps
     *  @param currentStep The index of the current post-processing
     *   step that will run, or equal to numberOfSteps if all of
     *   them has finished. This number is always strictly monotone
     *   increasing, although not necessarily linearly.
     *
     *  @note This is currently only used at the start and the end
     *   of the file parsing.
     *   */
    virtual void UpdateFileRead(int currentStep /*= 0*/, int numberOfSteps /*= 0*/) {
        float f = numberOfSteps ? currentStep / (float)numberOfSteps : 1.0f;
        Update( f * 0.5f );
    }

    // -------------------------------------------------------------------
    /** @brief Progress callback for post-processing steps
     *  @param numberOfSteps The number of total post-processing
     *   steps
     *  @param currentStep The index of the current post-processing
     *   step that will run, or equal to numberOfSteps if all of
     *   them has finished. This number is always strictly monotone
     *   increasing, although not necessarily linearly.
     *   */
    virtual void UpdatePostProcess(int currentStep /*= 0*/, int numberOfSteps /*= 0*/) {
        float f = numberOfSteps ? currentStep / (float)numberOfSteps : 1.0f;
        Update( f * 0.5f + 0.5f );
    }


    // -------------------------------------------------------------------
    /** @brief Progress callback for export steps.
     *  @param numberOfSteps The number of total processing
     *   steps
     *  @param currentStep The index of the current post-processing
     *   step that will run, or equal to numberOfSteps if all of
     *   them has finished. This number is always strictly monotone
     *   increasing, although not necessarily linearly.
     *   */
    virtual void UpdateFileWrite(int currentStep /*= 0*/, int numberOfSteps /*= 0*/) {
        float f = numberOfSteps ? currentStep / (float)numberOfSteps : 1.0f;
        Update(f * 0.5f);
    }
}; // !class ProgressHandler

// ------------------------------------------------------------------------------------

} // Namespace Assimp

#endif // AI_PROGRESSHANDLER_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/RemoveComments.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Declares a helper class, "CommentRemover", which can be
 *  used to remove comments (single and multi line) from a text file.
 */
#pragma once
#ifndef AI_REMOVE_COMMENTS_H_INC
#define AI_REMOVE_COMMENTS_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/defs.h>

namespace Assimp    {

// ---------------------------------------------------------------------------
/** \brief Helper class to remove single and multi line comments from a file
 *
 *  Some mesh formats like MD5 have comments that are quite similar
 *  to those in C or C++ so this code has been moved to a separate
 *  module.
 */
class ASSIMP_API CommentRemover {
    // class cannot be instanced
    CommentRemover() {}

public:

    //! Remove single-line comments. The end of a line is
    //! expected to be either NL or CR or NLCR.
    //! \param szComment The start sequence of the comment, e.g. "//"
    //! \param szBuffer Buffer to work with
    //! \param chReplacement Character to be used as replacement
    //! for commented lines. By default this is ' '
    static void RemoveLineComments(const char* szComment,
        char* szBuffer, char chReplacement = ' ');

    //! Remove multi-line comments. The end of a line is
    //! expected to be either NL or CR or NLCR. Multi-line comments
    //! may not be nested (as in C).
    //! \param szCommentStart The start sequence of the comment, e.g. "/*"
    //! \param szCommentEnd The end sequence of the comment, e.g. "*/"
    //! \param szBuffer Buffer to work with
    //! \param chReplacement Character to be used as replacement
    //! for commented lines. By default this is ' '
    static void RemoveMultiLineComments(const char* szCommentStart,
        const char* szCommentEnd,char* szBuffer,
        char chReplacement = ' ');
};
} // ! Assimp

#endif // !! AI_REMOVE_COMMENTS_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/SGSpatialSort.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** Small helper classes to optimize finding vertices close to a given location
 */
#pragma once
#ifndef AI_D3DSSPATIALSORT_H_INC
#define AI_D3DSSPATIALSORT_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/types.h>
#include <vector>
#include <stdint.h>

namespace Assimp    {

// ----------------------------------------------------------------------------------
/** Specialized version of SpatialSort to support smoothing groups
 *  This is used in by the 3DS, ASE and LWO loaders. 3DS and ASE share their
 *  normal computation code in SmoothingGroups.inl, the LWO loader has its own
 *  implementation to handle all details of its file format correctly.
 */
// ----------------------------------------------------------------------------------
class ASSIMP_API SGSpatialSort
{
public:

    SGSpatialSort();

    // -------------------------------------------------------------------
    /** Construction from a given face array, handling smoothing groups
     *  properly
     */
    explicit SGSpatialSort(const std::vector<aiVector3D>& vPositions);

    // -------------------------------------------------------------------
    /** Add a vertex to the spatial sort
     * @param vPosition Vertex position to be added
     * @param index Index of the vrtex
     * @param smoothingGroup SmoothingGroup for this vertex
     */
    void Add(const aiVector3D& vPosition, unsigned int index,
        unsigned int smoothingGroup);

    // -------------------------------------------------------------------
    /** Prepare the spatial sorter for use. This step runs in O(logn)
     */
    void Prepare();

    /** Destructor */
    ~SGSpatialSort();

    // -------------------------------------------------------------------
    /** Returns an iterator for all positions close to the given position.
     * @param pPosition The position to look for vertices.
     * @param pSG Only included vertices with at least one shared smooth group
     * @param pRadius Maximal distance from the position a vertex may have
     *   to be counted in.
     * @param poResults The container to store the indices of the found
     *   positions. Will be emptied by the call so it may contain anything.
     * @param exactMatch Specifies whether smoothing groups are bit masks
     *   (false) or integral values (true). In the latter case, a vertex
     *   cannot belong to more than one smoothing group.
     * @return An iterator to iterate over all vertices in the given area.
     */
    // -------------------------------------------------------------------
    void FindPositions( const aiVector3D& pPosition, uint32_t pSG,
        float pRadius, std::vector<unsigned int>& poResults,
        bool exactMatch = false) const;

protected:
    /** Normal of the sorting plane, normalized. The center is always at (0, 0, 0) */
    aiVector3D mPlaneNormal;

    // -------------------------------------------------------------------
    /** An entry in a spatially sorted position array. Consists of a
     *  vertex index, its position and its pre-calculated distance from
     *  the reference plane */
    // -------------------------------------------------------------------
    struct Entry {
        unsigned int mIndex;    ///< The vertex referred by this entry
        aiVector3D mPosition;   ///< Position
        uint32_t mSmoothGroups;
        float mDistance;        ///< Distance of this vertex to the sorting plane

        Entry() AI_NO_EXCEPT
        : mIndex(0)
        , mPosition()
        , mSmoothGroups(0)
        , mDistance(0.0f) {
            // empty
        }

        Entry( unsigned int pIndex, const aiVector3D& pPosition, float pDistance,uint32_t pSG)
        : mIndex( pIndex)
        , mPosition( pPosition)
        , mSmoothGroups(pSG)
        , mDistance( pDistance) {
            // empty
        }

        bool operator < (const Entry& e) const {
            return mDistance < e.mDistance;
        }
    };

    // all positions, sorted by distance to the sorting plane
    std::vector<Entry> mPositions;
};

} // end of namespace Assimp

#endif // AI_SPATIALSORT_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/SceneCombiner.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Declares a helper class, "SceneCombiner" providing various
 *  utilities to merge scenes.
 */
#pragma once
#ifndef AI_SCENE_COMBINER_H_INC
#define AI_SCENE_COMBINER_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/ai_assert.h>
#include <assimp/types.h>

#include <cstddef>
#include <cstdint>
#include <list>
#include <set>
#include <vector>

struct aiScene;
struct aiNode;
struct aiMaterial;
struct aiTexture;
struct aiCamera;
struct aiLight;
struct aiMetadata;
struct aiBone;
struct aiMesh;
struct aiAnimMesh;
struct aiAnimation;
struct aiNodeAnim;
struct aiMeshMorphAnim;

namespace Assimp {

// ---------------------------------------------------------------------------
/** \brief Helper data structure for SceneCombiner.
 *
 *  Describes to which node a scene must be attached to.
 */
struct AttachmentInfo {
    AttachmentInfo() :
            scene(nullptr),
            attachToNode(nullptr) {}

    AttachmentInfo(aiScene *_scene, aiNode *_attachToNode) :
            scene(_scene), attachToNode(_attachToNode) {}

    aiScene *scene;
    aiNode *attachToNode;
};

// ---------------------------------------------------------------------------
struct NodeAttachmentInfo {
    NodeAttachmentInfo() :
            node(nullptr),
            attachToNode(nullptr),
            resolved(false),
            src_idx(SIZE_MAX) {}

    NodeAttachmentInfo(aiNode *_scene, aiNode *_attachToNode, size_t idx) :
            node(_scene), attachToNode(_attachToNode), resolved(false), src_idx(idx) {}

    aiNode *node;
    aiNode *attachToNode;
    bool resolved;
    size_t src_idx;
};

// ---------------------------------------------------------------------------
/** @def AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES
 *  Generate unique names for all named scene items
 */
#define AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES 0x1

/** @def AI_INT_MERGE_SCENE_GEN_UNIQUE_MATNAMES
 *  Generate unique names for materials, too.
 *  This is not absolutely required to pass the validation.
 */
#define AI_INT_MERGE_SCENE_GEN_UNIQUE_MATNAMES 0x2

/** @def AI_INT_MERGE_SCENE_DUPLICATES_DEEP_CPY
 * Use deep copies of duplicate scenes
 */
#define AI_INT_MERGE_SCENE_DUPLICATES_DEEP_CPY 0x4

/** @def AI_INT_MERGE_SCENE_RESOLVE_CROSS_ATTACHMENTS
 * If attachment nodes are not found in the given master scene,
 * search the other imported scenes for them in an any order.
 */
#define AI_INT_MERGE_SCENE_RESOLVE_CROSS_ATTACHMENTS 0x8

/** @def AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY
 * Can be combined with AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES.
 * Unique names are generated, but only if this is absolutely
 * required to avoid name conflicts.
 */
#define AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY 0x10

typedef std::pair<aiBone *, unsigned int> BoneSrcIndex;

// ---------------------------------------------------------------------------
/** @brief Helper data structure for SceneCombiner::MergeBones.
 */
struct BoneWithHash : public std::pair<uint32_t, aiString *> {
    std::vector<BoneSrcIndex> pSrcBones;
};

// ---------------------------------------------------------------------------
/** @brief Utility for SceneCombiner
 */
struct SceneHelper {
    SceneHelper() :
            scene(nullptr),
            idlen(0) {
        id[0] = 0;
    }

    explicit SceneHelper(aiScene *_scene) :
            scene(_scene), idlen(0) {
        id[0] = 0;
    }

    AI_FORCE_INLINE aiScene *operator->() const {
        return scene;
    }

    // scene we're working on
    aiScene *scene;

    // prefix to be added to all identifiers in the scene ...
    char id[32];

    // and its strlen()
    unsigned int idlen;

    // hash table to quickly check whether a name is contained in the scene
    std::set<unsigned int> hashes;
};

// ---------------------------------------------------------------------------
/** \brief Static helper class providing various utilities to merge two
 *    scenes. It is intended as internal utility and NOT for use by
 *    applications.
 *
 * The class is currently being used by various postprocessing steps
 * and loaders (ie. LWS).
 */
class ASSIMP_API SceneCombiner {
    // class cannot be instanced
    SceneCombiner() = delete;

    ~SceneCombiner() = delete;

public:
    // -------------------------------------------------------------------
    /** Merges two or more scenes.
     *
     *  @param dest  Receives a pointer to the destination scene. If the
     *    pointer doesn't point to nullptr when the function is called, the
     *    existing scene is cleared and refilled.
     *  @param src Non-empty list of scenes to be merged. The function
     *    deletes the input scenes afterwards. There may be duplicate scenes.
     *  @param flags Combination of the AI_INT_MERGE_SCENE flags defined above
     */
    static void MergeScenes(aiScene **dest, std::vector<aiScene *> &src,
            unsigned int flags = 0);

    // -------------------------------------------------------------------
    /** Merges two or more scenes and attaches all scenes to a specific
     *  position in the node graph of the master scene.
     *
     *  @param dest Receives a pointer to the destination scene. If the
     *    pointer doesn't point to nullptr when the function is called, the
     *    existing scene is cleared and refilled.
     *  @param master Master scene. It will be deleted afterwards. All
     *    other scenes will be inserted in its node graph.
     *  @param src Non-empty list of scenes to be merged along with their
     *    corresponding attachment points in the master scene. The function
     *    deletes the input scenes afterwards. There may be duplicate scenes.
     *  @param flags Combination of the AI_INT_MERGE_SCENE flags defined above
     */
    static void MergeScenes(aiScene **dest, aiScene *master,
            std::vector<AttachmentInfo> &src,
            unsigned int flags = 0);

    // -------------------------------------------------------------------
    /** Merges two or more meshes
     *
     *  The meshes should have equal vertex formats. Only components
     *  that are provided by ALL meshes will be present in the output mesh.
     *  An exception is made for VColors - they are set to black. The
     *  meshes should have the same material indices, too. The output
     *  material index is always the material index of the first mesh.
     *
     *  @param dest Destination mesh. Must be empty.
     *  @param flags Currently no parameters
     *  @param begin First mesh to be processed
     *  @param end Points to the mesh after the last mesh to be processed
     */
    static void MergeMeshes(aiMesh **dest, unsigned int flags,
            std::vector<aiMesh *>::const_iterator begin,
            std::vector<aiMesh *>::const_iterator end);

    // -------------------------------------------------------------------
    /** Merges two or more bones
     *
     *  @param out Mesh to receive the output bone list
     *  @param flags Currently no parameters
     *  @param begin First mesh to be processed
     *  @param end Points to the mesh after the last mesh to be processed
     */
    static void MergeBones(aiMesh *out, std::vector<aiMesh *>::const_iterator it,
            std::vector<aiMesh *>::const_iterator end);

    // -------------------------------------------------------------------
    /** Merges two or more materials
     *
     *  The materials should be complementary as much as possible. In case
     *  of a property present in different materials, the first occurrence
     *  is used.
     *
     *  @param dest Destination material. Must be empty.
     *  @param begin First material to be processed
     *  @param end Points to the material after the last material to be processed
     */
    static void MergeMaterials(aiMaterial **dest,
            std::vector<aiMaterial *>::const_iterator begin,
            std::vector<aiMaterial *>::const_iterator end);

    // -------------------------------------------------------------------
    /** Builds a list of uniquely named bones in a mesh list
     *
     *  @param asBones Receives the output list
     *  @param it First mesh to be processed
     *  @param end Last mesh to be processed
     */
    static void BuildUniqueBoneList(std::list<BoneWithHash> &asBones,
            std::vector<aiMesh *>::const_iterator it,
            std::vector<aiMesh *>::const_iterator end);

    // -------------------------------------------------------------------
    /** Add a name prefix to all nodes in a scene.
     *
     *  @param Current node. This function is called recursively.
     *  @param prefix Prefix to be added to all nodes
     *  @param len STring length
     */
    static void AddNodePrefixes(aiNode *node, const char *prefix,
            unsigned int len);

    // -------------------------------------------------------------------
    /** Add an offset to all mesh indices in a node graph
     *
     *  @param Current node. This function is called recursively.
     *  @param offset Offset to be added to all mesh indices
     */
    static void OffsetNodeMeshIndices(aiNode *node, unsigned int offset);

    // -------------------------------------------------------------------
    /** Attach a list of node graphs to well-defined nodes in a master
     *  graph. This is a helper for MergeScenes()
     *
     *  @param master Master scene
     *  @param srcList List of source scenes along with their attachment
     *    points. If an attachment point is nullptr (or does not exist in
     *    the master graph), a scene is attached to the root of the master
     *    graph (as an additional child node)
     *  @duplicates List of duplicates. If elem[n] == n the scene is not
     *    a duplicate. Otherwise elem[n] links scene n to its first occurrence.
     */
    static void AttachToGraph(aiScene *master,
            std::vector<NodeAttachmentInfo> &srcList);

    static void AttachToGraph(aiNode *attach,
            std::vector<NodeAttachmentInfo> &srcList);

    // -------------------------------------------------------------------
    /** Get a deep copy of a scene
     *
     *  @param dest Receives a pointer to the destination scene
     *  @param src Source scene - remains unmodified.
     */
    static void CopyScene(aiScene **dest, const aiScene *source, bool allocate = true);

    // -------------------------------------------------------------------
    /** Get a flat copy of a scene
     *
     *  Only the first hierarchy layer is copied. All pointer members of
     *  aiScene are shared by source and destination scene.  If the
     *    pointer doesn't point to nullptr when the function is called, the
     *    existing scene is cleared and refilled.
     *  @param dest Receives a pointer to the destination scene
     *  @param src Source scene - remains unmodified.
     */
    static void CopySceneFlat(aiScene **dest, const aiScene *source);

    // -------------------------------------------------------------------
    /** Get a deep copy of a mesh
     *
     *  @param dest Receives a pointer to the destination mesh
     *  @param src Source mesh - remains unmodified.
     */
    static void Copy(aiMesh **dest, const aiMesh *src);

    // similar to Copy():
    static void Copy(aiAnimMesh **dest, const aiAnimMesh *src);
    static void Copy(aiMaterial **dest, const aiMaterial *src);
    static void Copy(aiTexture **dest, const aiTexture *src);
    static void Copy(aiAnimation **dest, const aiAnimation *src);
    static void Copy(aiCamera **dest, const aiCamera *src);
    static void Copy(aiBone **dest, const aiBone *src);
    static void Copy(aiLight **dest, const aiLight *src);
    static void Copy(aiNodeAnim **dest, const aiNodeAnim *src);
    static void Copy(aiMeshMorphAnim **dest, const aiMeshMorphAnim *src);
    static void Copy(aiMetadata **dest, const aiMetadata *src);
    static void Copy(aiString **dest, const aiString *src);

    // recursive, of course
    static void Copy(aiNode **dest, const aiNode *src);

private:
    // -------------------------------------------------------------------
    // Same as AddNodePrefixes, but with an additional check
    static void AddNodePrefixesChecked(aiNode *node, const char *prefix,
            unsigned int len,
            std::vector<SceneHelper> &input,
            unsigned int cur);

    // -------------------------------------------------------------------
    // Add node identifiers to a hashing set
    static void AddNodeHashes(aiNode *node, std::set<unsigned int> &hashes);

    // -------------------------------------------------------------------
    // Search for duplicate names
    static bool FindNameMatch(const aiString &name,
            std::vector<SceneHelper> &input, unsigned int cur);
};

} // namespace Assimp

#endif // !! AI_SCENE_COMBINER_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/SkeletonMeshBuilder.h
============================================================
/** Helper class to construct a dummy mesh for file formats containing only motion data */

/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
copyright notice, this list of conditions and the
following disclaimer.

* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the
following disclaimer in the documentation and/or other
materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
contributors may be used to endorse or promote products
derived from this software without specific prior
written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file SkeletonMeshBuilder.h
 *  Declares SkeletonMeshBuilder, a tiny utility to build dummy meshes
 *  for animation skeletons.
 */

#pragma once
#ifndef AI_SKELETONMESHBUILDER_H_INC
#define AI_SKELETONMESHBUILDER_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/mesh.h>
#include <vector>

struct aiMaterial;
struct aiScene;
struct aiNode;

namespace Assimp {

// ---------------------------------------------------------------------------
/**
 * This little helper class constructs a dummy mesh for a given scene
 * the resembles the node hierarchy. This is useful for file formats
 * that don't carry any mesh data but only animation data.
 */
class ASSIMP_API SkeletonMeshBuilder {
public:
    // -------------------------------------------------------------------
    /** The constructor processes the given scene and adds a mesh there.
     *
     * Does nothing if the scene already has mesh data.
     * @param pScene The scene for which a skeleton mesh should be constructed.
     * @param root The node to start with. nullptr is the scene root
     * @param bKnobsOnly Set this to true if you don't want the connectors
     *   between the knobs representing the nodes.
     */
    SkeletonMeshBuilder(aiScene *pScene, aiNode *root = nullptr,
            bool bKnobsOnly = false);

protected:
    // -------------------------------------------------------------------
    /** Recursively builds a simple mesh representation for the given node
     * and also creates a joint for the node that affects this part of
     * the mesh.
     * @param pNode The node to build geometry for.
     */
    void CreateGeometry(const aiNode *pNode);

    // -------------------------------------------------------------------
    /** Creates the mesh from the internally accumulated stuff and returns it.
     */
    aiMesh *CreateMesh();

    // -------------------------------------------------------------------
    /** Creates a dummy material and returns it. */
    aiMaterial *CreateMaterial();

private:
    /** space to assemble the mesh data: points */
    std::vector<aiVector3D> mVertices;

    /** faces */
    struct Face {
        unsigned int mIndices[3];
        Face();
        Face(unsigned int p0, unsigned int p1, unsigned int p2) {
            mIndices[0] = p0;
            mIndices[1] = p1;
            mIndices[2] = p2;
        }
    };
    std::vector<Face> mFaces;

    /** bones */
    std::vector<aiBone *> mBones;

    bool mKnobsOnly;
};

} // end of namespace Assimp

#endif // AI_SKELETONMESHBUILDER_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/SmallVector.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Defines small vector with inplace storage.
Based on CppCon 2016: Chandler Carruth "High Performance Code 201: Hybrid Data Structures" */

#pragma once
#ifndef AI_SMALLVECTOR_H_INC
#define AI_SMALLVECTOR_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

namespace Assimp {

// --------------------------------------------------------------------------------------------
/// @brief Small vector with inplace storage.
///
/// Reduces heap allocations when list is shorter. It uses a small array for a dedicated size.
/// When the growing gets bigger than this small cache a dynamic growing algorithm will be
/// used.
// --------------------------------------------------------------------------------------------
template<typename T, unsigned int Capacity>
class SmallVector {
public:
    /// @brief  The default class constructor.
    SmallVector() :
            mStorage(mInplaceStorage),
            mSize(0),
            mCapacity(Capacity) {
        // empty
    }

    /// @brief  The class destructor.
    ~SmallVector() {
        if (mStorage != mInplaceStorage) {
            delete [] mStorage;
        }
    }

    /// @brief  Will push a new item. The capacity will grow in case of a too small capacity.
    /// @param  item    [in] The item to push at the end of the vector.
    void push_back(const T& item) {
        if (mSize < mCapacity) {
            mStorage[mSize++] = item;
            return;
        }

        push_back_and_grow(item);
    }

    /// @brief  Will resize the vector.
    /// @param  newSize     [in] The new size.
    void resize(size_t newSize) {
        if (newSize > mCapacity) {
            grow(newSize);
        }
        mSize = newSize;
    }

    /// @brief  Returns the current size of the vector.
    /// @return The current size.
    size_t size() const {
        return mSize;
    }

    /// @brief  Returns a pointer to the first item.
    /// @return The first item as a pointer.
    T* begin() {
        return mStorage;
    }

    /// @brief  Returns a pointer to the end.
    /// @return The end as a pointer.
    T* end() {
        return &mStorage[mSize];
    }

    /// @brief  Returns a const pointer to the first item.
    /// @return The first item as a const pointer.
    T* begin() const {
        return mStorage;
    }

    /// @brief  Returns a const pointer to the end.
    /// @return The end as a const pointer.
    T* end() const {
        return &mStorage[mSize];
    }

    SmallVector(const SmallVector &) = delete;
    SmallVector(SmallVector &&) = delete;
    SmallVector &operator = (const SmallVector &) = delete;
    SmallVector &operator = (SmallVector &&) = delete;

private:
    void grow( size_t newCapacity) {
        T* oldStorage = mStorage;
        T* newStorage = new T[newCapacity];

        std::memcpy(newStorage, oldStorage, mSize * sizeof(T));

        mStorage = newStorage;
        mCapacity = newCapacity;

        if (oldStorage != mInplaceStorage) {
            delete [] oldStorage;
        }
    }

    void push_back_and_grow(const T& item) {
        grow(mCapacity + Capacity);

        mStorage[mSize++] = item;
    }

    T* mStorage;
    size_t mSize;
    size_t mCapacity;
    T mInplaceStorage[Capacity];
};

} // end namespace Assimp

#endif // !! AI_SMALLVECTOR_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/SmoothingGroups.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Defines the helper data structures for importing 3DS files.
http://www.jalix.org/ressources/graphics/3DS/_unofficials/3ds-unofficial.txt */

#pragma once
#ifndef AI_SMOOTHINGGROUPS_H_INC
#define AI_SMOOTHINGGROUPS_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/vector3.h>

#include <stdint.h>
#include <vector>

// ---------------------------------------------------------------------------
/** Helper structure representing a face with smoothing groups assigned */
struct FaceWithSmoothingGroup {
    FaceWithSmoothingGroup() AI_NO_EXCEPT
    : mIndices()
    , iSmoothGroup(0) {
        // in debug builds set all indices to a common magic value
#ifdef ASSIMP_BUILD_DEBUG
        this->mIndices[0] = 0xffffffff;
        this->mIndices[1] = 0xffffffff;
        this->mIndices[2] = 0xffffffff;
#endif
    }


    //! Indices. .3ds is using uint16. However, after
    //! an unique vertex set has been generated,
    //! individual index values might exceed 2^16
    uint32_t mIndices[3];

    //! specifies to which smoothing group the face belongs to
    uint32_t iSmoothGroup;
};

// ---------------------------------------------------------------------------
/** Helper structure representing a mesh whose faces have smoothing
    groups assigned. This allows us to reuse the code for normal computations
    from smoothings groups for several loaders (3DS, ASE). All of them
    use face structures which inherit from #FaceWithSmoothingGroup,
    but as they add extra members and need to be copied by value we
    need to use a template here.
    */
template <class T>
struct MeshWithSmoothingGroups
{
    //! Vertex positions
    std::vector<aiVector3D> mPositions;

    //! Face lists
    std::vector<T> mFaces;

    //! List of normal vectors
    std::vector<aiVector3D> mNormals;
};

// ---------------------------------------------------------------------------
/** Computes normal vectors for the mesh
 */
template <class T>
void ComputeNormalsWithSmoothingsGroups(MeshWithSmoothingGroups<T>& sMesh);


// include implementations
#include "SmoothingGroups.inl"

#endif // !! AI_SMOOTHINGGROUPS_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/SpatialSort.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** Small helper classes to optimise finding vertizes close to a given location */
#pragma once
#ifndef AI_SPATIALSORT_H_INC
#define AI_SPATIALSORT_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/types.h>
#include <vector>
#include <limits>

namespace Assimp {

// ------------------------------------------------------------------------------------------------
/** A little helper class to quickly find all vertices in the epsilon environment of a given
 * position. Construct an instance with an array of positions. The class stores the given positions
 * by their indices and sorts them by their distance to an arbitrary chosen plane.
 * You can then query the instance for all vertices close to a given position in an average O(log n)
 * time, with O(n) worst case complexity when all vertices lay on the plane. The plane is chosen
 * so that it avoids common planes in usual data sets. */
// ------------------------------------------------------------------------------------------------
class ASSIMP_API SpatialSort {
public:
    SpatialSort();

    // ------------------------------------------------------------------------------------
    /** Constructs a spatially sorted representation from the given position array.
     * Supply the positions in its layout in memory, the class will only refer to them
     * by index.
     * @param pPositions Pointer to the first position vector of the array.
     * @param pNumPositions Number of vectors to expect in that array.
     * @param pElementOffset Offset in bytes from the beginning of one vector in memory
     *   to the beginning of the next vector. */
    SpatialSort(const aiVector3D *pPositions, unsigned int pNumPositions,
            unsigned int pElementOffset);

    /** Destructor */
    ~SpatialSort();

    // ------------------------------------------------------------------------------------
    /** Sets the input data for the SpatialSort. This replaces existing data, if any.
     *  The new data receives new indices in ascending order.
     *
     * @param pPositions Pointer to the first position vector of the array.
     * @param pNumPositions Number of vectors to expect in that array.
     * @param pElementOffset Offset in bytes from the beginning of one vector in memory
     *   to the beginning of the next vector.
     * @param pFinalize Specifies whether the SpatialSort's internal representation
     *   is finalized after the new data has been added. Finalization is
     *   required in order to use #FindPosition() or #GenerateMappingTable().
     *   If you don't finalize yet, you can use #Append() to add data from
     *   other sources.*/
    void Fill(const aiVector3D *pPositions, unsigned int pNumPositions,
            unsigned int pElementOffset,
            bool pFinalize = true);

    // ------------------------------------------------------------------------------------
    /** Same as #Fill(), except the method appends to existing data in the #SpatialSort. */
    void Append(const aiVector3D *pPositions, unsigned int pNumPositions,
            unsigned int pElementOffset,
            bool pFinalize = true);

    // ------------------------------------------------------------------------------------
    /** Finalize the spatial hash data structure. This can be useful after
     *  multiple calls to #Append() with the pFinalize parameter set to false.
     *  This is finally required before one of #FindPositions() and #GenerateMappingTable()
     *  can be called to query the spatial sort.*/
    void Finalize();

    // ------------------------------------------------------------------------------------
    /** Returns an iterator for all positions close to the given position.
     * @param pPosition The position to look for vertices.
     * @param pRadius Maximal distance from the position a vertex may have to be counted in.
     * @param poResults The container to store the indices of the found positions.
     *   Will be emptied by the call so it may contain anything.
     * @return An iterator to iterate over all vertices in the given area.*/
    void FindPositions(const aiVector3D &pPosition, ai_real pRadius,
            std::vector<unsigned int> &poResults) const;

    // ------------------------------------------------------------------------------------
    /** Fills an array with indices of all positions identical to the given position. In
     *  opposite to FindPositions(), not an epsilon is used but a (very low) tolerance of
     *  four floating-point units.
     * @param pPosition The position to look for vertices.
     * @param poResults The container to store the indices of the found positions.
     *   Will be emptied by the call so it may contain anything.*/
    void FindIdenticalPositions(const aiVector3D &pPosition,
            std::vector<unsigned int> &poResults) const;

    // ------------------------------------------------------------------------------------
    /** Compute a table that maps each vertex ID referring to a spatially close
     *  enough position to the same output ID. Output IDs are assigned in ascending order
     *  from 0...n.
     * @param fill Will be filled with numPositions entries.
     * @param pRadius Maximal distance from the position a vertex may have to
     *   be counted in.
     *  @return Number of unique vertices (n).  */
    unsigned int GenerateMappingTable(std::vector<unsigned int> &fill,
            ai_real pRadius) const;

protected:
    /** Return the distance to the sorting plane. */
    ai_real CalculateDistance(const aiVector3D &pPosition) const;

protected:
    /** Normal of the sorting plane, normalized.
     */
    aiVector3D mPlaneNormal;

    /** The centroid of the positions, which is used as a point on the sorting plane
     * when calculating distance. This value is calculated in Finalize.
    */
    aiVector3D mCentroid;

    /** An entry in a spatially sorted position array. Consists of a vertex index,
     * its position and its pre-calculated distance from the reference plane */
    struct Entry {
        unsigned int mIndex; ///< The vertex referred by this entry
        aiVector3D mPosition; ///< Position
        /// Distance of this vertex to the sorting plane. This is set by Finalize.
        ai_real mDistance;

        Entry() AI_NO_EXCEPT
                : mIndex(std::numeric_limits<unsigned int>::max()),
                  mPosition(),
                  mDistance(std::numeric_limits<ai_real>::max()) {
            // empty
        }
        Entry(unsigned int pIndex, const aiVector3D &pPosition) :
                mIndex(pIndex), mPosition(pPosition), mDistance(std::numeric_limits<ai_real>::max()) {
            // empty
        }

        bool operator<(const Entry &e) const { return mDistance < e.mDistance; }
    };

    // all positions, sorted by distance to the sorting plane
    std::vector<Entry> mPositions;

    /// false until the Finalize method is called.
    bool mFinalized;
};

} // end of namespace Assimp

#endif // AI_SPATIALSORT_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/StandardShapes.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Declares a helper class, "StandardShapes" which generates
 *  vertices for standard shapes, such as cylinders, cones, spheres ..
 */
#pragma once
#ifndef AI_STANDARD_SHAPES_H_INC
#define AI_STANDARD_SHAPES_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/vector3.h>
#include <stddef.h>
#include <vector>

struct aiMesh;

namespace Assimp    {

// ---------------------------------------------------------------------------
/** \brief Helper class to generate vertex buffers for standard geometric
 *  shapes, such as cylinders, cones, boxes, spheres, elipsoids ... .
 */
class ASSIMP_API StandardShapes
{
    // class cannot be instanced
    StandardShapes() {}

public:


    // ----------------------------------------------------------------
    /** Generates a mesh from an array of vertex positions.
     *
     *  @param positions List of vertex positions
     *  @param numIndices Number of indices per primitive
     *  @return Output mesh
     */
    static aiMesh* MakeMesh(const std::vector<aiVector3D>& positions,
        unsigned int numIndices);


    static aiMesh* MakeMesh ( unsigned int (*GenerateFunc)
        (std::vector<aiVector3D>&));

    static aiMesh* MakeMesh ( unsigned int (*GenerateFunc)
        (std::vector<aiVector3D>&, bool));

    static aiMesh* MakeMesh ( unsigned int n,  void (*GenerateFunc)
        (unsigned int,std::vector<aiVector3D>&));

    // ----------------------------------------------------------------
    /** @brief Generates a hexahedron (cube)
     *
     *  Hexahedrons can be scaled on all axes.
     *  @param positions Receives output triangles.
     *  @param polygons If you pass true here quads will be returned
     *  @return Number of vertices per face
     */
    static unsigned int MakeHexahedron(
        std::vector<aiVector3D>& positions,
        bool polygons = false);

    // ----------------------------------------------------------------
    /** @brief Generates an icosahedron
     *
     *  @param positions Receives output triangles.
     *  @return Number of vertices per face
     */
    static unsigned int MakeIcosahedron(
        std::vector<aiVector3D>& positions);


    // ----------------------------------------------------------------
    /** @brief Generates a dodecahedron
     *
     *  @param positions Receives output triangles
     *  @param polygons If you pass true here pentagons will be returned
     *  @return Number of vertices per face
     */
    static unsigned int MakeDodecahedron(
        std::vector<aiVector3D>& positions,
        bool polygons = false);


    // ----------------------------------------------------------------
    /** @brief Generates an octahedron
     *
     *  @param positions Receives output triangles.
     *  @return Number of vertices per face
     */
    static unsigned int MakeOctahedron(
        std::vector<aiVector3D>& positions);


    // ----------------------------------------------------------------
    /** @brief Generates a tetrahedron
     *
     *  @param positions Receives output triangles.
     *  @return Number of vertices per face
     */
    static unsigned int MakeTetrahedron(
        std::vector<aiVector3D>& positions);



    // ----------------------------------------------------------------
    /** @brief Generates a sphere
     *
     *  @param tess Number of subdivions - 0 generates a octahedron
     *  @param positions Receives output triangles.
     */
    static void MakeSphere(unsigned int tess,
        std::vector<aiVector3D>& positions);


    // ----------------------------------------------------------------
    /** @brief Generates a cone or a cylinder, either open or closed.
     *
     *  @code
     *
     *       |-----|       <- radius 1
     *
     *        __x__        <- ]               ^
     *       /     \          | height        |
     *      /       \         |               Y
     *     /         \        |
     *    /           \       |
     *   /______x______\   <- ] <- end cap
     *
     *   |-------------|   <- radius 2
     *
     *  @endcode
     *
     *  @param height Height of the cone
     *  @param radius1 First radius
     *  @param radius2 Second radius
     *  @param tess Number of triangles.
     *  @param bOpened true for an open cone/cylinder. An open shape has
     *    no 'end caps'
     *  @param positions Receives output triangles
     */
    static void MakeCone(ai_real height,ai_real radius1,
        ai_real radius2,unsigned int tess,
        std::vector<aiVector3D>& positions,bool bOpen= false);


    // ----------------------------------------------------------------
    /** @brief Generates a flat circle
     *
     *  The circle is constructed in the planned formed by the x,z
     *  axes of the cartesian coordinate system.
     *
     *  @param radius Radius of the circle
     *  @param tess Number of segments.
     *  @param positions Receives output triangles.
     */
    static void MakeCircle(ai_real radius, unsigned int tess,
        std::vector<aiVector3D>& positions);

};
} // ! Assimp

#endif // !! AI_STANDARD_SHAPES_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/StreamReader.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Defines the StreamReader class which reads data from
 *  a binary stream with a well-defined endianness.
 */
#pragma once
#ifndef AI_STREAMREADER_H_INCLUDED
#define AI_STREAMREADER_H_INCLUDED

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/ByteSwapper.h>
#include <assimp/Exceptional.h>
#include <assimp/IOStream.hpp>

#include <memory>

namespace Assimp {

// --------------------------------------------------------------------------------------------
/** Wrapper class around IOStream to allow for consistent reading of binary data in both
 *  little and big endian format. Don't attempt to instance the template directly. Use
 *  StreamReaderLE to read from a little-endian stream and StreamReaderBE to read from a
 *  BE stream. The class expects that the endianness of any input data is known at
 *  compile-time, which should usually be true (#BaseImporter::ConvertToUTF8 implements
 *  runtime endianness conversions for text files).
 *
 *  XXX switch from unsigned int for size types to size_t? or ptrdiff_t?*/
// --------------------------------------------------------------------------------------------
template <bool SwapEndianess = false, bool RuntimeSwitch = false>
class StreamReader {
public:
    using diff = size_t;
    using pos = size_t;

    // ---------------------------------------------------------------------
    /** Construction from a given stream with a well-defined endianness.
     *
     *  The StreamReader holds a permanent strong reference to the
     *  stream, which is released upon destruction.
     *  @param stream Input stream. The stream is not restarted if
     *    its file pointer is not at 0. Instead, the stream reader
     *    reads from the current position to the end of the stream.
     *  @param le If @c RuntimeSwitch is true: specifies whether the
     *    stream is in little endian byte order. Otherwise the
     *    endianness information is contained in the @c SwapEndianess
     *    template parameter and this parameter is meaningless.  */
    StreamReader(std::shared_ptr<IOStream> stream, bool le = false) :
            mStream(stream),
            mBuffer(nullptr),
            mCurrent(nullptr),
            mEnd(nullptr),
            mLimit(nullptr),
            mLe(le) {
        ai_assert(stream);
        InternBegin();
    }

    // ---------------------------------------------------------------------
    StreamReader(IOStream *stream, bool le = false) :
            mStream(std::shared_ptr<IOStream>(stream)),
            mBuffer(nullptr),
            mCurrent(nullptr),
            mEnd(nullptr),
            mLimit(nullptr),
            mLe(le) {
        ai_assert(nullptr != stream);
        InternBegin();
    }

    // ---------------------------------------------------------------------
    ~StreamReader() {
        delete[] mBuffer;
    }

    // deprecated, use overloaded operator>> instead

    // ---------------------------------------------------------------------
    /// Read a float from the stream.
    float GetF4() {
        return Get<float>();
    }

    // ---------------------------------------------------------------------
    /// Read a double from the stream.
    double GetF8() {
        return Get<double>();
    }

    // ---------------------------------------------------------------------
    /** Read a signed 16 bit integer from the stream */
    int16_t GetI2() {
        return Get<int16_t>();
    }

    // ---------------------------------------------------------------------
    /** Read a signed 8 bit integer from the stream */
    int8_t GetI1() {
        return Get<int8_t>();
    }

    // ---------------------------------------------------------------------
    /** Read an signed 32 bit integer from the stream */
    int32_t GetI4() {
        return Get<int32_t>();
    }

    // ---------------------------------------------------------------------
    /** Read a signed 64 bit integer from the stream */
    int64_t GetI8() {
        return Get<int64_t>();
    }

    // ---------------------------------------------------------------------
    /** Read a unsigned 16 bit integer from the stream */
    uint16_t GetU2() {
        return Get<uint16_t>();
    }

    // ---------------------------------------------------------------------
    /// Read a unsigned 8 bit integer from the stream
    uint8_t GetU1() {
        return Get<uint8_t>();
    }

    // ---------------------------------------------------------------------
    /// Read an unsigned 32 bit integer from the stream
    uint32_t GetU4() {
        return Get<uint32_t>();
    }

    // ---------------------------------------------------------------------
    /// Read a unsigned 64 bit integer from the stream
    uint64_t GetU8() {
        return Get<uint64_t>();
    }

    // ---------------------------------------------------------------------
    /// Get the remaining stream size (to the end of the stream)
    size_t GetRemainingSize() const {
        return (unsigned int)(mEnd - mCurrent);
    }

    // ---------------------------------------------------------------------
    /** Get the remaining stream size (to the current read limit). The
     *  return value is the remaining size of the stream if no custom
     *  read limit has been set. */
    size_t GetRemainingSizeToLimit() const {
        return (unsigned int)(mLimit - mCurrent);
    }

    // ---------------------------------------------------------------------
    /** Increase the file pointer (relative seeking)  */
    void IncPtr(intptr_t plus) {
        mCurrent += plus;
        if (mCurrent > mLimit) {
            throw DeadlyImportError("End of file or read limit was reached");
        }
    }

    // ---------------------------------------------------------------------
    /** Get the current file pointer */
    int8_t *GetPtr() const {
        return mCurrent;
    }

    // ---------------------------------------------------------------------
    /** Set current file pointer (Get it from #GetPtr). This is if you
     *  prefer to do pointer arithmetic on your own or want to copy
     *  large chunks of data at once.
     *  @param p The new pointer, which is validated against the size
     *    limit and buffer boundaries. */
    void SetPtr(int8_t *p) {
        mCurrent = p;
        if (mCurrent > mLimit || mCurrent < mBuffer) {
            throw DeadlyImportError("End of file or read limit was reached");
        }
    }

    // ---------------------------------------------------------------------
    /** Copy n bytes to an external buffer
     *  @param out Destination for copying
     *  @param bytes Number of bytes to copy */
    void CopyAndAdvance(void *out, size_t bytes) {
        int8_t *ur = GetPtr();
        SetPtr(ur + bytes); // fire exception if eof

        ::memcpy(out, ur, bytes);
    }

    /// @brief Get the current offset from the beginning of the file
    int GetCurrentPos() const {
        return (unsigned int)(mCurrent - mBuffer);
    }

    void SetCurrentPos(size_t pos) {
        SetPtr(mBuffer + pos);
    }

    // ---------------------------------------------------------------------
    /** Setup a temporary read limit
     *
     *  @param limit Maximum number of bytes to be read from
     *    the beginning of the file. Specifying UINT_MAX
     *    resets the limit to the original end of the stream.
     *  Returns the previously set limit. */
    unsigned int SetReadLimit(unsigned int _limit) {
        unsigned int prev = GetReadLimit();
        if (UINT_MAX == _limit) {
            mLimit = mEnd;
            return prev;
        }

        mLimit = mBuffer + _limit;
        if (mLimit > mEnd) {
            throw DeadlyImportError("StreamReader: Invalid read limit");
        }
        return prev;
    }

    // ---------------------------------------------------------------------
    /** Get the current read limit in bytes. Reading over this limit
     *  accidentally raises an exception.  */
    unsigned int GetReadLimit() const {
        return (unsigned int)(mLimit - mBuffer);
    }

    // ---------------------------------------------------------------------
    /** Skip to the read limit in bytes. Reading over this limit
     *  accidentally raises an exception. */
    void SkipToReadLimit() {
        mCurrent = mLimit;
    }

    // ---------------------------------------------------------------------
    /** overload operator>> and allow chaining of >> ops. */
    template <typename T>
    StreamReader &operator>>(T &f) {
        f = Get<T>();
        return *this;
    }

    // ---------------------------------------------------------------------
    /** Generic read method. ByteSwap::Swap(T*) *must* be defined */
    template <typename T>
    T Get() {
        if (mCurrent + sizeof(T) > mLimit) {
            throw DeadlyImportError("End of file or stream limit was reached");
        }

        T f;
        ::memcpy(&f, mCurrent, sizeof(T));
        Intern::Getter<SwapEndianess, T, RuntimeSwitch>()(&f, mLe);
        mCurrent += sizeof(T);

        return f;
    }

private:
    // ---------------------------------------------------------------------
    void InternBegin() {
        if (nullptr == mStream) {
            throw DeadlyImportError("StreamReader: Unable to open file");
        }

        const size_t filesize = mStream->FileSize() - mStream->Tell();
        if (0 == filesize) {
            throw DeadlyImportError("StreamReader: File is empty or EOF is already reached");
        }

        mCurrent = mBuffer = new int8_t[filesize];
        const size_t read = mStream->Read(mCurrent, 1, filesize);
        // (read < s) can only happen if the stream was opened in text mode, in which case FileSize() is not reliable
        ai_assert(read <= filesize);
        mEnd = mLimit = &mBuffer[read - 1] + 1;
    }

private:
    std::shared_ptr<IOStream> mStream;
    int8_t *mBuffer;
    int8_t *mCurrent;
    int8_t *mEnd;
    int8_t *mLimit;
    bool mLe;
};

// --------------------------------------------------------------------------------------------
// `static` StreamReaders. Their byte order is fixed and they might be a little bit faster.
#ifdef AI_BUILD_BIG_ENDIAN
typedef StreamReader<true> StreamReaderLE;
typedef StreamReader<false> StreamReaderBE;
#else
typedef StreamReader<true> StreamReaderBE;
typedef StreamReader<false> StreamReaderLE;
#endif

// `dynamic` StreamReader. The byte order of the input data is specified in the
// c'tor. This involves runtime branching and might be a little bit slower.
typedef StreamReader<true, true> StreamReaderAny;

} // end namespace Assimp

#endif // !! AI_STREAMREADER_H_INCLUDED


============================================================
File Path: project/externals/assimp/include/assimp/StreamWriter.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Defines the StreamWriter class which writes data to
 *  a binary stream with a well-defined endianness. */
#pragma once
#ifndef AI_STREAMWRITER_H_INCLUDED
#define AI_STREAMWRITER_H_INCLUDED

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/ByteSwapper.h>
#include <assimp/IOStream.hpp>

#include <memory>
#include <vector>

namespace Assimp {

// --------------------------------------------------------------------------------------------
/** Wrapper class around IOStream to allow for consistent writing of binary data in both
 *  little and big endian format. Don't attempt to instance the template directly. Use
 *  StreamWriterLE to write to a little-endian stream and StreamWriterBE to write to a
 *  BE stream. Alternatively, there is StreamWriterAny if the endianness of the output
 *  stream is to be determined at runtime.
 */
// --------------------------------------------------------------------------------------------
template <bool SwapEndianess = false, bool RuntimeSwitch = false>
class StreamWriter {
    enum {
        INITIAL_CAPACITY = 1024
    };

public:

    // ---------------------------------------------------------------------
    /** Construction from a given stream with a well-defined endianness.
     *
     *  The StreamReader holds a permanent strong reference to the
     *  stream, which is released upon destruction.
     *  @param stream Input stream. The stream is not re-seeked and writing
          continues at the current position of the stream cursor.
     *  @param le If @c RuntimeSwitch is true: specifies whether the
     *    stream is in little endian byte order. Otherwise the
     *    endianness information is defined by the @c SwapEndianess
     *    template parameter and this parameter is meaningless.  */
    StreamWriter(std::shared_ptr<IOStream> stream, bool le = false)
        : stream(stream)
        , le(le)
        , cursor()
    {
        ai_assert(stream);
        buffer.reserve(INITIAL_CAPACITY);
    }

    // ---------------------------------------------------------------------
    StreamWriter(IOStream* stream, bool le = false)
        : stream(std::shared_ptr<IOStream>(stream))
        , le(le)
        , cursor()
    {
        ai_assert(stream);
        buffer.reserve(INITIAL_CAPACITY);
    }

    // ---------------------------------------------------------------------
    ~StreamWriter() {
        stream->Write(buffer.data(), 1, buffer.size());
        stream->Flush();
    }

public:

    // ---------------------------------------------------------------------
    /** Flush the contents of the internal buffer, and the output IOStream */
    void Flush()
    {
        stream->Write(buffer.data(), 1, buffer.size());
        stream->Flush();
        buffer.clear();
        cursor = 0;
    }

    // ---------------------------------------------------------------------
    /** Seek to the given offset / origin in the output IOStream.
     *
     *  Flushes the internal buffer and the output IOStream prior to seeking. */
    aiReturn Seek(size_t pOffset, aiOrigin pOrigin=aiOrigin_SET)
    {
        Flush();
        return stream->Seek(pOffset, pOrigin);
    }

    // ---------------------------------------------------------------------
    /** Tell the current position in the output IOStream.
     *
     *  First flushes the internal buffer and the output IOStream. */
    size_t Tell()
    {
        Flush();
        return stream->Tell();
    }

public:

    // ---------------------------------------------------------------------
    /** Write a float to the stream  */
    void PutF4(float f)
    {
        Put(f);
    }

    // ---------------------------------------------------------------------
    /** Write a double to the stream  */
    void PutF8(double d)    {
        Put(d);
    }

    // ---------------------------------------------------------------------
    /** Write a signed 16 bit integer to the stream */
    void PutI2(int16_t n)   {
        Put(n);
    }

    // ---------------------------------------------------------------------
    /** Write a signed 8 bit integer to the stream */
    void PutI1(int8_t n)    {
        Put(n);
    }

    // ---------------------------------------------------------------------
    /** Write an signed 32 bit integer to the stream */
    void PutI4(int32_t n)   {
        Put(n);
    }

    // ---------------------------------------------------------------------
    /** Write a signed 64 bit integer to the stream */
    void PutI8(int64_t n)   {
        Put(n);
    }

    // ---------------------------------------------------------------------
    /** Write a unsigned 16 bit integer to the stream */
    void PutU2(uint16_t n)  {
        Put(n);
    }

    // ---------------------------------------------------------------------
    /** Write a unsigned 8 bit integer to the stream */
    void PutU1(uint8_t n)   {
        Put(n);
    }

    // ---------------------------------------------------------------------
    /** Write an unsigned 32 bit integer to the stream */
    void PutU4(uint32_t n)  {
        Put(n);
    }

    // ---------------------------------------------------------------------
    /** Write a unsigned 64 bit integer to the stream */
    void PutU8(uint64_t n)  {
        Put(n);
    }

    // ---------------------------------------------------------------------
    /** Write a single character to the stream */
    void PutChar(char c)    {
        Put(c);
    }

    // ---------------------------------------------------------------------
    /** Write an aiString to the stream */
    void PutString(const aiString& s)
    {
        // as Put(T f) below
        if (cursor + s.length >= buffer.size()) {
            buffer.resize(cursor + s.length);
        }
        void* dest = &buffer[cursor];
        ::memcpy(dest, s.C_Str(), s.length);
        cursor += s.length;
    }

    // ---------------------------------------------------------------------
    /** Write a std::string to the stream */
    void PutString(const std::string& s)
    {
        // as Put(T f) below
        if (cursor + s.size() >= buffer.size()) {
            buffer.resize(cursor + s.size());
        }
        void* dest = &buffer[cursor];
        ::memcpy(dest, s.c_str(), s.size());
        cursor += s.size();
    }

public:

    // ---------------------------------------------------------------------
    /** overload operator<< and allow chaining of MM ops. */
    template <typename T>
    StreamWriter& operator << (T f) {
        Put(f);
        return *this;
    }

    // ---------------------------------------------------------------------
    std::size_t GetCurrentPos() const {
        return cursor;
    }

    // ---------------------------------------------------------------------
    void SetCurrentPos(std::size_t new_cursor) {
        cursor = new_cursor;
    }

    // ---------------------------------------------------------------------
    /** Generic write method. ByteSwap::Swap(T*) *must* be defined */
    template <typename T>
    void Put(T f)   {
        Intern :: Getter<SwapEndianess,T,RuntimeSwitch>() (&f, le);

        if (cursor + sizeof(T) >= buffer.size()) {
            buffer.resize(cursor + sizeof(T));
        }

        void* dest = &buffer[cursor];

        // reinterpret_cast + assignment breaks strict aliasing rules
        // and generally causes trouble on platforms such as ARM that
        // do not silently ignore alignment faults.
        ::memcpy(dest, &f, sizeof(T));
        cursor += sizeof(T);
    }

private:

    std::shared_ptr<IOStream> stream;
    bool le;

    std::vector<uint8_t> buffer;
    std::size_t cursor;
};


// --------------------------------------------------------------------------------------------
// `static` StreamWriter. Their byte order is fixed and they might be a little bit faster.
#ifdef AI_BUILD_BIG_ENDIAN
    typedef StreamWriter<true>  StreamWriterLE;
    typedef StreamWriter<false> StreamWriterBE;
#else
    typedef StreamWriter<true>  StreamWriterBE;
    typedef StreamWriter<false> StreamWriterLE;
#endif

// `dynamic` StreamWriter. The byte order of the input data is specified in the
// c'tor. This involves runtime branching and might be a little bit slower.
typedef StreamWriter<true,true> StreamWriterAny;

} // end namespace Assimp

#endif // !! AI_STREAMWriter_H_INCLUDED


============================================================
File Path: project/externals/assimp/include/assimp/StringComparison.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Definition of platform independent string workers:

   ASSIMP_itoa10
   ASSIMP_stricmp
   ASSIMP_strincmp

   These functions are not consistently available on all platforms,
   or the provided implementations behave too differently.
*/
#pragma once
#ifndef INCLUDED_AI_STRING_WORKERS_H
#define INCLUDED_AI_STRING_WORKERS_H

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/StringComparison.h>
#include <assimp/ai_assert.h>
#include <assimp/defs.h>

#include <cstdint>
#include <cstring>
#include <string>

namespace Assimp {

// -------------------------------------------------------------------------------
/** @brief itoa with a fixed base 10
 * 'itoa' is not consistently available on all platforms so it is quite useful
 * to have a small replacement function here. No need to use a full sprintf()
 * if we just want to print a number ...
 * @param out Output buffer
 * @param max Maximum number of characters to be written, including '\0'.
 *   This parameter may not be 0.
 * @param number Number to be written
 * @return Length of the output string, excluding the '\0'
 */
inline unsigned int ASSIMP_itoa10(char *out, unsigned int max, int32_t number) {
    ai_assert(nullptr != out);

    // write the unary minus to indicate we have a negative number
    unsigned int written = 1u;
    if (number < 0 && written < max) {
        *out++ = '-';
        ++written;
        number = -number;
    }

    // We begin with the largest number that is not zero.
    int32_t cur = 1000000000; // 2147483648
    bool mustPrint = false;
    while (written < max) {

        const unsigned int digit = number / cur;
        if (mustPrint || digit > 0 || 1 == cur) {
            // print all future zero's from now
            mustPrint = true;

            *out++ = '0' + static_cast<char>(digit);

            ++written;
            number -= digit * cur;
            if (1 == cur) {
                break;
            }
        }
        cur /= 10;
    }

    // append a terminal zero
    *out++ = '\0';
    return written - 1;
}

// -------------------------------------------------------------------------------
/** @brief itoa with a fixed base 10 (Secure template overload)
 *  The compiler should choose this function if he or she is able to determine the
 *  size of the array automatically.
 */
template <size_t length>
inline unsigned int ASSIMP_itoa10(char (&out)[length], int32_t number) {
    return ASSIMP_itoa10(out, length, number);
}

// -------------------------------------------------------------------------------
/** @brief Helper function to do platform independent string comparison.
 *
 *  This is required since stricmp() is not consistently available on
 *  all platforms. Some platforms use the '_' prefix, others don't even
 *  have such a function.
 *
 *  @param s1 First input string
 *  @param s2 Second input string
 *  @return 0 if the given strings are identical
 */
inline int ASSIMP_stricmp(const char *s1, const char *s2) {
    ai_assert(nullptr != s1);
    ai_assert(nullptr != s2);

#if (defined _MSC_VER)

    return ::_stricmp(s1, s2);
#else
    char c1, c2;
    do {
        c1 = tolower((unsigned char)*(s1++));
        c2 = tolower((unsigned char)*(s2++));
    } while (c1 && (c1 == c2));
    return c1 - c2;
#endif
}

// -------------------------------------------------------------------------------
/** @brief Case independent comparison of two std::strings
 *
 *  @param a First  string
 *  @param b Second string
 *  @return 0 if a == b
 */
inline int ASSIMP_stricmp(const std::string &a, const std::string &b) {
    int i = (int)b.length() - (int)a.length();
    return (i ? i : ASSIMP_stricmp(a.c_str(), b.c_str()));
}

// -------------------------------------------------------------------------------
/** @brief Helper function to do platform independent string comparison.
 *
 *  This is required since strincmp() is not consistently available on
 *  all platforms. Some platforms use the '_' prefix, others don't even
 *  have such a function.
 *
 *  @param s1 First input string
 *  @param s2 Second input string
 *  @param n Maximum number of characters to compare
 *  @return 0 if the given strings are identical
 */
inline int ASSIMP_strincmp(const char *s1, const char *s2, unsigned int n) {
    ai_assert(nullptr != s1);
    ai_assert(nullptr != s2);
    if (!n) {
        return 0;
    }

#if (defined _MSC_VER)

    return ::_strnicmp(s1, s2, n);

#elif defined(__GNUC__)

    return ::strncasecmp(s1, s2, n);

#else
    char c1, c2;
    unsigned int p = 0;
    do {
        if (p++ >= n) return 0;
        c1 = tolower((unsigned char)*(s1++));
        c2 = tolower((unsigned char)*(s2++));
    } while (c1 && (c1 == c2));

    return c1 - c2;
#endif
}

// -------------------------------------------------------------------------------
/** @brief Evaluates an integer power
 *
 * todo: move somewhere where it fits better in than here
 */
inline unsigned int integer_pow(unsigned int base, unsigned int power) {
    unsigned int res = 1;
    for (unsigned int i = 0; i < power; ++i) {
        res *= base;
    }

    return res;
}

} // namespace Assimp

#endif // !  AI_STRINGCOMPARISON_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/StringUtils.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
copyright notice, this list of conditions and the
following disclaimer.

* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the
following disclaimer in the documentation and/or other
materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
contributors may be used to endorse or promote products
derived from this software without specific prior
written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/
#pragma once
#ifndef INCLUDED_AI_STRINGUTILS_H
#define INCLUDED_AI_STRINGUTILS_H

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/defs.h>

#include <cstdarg>
#include <algorithm>
#include <cctype>
#include <cstdlib>
#include <locale>
#include <sstream>
#include <iomanip>

#if defined(_MSC_VER) && !defined(__clang__)
#define AI_SIZEFMT "%Iu"
#else
#define AI_SIZEFMT "%zu"
#endif

// ---------------------------------------------------------------------------------
///	@fn		ai_snprintf
///	@brief	The portable version of the function snprintf ( C99 standard ), which
///         works on visual studio compilers 2013 and earlier.
///	@param	outBuf		The buffer to write in
///	@param	size		The buffer size
///	@param	format		The format string
///	@param	ap			The additional arguments.
///	@return	The number of written characters if the buffer size was big enough.
///         If an encoding error occurs, a negative number is returned.
// ---------------------------------------------------------------------------------
#if defined(_MSC_VER) && _MSC_VER < 1900

inline int c99_ai_vsnprintf(char *outBuf, size_t size, const char *format, va_list ap) {
    int count(-1);
    if (0 != size) {
        count = _vsnprintf_s(outBuf, size, _TRUNCATE, format, ap);
    }
    if (count == -1) {
        count = _vscprintf(format, ap);
    }

    return count;
}

inline int ai_snprintf(char *outBuf, size_t size, const char *format, ...) {
    int count;
    va_list ap;

    va_start(ap, format);
    count = c99_ai_vsnprintf(outBuf, size, format, ap);
    va_end(ap);

    return count;
}

#elif defined(__MINGW32__)
#define ai_snprintf __mingw_snprintf
#else
#define ai_snprintf snprintf
#endif

// ---------------------------------------------------------------------------------
///	@fn		to_string
///	@brief	The portable version of to_string ( some gcc-versions on embedded
///         devices are not supporting this).
///	@param	value   The value to write into the std::string.
///	@return	The value as a std::string
// ---------------------------------------------------------------------------------
template <typename T>
AI_FORCE_INLINE std::string ai_to_string(T value) {
    std::ostringstream os;
    os << value;

    return os.str();
}

// ---------------------------------------------------------------------------------
///	@fn		ai_strtof
///	@brief	The portable version of strtof.
///	@param	begin   The first character of the string.
/// @param  end     The last character
///	@return	The float value, 0.0f in case of an error.
// ---------------------------------------------------------------------------------
AI_FORCE_INLINE
float ai_strtof(const char *begin, const char *end) {
    if (nullptr == begin) {
        return 0.0f;
    }
    float val(0.0f);
    if (nullptr == end) {
        val = static_cast<float>(::atof(begin));
    } else {
        std::string::size_type len(end - begin);
        std::string token(begin, len);
        val = static_cast<float>(::atof(token.c_str()));
    }

    return val;
}

// ---------------------------------------------------------------------------------
///	@fn		DecimalToHexa
///	@brief	The portable to convert a decimal value into a hexadecimal string.
///	@param	toConvert   Value to convert
///	@return	The hexadecimal string, is empty in case of an error.
// ---------------------------------------------------------------------------------
template <class T>
AI_FORCE_INLINE std::string ai_decimal_to_hexa(T toConvert) {
    std::string result;
    std::stringstream ss;
    ss << std::hex << toConvert;
    ss >> result;

    for (size_t i = 0; i < result.size(); ++i) {
        result[i] = (char)toupper((unsigned char)result[i]);
    }

    return result;
}

// ---------------------------------------------------------------------------------
///	@brief	translate RGBA to String
///	@param	r   aiColor.r
///	@param	g   aiColor.g
///	@param	b   aiColor.b
///	@param	a   aiColor.a
///	@param	with_head   #
///	@return	The hexadecimal string, is empty in case of an error.
// ---------------------------------------------------------------------------------
AI_FORCE_INLINE std::string ai_rgba2hex(int r, int g, int b, int a, bool with_head) {
    std::stringstream ss;
    if (with_head) {
        ss << "#";
    }
    ss << std::hex << std::setfill('0') << std::setw(8) << (r << 24 | g << 16 | b << 8 | a);

    return ss.str();
}

// ---------------------------------------------------------------------------------
/// @brief   Performs a trim from start (in place)
/// @param  s   string to trim.
AI_FORCE_INLINE void ai_trim_left(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !std::isspace(ch);
    }));
}

// ---------------------------------------------------------------------------------
/// @brief  Performs a trim from end (in place).
/// @param  s   string to trim.
// ---------------------------------------------------------------------------------
// ---------------------------------------------------------------------------------
AI_FORCE_INLINE void ai_trim_right(std::string &s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !std::isspace(ch);
    }).base(), s.end());
}

// ---------------------------------------------------------------------------------
/// @brief  Performs a trim from both ends (in place).
/// @param  s   string to trim.
// ---------------------------------------------------------------------------------
AI_FORCE_INLINE std::string ai_trim(std::string &s) {
    std::string out(s);
    ai_trim_left(out);
    ai_trim_right(out);

    return out;
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE char_t ai_tolower(char_t in) {
    return (in >= (char_t)'A' && in <= (char_t)'Z') ? (char_t)(in + 0x20) : in;
}

// ---------------------------------------------------------------------------------
/// @brief  Performs a ToLower-operation and return the lower-case string.
/// @param  in  The incoming string.
/// @return The string as lowercase.
// ---------------------------------------------------------------------------------
AI_FORCE_INLINE std::string ai_tolower(const std::string &in) {
    std::string out(in);
    ai_trim_left(out);
    ai_trim_right(out);
    std::transform(out.begin(), out.end(), out.begin(), [](unsigned char c) { return ai_tolower(c); });
    return out;
}

// ---------------------------------------------------------------------------------
template <class char_t>
AI_FORCE_INLINE char_t ai_toupper(char_t in) {
    return (in >= (char_t)'a' && in <= (char_t)'z') ? (char_t)(in - 0x20) : in;
}

// ---------------------------------------------------------------------------------
/// @brief  Performs a ToLower-operation and return the upper-case string.
/// @param  in  The incoming string.
/// @return The string as uppercase.
AI_FORCE_INLINE std::string ai_str_toupper(const std::string &in) {
    std::string out(in);
    std::transform(out.begin(), out.end(), out.begin(), [](char c) { return ai_toupper(c); });
    return out;
}

// ---------------------------------------------------------------------------------
/// @brief  Make a string printable by replacing all non-printable characters with
///         the specified placeholder character.
/// @param  in  The incoming string.
/// @param  placeholder  Placeholder character, default is a question mark.
/// @return The string, with all non-printable characters replaced.
AI_FORCE_INLINE std::string ai_str_toprintable(const std::string &in, char placeholder = '?') {
    std::string out(in);
    std::transform(out.begin(), out.end(), out.begin(), [placeholder] (unsigned char c) {
        return isprint(c) ? (char)c :  placeholder;
    });
    return out;
}

// ---------------------------------------------------------------------------------
/// @brief  Make a string printable by replacing all non-printable characters with
///         the specified placeholder character.
/// @param  in  The incoming string.
/// @param  len The length of the incoming string.
/// @param  placeholder  Placeholder character, default is a question mark.
/// @return The string, with all non-printable characters replaced. Will return an
///         empty string if in is null or len is <= 0.
AI_FORCE_INLINE std::string ai_str_toprintable(const char *in, int len, char placeholder = '?') {
    return (in && len > 0) ? ai_str_toprintable(std::string(in, len), placeholder) : std::string();
}


#endif // INCLUDED_AI_STRINGUTILS_H


============================================================
File Path: project/externals/assimp/include/assimp/Subdivision.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Defines a helper class to evaluate subdivision surfaces.*/
#pragma once
#ifndef AI_SUBDISIVION_H_INC
#define AI_SUBDISIVION_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/types.h>

struct aiMesh;

namespace Assimp    {

// ------------------------------------------------------------------------------
/** Helper class to evaluate subdivision surfaces. Different algorithms
 *  are provided for choice. */
// ------------------------------------------------------------------------------
class ASSIMP_API Subdivider {
public:

    /** Enumerates all supported subvidision algorithms */
    enum Algorithm  {
        CATMULL_CLARKE = 0x1
    };

    virtual ~Subdivider();

    // ---------------------------------------------------------------
    /** Create a subdivider of a specific type
     *
     *  @param algo Algorithm to be used for subdivision
     *  @return Subdivider instance. */
    static Subdivider* Create (Algorithm algo);

    // ---------------------------------------------------------------
    /** Subdivide a mesh using the selected algorithm
     *
     *  @param mesh First mesh to be subdivided. Must be in verbose
     *    format.
     *  @param out Receives the output mesh, allocated by me.
     *  @param num Number of subdivisions to perform.
     *  @param discard_input If true is passed, the input mesh is
     *    deleted after the subdivision is complete. This can
     *    improve performance because it allows the optimization
     *    to reuse the existing mesh for intermediate results.
     *  @pre out!=mesh*/
    virtual void Subdivide ( aiMesh* mesh,
        aiMesh*& out, unsigned int num,
        bool discard_input = false) = 0;

    // ---------------------------------------------------------------
    /** Subdivide multiple meshes using the selected algorithm. This
     *  avoids erroneous smoothing on objects consisting of multiple
     *  per-material meshes. Usually, most 3d modellers smooth on a
     *  per-object base, regardless the materials assigned to the
     *  meshes.
     *
     *  @param smesh Array of meshes to be subdivided. Must be in
     *    verbose format.
     *  @param nmesh Number of meshes in smesh.
     *  @param out Receives the output meshes. The array must be
     *    sufficiently large (at least @c nmesh elements) and may not
     *    overlap the input array. Output meshes map one-to-one to
     *    their corresponding input meshes. The meshes are allocated
     *    by the function.
     *  @param discard_input If true is passed, input meshes are
     *    deleted after the subdivision is complete. This can
     *    improve performance because it allows the optimization
     *    of reusing existing meshes for intermediate results.
     *  @param num Number of subdivisions to perform.
     *  @pre nmesh != 0, smesh and out may not overlap*/
    virtual void Subdivide (
        aiMesh** smesh,
        size_t nmesh,
        aiMesh** out,
        unsigned int num,
        bool discard_input = false) = 0;

};

inline Subdivider::~Subdivider() = default;

} // end namespace Assimp


#endif // !!  AI_SUBDISIVION_H_INC



============================================================
File Path: project/externals/assimp/include/assimp/TinyFormatter.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  TinyFormatter.h
 *  @brief Utility to format log messages more easily. Introduced
 *    to get rid of the boost::format dependency. Much slinker,
 *    basically just extends stringstream.
 */
#pragma once
#ifndef INCLUDED_TINY_FORMATTER_H
#define INCLUDED_TINY_FORMATTER_H

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <sstream>

namespace Assimp {
namespace Formatter {

// ------------------------------------------------------------------------------------------------
/** stringstream utility. Usage:
 *  @code
 *  void writelog(const std::string&s);
 *  void writelog(const std::wstring&s);
 *  ...
 *  writelog(format()<< "hi! this is a number: " << 4);
 *  writelog(wformat()<< L"hi! this is a number: " << 4);
 *
 *  @endcode */
template < typename T,
    typename CharTraits = std::char_traits<T>,
    typename Allocator  = std::allocator<T> >
class basic_formatter {
public:
    typedef class std::basic_string<T,CharTraits,Allocator> string;
    typedef class std::basic_ostringstream<T,CharTraits,Allocator> stringstream;

    basic_formatter() {
        // empty
    }

    /* Allow basic_formatter<T>'s to be used almost interchangeably
     * with std::(w)string or const (w)char* arguments because the
     * conversion c'tor is called implicitly. */
    template <typename TT>
    basic_formatter(const TT& sin)  {
        underlying << sin;
    }

    // Same problem as the copy constructor below, but with root cause is that stream move
    // is not permitted on older GCC versions. Small performance impact on those platforms.
#if defined(__GNUC__) && (__GNUC__ == 4 && __GNUC_MINOR__ <= 9)
    basic_formatter(basic_formatter&& other) {
        underlying << (string)other;
    }
#else
    basic_formatter(basic_formatter&& other)
        : underlying(std::move(other.underlying)) {
    }
#endif

    // The problem described here:
    // https://sourceforge.net/tracker/?func=detail&atid=1067632&aid=3358562&group_id=226462
    // can also cause trouble here. Apparently, older gcc versions sometimes copy temporaries
    // being bound to const ref& function parameters. Copying streams is not permitted, though.
    // This workaround avoids this by manually specifying a copy ctor.
#if !defined(__GNUC__) || !defined(__APPLE__) || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
    explicit basic_formatter(const basic_formatter& other) {
        underlying << (string)other;
    }
#endif

    operator string () const {
        return underlying.str();
    }

    /* note - this is declared const because binding temporaries does only
     * work for const references, so many function prototypes will
     * include const basic_formatter<T>& s but might still want to
     * modify the formatted string without the need for a full copy.*/
    template <typename TToken, typename std::enable_if<!std::is_base_of<std::exception, TToken>::value>::type * = nullptr>
    const basic_formatter &operator<<(const TToken &s) const {
        underlying << s;
        return *this;
    }

    template <typename TToken, typename std::enable_if<std::is_base_of<std::exception, TToken>::value>::type * = nullptr>
    const basic_formatter &operator<<(const TToken &s) const {
        underlying << s.what();
        return *this;
    }

    template <typename TToken, typename std::enable_if<!std::is_base_of<std::exception, TToken>::value>::type * = nullptr>
    basic_formatter &operator<<(const TToken &s) {
        underlying << s;
        return *this;
    }

    template <typename TToken, typename std::enable_if<std::is_base_of<std::exception, TToken>::value>::type * = nullptr>
    basic_formatter &operator<<(const TToken &s) {
        underlying << s.what();
        return *this;
    }


    // comma operator overloaded as well, choose your preferred way.
    template <typename TToken>
    const basic_formatter& operator, (const TToken& s) const {
        *this << s;
        return *this;
    }

    template <typename TToken>
    basic_formatter& operator, (const TToken& s) {
        *this << s;
        return *this;
    }

    // Fix for MSVC8
    // See https://sourceforge.net/projects/assimp/forums/forum/817654/topic/4372824
    template <typename TToken>
    basic_formatter& operator, (TToken& s) {
        *this << s;
        return *this;
    }


private:
    mutable stringstream underlying;
};


typedef basic_formatter< char > format;
typedef basic_formatter< wchar_t > wformat;

} // ! namespace Formatter

} // ! namespace Assimp

#endif


============================================================
File Path: project/externals/assimp/include/assimp/Vertex.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/
/** @file Defines a helper class to represent an interleaved vertex
  along with arithmetic operations to support vertex operations
  such as subdivision, smoothing etc.

  While the code is kept as general as possible, arithmetic operations
  that are not currently well-defined (and would cause compile errors
  due to missing operators in the math library), are commented.
  */
#pragma once
#ifndef AI_VERTEX_H_INC
#define AI_VERTEX_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/vector3.h>
#include <assimp/mesh.h>
#include <assimp/ai_assert.h>

#include <functional>

namespace Assimp    {

    ///////////////////////////////////////////////////////////////////////////
    // std::plus-family operates on operands with identical types - we need to
    // support all the (vectype op float) combinations in vector maths.
    // Providing T(float) would open the way to endless implicit conversions.
    ///////////////////////////////////////////////////////////////////////////
    namespace Intern {
        template <typename T0, typename T1, typename TRES = T0> struct plus {
            TRES operator() (const T0& t0, const T1& t1) const {
                return t0+t1;
            }
        };
        template <typename T0, typename T1, typename TRES = T0> struct minus {
            TRES operator() (const T0& t0, const T1& t1) const {
                return t0-t1;
            }
        };
        template <typename T0, typename T1, typename TRES = T0> struct multiplies {
            TRES operator() (const T0& t0, const T1& t1) const {
                return t0*t1;
            }
        };
        template <typename T0, typename T1, typename TRES = T0> struct divides {
            TRES operator() (const T0& t0, const T1& t1) const {
                return t0/t1;
            }
        };
    }

// ------------------------------------------------------------------------------------------------
/** Intermediate description a vertex with all possible components. Defines a full set of
 *  operators, so you may use such a 'Vertex' in basic arithmetic. All operators are applied
 *  to *all* vertex components equally. This is useful for stuff like interpolation
 *  or subdivision, but won't work if special handling is required for some vertex components. */
// ------------------------------------------------------------------------------------------------
struct Vertex {
    friend Vertex operator + (const Vertex&,const Vertex&);
    friend Vertex operator - (const Vertex&,const Vertex&);
    friend Vertex operator * (const Vertex&,ai_real);
    friend Vertex operator / (const Vertex&,ai_real);
    friend Vertex operator * (ai_real, const Vertex&);

    aiVector3D position;
    aiVector3D normal;
    aiVector3D tangent, bitangent;

    aiVector3D texcoords[AI_MAX_NUMBER_OF_TEXTURECOORDS];
    aiColor4D colors[AI_MAX_NUMBER_OF_COLOR_SETS];

    Vertex() = default;

    // ----------------------------------------------------------------------------
    /** Extract a particular vertex from a mesh and interleave all components */
    explicit Vertex(const aiMesh* msh, unsigned int idx) {
        ai_assert(idx < msh->mNumVertices);
        position = msh->mVertices[idx];

        if (msh->HasNormals()) {
            normal = msh->mNormals[idx];
        }

        if (msh->HasTangentsAndBitangents()) {
            tangent = msh->mTangents[idx];
            bitangent = msh->mBitangents[idx];
        }

        for (unsigned int i = 0; msh->HasTextureCoords(i); ++i) {
            texcoords[i] = msh->mTextureCoords[i][idx];
        }

        for (unsigned int i = 0; msh->HasVertexColors(i); ++i) {
            colors[i] = msh->mColors[i][idx];
        }
    }

    // ----------------------------------------------------------------------------
    /** Extract a particular vertex from a anim mesh and interleave all components */
    explicit Vertex(const aiAnimMesh* msh, unsigned int idx) {
        ai_assert(idx < msh->mNumVertices);
        if (msh->HasPositions()) {
            position = msh->mVertices[idx];
        }

        if (msh->HasNormals()) {
            normal = msh->mNormals[idx];
        }

        if (msh->HasTangentsAndBitangents()) {
            tangent = msh->mTangents[idx];
            bitangent = msh->mBitangents[idx];
        }

        for (unsigned int i = 0; msh->HasTextureCoords(i); ++i) {
            texcoords[i] = msh->mTextureCoords[i][idx];
        }

        for (unsigned int i = 0; msh->HasVertexColors(i); ++i) {
           colors[i] = msh->mColors[i][idx];
        }
    }

    Vertex& operator += (const Vertex& v) {
        *this = *this+v;
        return *this;
    }

    Vertex& operator -= (const Vertex& v) {
        *this = *this-v;
        return *this;
    }

    Vertex& operator *= (ai_real v) {
        *this = *this*v;
        return *this;
    }

    Vertex& operator /= (ai_real v) {
        *this = *this/v;
        return *this;
    }

    // ----------------------------------------------------------------------------
    /// Convert back to non-interleaved storage
    void SortBack(aiMesh* out, unsigned int idx) const {
        ai_assert(idx<out->mNumVertices);
        out->mVertices[idx] = position;

        if (out->HasNormals()) {
            out->mNormals[idx] = normal;
        }

        if (out->HasTangentsAndBitangents()) {
            out->mTangents[idx] = tangent;
            out->mBitangents[idx] = bitangent;
        }

        for(unsigned int i = 0; out->HasTextureCoords(i); ++i) {
            out->mTextureCoords[i][idx] = texcoords[i];
        }

        for(unsigned int i = 0; out->HasVertexColors(i); ++i) {
            out->mColors[i][idx] = colors[i];
        }
    }

private:

    // ----------------------------------------------------------------------------
    /// Construct from two operands and a binary operation to combine them
    template <template <typename t> class op> static Vertex BinaryOp(const Vertex& v0, const Vertex& v1) {
        // this is a heavy task for the compiler to optimize ... *pray*

        Vertex res;
        res.position  = op<aiVector3D>()(v0.position,v1.position);
        res.normal    = op<aiVector3D>()(v0.normal,v1.normal);
        res.tangent   = op<aiVector3D>()(v0.tangent,v1.tangent);
        res.bitangent = op<aiVector3D>()(v0.bitangent,v1.bitangent);

        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i) {
            res.texcoords[i] = op<aiVector3D>()(v0.texcoords[i],v1.texcoords[i]);
        }
        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_COLOR_SETS; ++i) {
            res.colors[i] = op<aiColor4D>()(v0.colors[i],v1.colors[i]);
        }
        return res;
    }

    // ----------------------------------------------------------------------------
    /// This time binary arithmetic of v0 with a floating-point number
    template <template <typename, typename, typename> class op> static Vertex BinaryOp(const Vertex& v0, ai_real f) {
        // this is a heavy task for the compiler to optimize ... *pray*

        Vertex res;
        res.position  = op<aiVector3D,ai_real,aiVector3D>()(v0.position,f);
        res.normal    = op<aiVector3D,ai_real,aiVector3D>()(v0.normal,f);
        res.tangent   = op<aiVector3D,ai_real,aiVector3D>()(v0.tangent,f);
        res.bitangent = op<aiVector3D,ai_real,aiVector3D>()(v0.bitangent,f);

        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i) {
            res.texcoords[i] = op<aiVector3D,ai_real,aiVector3D>()(v0.texcoords[i],f);
        }
        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_COLOR_SETS; ++i) {
            res.colors[i] = op<aiColor4D,ai_real,aiColor4D>()(v0.colors[i],f);
        }
        return res;
    }

    // ----------------------------------------------------------------------------
    /** This time binary arithmetic of v0 with a floating-point number */
    template <template <typename, typename, typename> class op> static Vertex BinaryOp(ai_real f, const Vertex& v0) {
        // this is a heavy task for the compiler to optimize ... *pray*

        Vertex res;
        res.position  = op<ai_real,aiVector3D,aiVector3D>()(f,v0.position);
        res.normal    = op<ai_real,aiVector3D,aiVector3D>()(f,v0.normal);
        res.tangent   = op<ai_real,aiVector3D,aiVector3D>()(f,v0.tangent);
        res.bitangent = op<ai_real,aiVector3D,aiVector3D>()(f,v0.bitangent);

        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i) {
            res.texcoords[i] = op<ai_real,aiVector3D,aiVector3D>()(f,v0.texcoords[i]);
        }
        for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_COLOR_SETS; ++i) {
            res.colors[i] = op<ai_real,aiColor4D,aiColor4D>()(f,v0.colors[i]);
        }
        return res;
    }
};

// ------------------------------------------------------------------------------------------------
AI_FORCE_INLINE Vertex operator + (const Vertex& v0,const Vertex& v1) {
    return Vertex::BinaryOp<std::plus>(v0,v1);
}

AI_FORCE_INLINE Vertex operator - (const Vertex& v0,const Vertex& v1) {
    return Vertex::BinaryOp<std::minus>(v0,v1);
}

AI_FORCE_INLINE Vertex operator * (const Vertex& v0,ai_real f) {
    return Vertex::BinaryOp<Intern::multiplies>(v0,f);
}

AI_FORCE_INLINE Vertex operator / (const Vertex& v0,ai_real f) {
    return Vertex::BinaryOp<Intern::multiplies>(v0,1.f/f);
}

AI_FORCE_INLINE Vertex operator * (ai_real f,const Vertex& v0) {
    return Vertex::BinaryOp<Intern::multiplies>(f,v0);
}

}

#endif // AI_VERTEX_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/XMLTools.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

#pragma once
#ifndef INCLUDED_ASSIMP_XML_TOOLS_H
#define INCLUDED_ASSIMP_XML_TOOLS_H

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <string>

namespace Assimp {
    // XML escape the 5 XML special characters (",',<,> and &) in |data|
    // Based on http://stackoverflow.com/questions/5665231
    std::string XMLEscape(const std::string& data) {
        std::string buffer;

        const size_t size = data.size();
        buffer.reserve(size + size / 8);
        for(size_t i = 0; i < size; ++i) {
            const char c = data[i];
            switch(c) {
                case '&' :
                    buffer.append("&amp;");
                    break;
                case '\"':
                    buffer.append("&quot;");
                    break;
                case '\'':
                    buffer.append("&apos;");
                    break;
                case '<' :
                    buffer.append("&lt;");
                    break;
                case '>' :
                    buffer.append("&gt;");
                    break;
                default:
                    buffer.append(&c, 1);
                    break;
            }
        }
        return buffer;
    }
}

#endif // INCLUDED_ASSIMP_XML_TOOLS_H


============================================================
File Path: project/externals/assimp/include/assimp/XmlParser.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
copyright notice, this list of conditions and the
following disclaimer.

* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the
following disclaimer in the documentation and/or other
materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
contributors may be used to endorse or promote products
derived from this software without specific prior
written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

#ifndef INCLUDED_AI_IRRXML_WRAPPER
#define INCLUDED_AI_IRRXML_WRAPPER

#include <assimp/ai_assert.h>
#include <assimp/DefaultLogger.hpp>

#include "BaseImporter.h"
#include "IOStream.hpp"

#include <pugixml.hpp>
#include <utility>
#include <vector>

namespace Assimp {

/// @brief  Will find a node by its name.
struct find_node_by_name_predicate {
    /// @brief The default constructor.
    find_node_by_name_predicate() = default;


    std::string mName; ///< The name to find.
    find_node_by_name_predicate(const std::string &name) :
            mName(name) {
        // empty
    }

    bool operator()(pugi::xml_node node) const {
        return node.name() == mName;
    }
};

/// @brief  Will convert an attribute to its int value.
/// @tparam[in] TNodeType  The node type.
template <class TNodeType>
struct NodeConverter {
public:
    static int to_int(TNodeType &node, const char *attribName) {
        ai_assert(nullptr != attribName);
        return node.attribute(attribName).to_int();
    }
};

using XmlNode = pugi::xml_node;
using XmlAttribute = pugi::xml_attribute;

/// @brief The Xml-Parser class.
///
/// Use this parser if you have to import any kind of xml-format.
///
/// An example:
/// @code
/// TXmlParser<XmlNode> theParser;
/// if (theParser.parse(fileStream)) {
///     auto node = theParser.getRootNode();
///     for ( auto currentNode : node.children()) {
///         // Will loop over all children
///     }
/// }
/// @endcode
/// @tparam TNodeType
template <class TNodeType>
class TXmlParser {
public:
    /// @brief The default class constructor.
    TXmlParser();

    ///	@brief  The class destructor.
    ~TXmlParser();

    ///	@brief  Will clear the parsed xml-file.
    void clear();

    ///	@brief  Will search for a child-node by its name
    /// @param[in] name     The name of the child-node.
    /// @return The node instance or nullptr, if nothing was found.
    TNodeType *findNode(const std::string &name);

    /// @brief  Will return true, if the node is a child-node.
    /// @param[in]  name    The name of the child node to look for.
    /// @return true, if the node is a child-node or false if not.
    bool hasNode(const std::string &name);

    /// @brief  Will parse an xml-file from a given stream.
    /// @param[in] stream      The input stream.
    /// @return true, if the parsing was successful, false if not.
    bool parse(IOStream *stream);

    /// @brief  Will return true if a root node is there.
    /// @return true in case of an existing root.
    bool hasRoot() const;

    /// @brief  Will return the document pointer, is nullptr if no xml-file was parsed.
    /// @return The pointer showing to the document.
    pugi::xml_document *getDocument() const;

    /// @brief  Will return the root node, const version.
    /// @return The root node.
    const TNodeType getRootNode() const;

    /// @brief  Will return the root node, non-const version.
    /// @return The root node.
    TNodeType getRootNode();

    /// @brief Will check if a node with the given name is in.
    /// @param[in] node     The node to look in.
    /// @param[in] name     The name of the child-node.
    /// @return true, if node was found, false if not.
    static inline bool hasNode(XmlNode &node, const char *name);

    /// @brief Will check if an attribute is part of the XmlNode.
    /// @param[in] xmlNode  The node to search in.
    /// @param[in] name     The attribute name to look for.
    /// @return true, if the was found, false if not.
    static inline bool hasAttribute(XmlNode &xmlNode, const char *name);

    /// @brief Will try to get an unsigned int attribute value.
    /// @param[in] xmlNode  The node to search in.
    /// @param[in] name     The attribute name to look for.
    /// @param[out] val     The unsigned int value from the attribute.
    /// @return true, if the node contains an attribute with the given name and if the value is an unsigned int.
    static inline bool getUIntAttribute(XmlNode &xmlNode, const char *name, unsigned int &val);

    /// @brief Will try to get an int attribute value.
    /// @param[in] xmlNode  The node to search in.
    /// @param[in] name     The attribute name to look for.
    /// @param[out] val     The int value from the attribute.
    /// @return true, if the node contains an attribute with the given name and if the value is an int.
    static inline bool getIntAttribute(XmlNode &xmlNode, const char *name, int &val);

    /// @brief Will try to get a real attribute value.
    /// @param[in] xmlNode  The node to search in.
    /// @param[in] name     The attribute name to look for.
    /// @param[out] val     The real value from the attribute.
    /// @return true, if the node contains an attribute with the given name and if the value is a real.
    static inline bool getRealAttribute(XmlNode &xmlNode, const char *name, ai_real &val);

    /// @brief Will try to get a float attribute value.
    /// @param[in] xmlNode  The node to search in.
    /// @param[in] name     The attribute name to look for.
    /// @param[out] val     The float value from the attribute.
    /// @return true, if the node contains an attribute with the given name and if the value is a float.
    static inline bool getFloatAttribute(XmlNode &xmlNode, const char *name, float &val);

    /// @brief Will try to get a double attribute value.
    /// @param[in] xmlNode  The node to search in.
    /// @param[in] name     The attribute name to look for.
    /// @param[out] val     The double value from the attribute.
    /// @return true, if the node contains an attribute with the given name and if the value is a double.
    static inline bool getDoubleAttribute(XmlNode &xmlNode, const char *name, double &val);

    /// @brief Will try to get a std::string attribute value.
    /// @param[in] xmlNode  The node to search in.
    /// @param[in] name     The attribute name to look for.
    /// @param[out] val     The std::string value from the attribute.
    /// @return true, if the node contains an attribute with the given name and if the value is a std::string.
    static inline bool getStdStrAttribute(XmlNode &xmlNode, const char *name, std::string &val);

    /// @brief Will try to get a bool attribute value.
    /// @param[in] xmlNode  The node to search in.
    /// @param[in] name     The attribute name to look for.
    /// @param[out] val     The bool value from the attribute.
    /// @return true, if the node contains an attribute with the given name and if the value is a bool.
    static inline bool getBoolAttribute(XmlNode &xmlNode, const char *name, bool &val);

    /// @brief Will try to get the value of the node as a string.
    /// @param[in] node     The node to search in.
    /// @param[out] text    The value as a text.
    /// @return true, if the value can be read out.
    static inline bool getValueAsString(XmlNode &node, std::string &text);

    /// @brief Will try to get the value of the node as a float.
    /// @param[in] node     The node to search in.
    /// @param[out] text    The value as a float.
    /// @return true, if the value can be read out.
    static inline bool getValueAsFloat(XmlNode &node, ai_real &v);

    /// @brief Will try to get the value of the node as an integer.
    /// @param[in] node     The node to search in.
    /// @param[out] text    The value as a int.
    /// @return true, if the value can be read out.
    static inline bool getValueAsInt(XmlNode &node, int &v);

    /// @brief Will try to get the value of the node as an bool.
    /// @param[in] node     The node to search in.
    /// @param[out] text    The value as a bool.
    /// @return true, if the value can be read out.
    static inline bool getValueAsBool(XmlNode &node, bool &v);

private:
    pugi::xml_document *mDoc;
    TNodeType mCurrent;
    std::vector<char> mData;
};

template <class TNodeType>
inline TXmlParser<TNodeType>::TXmlParser() :
        mDoc(nullptr),
        mData() {
    // empty
}

template <class TNodeType>
inline TXmlParser<TNodeType>::~TXmlParser() {
    clear();
}

template <class TNodeType>
inline void TXmlParser<TNodeType>::clear() {
    if (mData.empty()) {
        if (mDoc) {
            delete mDoc;
        }
        mDoc = nullptr;
        return;
    }

    mData.clear();
    delete mDoc;
    mDoc = nullptr;
}

template <class TNodeType>
inline TNodeType *TXmlParser<TNodeType>::findNode(const std::string &name) {
    if (name.empty()) {
        return nullptr;
    }

    if (nullptr == mDoc) {
        return nullptr;
    }

    find_node_by_name_predicate predicate(name);
    mCurrent = mDoc->find_node(std::move(predicate));
    if (mCurrent.empty()) {
        return nullptr;
    }

    return &mCurrent;
}

template <class TNodeType>
bool TXmlParser<TNodeType>::hasNode(const std::string &name) {
    return nullptr != findNode(name);
}

template <class TNodeType>
bool TXmlParser<TNodeType>::parse(IOStream *stream) {
    if (hasRoot()) {
        clear();
    }

    if (nullptr == stream) {
        ASSIMP_LOG_DEBUG("Stream is nullptr.");
        return false;
    }

    const size_t len = stream->FileSize();
    mData.resize(len + 1);
    memset(&mData[0], '\0', len + 1);
    stream->Read(&mData[0], 1, len);

    mDoc = new pugi::xml_document();
    // load_string assumes native encoding (aka always utf-8 per build options)
    //pugi::xml_parse_result parse_result = mDoc->load_string(&mData[0], pugi::parse_full);
     pugi::xml_parse_result parse_result = mDoc->load_buffer(&mData[0], mData.size(), pugi::parse_full);
    if (parse_result.status == pugi::status_ok) {
        return true;
    }

    ASSIMP_LOG_DEBUG("Error while parse xml.", std::string(parse_result.description()), " @ ", parse_result.offset);

    return false;
}

template <class TNodeType>
bool TXmlParser<TNodeType>::hasRoot() const {
    return nullptr != mDoc;
}

template <class TNodeType>
pugi::xml_document *TXmlParser<TNodeType>::getDocument() const {
    return mDoc;
}

template <class TNodeType>
const TNodeType TXmlParser<TNodeType>::getRootNode() const {
    static pugi::xml_node none;
    if (nullptr == mDoc) {
        return none;
    }
    return mDoc->root();
}

template <class TNodeType>
TNodeType TXmlParser<TNodeType>::getRootNode() {
    static pugi::xml_node none;
    if (nullptr == mDoc) {
        return none;
    }

    return mDoc->root();
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::hasNode(XmlNode &node, const char *name) {
    pugi::xml_node child = node.find_child(find_node_by_name_predicate(name));
    return !child.empty();
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::hasAttribute(XmlNode &xmlNode, const char *name) {
    pugi::xml_attribute attr = xmlNode.attribute(name);
    return !attr.empty();
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getUIntAttribute(XmlNode &xmlNode, const char *name, unsigned int &val) {
    pugi::xml_attribute attr = xmlNode.attribute(name);
    if (attr.empty()) {
        return false;
    }

    val = attr.as_uint();
    return true;
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getIntAttribute(XmlNode &xmlNode, const char *name, int &val) {
    pugi::xml_attribute attr = xmlNode.attribute(name);
    if (attr.empty()) {
        return false;
    }

    val = attr.as_int();
    return true;
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getRealAttribute(XmlNode &xmlNode, const char *name, ai_real &val) {
    pugi::xml_attribute attr = xmlNode.attribute(name);
    if (attr.empty()) {
        return false;
    }
#ifdef ASSIMP_DOUBLE_PRECISION
    val = attr.as_double();
#else
    val = attr.as_float();
#endif
    return true;
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getFloatAttribute(XmlNode &xmlNode, const char *name, float &val) {
    pugi::xml_attribute attr = xmlNode.attribute(name);
    if (attr.empty()) {
        return false;
    }

    val = attr.as_float();

    return true;
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getDoubleAttribute(XmlNode &xmlNode, const char *name, double &val) {
    pugi::xml_attribute attr = xmlNode.attribute(name);
    if (attr.empty()) {
        return false;
    }

    val = attr.as_double();

    return true;
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getStdStrAttribute(XmlNode &xmlNode, const char *name, std::string &val) {
    pugi::xml_attribute attr = xmlNode.attribute(name);
    if (attr.empty()) {
        return false;
    }

    val = attr.as_string();

    return true;
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getBoolAttribute(XmlNode &xmlNode, const char *name, bool &val) {
    pugi::xml_attribute attr = xmlNode.attribute(name);
    if (attr.empty()) {
        return false;
    }

    val = attr.as_bool();

    return true;
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getValueAsString(XmlNode &node, std::string &text) {
    text = std::string();
    if (node.empty()) {
        return false;
    }

    text = node.text().as_string();

    return true;
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getValueAsFloat(XmlNode &node, ai_real &v) {
    if (node.empty()) {
        return false;
    }

    v = node.text().as_float();

    return true;
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getValueAsInt(XmlNode &node, int &v) {
    if (node.empty()) {
        return false;
    }

    v = node.text().as_int();

    return true;
}

template <class TNodeType>
inline bool TXmlParser<TNodeType>::getValueAsBool(XmlNode &node, bool &v) {
    if (node.empty()) {
        return false;
    }

    v = node.text().as_bool();

    return true;
}

using XmlParser = TXmlParser<pugi::xml_node>;

///	@brief  This class declares an iterator to loop through all children of the root node.
class XmlNodeIterator {
public:
    /// @brief The iteration mode.
    enum IterationMode {
        PreOrderMode, ///< Pre-ordering, get the values, continue the iteration.
        PostOrderMode ///< Post-ordering, continue the iteration, get the values.
    };
    ///	@brief  The class constructor
    /// @param  parent      [in] The xml parent to to iterate through.
    /// @param  mode        [in] The iteration mode.
    explicit XmlNodeIterator(XmlNode &parent, IterationMode mode) :
            mParent(parent),
            mNodes(),
            mIndex(0) {
        if (mode == PreOrderMode) {
            collectChildrenPreOrder(parent);
        } else {
            collectChildrenPostOrder(parent);
        }
    }

    ///	@brief  The class destructor, default implementation.
    ~XmlNodeIterator() = default;

    ///	@brief  Will iterate through all children in pre-order iteration.
    /// @param  node    [in] The nod to iterate through.
    void collectChildrenPreOrder(XmlNode &node) {
        if (node != mParent && node.type() == pugi::node_element) {
            mNodes.push_back(node);
        }
        for (XmlNode currentNode : node.children()) {
            collectChildrenPreOrder(currentNode);
        }
    }

    ///	@brief  Will iterate through all children in post-order iteration.
    /// @param  node    [in] The nod to iterate through.
    void collectChildrenPostOrder(XmlNode &node) {
        for (XmlNode currentNode = node.first_child(); currentNode; currentNode = currentNode.next_sibling()) {
            collectChildrenPostOrder(currentNode);
        }
        if (node != mParent) {
            mNodes.push_back(node);
        }
    }

    ///	@brief  Will iterate through all collected nodes.
    /// @param  next    The next node, if there is any.
    /// @return true, if there is a node left.
    bool getNext(XmlNode &next) {
        if (mIndex == mNodes.size()) {
            return false;
        }

        next = mNodes[mIndex];
        ++mIndex;

        return true;
    }

    ///	@brief  Will return the number of collected nodes.
    /// @return The number of collected nodes.
    size_t size() const {
        return mNodes.size();
    }

    ///	@brief  Returns true, if the node is empty.
    /// @return true, if the node is empty, false if not.
    bool isEmpty() const {
        return mNodes.empty();
    }

    ///	@brief  Will clear all collected nodes.
    void clear() {
        if (mNodes.empty()) {
            return;
        }

        mNodes.clear();
        mIndex = 0;
    }

private:
    XmlNode &mParent;
    std::vector<XmlNode> mNodes;
    size_t mIndex;
};

} // namespace Assimp

#endif // !! INCLUDED_AI_IRRXML_WRAPPER


============================================================
File Path: project/externals/assimp/include/assimp/ZipArchiveIOSystem.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team



All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file ZipArchiveIOSystem.h
 *  @brief Implementation of IOSystem to read a ZIP file from another IOSystem
*/

#pragma once
#ifndef AI_ZIPARCHIVEIOSYSTEM_H_INC
#define AI_ZIPARCHIVEIOSYSTEM_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/IOStream.hpp>
#include <assimp/IOSystem.hpp>

namespace Assimp {

class ZipArchiveIOSystem : public IOSystem {
public:
    //! Open a Zip using the proffered IOSystem
    ZipArchiveIOSystem(IOSystem* pIOHandler, const char *pFilename, const char* pMode = "r");
    ZipArchiveIOSystem(IOSystem* pIOHandler, const std::string& rFilename, const char* pMode = "r");
    virtual ~ZipArchiveIOSystem() override;
    bool Exists(const char* pFilename) const override;
    char getOsSeparator() const override;
    IOStream* Open(const char* pFilename, const char* pMode = "rb") override;
    void Close(IOStream* pFile) override;

    // Specific to ZIP
    //! The file was opened and is a ZIP
    bool isOpen() const;

    //! Get the list of all files with their simplified paths
    //! Intended for use within Assimp library boundaries
    void getFileList(std::vector<std::string>& rFileList) const;

    //! Get the list of all files with extension (must be lowercase)
    //! Intended for use within Assimp library boundaries
    void getFileListExtension(std::vector<std::string>& rFileList, const std::string& extension) const;

    static bool isZipArchive(IOSystem* pIOHandler, const char *pFilename);
    static bool isZipArchive(IOSystem* pIOHandler, const std::string& rFilename);

private:
    class Implement;
    Implement *pImpl = nullptr;
};

} // Namespace Assimp

#endif // AI_ZIPARCHIVEIOSYSTEM_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/aabb.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
copyright notice, this list of conditions and the
following disclaimer.

* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the
following disclaimer in the documentation and/or other
materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
contributors may be used to endorse or promote products
derived from this software without specific prior
written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

#pragma once
#ifndef AI_AABB_H_INC
#define AI_AABB_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/vector3.h>

// ---------------------------------------------------------------------------
/**
 *  An axis-aligned bounding box.
 */
struct aiAABB {
    C_STRUCT aiVector3D mMin;
    C_STRUCT aiVector3D mMax;

#ifdef __cplusplus
    /// @brief The default class constructor.
    aiAABB() :
            mMin(), mMax() {
        // empty
    }

    /// @brief The class constructor with the minimum and maximum.
    /// @param min  The minimum dimension.
    /// @param max  The maximum dimension.
    aiAABB(const aiVector3D &min, const aiVector3D &max) :
            mMin(min), mMax(max) {
        // empty
    }

    ///	@brief  The class destructor.
    ~aiAABB() = default;

#endif // __cplusplus
};

#endif // AI_AABB_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/ai_assert.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file ai_assert.h
 *  @brief Declares the assimp-specific assertion handler.
 */

#pragma once
#ifndef AI_ASSERT_H_INC
#define AI_ASSERT_H_INC

#include <assimp/defs.h>

#if defined(ASSIMP_BUILD_DEBUG)

namespace Assimp {

/// @brief Assert violation behavior can be customized: see AssertHandler.h.
/// @param failedExpression     The expression to validate.
/// @param file                 The file location
/// @param line                 The line number
ASSIMP_API void aiAssertViolation(const char* failedExpression, const char* file, int line);

}
#endif

// Define assertion resolinig
#if defined(ASSIMP_BUILD_DEBUG)
#   define ai_assert(expression) (void)((!!(expression)) || (Assimp::aiAssertViolation(#expression, __FILE__, __LINE__), 0))
#   define ai_assert_entry() ai_assert(false)
#else
#   define  ai_assert(expression)
#   define  ai_assert_entry()
#endif // ASSIMP_BUILD_DEBUG

#endif // AI_ASSERT_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/anim.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/**
  * @file   anim.h
  * @brief  Defines the data structures in which the imported animations
  *         are returned.
  */
#pragma once
#ifndef AI_ANIM_H_INC
#define AI_ANIM_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/quaternion.h>
#include <assimp/types.h>

#ifdef __cplusplus
extern "C" {
#endif

// ---------------------------------------------------------------------------
/** A time-value pair specifying a certain 3D vector for the given time. */
struct aiVectorKey {
    /** The time of this key */
    double mTime;

    /** The value of this key */
    C_STRUCT aiVector3D mValue;

#ifdef __cplusplus

    /// @brief  The default constructor.
    aiVectorKey() AI_NO_EXCEPT
            : mTime(0.0),
              mValue() {
        // empty
    }

    /// @brief  Construction from a given time and key value.

    aiVectorKey(double time, const aiVector3D &value) :
            mTime(time), mValue(value) {
        // empty
    }

    typedef aiVector3D elem_type;

    // Comparison operators. For use with std::find();
    bool operator==(const aiVectorKey &rhs) const {
        return rhs.mValue == this->mValue;
    }
    bool operator!=(const aiVectorKey &rhs) const {
        return rhs.mValue != this->mValue;
    }

    // Relational operators. For use with std::sort();
    bool operator<(const aiVectorKey &rhs) const {
        return mTime < rhs.mTime;
    }

    bool operator>(const aiVectorKey &rhs) const {
        return mTime > rhs.mTime;
    }
#endif // __cplusplus
};

// ---------------------------------------------------------------------------
/** A time-value pair specifying a rotation for the given time.
 *  Rotations are expressed with quaternions. */
struct aiQuatKey {
    /** The time of this key */
    double mTime;

    /** The value of this key */
    C_STRUCT aiQuaternion mValue;

#ifdef __cplusplus
    aiQuatKey() AI_NO_EXCEPT
            : mTime(0.0),
              mValue() {
        // empty
    }

    /** Construction from a given time and key value */
    aiQuatKey(double time, const aiQuaternion &value) :
            mTime(time), mValue(value) {}

    typedef aiQuaternion elem_type;

    // Comparison operators. For use with std::find();
    bool operator==(const aiQuatKey &rhs) const {
        return rhs.mValue == this->mValue;
    }

    bool operator!=(const aiQuatKey &rhs) const {
        return rhs.mValue != this->mValue;
    }

    // Relational operators. For use with std::sort();
    bool operator<(const aiQuatKey &rhs) const {
        return mTime < rhs.mTime;
    }

    bool operator>(const aiQuatKey &rhs) const {
        return mTime > rhs.mTime;
    }
#endif
};

// ---------------------------------------------------------------------------
/** Binds a anim-mesh to a specific point in time. */
struct aiMeshKey {
    /** The time of this key */
    double mTime;

    /** Index into the aiMesh::mAnimMeshes array of the
     *  mesh corresponding to the #aiMeshAnim hosting this
     *  key frame. The referenced anim mesh is evaluated
     *  according to the rules defined in the docs for #aiAnimMesh.*/
    unsigned int mValue;

#ifdef __cplusplus

    aiMeshKey() AI_NO_EXCEPT
            : mTime(0.0),
              mValue(0) {
    }

    /** Construction from a given time and key value */
    aiMeshKey(double time, const unsigned int value) :
            mTime(time), mValue(value) {}

    typedef unsigned int elem_type;

    // Comparison operators. For use with std::find();
    bool operator==(const aiMeshKey &o) const {
        return o.mValue == this->mValue;
    }
    bool operator!=(const aiMeshKey &o) const {
        return o.mValue != this->mValue;
    }

    // Relational operators. For use with std::sort();
    bool operator<(const aiMeshKey &o) const {
        return mTime < o.mTime;
    }
    bool operator>(const aiMeshKey &o) const {
        return mTime > o.mTime;
    }

#endif
};

// ---------------------------------------------------------------------------
/** Binds a morph anim mesh to a specific point in time. */
struct aiMeshMorphKey {
    /** The time of this key */
    double mTime;

    /** The values and weights at the time of this key
     *   - mValues: index of attachment mesh to apply weight at the same position in mWeights
     *   - mWeights: weight to apply to the blend shape index at the same position in mValues
     */
    unsigned int *mValues;
    double *mWeights;

    /** The number of values and weights */
    unsigned int mNumValuesAndWeights;
#ifdef __cplusplus
    aiMeshMorphKey() AI_NO_EXCEPT
            : mTime(0.0),
              mValues(nullptr),
              mWeights(nullptr),
              mNumValuesAndWeights(0) {
    }

    ~aiMeshMorphKey() {
        if (mNumValuesAndWeights && mValues && mWeights) {
            delete[] mValues;
            delete[] mWeights;
        }
    }
#endif
};

// ---------------------------------------------------------------------------
/** Defines how an animation channel behaves outside the defined time
 *  range. This corresponds to aiNodeAnim::mPreState and
 *  aiNodeAnim::mPostState.*/
enum aiAnimBehaviour {
    /** The value from the default node transformation is taken*/
    aiAnimBehaviour_DEFAULT = 0x0,

    /** The nearest key value is used without interpolation */
    aiAnimBehaviour_CONSTANT = 0x1,

    /** The value of the nearest two keys is linearly
     *  extrapolated for the current time value.*/
    aiAnimBehaviour_LINEAR = 0x2,

    /** The animation is repeated.
     *
     *  If the animation key go from n to m and the current
     *  time is t, use the value at (t-n) % (|m-n|).*/
    aiAnimBehaviour_REPEAT = 0x3,

/** This value is not used, it is just here to force the
     *  the compiler to map this enum to a 32 Bit integer  */
#ifndef SWIG
    _aiAnimBehaviour_Force32Bit = INT_MAX
#endif
};

// ---------------------------------------------------------------------------
/** Describes the animation of a single node. The name specifies the
 *  bone/node which is affected by this animation channel. The keyframes
 *  are given in three separate series of values, one each for position,
 *  rotation and scaling. The transformation matrix computed from these
 *  values replaces the node's original transformation matrix at a
 *  specific time.
 *  This means all keys are absolute and not relative to the bone default pose.
 *  The order in which the transformations are applied is
 *  - as usual - scaling, rotation, translation.
 *
 *  @note All keys are returned in their correct, chronological order.
 *  Duplicate keys don't pass the validation step. Most likely there
 *  will be no negative time values, but they are not forbidden also ( so
 *  implementations need to cope with them! ) */
struct aiNodeAnim {
    /** The name of the node affected by this animation. The node
     *  must exist and it must be unique.*/
    C_STRUCT aiString mNodeName;

    /** The number of position keys */
    unsigned int mNumPositionKeys;

    /** The position keys of this animation channel. Positions are
     * specified as 3D vector. The array is mNumPositionKeys in size.
     *
     * If there are position keys, there will also be at least one
     * scaling and one rotation key.*/
    C_STRUCT aiVectorKey *mPositionKeys;

    /** The number of rotation keys */
    unsigned int mNumRotationKeys;

    /** The rotation keys of this animation channel. Rotations are
     *  given as quaternions,  which are 4D vectors. The array is
     *  mNumRotationKeys in size.
     *
     * If there are rotation keys, there will also be at least one
     * scaling and one position key. */
    C_STRUCT aiQuatKey *mRotationKeys;

    /** The number of scaling keys */
    unsigned int mNumScalingKeys;

    /** The scaling keys of this animation channel. Scalings are
     *  specified as 3D vector. The array is mNumScalingKeys in size.
     *
     * If there are scaling keys, there will also be at least one
     * position and one rotation key.*/
    C_STRUCT aiVectorKey *mScalingKeys;

    /** Defines how the animation behaves before the first
     *  key is encountered.
     *
     *  The default value is aiAnimBehaviour_DEFAULT (the original
     *  transformation matrix of the affected node is used).*/
    C_ENUM aiAnimBehaviour mPreState;

    /** Defines how the animation behaves after the last
     *  key was processed.
     *
     *  The default value is aiAnimBehaviour_DEFAULT (the original
     *  transformation matrix of the affected node is taken).*/
    C_ENUM aiAnimBehaviour mPostState;

#ifdef __cplusplus
    aiNodeAnim() AI_NO_EXCEPT
            : mNumPositionKeys(0),
              mPositionKeys(nullptr),
              mNumRotationKeys(0),
              mRotationKeys(nullptr),
              mNumScalingKeys(0),
              mScalingKeys(nullptr),
              mPreState(aiAnimBehaviour_DEFAULT),
              mPostState(aiAnimBehaviour_DEFAULT) {
        // empty
    }

    ~aiNodeAnim() {
        delete[] mPositionKeys;
        delete[] mRotationKeys;
        delete[] mScalingKeys;
    }
#endif // __cplusplus
};

// ---------------------------------------------------------------------------
/** Describes vertex-based animations for a single mesh or a group of
 *  meshes. Meshes carry the animation data for each frame in their
 *  aiMesh::mAnimMeshes array. The purpose of aiMeshAnim is to
 *  define keyframes linking each mesh attachment to a particular
 *  point in time. */
struct aiMeshAnim {
    /** Name of the mesh to be animated. An empty string is not allowed,
     *  animated meshes need to be named (not necessarily uniquely,
     *  the name can basically serve as wild-card to select a group
     *  of meshes with similar animation setup)*/
    C_STRUCT aiString mName;

    /** Size of the #mKeys array. Must be 1, at least. */
    unsigned int mNumKeys;

    /** Key frames of the animation. May not be nullptr. */
    C_STRUCT aiMeshKey *mKeys;

#ifdef __cplusplus

    aiMeshAnim() AI_NO_EXCEPT
            : mNumKeys(),
              mKeys() {}

    ~aiMeshAnim() {
        delete[] mKeys;
    }

#endif
};

// ---------------------------------------------------------------------------
/** Describes a morphing animation of a given mesh. */
struct aiMeshMorphAnim {
    /** Name of the mesh to be animated. An empty string is not allowed,
     *  animated meshes need to be named (not necessarily uniquely,
     *  the name can basically serve as wildcard to select a group
     *  of meshes with similar animation setup)*/
    C_STRUCT aiString mName;

    /** Size of the #mKeys array. Must be 1, at least. */
    unsigned int mNumKeys;

    /** Key frames of the animation. May not be nullptr. */
    C_STRUCT aiMeshMorphKey *mKeys;

#ifdef __cplusplus

    aiMeshMorphAnim() AI_NO_EXCEPT
            : mNumKeys(),
              mKeys() {}

    ~aiMeshMorphAnim() {
        delete[] mKeys;
    }

#endif
};

// ---------------------------------------------------------------------------
/** An animation consists of key-frame data for a number of nodes. For
 *  each node affected by the animation a separate series of data is given.*/
struct aiAnimation {
    /** The name of the animation. If the modeling package this data was
     *  exported from does support only a single animation channel, this
     *  name is usually empty (length is zero). */
    C_STRUCT aiString mName;

    /** Duration of the animation in ticks.  */
    double mDuration;

    /** Ticks per second. 0 if not specified in the imported file */
    double mTicksPerSecond;

    /** The number of bone animation channels. Each channel affects
     *  a single node. */
    unsigned int mNumChannels;

    /** The node animation channels. Each channel affects a single node.
     *  The array is mNumChannels in size. */
    C_STRUCT aiNodeAnim **mChannels;

    /** The number of mesh animation channels. Each channel affects
     *  a single mesh and defines vertex-based animation. */
    unsigned int mNumMeshChannels;

    /** The mesh animation channels. Each channel affects a single mesh.
     *  The array is mNumMeshChannels in size. */
    C_STRUCT aiMeshAnim **mMeshChannels;

    /** The number of mesh animation channels. Each channel affects
     *  a single mesh and defines morphing animation. */
    unsigned int mNumMorphMeshChannels;

    /** The morph mesh animation channels. Each channel affects a single mesh.
     *  The array is mNumMorphMeshChannels in size. */
    C_STRUCT aiMeshMorphAnim **mMorphMeshChannels;

#ifdef __cplusplus
    aiAnimation() AI_NO_EXCEPT
            : mDuration(-1.),
              mTicksPerSecond(0.),
              mNumChannels(0),
              mChannels(nullptr),
              mNumMeshChannels(0),
              mMeshChannels(nullptr),
              mNumMorphMeshChannels(0),
              mMorphMeshChannels(nullptr) {
        // empty
    }

    ~aiAnimation() {
        // DO NOT REMOVE THIS ADDITIONAL CHECK
        if (mNumChannels && mChannels) {
            for (unsigned int a = 0; a < mNumChannels; a++) {
                delete mChannels[a];
            }

            delete[] mChannels;
        }
        if (mNumMeshChannels && mMeshChannels) {
            for (unsigned int a = 0; a < mNumMeshChannels; a++) {
                delete mMeshChannels[a];
            }

            delete[] mMeshChannels;
        }
        if (mNumMorphMeshChannels && mMorphMeshChannels) {
            for (unsigned int a = 0; a < mNumMorphMeshChannels; a++) {
                delete mMorphMeshChannels[a];
            }

            delete[] mMorphMeshChannels;
        }
    }
#endif // __cplusplus
};

#ifdef __cplusplus
}

/// @brief  Some C++ utilities for inter- and extrapolation
namespace Assimp {

// ---------------------------------------------------------------------------
/**
  * @brief CPP-API: Utility class to simplify interpolations of various data types.
  *
  *  The type of interpolation is chosen automatically depending on the
  *  types of the arguments.
  */
template <typename T>
struct Interpolator {
    // ------------------------------------------------------------------
    /** @brief Get the result of the interpolation between a,b.
     *
     *  The interpolation algorithm depends on the type of the operands.
     *  aiQuaternion's and aiQuatKey's SLERP, the rest does a simple
     *  linear interpolation. */
    void operator()(T &anim_out, const T &a, const T &b, ai_real d) const {
        anim_out = a + (b - a) * d;
    }
}; // ! Interpolator <T>

//! @cond Never

template <>
struct Interpolator<aiQuaternion> {
    void operator()(aiQuaternion &out, const aiQuaternion &a,
            const aiQuaternion &b, ai_real d) const {
        aiQuaternion::Interpolate(out, a, b, d);
    }
}; // ! Interpolator <aiQuaternion>

template <>
struct Interpolator<unsigned int> {
    void operator()(unsigned int &out, unsigned int a,
            unsigned int b, ai_real d) const {
        out = d > 0.5f ? b : a;
    }
}; // ! Interpolator <aiQuaternion>

template <>
struct Interpolator<aiVectorKey> {
    void operator()(aiVector3D &out, const aiVectorKey &a,
            const aiVectorKey &b, ai_real d) const {
        Interpolator<aiVector3D> ipl;
        ipl(out, a.mValue, b.mValue, d);
    }
}; // ! Interpolator <aiVectorKey>

template <>
struct Interpolator<aiQuatKey> {
    void operator()(aiQuaternion &out, const aiQuatKey &a,
            const aiQuatKey &b, ai_real d) const {
        Interpolator<aiQuaternion> ipl;
        ipl(out, a.mValue, b.mValue, d);
    }
}; // ! Interpolator <aiQuatKey>

template <>
struct Interpolator<aiMeshKey> {
    void operator()(unsigned int &out, const aiMeshKey &a,
            const aiMeshKey &b, ai_real d) const {
        Interpolator<unsigned int> ipl;
        ipl(out, a.mValue, b.mValue, d);
    }
}; // ! Interpolator <aiQuatKey>

//! @endcond

} // namespace Assimp

#endif // __cplusplus

#endif // AI_ANIM_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/camera.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file camera.h
 *  @brief Defines the aiCamera data structure
 */

#pragma once
#ifndef AI_CAMERA_H_INC
#define AI_CAMERA_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include "types.h"

#ifdef __cplusplus
extern "C" {
#endif

// ---------------------------------------------------------------------------
/** Helper structure to describe a virtual camera.
 *
 * Cameras have a representation in the node graph and can be animated.
 * An important aspect is that the camera itself is also part of the
 * scene-graph. This means, any values such as the look-at vector are not
 * *absolute*, they're <b>relative</b> to the coordinate system defined
 * by the node which corresponds to the camera. This allows for camera
 * animations. For static cameras parameters like the 'look-at' or 'up' vectors
 * are usually specified directly in aiCamera, but beware, they could also
 * be encoded in the node transformation. The following (pseudo)code sample
 * shows how to do it: <br><br>
 * @code
 * // Get the camera matrix for a camera at a specific time
 * // if the node hierarchy for the camera does not contain
 * // at least one animated node this is a static computation
 * get-camera-matrix (node sceneRoot, camera cam) : matrix
 * {
 *    node   cnd = find-node-for-camera(cam)
 *    matrix cmt = identity()
 *
 *    // as usual - get the absolute camera transformation for this frame
 *    for each node nd in hierarchy from sceneRoot to cnd
 *      matrix cur
 *      if (is-animated(nd))
 *         cur = eval-animation(nd)
 *      else cur = nd->mTransformation;
 *      cmt = mult-matrices( cmt, cur )
 *    end for
 *
 *    // now multiply with the camera's own local transform
 *    cam = mult-matrices (cam, get-camera-matrix(cmt) )
 * }
 * @endcode
 *
 * @note some file formats (such as 3DS, ASE) export a "target point" -
 * the point the camera is looking at (it can even be animated). Assimp
 * writes the target point as a subnode of the camera's main node,
 * called "<camName>.Target". However this is just additional information
 * then the transformation tracks of the camera main node make the
 * camera already look in the right direction.
 *
*/
struct aiCamera {
    /** The name of the camera.
     *
     *  There must be a node in the scenegraph with the same name.
     *  This node specifies the position of the camera in the scene
     *  hierarchy and can be animated.
     */
    C_STRUCT aiString mName;

    /** Position of the camera relative to the coordinate space
     *  defined by the corresponding node.
     *
     *  The default value is 0|0|0.
     */
    C_STRUCT aiVector3D mPosition;

    /** 'Up' - vector of the camera coordinate system relative to
     *  the coordinate space defined by the corresponding node.
     *
     *  The 'right' vector of the camera coordinate system is
     *  the cross product of  the up and lookAt vectors.
     *  The default value is 0|1|0. The vector
     *  may be normalized, but it needn't.
     */
    C_STRUCT aiVector3D mUp;

    /** 'LookAt' - vector of the camera coordinate system relative to
     *  the coordinate space defined by the corresponding node.
     *
     *  This is the viewing direction of the user.
     *  The default value is 0|0|1. The vector
     *  may be normalized, but it needn't.
     */
    C_STRUCT aiVector3D mLookAt;

    /** Horizontal field of view angle, in radians.
     *
     *  The field of view angle is the angle between the center
     *  line of the screen and the left or right border.
     *  The default value is 1/4PI.
     */
    float mHorizontalFOV;

    /** Distance of the near clipping plane from the camera.
     *
     * The value may not be 0.f (for arithmetic reasons to prevent
     * a division through zero). The default value is 0.1f.
     */
    float mClipPlaneNear;

    /** Distance of the far clipping plane from the camera.
     *
     * The far clipping plane must, of course, be further away than the
     * near clipping plane. The default value is 1000.f. The ratio
     * between the near and the far plane should not be too
     * large (between 1000-10000 should be ok) to avoid floating-point
     * inaccuracies which could lead to z-fighting.
     */
    float mClipPlaneFar;

    /** Screen aspect ratio.
     *
     * This is the ration between the width and the height of the
     * screen. Typical values are 4/3, 1/2 or 1/1. This value is
     * 0 if the aspect ratio is not defined in the source file.
     * 0 is also the default value.
     */
    float mAspect;

    /** Half horizontal orthographic width, in scene units.
     *
     *  The orthographic width specifies the half width of the
     *  orthographic view box. If non-zero the camera is
     *  orthographic and the mAspect should define to the
     *  ratio between the orthographic width and height
     *  and mHorizontalFOV should be set to 0.
     *  The default value is 0 (not orthographic).
     */
    float mOrthographicWidth;
#ifdef __cplusplus

    aiCamera() AI_NO_EXCEPT
            : mUp(0.f, 1.f, 0.f),
              mLookAt(0.f, 0.f, 1.f),
              mHorizontalFOV(0.25f * (float)AI_MATH_PI),
              mClipPlaneNear(0.1f),
              mClipPlaneFar(1000.f),
              mAspect(0.f),
              mOrthographicWidth(0.f) {}

    /** @brief Get a *right-handed* camera matrix from me
     *  @param out Camera matrix to be filled
     */
    void GetCameraMatrix(aiMatrix4x4 &out) const {
        /** todo: test ... should work, but i'm not absolutely sure */

        /** We don't know whether these vectors are already normalized ...*/
        aiVector3D zaxis = mLookAt;
        zaxis.Normalize();
        aiVector3D yaxis = mUp;
        yaxis.Normalize();
        aiVector3D xaxis = mUp ^ mLookAt;
        xaxis.Normalize();

        out.a4 = -(xaxis * mPosition);
        out.b4 = -(yaxis * mPosition);
        out.c4 = -(zaxis * mPosition);

        out.a1 = xaxis.x;
        out.a2 = xaxis.y;
        out.a3 = xaxis.z;

        out.b1 = yaxis.x;
        out.b2 = yaxis.y;
        out.b3 = yaxis.z;

        out.c1 = zaxis.x;
        out.c2 = zaxis.y;
        out.c3 = zaxis.z;

        out.d1 = out.d2 = out.d3 = 0.f;
        out.d4 = 1.f;
    }

#endif
};

#ifdef __cplusplus
}
#endif

#endif // AI_CAMERA_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/cexport.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
copyright notice, this list of conditions and the
following disclaimer.

* Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the
following disclaimer in the documentation and/or other
materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
contributors may be used to endorse or promote products
derived from this software without specific prior
written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  cexport.h
*  @brief Defines the C-API for the Assimp export interface
*/
#pragma once
#ifndef AI_EXPORT_H_INC
#define AI_EXPORT_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#ifndef ASSIMP_BUILD_NO_EXPORT

#include <assimp/types.h>

#ifdef __cplusplus
extern "C" {
#endif

struct aiScene;
struct aiFileIO;

// --------------------------------------------------------------------------------
/**
 *  @brief  Describes an file format which Assimp can export to.
 *
 *  Use #aiGetExportFormatCount() to learn how many export-formats are supported by
 *  the current Assimp-build and #aiGetExportFormatDescription() to retrieve the
 *  description of the export format option.
 */
struct aiExportFormatDesc {
    /// a short string ID to uniquely identify the export format. Use this ID string to
    /// specify which file format you want to export to when calling #aiExportScene().
    /// Example: "dae" or "obj"
    const char *id;

    /// A short description of the file format to present to users. Useful if you want
    /// to allow the user to select an export format.
    const char *description;

    /// Recommended file extension for the exported file in lower case.
    const char *fileExtension;
};

// --------------------------------------------------------------------------------
/** Returns the number of export file formats available in the current Assimp build.
 * Use aiGetExportFormatDescription() to retrieve infos of a specific export format.
 */
ASSIMP_API size_t aiGetExportFormatCount(void);

// --------------------------------------------------------------------------------
/** Returns a description of the nth export file format. Use #aiGetExportFormatCount()
 * to learn how many export formats are supported. The description must be released by
 * calling aiReleaseExportFormatDescription afterwards.
 * @param pIndex Index of the export format to retrieve information for. Valid range is
 *    0 to #aiGetExportFormatCount()
 * @return A description of that specific export format. NULL if pIndex is out of range.
 */
ASSIMP_API const C_STRUCT aiExportFormatDesc *aiGetExportFormatDescription(size_t pIndex);

// --------------------------------------------------------------------------------
/** Release a description of the nth export file format. Must be returned by
* aiGetExportFormatDescription
* @param desc Pointer to the description
*/
ASSIMP_API void aiReleaseExportFormatDescription(const C_STRUCT aiExportFormatDesc *desc);

// --------------------------------------------------------------------------------
/** Create a modifiable copy of a scene.
 *  This is useful to import files via Assimp, change their topology and
 *  export them again. Since the scene returned by the various importer functions
 *  is const, a modifiable copy is needed.
 *  @param pIn Valid scene to be copied
 *  @param pOut Receives a modifiable copy of the scene. Use aiFreeScene() to
 *    delete it again.
 */
ASSIMP_API void aiCopyScene(const C_STRUCT aiScene *pIn,
        C_STRUCT aiScene **pOut);

// --------------------------------------------------------------------------------
/** Frees a scene copy created using aiCopyScene() */
ASSIMP_API void aiFreeScene(const C_STRUCT aiScene *pIn);

// --------------------------------------------------------------------------------
/** Exports the given scene to a chosen file format and writes the result file(s) to disk.
* @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
*   The scene is expected to conform to Assimp's Importer output format as specified
*   in the @link data Data Structures Page @endlink. In short, this means the model data
*   should use a right-handed coordinate systems, face winding should be counter-clockwise
*   and the UV coordinate origin is assumed to be in the upper left. If your input data
*   uses different conventions, have a look at the last parameter.
* @param pFormatId ID string to specify to which format you want to export to. Use
* aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.
* @param pFileName Output file to write
* @param pPreprocessing Accepts any choice of the #aiPostProcessSteps enumerated
*   flags, but in reality only a subset of them makes sense here. Specifying
*   'preprocessing' flags is useful if the input scene does not conform to
*   Assimp's default conventions as specified in the @link data Data Structures Page @endlink.
*   In short, this means the geometry data should use a right-handed coordinate systems, face
*   winding should be counter-clockwise and the UV coordinate origin is assumed to be in
*   the upper left. The #aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
*   #aiProcess_FlipWindingOrder flags are used in the import side to allow users
*   to have those defaults automatically adapted to their conventions. Specifying those flags
*   for exporting has the opposite effect, respectively. Some other of the
*   #aiPostProcessSteps enumerated values may be useful as well, but you'll need
*   to try out what their effect on the exported file is. Many formats impose
*   their own restrictions on the structure of the geometry stored therein,
*   so some preprocessing may have little or no effect at all, or may be
*   redundant as exporters would apply them anyhow. A good example
*   is triangulation - whilst you can enforce it by specifying
*   the #aiProcess_Triangulate flag, most export formats support only
*   triangulate data so they would run the step anyway.
*
*   If assimp detects that the input scene was directly taken from the importer side of
*   the library (i.e. not copied using aiCopyScene and potentially modified afterwards),
*   any post-processing steps already applied to the scene will not be applied again, unless
*   they show non-idempotent behavior (#aiProcess_MakeLeftHanded, #aiProcess_FlipUVs and
*   #aiProcess_FlipWindingOrder).
* @return a status code indicating the result of the export
* @note Use aiCopyScene() to get a modifiable copy of a previously
*   imported scene.
*/
ASSIMP_API aiReturn aiExportScene(const C_STRUCT aiScene *pScene,
        const char *pFormatId,
        const char *pFileName,
        unsigned int pPreprocessing);

// --------------------------------------------------------------------------------
/** Exports the given scene to a chosen file format using custom IO logic supplied by you.
* @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
* @param pFormatId ID string to specify to which format you want to export to. Use
* aiGetExportFormatCount() / aiGetExportFormatDescription() to learn which export formats are available.
* @param pFileName Output file to write
* @param pIO custom IO implementation to be used. Use this if you use your own storage methods.
*   If none is supplied, a default implementation using standard file IO is used. Note that
*   #aiExportSceneToBlob is provided as convenience function to export to memory buffers.
* @param pPreprocessing Please see the documentation for #aiExportScene
* @return a status code indicating the result of the export
* @note Include <aiFileIO.h> for the definition of #aiFileIO.
* @note Use aiCopyScene() to get a modifiable copy of a previously
*   imported scene.
*/
ASSIMP_API aiReturn aiExportSceneEx(const C_STRUCT aiScene *pScene,
        const char *pFormatId,
        const char *pFileName,
        C_STRUCT aiFileIO *pIO,
        unsigned int pPreprocessing);

// --------------------------------------------------------------------------------
/** Describes a blob of exported scene data. Use #aiExportSceneToBlob() to create a blob containing an
* exported scene. The memory referred by this structure is owned by Assimp.
* to free its resources. Don't try to free the memory on your side - it will crash for most build configurations
* due to conflicting heaps.
*
* Blobs can be nested - each blob may reference another blob, which may in turn reference another blob and so on.
* This is used when exporters write more than one output file for a given #aiScene. See the remarks for
* #aiExportDataBlob::name for more information.
*/
struct aiExportDataBlob {
    /// Size of the data in bytes
    size_t size;

    /// The data.
    void *data;

    /** Name of the blob. An empty string always
      * indicates the first (and primary) blob,
      * which contains the actual file data.
      * Any other blobs are auxiliary files produced
      * by exporters (i.e. material files). Existence
      * of such files depends on the file format. Most
      * formats don't split assets across multiple files.
      *
      * If used, blob names usually contain the file
      * extension that should be used when writing
      * the data to disc.
      *
      * The blob names generated can be influenced by
      * setting the #AI_CONFIG_EXPORT_BLOB_NAME export
      * property to the name that is used for the master
      * blob. All other names are typically derived from
      * the base name, by the file format exporter.
     */
    C_STRUCT aiString name;

    /** Pointer to the next blob in the chain or NULL if there is none. */
    C_STRUCT aiExportDataBlob *next;

#ifdef __cplusplus
    /// Default constructor
    aiExportDataBlob() {
        size = 0;
        data = next = nullptr;
    }
    /// Releases the data
    ~aiExportDataBlob() {
        delete[] static_cast<unsigned char *>(data);
        delete next;
    }

    aiExportDataBlob(const aiExportDataBlob &) = delete;
    aiExportDataBlob &operator=(const aiExportDataBlob &) = delete;

#endif // __cplusplus
};

// --------------------------------------------------------------------------------
/** Exports the given scene to a chosen file format. Returns the exported data as a binary blob which
* you can write into a file or something. When you're done with the data, use #aiReleaseExportBlob()
* to free the resources associated with the export.
* @param pScene The scene to export. Stays in possession of the caller, is not changed by the function.
* @param pFormatId ID string to specify to which format you want to export to. Use
* #aiGetExportFormatCount() / #aiGetExportFormatDescription() to learn which export formats are available.
* @param pPreprocessing Please see the documentation for #aiExportScene
* @return the exported data or NULL in case of error
*/
ASSIMP_API const C_STRUCT aiExportDataBlob *aiExportSceneToBlob(const C_STRUCT aiScene *pScene, const char *pFormatId,
        unsigned int pPreprocessing);

// --------------------------------------------------------------------------------
/** Releases the memory associated with the given exported data. Use this function to free a data blob
* returned by aiExportScene().
* @param pData the data blob returned by #aiExportSceneToBlob
*/
ASSIMP_API void aiReleaseExportBlob(const C_STRUCT aiExportDataBlob *pData);

#ifdef __cplusplus
}
#endif

#endif // ASSIMP_BUILD_NO_EXPORT
#endif // AI_EXPORT_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/cfileio.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file cfileio.h
 *  @brief Defines generic C routines to access memory-mapped files
 */
#pragma once
#ifndef AI_FILEIO_H_INC
#define AI_FILEIO_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/types.h>

#ifdef __cplusplus
extern "C" {
#endif

struct aiFileIO;
struct aiFile;

// aiFile callbacks
typedef size_t          (*aiFileWriteProc) (C_STRUCT aiFile*,   const char*, size_t, size_t);
typedef size_t          (*aiFileReadProc)  (C_STRUCT aiFile*,   char*, size_t,size_t);
typedef size_t          (*aiFileTellProc)  (C_STRUCT aiFile*);
typedef void            (*aiFileFlushProc) (C_STRUCT aiFile*);
typedef C_ENUM aiReturn (*aiFileSeek)      (C_STRUCT aiFile*, size_t, C_ENUM aiOrigin);

// aiFileIO callbacks
typedef C_STRUCT aiFile* (*aiFileOpenProc)  (C_STRUCT aiFileIO*, const char*, const char*);
typedef void             (*aiFileCloseProc) (C_STRUCT aiFileIO*, C_STRUCT aiFile*);

// Represents user-defined data
typedef char* aiUserData;

// ----------------------------------------------------------------------------------
/** @brief C-API: File system callbacks
 *
 *  Provided are functions to open and close files. Supply a custom structure to
 *  the import function. If you don't, a default implementation is used. Use custom
 *  file systems to enable reading from other sources, such as ZIPs
 *  or memory locations. */
struct aiFileIO
{
    /** Function used to open a new file
     */
    aiFileOpenProc OpenProc;

    /** Function used to close an existing file
     */
    aiFileCloseProc CloseProc;

    /** User-defined, opaque data */
    aiUserData UserData;
};

// ----------------------------------------------------------------------------------
/** @brief C-API: File callbacks
 *
 *  Actually, it's a data structure to wrap a set of fXXXX (e.g fopen)
 *  replacement functions.
 *
 *  The default implementation of the functions utilizes the fXXX functions from
 *  the CRT. However, you can supply a custom implementation to Assimp by
 *  delivering a custom aiFileIO. Use this to enable reading from other sources,
 *  such as ZIP archives or memory locations. */
struct aiFile {
    /** Callback to read from a file */
    aiFileReadProc ReadProc;

    /** Callback to write to a file */
    aiFileWriteProc WriteProc;

    /** Callback to retrieve the current position of
     *  the file cursor (ftell())
     */
    aiFileTellProc TellProc;

    /** Callback to retrieve the size of the file,
     *  in bytes
     */
    aiFileTellProc FileSizeProc;

    /** Callback to set the current position
     * of the file cursor (fseek())
     */
    aiFileSeek SeekProc;

    /** Callback to flush the file contents
     */
    aiFileFlushProc FlushProc;

    /** User-defined, opaque data
     */
    aiUserData UserData;
};

#ifdef __cplusplus
}
#endif
#endif // AI_FILEIO_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/cimport.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  cimport.h
 *  @brief Defines the C-API to the Open Asset Import Library.
 */
#pragma once
#ifndef AI_ASSIMP_H_INC
#define AI_ASSIMP_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/importerdesc.h>
#include <assimp/types.h>

#ifdef __cplusplus
extern "C" {
#endif

struct aiScene;
struct aiFileIO;

typedef void (*aiLogStreamCallback)(const char * /* message */, char * /* user */);

// --------------------------------------------------------------------------------
/** C-API: Represents a log stream. A log stream receives all log messages and
 *  streams them _somewhere_.
 *  @see aiGetPredefinedLogStream
 *  @see aiAttachLogStream
 *  @see aiDetachLogStream */
// --------------------------------------------------------------------------------
struct aiLogStream {
    /** callback to be called */
    aiLogStreamCallback callback;

    /** user data to be passed to the callback */
    char *user;
};

// --------------------------------------------------------------------------------
/** C-API: Represents an opaque set of settings to be used during importing.
 *  @see aiCreatePropertyStore
 *  @see aiReleasePropertyStore
 *  @see aiImportFileExWithProperties
 *  @see aiSetPropertyInteger
 *  @see aiSetPropertyFloat
 *  @see aiSetPropertyString
 *  @see aiSetPropertyMatrix
 */
// --------------------------------------------------------------------------------
struct aiPropertyStore {
    char sentinel;
};

/** Our own C boolean type */
typedef int aiBool;

#define AI_FALSE 0
#define AI_TRUE 1

// --------------------------------------------------------------------------------
/** Reads the given file and returns its content.
 *
 * If the call succeeds, the imported data is returned in an aiScene structure.
 * The data is intended to be read-only, it stays property of the ASSIMP
 * library and will be stable until aiReleaseImport() is called. After you're
 * done with it, call aiReleaseImport() to free the resources associated with
 * this file. If the import fails, NULL is returned instead. Call
 * aiGetErrorString() to retrieve a human-readable error text.
 * @param pFile Path and filename of the file to be imported,
 *   expected to be a null-terminated c-string. NULL is not a valid value.
 * @param pFlags Optional post processing steps to be executed after
 *   a successful import. Provide a bitwise combination of the
 *   #aiPostProcessSteps flags.
 * @return Pointer to the imported data or NULL if the import failed.
 */
ASSIMP_API const C_STRUCT aiScene *aiImportFile(
        const char *pFile,
        unsigned int pFlags);

// --------------------------------------------------------------------------------
/** Reads the given file using user-defined I/O functions and returns
 *   its content.
 *
 * If the call succeeds, the imported data is returned in an aiScene structure.
 * The data is intended to be read-only, it stays property of the ASSIMP
 * library and will be stable until aiReleaseImport() is called. After you're
 * done with it, call aiReleaseImport() to free the resources associated with
 * this file. If the import fails, NULL is returned instead. Call
 * aiGetErrorString() to retrieve a human-readable error text.
 * @param pFile Path and filename of the file to be imported,
 *   expected to be a null-terminated c-string. NULL is not a valid value.
 * @param pFlags Optional post processing steps to be executed after
 *   a successful import. Provide a bitwise combination of the
 *   #aiPostProcessSteps flags.
 * @param pFS aiFileIO structure. Will be used to open the model file itself
 *   and any other files the loader needs to open.  Pass NULL to use the default
 *   implementation.
 * @return Pointer to the imported data or NULL if the import failed.
 * @note Include <aiFileIO.h> for the definition of #aiFileIO.
 */
ASSIMP_API const C_STRUCT aiScene *aiImportFileEx(
        const char *pFile,
        unsigned int pFlags,
        C_STRUCT aiFileIO *pFS);

// --------------------------------------------------------------------------------
/** Same as #aiImportFileEx, but adds an extra parameter containing importer settings.
 *
 * @param pFile Path and filename of the file to be imported,
 *   expected to be a null-terminated c-string. NULL is not a valid value.
 * @param pFlags Optional post processing steps to be executed after
 *   a successful import. Provide a bitwise combination of the
 *   #aiPostProcessSteps flags.
 * @param pFS aiFileIO structure. Will be used to open the model file itself
 *   and any other files the loader needs to open.  Pass NULL to use the default
 *   implementation.
 * @param pProps #aiPropertyStore instance containing import settings.
 * @return Pointer to the imported data or NULL if the import failed.
 * @note Include <aiFileIO.h> for the definition of #aiFileIO.
 * @see aiImportFileEx
 */
ASSIMP_API const C_STRUCT aiScene *aiImportFileExWithProperties(
        const char *pFile,
        unsigned int pFlags,
        C_STRUCT aiFileIO *pFS,
        const C_STRUCT aiPropertyStore *pProps);

// --------------------------------------------------------------------------------
/** Reads the given file from a given memory buffer,
 *
 * If the call succeeds, the contents of the file are returned as a pointer to an
 * aiScene object. The returned data is intended to be read-only, the importer keeps
 * ownership of the data and will destroy it upon destruction. If the import fails,
 * NULL is returned.
 * A human-readable error description can be retrieved by calling aiGetErrorString().
 * @param pBuffer Pointer to the file data
 * @param pLength Length of pBuffer, in bytes
 * @param pFlags Optional post processing steps to be executed after
 *   a successful import. Provide a bitwise combination of the
 *   #aiPostProcessSteps flags. If you wish to inspect the imported
 *   scene first in order to fine-tune your post-processing setup,
 *   consider to use #aiApplyPostProcessing().
 * @param pHint An additional hint to the library. If this is a non empty string,
 *   the library looks for a loader to support the file extension specified by pHint
 *   and passes the file to the first matching loader. If this loader is unable to
 *   completely the request, the library continues and tries to determine the file
 *   format on its own, a task that may or may not be successful.
 *   Check the return value, and you'll know ...
 * @return A pointer to the imported data, NULL if the import failed.
 *
 * @note This is a straightforward way to decode models from memory
 * buffers, but it doesn't handle model formats that spread their
 * data across multiple files or even directories. Examples include
 * OBJ or MD3, which outsource parts of their material info into
 * external scripts. If you need full functionality, provide
 * a custom IOSystem to make Assimp find these files and use
 * the regular aiImportFileEx()/aiImportFileExWithProperties() API.
 */
ASSIMP_API const C_STRUCT aiScene *aiImportFileFromMemory(
        const char *pBuffer,
        unsigned int pLength,
        unsigned int pFlags,
        const char *pHint);

// --------------------------------------------------------------------------------
/** Same as #aiImportFileFromMemory, but adds an extra parameter containing importer settings.
 *
 * @param pBuffer Pointer to the file data
 * @param pLength Length of pBuffer, in bytes
 * @param pFlags Optional post processing steps to be executed after
 *   a successful import. Provide a bitwise combination of the
 *   #aiPostProcessSteps flags. If you wish to inspect the imported
 *   scene first in order to fine-tune your post-processing setup,
 *   consider to use #aiApplyPostProcessing().
 * @param pHint An additional hint to the library. If this is a non empty string,
 *   the library looks for a loader to support the file extension specified by pHint
 *   and passes the file to the first matching loader. If this loader is unable to
 *   completely the request, the library continues and tries to determine the file
 *   format on its own, a task that may or may not be successful.
 *   Check the return value, and you'll know ...
 * @param pProps #aiPropertyStore instance containing import settings.
 * @return A pointer to the imported data, NULL if the import failed.
 *
 * @note This is a straightforward way to decode models from memory
 * buffers, but it doesn't handle model formats that spread their
 * data across multiple files or even directories. Examples include
 * OBJ or MD3, which outsource parts of their material info into
 * external scripts. If you need full functionality, provide
 * a custom IOSystem to make Assimp find these files and use
 * the regular aiImportFileEx()/aiImportFileExWithProperties() API.
 * @see aiImportFileFromMemory
 */
ASSIMP_API const C_STRUCT aiScene *aiImportFileFromMemoryWithProperties(
        const char *pBuffer,
        unsigned int pLength,
        unsigned int pFlags,
        const char *pHint,
        const C_STRUCT aiPropertyStore *pProps);

// --------------------------------------------------------------------------------
/** Apply post-processing to an already-imported scene.
 *
 * This is strictly equivalent to calling #aiImportFile()/#aiImportFileEx with the
 * same flags. However, you can use this separate function to inspect the imported
 * scene first to fine-tune your post-processing setup.
 * @param pScene Scene to work on.
 * @param pFlags Provide a bitwise combination of the #aiPostProcessSteps flags.
 * @return A pointer to the post-processed data. Post processing is done in-place,
 *   meaning this is still the same #aiScene which you passed for pScene. However,
 *   _if_ post-processing failed, the scene could now be NULL. That's quite a rare
 *   case, post processing steps are not really designed to 'fail'. To be exact,
 *   the #aiProcess_ValidateDataStructure flag is currently the only post processing step
 *   which can actually cause the scene to be reset to NULL.
 */
ASSIMP_API const C_STRUCT aiScene *aiApplyPostProcessing(
        const C_STRUCT aiScene *pScene,
        unsigned int pFlags);

// --------------------------------------------------------------------------------
/** Get one of the predefine log streams. This is the quick'n'easy solution to
 *  access Assimp's log system. Attaching a log stream can slightly reduce Assimp's
 *  overall import performance.
 *
 *  Usage is rather simple (this will stream the log to a file, named log.txt, and
 *  the stdout stream of the process:
 *  @code
 *    struct aiLogStream c;
 *    c = aiGetPredefinedLogStream(aiDefaultLogStream_FILE,"log.txt");
 *    aiAttachLogStream(&c);
 *    c = aiGetPredefinedLogStream(aiDefaultLogStream_STDOUT,NULL);
 *    aiAttachLogStream(&c);
 *  @endcode
 *
 *  @param pStreams One of the #aiDefaultLogStream enumerated values.
 *  @param file Solely for the #aiDefaultLogStream_FILE flag: specifies the file to write to.
 *    Pass NULL for all other flags.
 *  @return The log stream. callback is set to NULL if something went wrong.
 */
ASSIMP_API C_STRUCT aiLogStream aiGetPredefinedLogStream(
        C_ENUM aiDefaultLogStream pStreams,
        const char *file);

// --------------------------------------------------------------------------------
/** Attach a custom log stream to the libraries' logging system.
 *
 *  Attaching a log stream can slightly reduce Assimp's overall import
 *  performance. Multiple log-streams can be attached.
 *  @param stream Describes the new log stream.
 *  @note To ensure proper destruction of the logging system, you need to manually
 *    call aiDetachLogStream() on every single log stream you attach.
 *    Alternatively (for the lazy folks) #aiDetachAllLogStreams is provided.
 */
ASSIMP_API void aiAttachLogStream(
        const C_STRUCT aiLogStream *stream);

// --------------------------------------------------------------------------------
/** Enable verbose logging. Verbose logging includes debug-related stuff and
 *  detailed import statistics. This can have severe impact on import performance
 *  and memory consumption. However, it might be useful to find out why a file
 *  didn't read correctly.
 *  @param d AI_TRUE or AI_FALSE, your decision.
 */
ASSIMP_API void aiEnableVerboseLogging(aiBool d);

// --------------------------------------------------------------------------------
/** Detach a custom log stream from the libraries' logging system.
 *
 *  This is the counterpart of #aiAttachLogStream. If you attached a stream,
 *  don't forget to detach it again.
 *  @param stream The log stream to be detached.
 *  @return AI_SUCCESS if the log stream has been detached successfully.
 *  @see aiDetachAllLogStreams
 */
ASSIMP_API C_ENUM aiReturn aiDetachLogStream(
        const C_STRUCT aiLogStream *stream);

// --------------------------------------------------------------------------------
/** Detach all active log streams from the libraries' logging system.
 *  This ensures that the logging system is terminated properly and all
 *  resources allocated by it are actually freed. If you attached a stream,
 *  don't forget to detach it again.
 *  @see aiAttachLogStream
 *  @see aiDetachLogStream
 */
ASSIMP_API void aiDetachAllLogStreams(void);

// --------------------------------------------------------------------------------
/** Releases all resources associated with the given import process.
 *
 * Call this function after you're done with the imported data.
 * @param pScene The imported data to release. NULL is a valid value.
 */
ASSIMP_API void aiReleaseImport(
        const C_STRUCT aiScene *pScene);

// --------------------------------------------------------------------------------
/** Returns the error text of the last failed import process.
 *
 * @return A textual description of the error that occurred at the last
 * import process. NULL if there was no error. There can't be an error if you
 * got a non-NULL #aiScene from #aiImportFile/#aiImportFileEx/#aiApplyPostProcessing.
 */
ASSIMP_API const char *aiGetErrorString(void);

// --------------------------------------------------------------------------------
/** Returns whether a given file extension is supported by ASSIMP
 *
 * @param szExtension Extension for which the function queries support for.
 * Must include a leading dot '.'. Example: ".3ds", ".md3"
 * @return AI_TRUE if the file extension is supported.
 */
ASSIMP_API aiBool aiIsExtensionSupported(
        const char *szExtension);

// --------------------------------------------------------------------------------
/** Get a list of all file extensions supported by ASSIMP.
 *
 * If a file extension is contained in the list this does, of course, not
 * mean that ASSIMP is able to load all files with this extension.
 * @param szOut String to receive the extension list.
 * Format of the list: "*.3ds;*.obj;*.dae". NULL is not a valid parameter.
 */
ASSIMP_API void aiGetExtensionList(
        C_STRUCT aiString *szOut);

// --------------------------------------------------------------------------------
/** Get the approximated storage required by an imported asset
 * @param pIn Input asset.
 * @param in Data structure to be filled.
 */
ASSIMP_API void aiGetMemoryRequirements(
        const C_STRUCT aiScene *pIn,
        C_STRUCT aiMemoryInfo *in);

// --------------------------------------------------------------------------------
/** Create an empty property store. Property stores are used to collect import
 *  settings.
 * @return New property store. Property stores need to be manually destroyed using
 *   the #aiReleasePropertyStore API function.
 */
ASSIMP_API C_STRUCT aiPropertyStore *aiCreatePropertyStore(void);

// --------------------------------------------------------------------------------
/** Delete a property store.
 * @param p Property store to be deleted.
 */
ASSIMP_API void aiReleasePropertyStore(C_STRUCT aiPropertyStore *p);

// --------------------------------------------------------------------------------
/** Set an integer property.
 *
 *  This is the C-version of #Assimp::Importer::SetPropertyInteger(). In the C
 *  interface, properties are always shared by all imports. It is not possible to
 *  specify them per import.
 *
 * @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
 * @param szName Name of the configuration property to be set. All supported
 *   public properties are defined in the config.h header file (AI_CONFIG_XXX).
 * @param value New value for the property
 */
ASSIMP_API void aiSetImportPropertyInteger(
        C_STRUCT aiPropertyStore *store,
        const char *szName,
        int value);

// --------------------------------------------------------------------------------
/** Set a floating-point property.
 *
 *  This is the C-version of #Assimp::Importer::SetPropertyFloat(). In the C
 *  interface, properties are always shared by all imports. It is not possible to
 *  specify them per import.
 *
 * @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
 * @param szName Name of the configuration property to be set. All supported
 *   public properties are defined in the config.h header file (AI_CONFIG_XXX).
 * @param value New value for the property
 */
ASSIMP_API void aiSetImportPropertyFloat(
        C_STRUCT aiPropertyStore *store,
        const char *szName,
        ai_real value);

// --------------------------------------------------------------------------------
/** Set a string property.
 *
 *  This is the C-version of #Assimp::Importer::SetPropertyString(). In the C
 *  interface, properties are always shared by all imports. It is not possible to
 *  specify them per import.
 *
 * @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
 * @param szName Name of the configuration property to be set. All supported
 *   public properties are defined in the config.h header file (AI_CONFIG_XXX).
 * @param st New value for the property
 */
ASSIMP_API void aiSetImportPropertyString(
        C_STRUCT aiPropertyStore *store,
        const char *szName,
        const C_STRUCT aiString *st);

// --------------------------------------------------------------------------------
/** Set a matrix property.
 *
 *  This is the C-version of #Assimp::Importer::SetPropertyMatrix(). In the C
 *  interface, properties are always shared by all imports. It is not possible to
 *  specify them per import.
 *
 * @param store Store to modify. Use #aiCreatePropertyStore to obtain a store.
 * @param szName Name of the configuration property to be set. All supported
 *   public properties are defined in the config.h header file (AI_CONFIG_XXX).
 * @param mat New value for the property
 */
ASSIMP_API void aiSetImportPropertyMatrix(
        C_STRUCT aiPropertyStore *store,
        const char *szName,
        const C_STRUCT aiMatrix4x4 *mat);

// --------------------------------------------------------------------------------
/** Construct a quaternion from a 3x3 rotation matrix.
 *  @param quat Receives the output quaternion.
 *  @param mat Matrix to 'quaternionize'.
 *  @see aiQuaternion(const aiMatrix3x3& pRotMatrix)
 */
ASSIMP_API void aiCreateQuaternionFromMatrix(
        C_STRUCT aiQuaternion *quat,
        const C_STRUCT aiMatrix3x3 *mat);

// --------------------------------------------------------------------------------
/** Decompose a transformation matrix into its rotational, translational and
 *  scaling components.
 *
 * @param mat Matrix to decompose
 * @param scaling Receives the scaling component
 * @param rotation Receives the rotational component
 * @param position Receives the translational component.
 * @see aiMatrix4x4::Decompose (aiVector3D&, aiQuaternion&, aiVector3D&) const;
 */
ASSIMP_API void aiDecomposeMatrix(
        const C_STRUCT aiMatrix4x4 *mat,
        C_STRUCT aiVector3D *scaling,
        C_STRUCT aiQuaternion *rotation,
        C_STRUCT aiVector3D *position);

// --------------------------------------------------------------------------------
/** Transpose a 4x4 matrix.
 *  @param mat Pointer to the matrix to be transposed
 */
ASSIMP_API void aiTransposeMatrix4(
        C_STRUCT aiMatrix4x4 *mat);

// --------------------------------------------------------------------------------
/** Transpose a 3x3 matrix.
 *  @param mat Pointer to the matrix to be transposed
 */
ASSIMP_API void aiTransposeMatrix3(
        C_STRUCT aiMatrix3x3 *mat);

// --------------------------------------------------------------------------------
/** Transform a vector by a 3x3 matrix
 *  @param vec Vector to be transformed.
 *  @param mat Matrix to transform the vector with.
 */
ASSIMP_API void aiTransformVecByMatrix3(
        C_STRUCT aiVector3D *vec,
        const C_STRUCT aiMatrix3x3 *mat);

// --------------------------------------------------------------------------------
/** Transform a vector by a 4x4 matrix
 *  @param vec Vector to be transformed.
 *  @param mat Matrix to transform the vector with.
 */
ASSIMP_API void aiTransformVecByMatrix4(
        C_STRUCT aiVector3D *vec,
        const C_STRUCT aiMatrix4x4 *mat);

// --------------------------------------------------------------------------------
/** Multiply two 4x4 matrices.
 *  @param dst First factor, receives result.
 *  @param src Matrix to be multiplied with 'dst'.
 */
ASSIMP_API void aiMultiplyMatrix4(
        C_STRUCT aiMatrix4x4 *dst,
        const C_STRUCT aiMatrix4x4 *src);

// --------------------------------------------------------------------------------
/** Multiply two 3x3 matrices.
 *  @param dst First factor, receives result.
 *  @param src Matrix to be multiplied with 'dst'.
 */
ASSIMP_API void aiMultiplyMatrix3(
        C_STRUCT aiMatrix3x3 *dst,
        const C_STRUCT aiMatrix3x3 *src);

// --------------------------------------------------------------------------------
/** Get a 3x3 identity matrix.
 *  @param mat Matrix to receive its personal identity
 */
ASSIMP_API void aiIdentityMatrix3(
        C_STRUCT aiMatrix3x3 *mat);

// --------------------------------------------------------------------------------
/** Get a 4x4 identity matrix.
 *  @param mat Matrix to receive its personal identity
 */
ASSIMP_API void aiIdentityMatrix4(
        C_STRUCT aiMatrix4x4 *mat);

// --------------------------------------------------------------------------------
/** Returns the number of import file formats available in the current Assimp build.
 * Use aiGetImportFormatDescription() to retrieve infos of a specific import format.
 */
ASSIMP_API size_t aiGetImportFormatCount(void);

// --------------------------------------------------------------------------------
/** Returns a description of the nth import file format. Use #aiGetImportFormatCount()
 * to learn how many import formats are supported.
 * @param pIndex Index of the import format to retrieve information for. Valid range is
 *    0 to #aiGetImportFormatCount()
 * @return A description of that specific import format. NULL if pIndex is out of range.
 */
ASSIMP_API const C_STRUCT aiImporterDesc *aiGetImportFormatDescription(size_t pIndex);

// --------------------------------------------------------------------------------
/** Check if 2D vectors are equal.
 *  @param a First vector to compare
 *  @param b Second vector to compare
 *  @return 1 if the vectors are equal
 *  @return 0 if the vectors are not equal
 */
ASSIMP_API int aiVector2AreEqual(
        const C_STRUCT aiVector2D *a,
        const C_STRUCT aiVector2D *b);

// --------------------------------------------------------------------------------
/** Check if 2D vectors are equal using epsilon.
 *  @param a First vector to compare
 *  @param b Second vector to compare
 *  @param epsilon Epsilon
 *  @return 1 if the vectors are equal
 *  @return 0 if the vectors are not equal
 */
ASSIMP_API int aiVector2AreEqualEpsilon(
        const C_STRUCT aiVector2D *a,
        const C_STRUCT aiVector2D *b,
        const float epsilon);

// --------------------------------------------------------------------------------
/** Add 2D vectors.
 *  @param dst First addend, receives result.
 *  @param src Vector to be added to 'dst'.
 */
ASSIMP_API void aiVector2Add(
        C_STRUCT aiVector2D *dst,
        const C_STRUCT aiVector2D *src);

// --------------------------------------------------------------------------------
/** Subtract 2D vectors.
 *  @param dst Minuend, receives result.
 *  @param src Vector to be subtracted from 'dst'.
 */
ASSIMP_API void aiVector2Subtract(
        C_STRUCT aiVector2D *dst,
        const C_STRUCT aiVector2D *src);

// --------------------------------------------------------------------------------
/** Multiply a 2D vector by a scalar.
 *  @param dst Vector to be scaled by \p s
 *  @param s Scale factor
 */
ASSIMP_API void aiVector2Scale(
        C_STRUCT aiVector2D *dst,
        const float s);

// --------------------------------------------------------------------------------
/** Multiply each component of a 2D vector with
 *  the components of another vector.
 *  @param dst First vector, receives result
 *  @param other Second vector
 */
ASSIMP_API void aiVector2SymMul(
        C_STRUCT aiVector2D *dst,
        const C_STRUCT aiVector2D *other);

// --------------------------------------------------------------------------------
/** Divide a 2D vector by a scalar.
 *  @param dst Vector to be divided by \p s
 *  @param s Scalar divisor
 */
ASSIMP_API void aiVector2DivideByScalar(
        C_STRUCT aiVector2D *dst,
        const float s);

// --------------------------------------------------------------------------------
/** Divide each component of a 2D vector by
 *  the components of another vector.
 *  @param dst Vector as the dividend
 *  @param v Vector as the divisor
 */
ASSIMP_API void aiVector2DivideByVector(
        C_STRUCT aiVector2D *dst,
        C_STRUCT aiVector2D *v);

// --------------------------------------------------------------------------------
/** Get the length of a 2D vector.
 *  @return v Vector to evaluate
 */
ASSIMP_API float aiVector2Length(
        const C_STRUCT aiVector2D *v);

// --------------------------------------------------------------------------------
/** Get the squared length of a 2D vector.
 *  @return v Vector to evaluate
 */
ASSIMP_API float aiVector2SquareLength(
        const C_STRUCT aiVector2D *v);

// --------------------------------------------------------------------------------
/** Negate a 2D vector.
 *  @param dst Vector to be negated
 */
ASSIMP_API void aiVector2Negate(
        C_STRUCT aiVector2D *dst);

// --------------------------------------------------------------------------------
/** Get the dot product of 2D vectors.
 *  @param a First vector
 *  @param b Second vector
 *  @return The dot product of vectors
 */
ASSIMP_API float aiVector2DotProduct(
        const C_STRUCT aiVector2D *a,
        const C_STRUCT aiVector2D *b);

// --------------------------------------------------------------------------------
/** Normalize a 2D vector.
 *  @param v Vector to normalize
 */
ASSIMP_API void aiVector2Normalize(
        C_STRUCT aiVector2D *v);

// --------------------------------------------------------------------------------
/** Check if 3D vectors are equal.
 *  @param a First vector to compare
 *  @param b Second vector to compare
 *  @return 1 if the vectors are equal
 *  @return 0 if the vectors are not equal
 */
ASSIMP_API int aiVector3AreEqual(
        const C_STRUCT aiVector3D *a,
        const C_STRUCT aiVector3D *b);

// --------------------------------------------------------------------------------
/** Check if 3D vectors are equal using epsilon.
 *  @param a First vector to compare
 *  @param b Second vector to compare
 *  @param epsilon Epsilon
 *  @return 1 if the vectors are equal
 *  @return 0 if the vectors are not equal
 */
ASSIMP_API int aiVector3AreEqualEpsilon(
        const C_STRUCT aiVector3D *a,
        const C_STRUCT aiVector3D *b,
        const float epsilon);

// --------------------------------------------------------------------------------
/** Check if vector \p a is less than vector \p b.
 *  @param a First vector to compare
 *  @param b Second vector to compare
 *  @param epsilon Epsilon
 *  @return 1 if \p a is less than \p b
 *  @return 0 if \p a is equal or greater than \p b
 */
ASSIMP_API int aiVector3LessThan(
        const C_STRUCT aiVector3D *a,
        const C_STRUCT aiVector3D *b);

// --------------------------------------------------------------------------------
/** Add 3D vectors.
 *  @param dst First addend, receives result.
 *  @param src Vector to be added to 'dst'.
 */
ASSIMP_API void aiVector3Add(
        C_STRUCT aiVector3D *dst,
        const C_STRUCT aiVector3D *src);

// --------------------------------------------------------------------------------
/** Subtract 3D vectors.
 *  @param dst Minuend, receives result.
 *  @param src Vector to be subtracted from 'dst'.
 */
ASSIMP_API void aiVector3Subtract(
        C_STRUCT aiVector3D *dst,
        const C_STRUCT aiVector3D *src);

// --------------------------------------------------------------------------------
/** Multiply a 3D vector by a scalar.
 *  @param dst Vector to be scaled by \p s
 *  @param s Scale factor
 */
ASSIMP_API void aiVector3Scale(
        C_STRUCT aiVector3D *dst,
        const float s);

// --------------------------------------------------------------------------------
/** Multiply each component of a 3D vector with
 *  the components of another vector.
 *  @param dst First vector, receives result
 *  @param other Second vector
 */
ASSIMP_API void aiVector3SymMul(
        C_STRUCT aiVector3D *dst,
        const C_STRUCT aiVector3D *other);

// --------------------------------------------------------------------------------
/** Divide a 3D vector by a scalar.
 *  @param dst Vector to be divided by \p s
 *  @param s Scalar divisor
 */
ASSIMP_API void aiVector3DivideByScalar(
        C_STRUCT aiVector3D *dst,
        const float s);

// --------------------------------------------------------------------------------
/** Divide each component of a 3D vector by
 *  the components of another vector.
 *  @param dst Vector as the dividend
 *  @param v Vector as the divisor
 */
ASSIMP_API void aiVector3DivideByVector(
        C_STRUCT aiVector3D *dst,
        C_STRUCT aiVector3D *v);

// --------------------------------------------------------------------------------
/** Get the length of a 3D vector.
 *  @return v Vector to evaluate
 */
ASSIMP_API float aiVector3Length(
        const C_STRUCT aiVector3D *v);

// --------------------------------------------------------------------------------
/** Get the squared length of a 3D vector.
 *  @return v Vector to evaluate
 */
ASSIMP_API float aiVector3SquareLength(
        const C_STRUCT aiVector3D *v);

// --------------------------------------------------------------------------------
/** Negate a 3D vector.
 *  @param dst Vector to be negated
 */
ASSIMP_API void aiVector3Negate(
        C_STRUCT aiVector3D *dst);

// --------------------------------------------------------------------------------
/** Get the dot product of 3D vectors.
 *  @param a First vector
 *  @param b Second vector
 *  @return The dot product of vectors
 */
ASSIMP_API float aiVector3DotProduct(
        const C_STRUCT aiVector3D *a,
        const C_STRUCT aiVector3D *b);

// --------------------------------------------------------------------------------
/** Get cross product of 3D vectors.
 *  @param dst Vector to receive the result.
 *  @param a First vector
 *  @param b Second vector
 *  @return The dot product of vectors
 */
ASSIMP_API void aiVector3CrossProduct(
        C_STRUCT aiVector3D *dst,
        const C_STRUCT aiVector3D *a,
        const C_STRUCT aiVector3D *b);

// --------------------------------------------------------------------------------
/** Normalize a 3D vector.
 *  @param v Vector to normalize
 */
ASSIMP_API void aiVector3Normalize(
        C_STRUCT aiVector3D *v);

// --------------------------------------------------------------------------------
/** Check for division by zero and normalize a 3D vector.
 *  @param v Vector to normalize
 */
ASSIMP_API void aiVector3NormalizeSafe(
        C_STRUCT aiVector3D *v);

// --------------------------------------------------------------------------------
/** Rotate a 3D vector by a quaternion.
 *  @param v The vector to rotate by \p q
 *  @param q Quaternion to use to rotate \p v
 */
ASSIMP_API void aiVector3RotateByQuaternion(
        C_STRUCT aiVector3D *v,
        const C_STRUCT aiQuaternion *q);

// --------------------------------------------------------------------------------
/** Construct a 3x3 matrix from a 4x4 matrix.
 *  @param dst Receives the output matrix
 *  @param mat The 4x4 matrix to use
 */
ASSIMP_API void aiMatrix3FromMatrix4(
        C_STRUCT aiMatrix3x3 *dst,
        const C_STRUCT aiMatrix4x4 *mat);

// --------------------------------------------------------------------------------
/** Construct a 3x3 matrix from a quaternion.
 *  @param mat Receives the output matrix
 *  @param q The quaternion matrix to use
 */
ASSIMP_API void aiMatrix3FromQuaternion(
        C_STRUCT aiMatrix3x3 *mat,
        const C_STRUCT aiQuaternion *q);

// --------------------------------------------------------------------------------
/** Check if 3x3 matrices are equal.
 *  @param a First matrix to compare
 *  @param b Second matrix to compare
 *  @return 1 if the matrices are equal
 *  @return 0 if the matrices are not equal
 */
ASSIMP_API int aiMatrix3AreEqual(
        const C_STRUCT aiMatrix3x3 *a,
        const C_STRUCT aiMatrix3x3 *b);

// --------------------------------------------------------------------------------
/** Check if 3x3 matrices are equal.
 *  @param a First matrix to compare
 *  @param b Second matrix to compare
 *  @param epsilon Epsilon
 *  @return 1 if the matrices are equal
 *  @return 0 if the matrices are not equal
 */
ASSIMP_API int aiMatrix3AreEqualEpsilon(
        const C_STRUCT aiMatrix3x3 *a,
        const C_STRUCT aiMatrix3x3 *b,
        const float epsilon);

// --------------------------------------------------------------------------------
/** Invert a 3x3 matrix.
 *  @param mat Matrix to invert
 */
ASSIMP_API void aiMatrix3Inverse(
        C_STRUCT aiMatrix3x3 *mat);

// --------------------------------------------------------------------------------
/** Get the determinant of a 3x3 matrix.
 *  @param mat Matrix to get the determinant from
 */
ASSIMP_API float aiMatrix3Determinant(
        const C_STRUCT aiMatrix3x3 *mat);

// --------------------------------------------------------------------------------
/** Get a 3x3 rotation matrix around the Z axis.
 *  @param mat Receives the output matrix
 *  @param angle Rotation angle, in radians
 */
ASSIMP_API void aiMatrix3RotationZ(
        C_STRUCT aiMatrix3x3 *mat,
        const float angle);

// --------------------------------------------------------------------------------
/** Returns a 3x3 rotation matrix for a rotation around an arbitrary axis.
 *  @param mat Receives the output matrix
 *  @param axis Rotation axis, should be a normalized vector
 *  @param angle Rotation angle, in radians
 */
ASSIMP_API void aiMatrix3FromRotationAroundAxis(
        C_STRUCT aiMatrix3x3 *mat,
        const C_STRUCT aiVector3D *axis,
        const float angle);

// --------------------------------------------------------------------------------
/** Get a 3x3 translation matrix.
 *  @param mat Receives the output matrix
 *  @param translation The translation vector
 */
ASSIMP_API void aiMatrix3Translation(
        C_STRUCT aiMatrix3x3 *mat,
        const C_STRUCT aiVector2D *translation);

// --------------------------------------------------------------------------------
/** Create a 3x3 matrix that rotates one vector to another vector.
 *  @param mat Receives the output matrix
 *  @param from Vector to rotate from
 *  @param to Vector to rotate to
 */
ASSIMP_API void aiMatrix3FromTo(
        C_STRUCT aiMatrix3x3 *mat,
        const C_STRUCT aiVector3D *from,
        const C_STRUCT aiVector3D *to);

// --------------------------------------------------------------------------------
/** Construct a 4x4 matrix from a 3x3 matrix.
 *  @param dst Receives the output matrix
 *  @param mat The 3x3 matrix to use
 */
ASSIMP_API void aiMatrix4FromMatrix3(
        C_STRUCT aiMatrix4x4 *dst,
        const C_STRUCT aiMatrix3x3 *mat);

// --------------------------------------------------------------------------------
/** Construct a 4x4 matrix from scaling, rotation and position.
 *  @param mat Receives the output matrix.
 *  @param scaling The scaling for the x,y,z axes
 *  @param rotation The rotation as a hamilton quaternion
 *  @param position The position for the x,y,z axes
 */
ASSIMP_API void aiMatrix4FromScalingQuaternionPosition(
        C_STRUCT aiMatrix4x4 *mat,
        const C_STRUCT aiVector3D *scaling,
        const C_STRUCT aiQuaternion *rotation,
        const C_STRUCT aiVector3D *position);

// --------------------------------------------------------------------------------
/** Add 4x4 matrices.
 *  @param dst First addend, receives result.
 *  @param src Matrix to be added to 'dst'.
 */
ASSIMP_API void aiMatrix4Add(
        C_STRUCT aiMatrix4x4 *dst,
        const C_STRUCT aiMatrix4x4 *src);

// --------------------------------------------------------------------------------
/** Check if 4x4 matrices are equal.
 *  @param a First matrix to compare
 *  @param b Second matrix to compare
 *  @return 1 if the matrices are equal
 *  @return 0 if the matrices are not equal
 */
ASSIMP_API int aiMatrix4AreEqual(
        const C_STRUCT aiMatrix4x4 *a,
        const C_STRUCT aiMatrix4x4 *b);

// --------------------------------------------------------------------------------
/** Check if 4x4 matrices are equal.
 *  @param a First matrix to compare
 *  @param b Second matrix to compare
 *  @param epsilon Epsilon
 *  @return 1 if the matrices are equal
 *  @return 0 if the matrices are not equal
 */
ASSIMP_API int aiMatrix4AreEqualEpsilon(
        const C_STRUCT aiMatrix4x4 *a,
        const C_STRUCT aiMatrix4x4 *b,
        const float epsilon);

// --------------------------------------------------------------------------------
/** Invert a 4x4 matrix.
 *  @param result Matrix to invert
 */
ASSIMP_API void aiMatrix4Inverse(
        C_STRUCT aiMatrix4x4 *mat);

// --------------------------------------------------------------------------------
/** Get the determinant of a 4x4 matrix.
 *  @param mat Matrix to get the determinant from
 *  @return The determinant of the matrix
 */
ASSIMP_API float aiMatrix4Determinant(
        const C_STRUCT aiMatrix4x4 *mat);

// --------------------------------------------------------------------------------
/** Returns true of the matrix is the identity matrix.
 *  @param mat Matrix to get the determinant from
 *  @return 1 if \p mat is an identity matrix.
 *  @return 0 if \p mat is not an identity matrix.
 */
ASSIMP_API int aiMatrix4IsIdentity(
        const C_STRUCT aiMatrix4x4 *mat);

// --------------------------------------------------------------------------------
/** Decompose a transformation matrix into its scaling,
 *  rotational as euler angles, and translational components.
 *
 * @param mat Matrix to decompose
 * @param scaling Receives the output scaling for the x,y,z axes
 * @param rotation Receives the output rotation as a Euler angles
 * @param position Receives the output position for the x,y,z axes
 */
ASSIMP_API void aiMatrix4DecomposeIntoScalingEulerAnglesPosition(
        const C_STRUCT aiMatrix4x4 *mat,
        C_STRUCT aiVector3D *scaling,
        C_STRUCT aiVector3D *rotation,
        C_STRUCT aiVector3D *position);

// --------------------------------------------------------------------------------
/** Decompose a transformation matrix into its scaling,
 *  rotational split into an axis and rotational angle,
 *  and it's translational components.
 *
 * @param mat Matrix to decompose
 * @param rotation Receives the rotational component
 * @param axis Receives the output rotation axis
 * @param angle Receives the output rotation angle
 * @param position Receives the output position for the x,y,z axes.
 */
ASSIMP_API void aiMatrix4DecomposeIntoScalingAxisAnglePosition(
        const C_STRUCT aiMatrix4x4 *mat,
        C_STRUCT aiVector3D *scaling,
        C_STRUCT aiVector3D *axis,
        ai_real *angle,
        C_STRUCT aiVector3D *position);

// --------------------------------------------------------------------------------
/** Decompose a transformation matrix into its rotational and
 *  translational components.
 *
 * @param mat Matrix to decompose
 * @param rotation Receives the rotational component
 * @param position Receives the translational component.
 */
ASSIMP_API void aiMatrix4DecomposeNoScaling(
        const C_STRUCT aiMatrix4x4 *mat,
        C_STRUCT aiQuaternion *rotation,
        C_STRUCT aiVector3D *position);

// --------------------------------------------------------------------------------
/** Creates a 4x4 matrix from a set of euler angles.
 *  @param mat Receives the output matrix
 *  @param x Rotation angle for the x-axis, in radians
 *  @param y Rotation angle for the y-axis, in radians
 *  @param z Rotation angle for the z-axis, in radians
 */
ASSIMP_API void aiMatrix4FromEulerAngles(
        C_STRUCT aiMatrix4x4 *mat,
        float x, float y, float z);

// --------------------------------------------------------------------------------
/** Get a 4x4 rotation matrix around the X axis.
 *  @param mat Receives the output matrix
 *  @param angle Rotation angle, in radians
 */
ASSIMP_API void aiMatrix4RotationX(
        C_STRUCT aiMatrix4x4 *mat,
        const float angle);

// --------------------------------------------------------------------------------
/** Get a 4x4 rotation matrix around the Y axis.
 *  @param mat Receives the output matrix
 *  @param angle Rotation angle, in radians
 */
ASSIMP_API void aiMatrix4RotationY(
        C_STRUCT aiMatrix4x4 *mat,
        const float angle);

// --------------------------------------------------------------------------------
/** Get a 4x4 rotation matrix around the Z axis.
 *  @param mat Receives the output matrix
 *  @param angle Rotation angle, in radians
 */
ASSIMP_API void aiMatrix4RotationZ(
        C_STRUCT aiMatrix4x4 *mat,
        const float angle);

// --------------------------------------------------------------------------------
/** Returns a 4x4 rotation matrix for a rotation around an arbitrary axis.
 *  @param mat Receives the output matrix
 *  @param axis Rotation axis, should be a normalized vector
 *  @param angle Rotation angle, in radians
 */
ASSIMP_API void aiMatrix4FromRotationAroundAxis(
        C_STRUCT aiMatrix4x4 *mat,
        const C_STRUCT aiVector3D *axis,
        const float angle);

// --------------------------------------------------------------------------------
/** Get a 4x4 translation matrix.
 *  @param mat Receives the output matrix
 *  @param translation The translation vector
 */
ASSIMP_API void aiMatrix4Translation(
        C_STRUCT aiMatrix4x4 *mat,
        const C_STRUCT aiVector3D *translation);

// --------------------------------------------------------------------------------
/** Get a 4x4 scaling matrix.
 *  @param mat Receives the output matrix
 *  @param scaling The scaling vector
 */
ASSIMP_API void aiMatrix4Scaling(
        C_STRUCT aiMatrix4x4 *mat,
        const C_STRUCT aiVector3D *scaling);

// --------------------------------------------------------------------------------
/** Create a 4x4 matrix that rotates one vector to another vector.
 *  @param mat Receives the output matrix
 *  @param from Vector to rotate from
 *  @param to Vector to rotate to
 */
ASSIMP_API void aiMatrix4FromTo(
        C_STRUCT aiMatrix4x4 *mat,
        const C_STRUCT aiVector3D *from,
        const C_STRUCT aiVector3D *to);

// --------------------------------------------------------------------------------
/** Create a Quaternion from euler angles.
 *  @param q Receives the output quaternion
 *  @param x Rotation angle for the x-axis, in radians
 *  @param y Rotation angle for the y-axis, in radians
 *  @param z Rotation angle for the z-axis, in radians
 */
ASSIMP_API void aiQuaternionFromEulerAngles(
        C_STRUCT aiQuaternion *q,
        float x, float y, float z);

// --------------------------------------------------------------------------------
/** Create a Quaternion from an axis angle pair.
 *  @param q Receives the output quaternion
 *  @param axis The orientation axis
 *  @param angle The rotation angle, in radians
 */
ASSIMP_API void aiQuaternionFromAxisAngle(
        C_STRUCT aiQuaternion *q,
        const C_STRUCT aiVector3D *axis,
        const float angle);

// --------------------------------------------------------------------------------
/** Create a Quaternion from a normalized quaternion stored
 *  in a 3D vector.
 *  @param q Receives the output quaternion
 *  @param normalized The vector that stores the quaternion
 */
ASSIMP_API void aiQuaternionFromNormalizedQuaternion(
        C_STRUCT aiQuaternion *q,
        const C_STRUCT aiVector3D *normalized);

// --------------------------------------------------------------------------------
/** Check if quaternions are equal.
 *  @param a First quaternion to compare
 *  @param b Second quaternion to compare
 *  @return 1 if the quaternions are equal
 *  @return 0 if the quaternions are not equal
 */
ASSIMP_API int aiQuaternionAreEqual(
        const C_STRUCT aiQuaternion *a,
        const C_STRUCT aiQuaternion *b);

// --------------------------------------------------------------------------------
/** Check if quaternions are equal using epsilon.
 *  @param a First quaternion to compare
 *  @param b Second quaternion to compare
 *  @param epsilon Epsilon
 *  @return 1 if the quaternions are equal
 *  @return 0 if the quaternions are not equal
 */
ASSIMP_API int aiQuaternionAreEqualEpsilon(
        const C_STRUCT aiQuaternion *a,
        const C_STRUCT aiQuaternion *b,
        const float epsilon);

// --------------------------------------------------------------------------------
/** Normalize a quaternion.
 *  @param q Quaternion to normalize
 */
ASSIMP_API void aiQuaternionNormalize(
        C_STRUCT aiQuaternion *q);

// --------------------------------------------------------------------------------
/** Compute quaternion conjugate.
 *  @param q Quaternion to compute conjugate,
 *           receives the output quaternion
 */
ASSIMP_API void aiQuaternionConjugate(
        C_STRUCT aiQuaternion *q);

// --------------------------------------------------------------------------------
/** Multiply quaternions.
 *  @param dst First quaternion, receives the output quaternion
 *  @param q Second quaternion
 */
ASSIMP_API void aiQuaternionMultiply(
        C_STRUCT aiQuaternion *dst,
        const C_STRUCT aiQuaternion *q);

// --------------------------------------------------------------------------------
/** Performs a spherical interpolation between two quaternions.
 * @param dst Receives the quaternion resulting from the interpolation.
 * @param start Quaternion when factor == 0
 * @param end Quaternion when factor == 1
 * @param factor Interpolation factor between 0 and 1
 */
ASSIMP_API void aiQuaternionInterpolate(
        C_STRUCT aiQuaternion *dst,
        const C_STRUCT aiQuaternion *start,
        const C_STRUCT aiQuaternion *end,
        const float factor);

#ifdef __cplusplus
}
#endif

#endif // AI_ASSIMP_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/color4.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/
/** @file color4.h
 *  @brief RGBA color structure, including operators when compiling in C++
 */
#pragma once
#ifndef AI_COLOR4D_H_INC
#define AI_COLOR4D_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/defs.h>

#ifdef __cplusplus

// ----------------------------------------------------------------------------------
/** Represents a color in Red-Green-Blue space including an
*   alpha component. Color values range from 0 to 1. */
// ----------------------------------------------------------------------------------
template <typename TReal>
class aiColor4t {
public:
    aiColor4t() AI_NO_EXCEPT : r(), g(), b(), a() {}
    aiColor4t (TReal _r, TReal _g, TReal _b, TReal _a)
        : r(_r), g(_g), b(_b), a(_a) {}
    explicit aiColor4t (TReal _r) : r(_r), g(_r), b(_r), a(_r) {}
    aiColor4t (const aiColor4t& o) = default;

    // combined operators
    const aiColor4t& operator += (const aiColor4t& o);
    const aiColor4t& operator -= (const aiColor4t& o);
    const aiColor4t& operator *= (TReal f);
    const aiColor4t& operator /= (TReal f);

    // comparison
    bool operator == (const aiColor4t& other) const;
    bool operator != (const aiColor4t& other) const;
    bool operator <  (const aiColor4t& other) const;

    // color tuple access, rgba order
    inline TReal operator[](unsigned int i) const;
    inline TReal& operator[](unsigned int i);

    /** check whether a color is (close to) black */
    inline bool IsBlack() const;

    // Red, green, blue and alpha color values
    TReal r, g, b, a;
};  // !struct aiColor4D

typedef aiColor4t<ai_real> aiColor4D;

#else

struct aiColor4D {
    ai_real r, g, b, a;
};

#endif // __cplusplus

#endif // AI_COLOR4D_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/commonMetaData.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file commonMetaData.h
 *  @brief Defines a set of common scene metadata keys.
 */
#pragma once
#ifndef AI_COMMONMETADATA_H_INC
#define AI_COMMONMETADATA_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

/// Scene metadata holding the name of the importer which loaded the source asset.
/// This is always present if the scene was created from an imported asset.
#define AI_METADATA_SOURCE_FORMAT "SourceAsset_Format"

/// Scene metadata holding the version of the source asset as a string, if available.
/// Not all formats add this metadata.
#define AI_METADATA_SOURCE_FORMAT_VERSION "SourceAsset_FormatVersion"

/// Scene metadata holding the name of the software which generated the source asset, if available.
/// Not all formats add this metadata.
#define AI_METADATA_SOURCE_GENERATOR "SourceAsset_Generator"

/// Scene metadata holding the source asset copyright statement, if available.
/// Not all formats add this metadata.
#define AI_METADATA_SOURCE_COPYRIGHT "SourceAsset_Copyright"

#endif


============================================================
File Path: project/externals/assimp/include/assimp/config.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file config.h
 *  @brief Defines constants for configurable properties for the library
 *
 *  Typically these properties are set via
 *  #Assimp::Importer::SetPropertyFloat,
 *  #Assimp::Importer::SetPropertyInteger or
 *  #Assimp::Importer::SetPropertyString,
 *  depending on the data type of a property. All properties have a
 *  default value. See the doc for the mentioned methods for more details.
 *
 *  <br><br>
 *  The corresponding functions for use with the plain-c API are:
 *  #aiSetImportPropertyInteger,
 *  #aiSetImportPropertyFloat,
 *  #aiSetImportPropertyString
 */
#pragma once
#ifndef AI_CONFIG_H_INC
#define AI_CONFIG_H_INC

// ###########################################################################
// LIBRARY SETTINGS
// General, global settings
// ###########################################################################

// ---------------------------------------------------------------------------
/** @brief Enables time measurements.
 *
 *  If enabled, measures the time needed for each part of the loading
 *  process (i.e. IO time, importing, postprocessing, ..) and dumps
 *  these timings to the DefaultLogger. See the @link perf Performance
 *  Page@endlink for more information on this topic.
 *
 * Property type: bool. Default value: false.
 */
#define AI_CONFIG_GLOB_MEASURE_TIME  \
    "GLOB_MEASURE_TIME"

// ---------------------------------------------------------------------------
/** @brief Global setting to disable generation of skeleton dummy meshes
 *
 * Skeleton dummy meshes are generated as a visualization aid in cases which
 * the input data contains no geometry, but only animation data.
 * Property data type: bool. Default value: false
 */
// ---------------------------------------------------------------------------
#define AI_CONFIG_IMPORT_NO_SKELETON_MESHES \
    "IMPORT_NO_SKELETON_MESHES"

// ###########################################################################
// POST PROCESSING SETTINGS
// Various stuff to fine-tune the behavior of a specific post processing step.
// ###########################################################################

// ---------------------------------------------------------------------------
/** @brief Maximum bone count per mesh for the SplitbyBoneCount step.
 *
 * Meshes are split until the maximum number of bones is reached. The default
 * value is AI_SBBC_DEFAULT_MAX_BONES, which may be altered at
 * compile-time.
 * Property data type: integer.
 */
// ---------------------------------------------------------------------------
#define AI_CONFIG_PP_SBBC_MAX_BONES \
    "PP_SBBC_MAX_BONES"

// default limit for bone count
#if (!defined AI_SBBC_DEFAULT_MAX_BONES)
#   define AI_SBBC_DEFAULT_MAX_BONES        60
#endif

// ---------------------------------------------------------------------------
/** @brief  Specifies the maximum angle that may be between two vertex tangents
 *         that their tangents and bi-tangents are smoothed.
 *
 * This applies to the CalcTangentSpace-Step. The angle is specified
 * in degrees. The maximum value is 175.
 * Property type: float. Default value: 45 degrees
 */
#define AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE \
    "PP_CT_MAX_SMOOTHING_ANGLE"

// ---------------------------------------------------------------------------
/** @brief Source UV channel for tangent space computation.
 *
 * The specified channel must exist or an error will be raised.
 * Property type: integer. Default value: 0
 */
// ---------------------------------------------------------------------------
#define AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX \
    "PP_CT_TEXTURE_CHANNEL_INDEX"

// ---------------------------------------------------------------------------
/** @brief  Specifies the maximum angle that may be between two face normals
 *          at the same vertex position that their are smoothed together.
 *
 * Sometimes referred to as 'crease angle'.
 * This applies to the GenSmoothNormals-Step. The angle is specified
 * in degrees, so 180 is PI. The default value is 175 degrees (all vertex
 * normals are smoothed). The maximum value is 175, too. Property type: float.
 * Warning: setting this option may cause a severe loss of performance. The
 * performance is unaffected if the #AI_CONFIG_FAVOUR_SPEED flag is set but
 * the output quality may be reduced.
 */
#define AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE \
    "PP_GSN_MAX_SMOOTHING_ANGLE"

// ---------------------------------------------------------------------------
/** @brief Sets the colormap (= palette) to be used to decode embedded
 *         textures in MDL (Quake or 3DGS) files.
 *
 * This must be a valid path to a file. The file is 768 (256*3) bytes
 * large and contains RGB triplets for each of the 256 palette entries.
 * The default value is colormap.lmp. If the file is not found,
 * a default palette (from Quake 1) is used.
 * Property type: string.
 */
#define AI_CONFIG_IMPORT_MDL_COLORMAP       \
    "IMPORT_MDL_COLORMAP"

// ---------------------------------------------------------------------------
/** @brief Configures the #aiProcess_RemoveRedundantMaterials step to
 *  keep materials matching a name in a given list.
 *
 * This is a list of 1 to n strings, ' ' serves as delimiter character.
 * Identifiers containing whitespaces must be enclosed in *single*
 * quotation marks. For example:<tt>
 * "keep-me and_me_to anotherMaterialToBeKept \'name with whitespace\'"</tt>.
 * If a material matches on of these names, it will not be modified or
 * removed by the postprocessing step nor will other materials be replaced
 * by a reference to it. <br>
 * This option might be useful if you are using some magic material names
 * to pass additional semantics through the content pipeline. This ensures
 * they won't be optimized away, but a general optimization is still
 * performed for materials not contained in the list.
 * Property type: String. Default value: n/a
 * @note Linefeeds, tabs or carriage returns are treated as whitespace.
 *   Material names are case sensitive.
 */
#define AI_CONFIG_PP_RRM_EXCLUDE_LIST   \
    "PP_RRM_EXCLUDE_LIST"

// ---------------------------------------------------------------------------
/** @brief Configures the #aiProcess_PreTransformVertices step to
 *  keep the scene hierarchy. Meshes are moved to worldspace, but
 *  no optimization is performed (read: meshes with equal materials are not
 *  joined. The total number of meshes won't change).
 *
 * This option could be of use for you if the scene hierarchy contains
 * important additional information which you intend to parse.
 * For rendering, you can still render all meshes in the scene without
 * any transformations.
 * Property type: bool. Default value: false.
 */
#define AI_CONFIG_PP_PTV_KEEP_HIERARCHY     \
    "PP_PTV_KEEP_HIERARCHY"

// ---------------------------------------------------------------------------
/** @brief Configures the #aiProcess_PreTransformVertices step to normalize
 *  all vertex components into the [-1,1] range. That is, a bounding box
 *  for the whole scene is computed, the maximum component is taken and all
 *  meshes are scaled appropriately (uniformly of course!).
 *  This might be useful if you don't know the spatial dimension of the input
 *  data*/
#define AI_CONFIG_PP_PTV_NORMALIZE  \
    "PP_PTV_NORMALIZE"

// ---------------------------------------------------------------------------
/** @brief Configures the #aiProcess_PreTransformVertices step to use
 *  a users defined matrix as the scene root node transformation before
 *  transforming vertices.
 *  Property type: bool. Default value: false.
 */
#define AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION    \
    "PP_PTV_ADD_ROOT_TRANSFORMATION"

// ---------------------------------------------------------------------------
/** @brief Configures the #aiProcess_PreTransformVertices step to use
 *  a users defined matrix as the scene root node transformation before
 *  transforming vertices. This property correspond to the 'a1' component
 *  of the transformation matrix.
 *  Property type: aiMatrix4x4.
 */
#define AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION    \
    "PP_PTV_ROOT_TRANSFORMATION"

// ---------------------------------------------------------------------------
/** @brief Configures the #aiProcess_FindDegenerates step to
 *  remove degenerated primitives from the import - immediately.
 *
 * The default behaviour converts degenerated triangles to lines and
 * degenerated lines to points. See the documentation to the
 * #aiProcess_FindDegenerates step for a detailed example of the various ways
 * to get rid of these lines and points if you don't want them.
 * Property type: bool. Default value: false.
 */
#define AI_CONFIG_PP_FD_REMOVE \
    "PP_FD_REMOVE"

// ---------------------------------------------------------------------------
/**
 *  @brief  Configures the #aiProcess_FindDegenerates to check the area of a
 *  triangle to be greater than e-6. If this is not the case the triangle will
 *  be removed if #AI_CONFIG_PP_FD_REMOVE is set to true.
 */
#define AI_CONFIG_PP_FD_CHECKAREA \
    "PP_FD_CHECKAREA"

// ---------------------------------------------------------------------------
/** @brief Configures the #aiProcess_OptimizeGraph step to preserve nodes
 * matching a name in a given list.
 *
 * This is a list of 1 to n strings, ' ' serves as delimiter character.
 * Identifiers containing whitespaces must be enclosed in *single*
 * quotation marks. For example:<tt>
 * "keep-me and_me_to anotherNodeToBeKept \'name with whitespace\'"</tt>.
 * If a node matches on of these names, it will not be modified or
 * removed by the postprocessing step.<br>
 * This option might be useful if you are using some magic node names
 * to pass additional semantics through the content pipeline. This ensures
 * they won't be optimized away, but a general optimization is still
 * performed for nodes not contained in the list.
 * Property type: String. Default value: n/a
 * @note Linefeeds, tabs or carriage returns are treated as whitespace.
 *   Node names are case sensitive.
 */
#define AI_CONFIG_PP_OG_EXCLUDE_LIST    \
    "PP_OG_EXCLUDE_LIST"

// ---------------------------------------------------------------------------
/** @brief  Set the maximum number of triangles in a mesh.
 *
 * This is used by the "SplitLargeMeshes" PostProcess-Step to determine
 * whether a mesh must be split or not.
 * @note The default value is AI_SLM_DEFAULT_MAX_TRIANGLES
 * Property type: integer.
 */
#define AI_CONFIG_PP_SLM_TRIANGLE_LIMIT \
    "PP_SLM_TRIANGLE_LIMIT"

// default value for AI_CONFIG_PP_SLM_TRIANGLE_LIMIT
#if (!defined AI_SLM_DEFAULT_MAX_TRIANGLES)
#   define AI_SLM_DEFAULT_MAX_TRIANGLES     1000000
#endif

// ---------------------------------------------------------------------------
/** @brief  Set the maximum number of vertices in a mesh.
 *
 * This is used by the "SplitLargeMeshes" PostProcess-Step to determine
 * whether a mesh must be split or not.
 * @note The default value is AI_SLM_DEFAULT_MAX_VERTICES
 * Property type: integer.
 */
#define AI_CONFIG_PP_SLM_VERTEX_LIMIT \
    "PP_SLM_VERTEX_LIMIT"

// default value for AI_CONFIG_PP_SLM_VERTEX_LIMIT
#if (!defined AI_SLM_DEFAULT_MAX_VERTICES)
#   define AI_SLM_DEFAULT_MAX_VERTICES      1000000
#endif

// ---------------------------------------------------------------------------
/** @brief Set the maximum number of bones affecting a single vertex
 *
 * This is used by the #aiProcess_LimitBoneWeights PostProcess-Step.
 * @note The default value is AI_LMW_MAX_WEIGHTS
 * Property type: integer.*/
#define AI_CONFIG_PP_LBW_MAX_WEIGHTS    \
    "PP_LBW_MAX_WEIGHTS"

// default value for AI_CONFIG_PP_LBW_MAX_WEIGHTS
#if (!defined AI_LMW_MAX_WEIGHTS)
#   define AI_LMW_MAX_WEIGHTS   0x4
#endif // !! AI_LMW_MAX_WEIGHTS

// ---------------------------------------------------------------------------
/** @brief Lower the deboning threshold in order to remove more bones.
 *
 * This is used by the #aiProcess_Debone PostProcess-Step.
 * @note The default value is AI_DEBONE_THRESHOLD
 * Property type: float.*/
#define AI_CONFIG_PP_DB_THRESHOLD \
    "PP_DB_THRESHOLD"

// default value for AI_CONFIG_PP_LBW_MAX_WEIGHTS
#if (!defined AI_DEBONE_THRESHOLD)
#   define AI_DEBONE_THRESHOLD  1.0f
#endif // !! AI_DEBONE_THRESHOLD

// ---------------------------------------------------------------------------
/** @brief Require all bones qualify for deboning before removing any
 *
 * This is used by the #aiProcess_Debone PostProcess-Step.
 * @note The default value is 0
 * Property type: bool.*/
#define AI_CONFIG_PP_DB_ALL_OR_NONE \
    "PP_DB_ALL_OR_NONE"

/** @brief Default value for the #AI_CONFIG_PP_ICL_PTCACHE_SIZE property
 */
#ifndef PP_ICL_PTCACHE_SIZE
#   define PP_ICL_PTCACHE_SIZE 12
#endif

// ---------------------------------------------------------------------------
/** @brief Set the size of the post-transform vertex cache to optimize the
 *    vertices for. This configures the #aiProcess_ImproveCacheLocality step.
 *
 * The size is given in vertices. Of course you can't know how the vertex
 * format will exactly look like after the import returns, but you can still
 * guess what your meshes will probably have.
 * @note The default value is #PP_ICL_PTCACHE_SIZE. That results in slight
 * performance improvements for most nVidia/AMD cards since 2002.
 * Property type: integer.
 */
#define AI_CONFIG_PP_ICL_PTCACHE_SIZE   "PP_ICL_PTCACHE_SIZE"

// ---------------------------------------------------------------------------
/** @brief Enumerates components of the aiScene and aiMesh data structures
 *  that can be excluded from the import using the #aiProcess_RemoveComponent step.
 *
 *  See the documentation to #aiProcess_RemoveComponent for more details.
 */
enum aiComponent
{
    /** Normal vectors */
#ifdef SWIG
    aiComponent_NORMALS = 0x2,
#else
    aiComponent_NORMALS = 0x2u,
#endif

    /** Tangents and bitangents go always together ... */
#ifdef SWIG
    aiComponent_TANGENTS_AND_BITANGENTS = 0x4,
#else
    aiComponent_TANGENTS_AND_BITANGENTS = 0x4u,
#endif

    /** ALL color sets
     * Use aiComponent_COLORn(N) to specify the N'th set */
    aiComponent_COLORS = 0x8,

    /** ALL texture UV sets
     * aiComponent_TEXCOORDn(N) to specify the N'th set  */
    aiComponent_TEXCOORDS = 0x10,

    /** Removes all bone weights from all meshes.
     * The scenegraph nodes corresponding to the bones are NOT removed.
     * use the #aiProcess_OptimizeGraph step to do this */
    aiComponent_BONEWEIGHTS = 0x20,

    /** Removes all node animations (aiScene::mAnimations).
     * The corresponding scenegraph nodes are NOT removed.
     * use the #aiProcess_OptimizeGraph step to do this */
    aiComponent_ANIMATIONS = 0x40,

    /** Removes all embedded textures (aiScene::mTextures) */
    aiComponent_TEXTURES = 0x80,

    /** Removes all light sources (aiScene::mLights).
     * The corresponding scenegraph nodes are NOT removed.
     * use the #aiProcess_OptimizeGraph step to do this */
    aiComponent_LIGHTS = 0x100,

    /** Removes all cameras (aiScene::mCameras).
     * The corresponding scenegraph nodes are NOT removed.
     * use the #aiProcess_OptimizeGraph step to do this */
    aiComponent_CAMERAS = 0x200,

    /** Removes all meshes (aiScene::mMeshes). */
    aiComponent_MESHES = 0x400,

    /** Removes all materials. One default material will
     * be generated, so aiScene::mNumMaterials will be 1. */
    aiComponent_MATERIALS = 0x800,


    /** This value is not used. It is just there to force the
     *  compiler to map this enum to a 32 Bit integer. */
#ifndef SWIG
    _aiComponent_Force32Bit = 0x9fffffff
#endif
};

// Remove a specific color channel 'n'
#define aiComponent_COLORSn(n) (1u << (n+20u))

// Remove a specific UV channel 'n'
#define aiComponent_TEXCOORDSn(n) (1u << (n+25u))

// ---------------------------------------------------------------------------
/** @brief Input parameter to the #aiProcess_RemoveComponent step:
 *  Specifies the parts of the data structure to be removed.
 *
 * See the documentation to this step for further details. The property
 * is expected to be an integer, a bitwise combination of the
 * #aiComponent flags defined above in this header. The default
 * value is 0. Important: if no valid mesh is remaining after the
 * step has been executed (e.g you thought it was funny to specify ALL
 * of the flags defined above) the import FAILS. Mainly because there is
 * no data to work on anymore ...
 */
#define AI_CONFIG_PP_RVC_FLAGS              \
    "PP_RVC_FLAGS"

// ---------------------------------------------------------------------------
/** @brief Input parameter to the #aiProcess_SortByPType step:
 *  Specifies which primitive types are removed by the step.
 *
 *  This is a bitwise combination of the aiPrimitiveType flags.
 *  Specifying all of them is illegal, of course. A typical use would
 *  be to exclude all line and point meshes from the import. This
 *  is an integer property, its default value is 0.
 */
#define AI_CONFIG_PP_SBP_REMOVE             \
    "PP_SBP_REMOVE"

// ---------------------------------------------------------------------------
/** @brief Input parameter to the #aiProcess_FindInvalidData step:
 *  Specifies the floating-point accuracy for animation values. The step
 *  checks for animation tracks where all frame values are absolutely equal
 *  and removes them. This tweakable controls the epsilon for floating-point
 *  comparisons - two keys are considered equal if the invariant
 *  abs(n0-n1)>epsilon holds true for all vector respectively quaternion
 *  components. The default value is 0.f - comparisons are exact then.
 */
#define AI_CONFIG_PP_FID_ANIM_ACCURACY              \
    "PP_FID_ANIM_ACCURACY"

// ---------------------------------------------------------------------------
/** @brief Input parameter to the #aiProcess_FindInvalidData step:
 *  Set to true to ignore texture coordinates. This may be useful if you have
 *  to assign different kind of textures like one for the summer or one for the winter.
 */
#define AI_CONFIG_PP_FID_IGNORE_TEXTURECOORDS        \
    "PP_FID_IGNORE_TEXTURECOORDS"

// TransformUVCoords evaluates UV scalings
#define AI_UVTRAFO_SCALING 0x1

// TransformUVCoords evaluates UV rotations
#define AI_UVTRAFO_ROTATION 0x2

// TransformUVCoords evaluates UV translation
#define AI_UVTRAFO_TRANSLATION 0x4

// Everything baked together -> default value
#define AI_UVTRAFO_ALL (AI_UVTRAFO_SCALING | AI_UVTRAFO_ROTATION | AI_UVTRAFO_TRANSLATION)

// ---------------------------------------------------------------------------
/** @brief Input parameter to the #aiProcess_TransformUVCoords step:
 *  Specifies which UV transformations are evaluated.
 *
 *  This is a bitwise combination of the AI_UVTRAFO_XXX flags (integer
 *  property, of course). By default all transformations are enabled
 * (AI_UVTRAFO_ALL).
 */
#define AI_CONFIG_PP_TUV_EVALUATE               \
    "PP_TUV_EVALUATE"

// ---------------------------------------------------------------------------
/** @brief A hint to assimp to favour speed against import quality.
 *
 * Enabling this option may result in faster loading, but it needn't.
 * It represents just a hint to loaders and post-processing steps to use
 * faster code paths, if possible.
 * This property is expected to be an integer, != 0 stands for true.
 * The default value is 0.
 */
#define AI_CONFIG_FAVOUR_SPEED              \
 "FAVOUR_SPEED"

// ###########################################################################
// IMPORTER SETTINGS
// Various stuff to fine-tune the behaviour of specific importer plugins.
// ###########################################################################

// ---------------------------------------------------------------------------
/** @brief Importers which parse JSON may use this to obtain a pointer to a
 * rapidjson::IRemoteSchemaDocumentProvider.
 *
 * The default value is nullptr
 * Property type: void*
 */
#define AI_CONFIG_IMPORT_SCHEMA_DOCUMENT_PROVIDER \
    "IMPORT_SCHEMA_DOCUMENT_PROVIDER"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will merge all geometry layers present
 *    in the source file or take only the first.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS \
    "IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will read all materials present in the
 *    source file or take only the referenced materials.
 *
 * This is void unless IMPORT_FBX_READ_MATERIALS=1.
 *
 * The default value is false (0)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS \
    "IMPORT_FBX_READ_ALL_MATERIALS"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will read materials.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_READ_MATERIALS \
    "IMPORT_FBX_READ_MATERIALS"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will read embedded textures.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_READ_TEXTURES \
    "IMPORT_FBX_READ_TEXTURES"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will read cameras.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_READ_CAMERAS \
    "IMPORT_FBX_READ_CAMERAS"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will read light sources.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_READ_LIGHTS \
    "IMPORT_FBX_READ_LIGHTS"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will read animations.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS \
    "IMPORT_FBX_READ_ANIMATIONS"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will read weights.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_READ_WEIGHTS \
    "IMPORT_FBX_READ_WEIGHTS"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will act in strict mode in which only
 *    FBX 2013 is supported and any other sub formats are rejected. FBX 2013
 *    is the primary target for the importer, so this format is best
 *    supported and well-tested.
 *
 * The default value is false (0)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_STRICT_MODE \
    "IMPORT_FBX_STRICT_MODE"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will preserve pivot points for
 *    transformations (as extra nodes). If set to false, pivots and offsets
 *    will be evaluated whenever possible.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS \
    "IMPORT_FBX_PRESERVE_PIVOTS"

// ---------------------------------------------------------------------------
/** @brief Specifies whether the importer will drop empty animation curves or
 *    animation curves which match the bind pose transformation over their
 *    entire defined range.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES \
    "IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES"

// ---------------------------------------------------------------------------
/** @brief Set whether the fbx importer will use the legacy embedded texture naming.
 *
 * The default value is false (0)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING \
	"AI_CONFIG_IMPORT_FBX_EMBEDDED_TEXTURES_LEGACY_NAMING"

// ---------------------------------------------------------------------------
/** @brief  Set wether the importer shall not remove empty bones.
 *
 *  Empty bone are often used to define connections for other models.
 */
#define AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES \
    "AI_CONFIG_IMPORT_REMOVE_EMPTY_BONES"


// ---------------------------------------------------------------------------
/** @brief  Set wether the FBX importer shall convert the unit from cm to m.
 */
#define AI_CONFIG_FBX_CONVERT_TO_M \
    "AI_CONFIG_FBX_CONVERT_TO_M"

// ---------------------------------------------------------------------------
/** @brief  Will enable the skeleton struct to store bone data.
 *
 *  This will decouple the bone coupling to the mesh. This feature is
 *  experimental.
 */
#define AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER \
    "AI_CONFIG_FBX_USE_SKELETON_BONE_CONTAINER"

// ---------------------------------------------------------------------------
/** @brief  Set the vertex animation keyframe to be imported
 *
 * ASSIMP does not support vertex keyframes (only bone animation is supported).
 * The library reads only one frame of models with vertex animations.
 * By default this is the first frame.
 * \note The default value is 0. This option applies to all importers.
 *   However, it is also possible to override the global setting
 *   for a specific loader. You can use the AI_CONFIG_IMPORT_XXX_KEYFRAME
 *   options (where XXX is a placeholder for the file format for which you
 *   want to override the global setting).
 * Property type: integer.
 */
#define AI_CONFIG_IMPORT_GLOBAL_KEYFRAME    "IMPORT_GLOBAL_KEYFRAME"

#define AI_CONFIG_IMPORT_MD3_KEYFRAME       "IMPORT_MD3_KEYFRAME"
#define AI_CONFIG_IMPORT_MD2_KEYFRAME       "IMPORT_MD2_KEYFRAME"
#define AI_CONFIG_IMPORT_MDL_KEYFRAME       "IMPORT_MDL_KEYFRAME"
#define AI_CONFIG_IMPORT_MDC_KEYFRAME       "IMPORT_MDC_KEYFRAME"
#define AI_CONFIG_IMPORT_SMD_KEYFRAME       "IMPORT_SMD_KEYFRAME"
#define AI_CONFIG_IMPORT_UNREAL_KEYFRAME    "IMPORT_UNREAL_KEYFRAME"

// ---------------------------------------------------------------------------
/** @brief Set whether the MDL (HL1) importer will read animations.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS "IMPORT_MDL_HL1_READ_ANIMATIONS"

// ---------------------------------------------------------------------------
/** @brief Set whether the MDL (HL1) importer will read animation events.
 * \note This property requires AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS to be set to true.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATION_EVENTS "IMPORT_MDL_HL1_READ_ANIMATION_EVENTS"

// ---------------------------------------------------------------------------
/** @brief Set whether the MDL (HL1) importer will read blend controllers.
 * \note This property requires AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS to be set to true.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS "IMPORT_MDL_HL1_READ_BLEND_CONTROLLERS"

// ---------------------------------------------------------------------------
/** @brief Set whether the MDL (HL1) importer will read sequence transition graph.
 * \note This property requires AI_CONFIG_IMPORT_MDL_HL1_READ_ANIMATIONS to be set to true.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS "IMPORT_MDL_HL1_READ_SEQUENCE_TRANSITIONS"

// ---------------------------------------------------------------------------
/** @brief Set whether the MDL (HL1) importer will read attachments info.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_MDL_HL1_READ_ATTACHMENTS "IMPORT_MDL_HL1_READ_ATTACHMENTS"

// ---------------------------------------------------------------------------
/** @brief Set whether the MDL (HL1) importer will read bone controllers info.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_MDL_HL1_READ_BONE_CONTROLLERS "IMPORT_MDL_HL1_READ_BONE_CONTROLLERS"

// ---------------------------------------------------------------------------
/** @brief Set whether the MDL (HL1) importer will read hitboxes info.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_MDL_HL1_READ_HITBOXES "IMPORT_MDL_HL1_READ_HITBOXES"

// ---------------------------------------------------------------------------
/** @brief Set whether the MDL (HL1) importer will read miscellaneous global model info.
 *
 * The default value is true (1)
 * Property type: bool
 */
#define AI_CONFIG_IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO "IMPORT_MDL_HL1_READ_MISC_GLOBAL_INFO"

// ---------------------------------------------------------------------------
/** Smd load multiple animations
 *
 *  Property type: bool. Default value: true.
 */
#define AI_CONFIG_IMPORT_SMD_LOAD_ANIMATION_LIST "IMPORT_SMD_LOAD_ANIMATION_LIST"

// ---------------------------------------------------------------------------
/** @brief  Configures the AC loader to collect all surfaces which have the
 *    "Backface cull" flag set in separate meshes.
 *
 *  Property type: bool. Default value: true.
 */
#define AI_CONFIG_IMPORT_AC_SEPARATE_BFCULL \
    "IMPORT_AC_SEPARATE_BFCULL"

// ---------------------------------------------------------------------------
/** @brief  Configures whether the AC loader evaluates subdivision surfaces (
 *  indicated by the presence of the 'subdiv' attribute in the file). By
 *  default, Assimp performs the subdivision using the standard
 *  Catmull-Clark algorithm
 *
 * * Property type: bool. Default value: true.
 */
#define AI_CONFIG_IMPORT_AC_EVAL_SUBDIVISION    \
    "IMPORT_AC_EVAL_SUBDIVISION"

// ---------------------------------------------------------------------------
/** @brief  Configures the UNREAL 3D loader to separate faces with different
 *    surface flags (e.g. two-sided vs. single-sided).
 *
 * * Property type: bool. Default value: true.
 */
#define AI_CONFIG_IMPORT_UNREAL_HANDLE_FLAGS \
    "UNREAL_HANDLE_FLAGS"

// ---------------------------------------------------------------------------
/** @brief Configures the terragen import plugin to compute uv's for
 *  terrains, if not given. Furthermore a default texture is assigned.
 *
 * UV coordinates for terrains are so simple to compute that you'll usually
 * want to compute them on your own, if you need them. This option is intended
 * for model viewers which want to offer an easy way to apply textures to
 * terrains.
 * * Property type: bool. Default value: false.
 */
#define AI_CONFIG_IMPORT_TER_MAKE_UVS \
    "IMPORT_TER_MAKE_UVS"

// ---------------------------------------------------------------------------
/** @brief  Configures the ASE loader to always reconstruct normal vectors
 *  basing on the smoothing groups loaded from the file.
 *
 * Some ASE files have carry invalid normals, other don't.
 * * Property type: bool. Default value: true.
 */
#define AI_CONFIG_IMPORT_ASE_RECONSTRUCT_NORMALS    \
    "IMPORT_ASE_RECONSTRUCT_NORMALS"

// ---------------------------------------------------------------------------
/** @brief  Configures the M3D loader to detect and process multi-part
 *    Quake player models.
 *
 * These models usually consist of 3 files, lower.md3, upper.md3 and
 * head.md3. If this property is set to true, Assimp will try to load and
 * combine all three files if one of them is loaded.
 * Property type: bool. Default value: true.
 */
#define AI_CONFIG_IMPORT_MD3_HANDLE_MULTIPART \
    "IMPORT_MD3_HANDLE_MULTIPART"

// ---------------------------------------------------------------------------
/** @brief  Tells the MD3 loader which skin files to load.
 *
 * When loading MD3 files, Assimp checks whether a file
 * [md3_file_name]_[skin_name].skin is existing. These files are used by
 * Quake III to be able to assign different skins (e.g. red and blue team)
 * to models. 'default', 'red', 'blue' are typical skin names.
 * Property type: String. Default value: "default".
 */
#define AI_CONFIG_IMPORT_MD3_SKIN_NAME \
    "IMPORT_MD3_SKIN_NAME"

// ---------------------------------------------------------------------------
/** @brief  Specify if to try load Quake 3 shader files. This also controls
 *  original surface name handling: when disabled it will be used unchanged.
 *
 * Property type: bool. Default value: true.
 */
#define AI_CONFIG_IMPORT_MD3_LOAD_SHADERS \
    "IMPORT_MD3_LOAD_SHADERS"

// ---------------------------------------------------------------------------
/** @brief  Specify the Quake 3 shader file to be used for a particular
 *  MD3 file. This can also be a search path.
 *
 * By default Assimp's behaviour is as follows: If a MD3 file
 * <tt>any_path/models/any_q3_subdir/model_name/file_name.md3</tt> is
 * loaded, the library tries to locate the corresponding shader file in
 * <tt>any_path/scripts/model_name.shader</tt>. This property overrides this
 * behaviour. It can either specify a full path to the shader to be loaded
 * or alternatively the path (relative or absolute) to the directory where
 * the shaders for all MD3s to be loaded reside. Assimp attempts to open
 * <tt>IMPORT_MD3_SHADER_SRC/model_name.shader</tt> first, <tt>IMPORT_MD3_SHADER_SRC/file_name.shader</tt>
 * is the fallback file. Note that IMPORT_MD3_SHADER_SRC should have a terminal (back)slash.
 * Property type: String. Default value: n/a.
 */
#define AI_CONFIG_IMPORT_MD3_SHADER_SRC \
    "IMPORT_MD3_SHADER_SRC"

// ---------------------------------------------------------------------------
/** @brief  Configures the LWO loader to load just one layer from the model.
 *
 * LWO files consist of layers and in some cases it could be useful to load
 * only one of them. This property can be either a string - which specifies
 * the name of the layer - or an integer - the index of the layer. If the
 * property is not set the whole LWO model is loaded. Loading fails if the
 * requested layer is not available. The layer index is zero-based and the
 * layer name may not be empty.<br>
 * Property type: Integer. Default value: all layers are loaded.
 */
#define AI_CONFIG_IMPORT_LWO_ONE_LAYER_ONLY         \
    "IMPORT_LWO_ONE_LAYER_ONLY"

// ---------------------------------------------------------------------------
/** @brief  Configures the MD5 loader to not load the MD5ANIM file for
 *  a MD5MESH file automatically.
 *
 * The default strategy is to look for a file with the same name but the
 * MD5ANIM extension in the same directory. If it is found, it is loaded
 * and combined with the MD5MESH file. This configuration option can be
 * used to disable this behaviour.
 *
 * * Property type: bool. Default value: false.
 */
#define AI_CONFIG_IMPORT_MD5_NO_ANIM_AUTOLOAD           \
    "IMPORT_MD5_NO_ANIM_AUTOLOAD"

// ---------------------------------------------------------------------------
/** @brief Defines the begin of the time range for which the LWS loader
 *    evaluates animations and computes aiNodeAnim's.
 *
 * Assimp provides full conversion of LightWave's envelope system, including
 * pre and post conditions. The loader computes linearly subsampled animation
 * chanels with the frame rate given in the LWS file. This property defines
 * the start time. Note: animation channels are only generated if a node
 * has at least one envelope with more tan one key assigned. This property.
 * is given in frames, '0' is the first frame. By default, if this property
 * is not set, the importer takes the animation start from the input LWS
 * file ('FirstFrame' line)<br>
 * Property type: Integer. Default value: taken from file.
 *
 * @see AI_CONFIG_IMPORT_LWS_ANIM_END - end of the imported time range
 */
#define AI_CONFIG_IMPORT_LWS_ANIM_START         \
    "IMPORT_LWS_ANIM_START"
#define AI_CONFIG_IMPORT_LWS_ANIM_END           \
    "IMPORT_LWS_ANIM_END"

// ---------------------------------------------------------------------------
/** @brief Defines the output frame rate of the IRR loader.
 *
 * IRR animations are difficult to convert for Assimp and there will
 * always be a loss of quality. This setting defines how many keys per second
 * are returned by the converter.<br>
 * Property type: integer. Default value: 100
 */
#define AI_CONFIG_IMPORT_IRR_ANIM_FPS               \
    "IMPORT_IRR_ANIM_FPS"

// ---------------------------------------------------------------------------
/** @brief Ogre Importer will try to find referenced materials from this file.
 *
 * Ogre meshes reference with material names, this does not tell Assimp the file
 * where it is located in. Assimp will try to find the source file in the following
 * order: <material-name>.material, <mesh-filename-base>.material and
 * lastly the material name defined by this config property.
 * <br>
 * Property type: String. Default value: Scene.material.
 */
#define AI_CONFIG_IMPORT_OGRE_MATERIAL_FILE \
    "IMPORT_OGRE_MATERIAL_FILE"

// ---------------------------------------------------------------------------
/** @brief Ogre Importer detect the texture usage from its filename.
 *
 * Ogre material texture units do not define texture type, the textures usage
 * depends on the used shader or Ogre's fixed pipeline. If this config property
 * is true Assimp will try to detect the type from the textures filename postfix:
 * _n, _nrm, _nrml, _normal, _normals and _normalmap for normal map, _s, _spec,
 * _specular and _specularmap for specular map, _l, _light, _lightmap, _occ
 * and _occlusion for light map, _disp and _displacement for displacement map.
 * The matching is case insensitive. Post fix is taken between the last
 * underscore and the last period.
 * Default behavior is to detect type from lower cased texture unit name by
 * matching against: normalmap, specularmap, lightmap and displacementmap.
 * For both cases if no match is found aiTextureType_DIFFUSE is used.
 * <br>
 * Property type: Bool. Default value: false.
 */
#define AI_CONFIG_IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME \
    "IMPORT_OGRE_TEXTURETYPE_FROM_FILENAME"

 /** @brief Specifies whether the Android JNI asset extraction is supported.
  *
  * Turn on this option if you want to manage assets in native
  * Android application without having to keep the internal directory and asset
  * manager pointer.
  */
 #define AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT "AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT"

// ---------------------------------------------------------------------------
/** @brief Specifies whether the IFC loader skips over IfcSpace elements.
 *
 * IfcSpace elements (and their geometric representations) are used to
 * represent, well, free space in a building storey.<br>
 * Property type: Bool. Default value: true.
 */
#define AI_CONFIG_IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS "IMPORT_IFC_SKIP_SPACE_REPRESENTATIONS"

// ---------------------------------------------------------------------------
/** @brief Specifies whether the IFC loader will use its own, custom triangulation
 *   algorithm to triangulate wall and floor meshes.
 *
 * If this property is set to false, walls will be either triangulated by
 * #aiProcess_Triangulate or will be passed through as huge polygons with
 * faked holes (i.e. holes that are connected with the outer boundary using
 * a dummy edge). It is highly recommended to set this property to true
 * if you want triangulated data because #aiProcess_Triangulate is known to
 * have problems with the kind of polygons that the IFC loader spits out for
 * complicated meshes.
 * Property type: Bool. Default value: true.
 */
#define AI_CONFIG_IMPORT_IFC_CUSTOM_TRIANGULATION "IMPORT_IFC_CUSTOM_TRIANGULATION"

// ---------------------------------------------------------------------------
/** @brief  Set the tessellation conic angle for IFC smoothing curves.
 *
 * This is used by the IFC importer to determine the tessellation parameter
 * for smoothing curves.
 * @note The default value is AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE and the
 * accepted values are in range [5.0, 120.0].
 * Property type: Float.
 */
#define AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE "IMPORT_IFC_SMOOTHING_ANGLE"

// default value for AI_CONFIG_IMPORT_IFC_SMOOTHING_ANGLE
#if (!defined AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE)
#   define AI_IMPORT_IFC_DEFAULT_SMOOTHING_ANGLE 10.0f
#endif

// ---------------------------------------------------------------------------
/** @brief  Set the tessellation for IFC cylindrical shapes.
 *
 * This is used by the IFC importer to determine the tessellation parameter
 * for cylindrical shapes, i.e. the number of segments used to approximate a circle.
 * @note The default value is AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION and the
 * accepted values are in range [3, 180].
 * Property type: Integer.
 */
#define AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION "IMPORT_IFC_CYLINDRICAL_TESSELLATION"

// default value for AI_CONFIG_IMPORT_IFC_CYLINDRICAL_TESSELLATION
#if (!defined AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION)
#   define AI_IMPORT_IFC_DEFAULT_CYLINDRICAL_TESSELLATION 32
#endif

// ---------------------------------------------------------------------------
/** @brief Specifies whether the Collada loader will ignore the provided up direction.
 *
 * If this property is set to true, the up direction provided in the file header will
 * be ignored and the file will be loaded as is.
 * Property type: Bool. Default value: false.
 */
#define AI_CONFIG_IMPORT_COLLADA_IGNORE_UP_DIRECTION "IMPORT_COLLADA_IGNORE_UP_DIRECTION"

// ---------------------------------------------------------------------------
/** @brief Specifies whether the Collada loader will ignore the provided unit size.
 *
 * If this property is set to true, the unit size provided in the file header will
 * be ignored and the file will be loaded without scaling the assets.
 * Property type: Bool. Default value: false.
 */
#define AI_CONFIG_IMPORT_COLLADA_IGNORE_UNIT_SIZE "IMPORT_COLLADA_IGNORE_UNIT_SIZE"

// ---------------------------------------------------------------------------
/** @brief Specifies whether the Collada loader should use Collada names.
 *
 * If this property is set to true, the Collada names will be used as the node and
 * mesh names. The default is to use the id tag (resp. sid tag, if no id tag is present)
 * instead.
 * Property type: Bool. Default value: false.
 */
#define AI_CONFIG_IMPORT_COLLADA_USE_COLLADA_NAMES "IMPORT_COLLADA_USE_COLLADA_NAMES"

// ---------- All the Export defines ------------

/** @brief Specifies the xfile use double for real values of float
 *
 * Property type: Bool. Default value: false.
 */

#define AI_CONFIG_EXPORT_XFILE_64BIT "EXPORT_XFILE_64BIT"

/** @brief Specifies whether the assimp export shall be able to export point clouds
 *
 *  When this flag is not defined the render data has to contain valid faces.
 *  Point clouds are only a collection of vertices which have nor spatial organization
 *  by a face and the validation process will remove them. Enabling this feature will
 *  switch off the flag and enable the functionality to export pure point clouds.
 *
 * Property type: Bool. Default value: false.
 */
#define AI_CONFIG_EXPORT_POINT_CLOUDS "EXPORT_POINT_CLOUDS"

/** @brief Specifies whether to use the deprecated KHR_materials_pbrSpecularGlossiness extension
 * 
 * When this flag is undefined any material with specularity will use the new KHR_materials_specular
 * extension. Enabling this flag will revert to the deprecated extension. Note that exporting
 * KHR_materials_pbrSpecularGlossiness with extensions other than KHR_materials_unlit is unsupported,
 * including the basic pbrMetallicRoughness spec.
 *
 * Property type: Bool. Default value: false.
 */
#define AI_CONFIG_USE_GLTF_PBR_SPECULAR_GLOSSINESS "USE_GLTF_PBR_SPECULAR_GLOSSINESS"

/**
 * @brief Specifies the blob name, assimp uses for exporting.
 * 
 * Some formats require auxiliary files to be written, that need to be linked back into 
 * the original file. For example, OBJ files export materials to a separate MTL file and
 * use the `mtllib` keyword to reference this file.
 * 
 * When exporting blobs using #ExportToBlob, assimp does not know the name of the blob
 * file and thus outputs `mtllib $blobfile.mtl`, which might not be desired, since the 
 * MTL file might be called differently. 
 * 
 * This property can be used to give the exporter a hint on how to use the magic 
 * `$blobfile` keyword. If the exporter detects the keyword and is provided with a name
 * for the blob, it instead uses this name.
 */
#define AI_CONFIG_EXPORT_BLOB_NAME "EXPORT_BLOB_NAME"

/**
 *  @brief  Specifies a global key factor for scale, float value
 */
#define AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY "GLOBAL_SCALE_FACTOR"

#if (!defined AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT)
#   define AI_CONFIG_GLOBAL_SCALE_FACTOR_DEFAULT  1.0f
#endif // !! AI_DEBONE_THRESHOLD

#define AI_CONFIG_APP_SCALE_KEY "APP_SCALE_FACTOR"

#if (!defined AI_CONFIG_APP_SCALE_KEY)
#   define AI_CONFIG_APP_SCALE_KEY 1.0
#endif // AI_CONFIG_APP_SCALE_KEY


// ---------- All the Build/Compile-time defines ------------

/** @brief Specifies if double precision is supported inside assimp
 *
 * Property type: Bool. Default value: undefined.
 */

/* #undef ASSIMP_DOUBLE_PRECISION */

#endif // !! AI_CONFIG_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/defs.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file defs.h
 *  @brief Assimp build configuration setup. See the notes in the comment
 *  blocks to find out how to customize _your_ Assimp build.
 */

#pragma once
#ifndef AI_DEFINES_H_INC
#define AI_DEFINES_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/config.h>

//////////////////////////////////////////////////////////////////////////
/* Define ASSIMP_BUILD_NO_XX_IMPORTER to disable a specific
 * file format loader. The loader is be excluded from the
 * build in this case. 'XX' stands for the most common file
 * extension of the file format. E.g.:
 * ASSIMP_BUILD_NO_X_IMPORTER disables the X loader.
 *
 * If you're unsure about that, take a look at the implementation of the
 * import plugin you wish to disable. You'll find the right define in the
 * first lines of the corresponding unit.
 *
 * Other (mixed) configuration switches are listed here:
 *    ASSIMP_BUILD_NO_COMPRESSED_X
 *      - Disable support for compressed X files (zip)
 *    ASSIMP_BUILD_NO_COMPRESSED_BLEND
 *      - Disable support for compressed Blender files (zip)
 *    ASSIMP_BUILD_NO_COMPRESSED_IFC
 *      - Disable support for IFCZIP files (unzip)
 */
//////////////////////////////////////////////////////////////////////////

#ifndef ASSIMP_BUILD_NO_COMPRESSED_X
#define ASSIMP_BUILD_NEED_Z_INFLATE
#endif

#ifndef ASSIMP_BUILD_NO_COMPRESSED_BLEND
#define ASSIMP_BUILD_NEED_Z_INFLATE
#endif

#ifndef ASSIMP_BUILD_NO_COMPRESSED_IFC
#define ASSIMP_BUILD_NEED_Z_INFLATE
#define ASSIMP_BUILD_NEED_UNZIP
#endif

#ifndef ASSIMP_BUILD_NO_Q3BSP_IMPORTER
#define ASSIMP_BUILD_NEED_Z_INFLATE
#define ASSIMP_BUILD_NEED_UNZIP
#endif

// We need those constants, workaround for any platforms where nobody defined them yet
#if (!defined SIZE_MAX)
#define SIZE_MAX (~((size_t)0))
#endif

/*#if (!defined UINT_MAX)
#define UINT_MAX (~((unsigned int)0))
#endif*/

//////////////////////////////////////////////////////////////////////////
/* Define ASSIMP_BUILD_NO_XX_PROCESS to disable a specific
 * post processing step. This is the current list of process names ('XX'):
 * CALCTANGENTS
 * JOINVERTICES
 * TRIANGULATE
 * DROPFACENORMALS
 * GENFACENORMALS
 * GENVERTEXNORMALS
 * REMOVEVC
 * SPLITLARGEMESHES
 * PRETRANSFORMVERTICES
 * LIMITBONEWEIGHTS
 * VALIDATEDS
 * IMPROVECACHELOCALITY
 * FIXINFACINGNORMALS
 * REMOVE_REDUNDANTMATERIALS
 * OPTIMIZEGRAPH
 * SORTBYPTYPE
 * FINDINVALIDDATA
 * TRANSFORMTEXCOORDS
 * GENUVCOORDS
 * ENTITYMESHBUILDER
 * EMBEDTEXTURES
 * MAKELEFTHANDED
 * FLIPUVS
 * FLIPWINDINGORDER
 * OPTIMIZEMESHES
 * OPTIMIZEANIMS
 * OPTIMIZEGRAPH
 * GENENTITYMESHES
 * FIXTEXTUREPATHS
 * GENBOUNDINGBOXES */
//////////////////////////////////////////////////////////////////////////

#ifdef _WIN32
#undef ASSIMP_API
//////////////////////////////////////////////////////////////////////////
/* Define 'ASSIMP_BUILD_DLL_EXPORT' to build a DLL of the library */
//////////////////////////////////////////////////////////////////////////
#ifdef ASSIMP_BUILD_DLL_EXPORT
#define ASSIMP_API __declspec(dllexport)
#define ASSIMP_API_WINONLY __declspec(dllexport)

//////////////////////////////////////////////////////////////////////////
/* Define 'ASSIMP_DLL' before including Assimp to link to ASSIMP in
     * an external DLL under Windows. Default is static linkage. */
//////////////////////////////////////////////////////////////////////////
#elif (defined ASSIMP_DLL)
#define ASSIMP_API __declspec(dllimport)
#define ASSIMP_API_WINONLY __declspec(dllimport)
#else
#define ASSIMP_API
#define ASSIMP_API_WINONLY
#endif
#elif defined(SWIG)
/* Do nothing, the relevant defines are all in AssimpSwigPort.i */
#else
#define ASSIMP_API __attribute__((visibility("default")))
#define ASSIMP_API_WINONLY
#endif // _WIN32

#ifdef _MSC_VER
    #pragma warning(disable : 4521 4512 4714 4127 4351 4510)
    #ifdef ASSIMP_BUILD_DLL_EXPORT
        #pragma warning(disable : 4251)
    #endif
    /* Force the compiler to inline a function, if possible */
    #define AI_FORCE_INLINE inline

    /* Tells the compiler that a function never returns. Used in code analysis
    * to skip dead paths (e.g. after an assertion evaluated to false). */
    #define AI_WONT_RETURN __declspec(noreturn)
#elif defined(SWIG)
  /* Do nothing, the relevant defines are all in AssimpSwigPort.i */
#else
    #define AI_WONT_RETURN
    #define AI_FORCE_INLINE inline
#endif // (defined _MSC_VER)

#ifdef __GNUC__
#   define AI_WONT_RETURN_SUFFIX __attribute__((noreturn))
#elif _MSC_VER
#if defined(__clang__)
#   define AI_WONT_RETURN_SUFFIX __attribute__((noreturn))
#else
#   define AI_WONT_RETURN_SUFFIX
#endif
#else
#   define AI_WONT_RETURN_SUFFIX
#endif // (defined __clang__)

#ifdef __cplusplus
/* No explicit 'struct' and 'enum' tags for C++, this keeps showing up
 * in doxydocs.
 */
#define C_STRUCT
#define C_ENUM
#else
//////////////////////////////////////////////////////////////////////////
/* To build the documentation, make sure ASSIMP_DOXYGEN_BUILD
     * is defined by Doxygen's preprocessor. The corresponding
     * entries in the DOXYFILE are: */
//////////////////////////////////////////////////////////////////////////
#if 0
    ENABLE_PREPROCESSING   = YES
    MACRO_EXPANSION        = YES
    EXPAND_ONLY_PREDEF     = YES
    SEARCH_INCLUDES        = YES
    INCLUDE_PATH           =
    INCLUDE_FILE_PATTERNS  =
    PREDEFINED             = ASSIMP_DOXYGEN_BUILD=1
    EXPAND_AS_DEFINED      = C_STRUCT C_ENUM
    SKIP_FUNCTION_MACROS   = YES
#endif
//////////////////////////////////////////////////////////////////////////
/* Doxygen gets confused if we use c-struct typedefs to avoid
     * the explicit 'struct' notation. This trick here has the same
     * effect as the TYPEDEF_HIDES_STRUCT option, but we don't need
     * to typedef all structs/enums. */
//////////////////////////////////////////////////////////////////////////
#if (defined ASSIMP_DOXYGEN_BUILD)
#define C_STRUCT
#define C_ENUM
#else
#define C_STRUCT struct
#define C_ENUM enum
#endif
#endif

#if (defined(__BORLANDC__) || defined(__BCPLUSPLUS__))
#error Currently, Borland is unsupported. Feel free to port Assimp.
#endif

//////////////////////////////////////////////////////////////////////////
/* Define ASSIMP_BUILD_SINGLETHREADED to compile assimp
     * without threading support. The library doesn't utilize
     * threads then and is itself not threadsafe. */
//////////////////////////////////////////////////////////////////////////
#ifndef ASSIMP_BUILD_SINGLETHREADED
#define ASSIMP_BUILD_SINGLETHREADED
#endif

#if defined(_DEBUG) || !defined(NDEBUG)
#define ASSIMP_BUILD_DEBUG
#endif

//////////////////////////////////////////////////////////////////////////
/* Define ASSIMP_DOUBLE_PRECISION to compile assimp
     * with double precision support (64-bit). */
//////////////////////////////////////////////////////////////////////////

#ifdef ASSIMP_DOUBLE_PRECISION
typedef double ai_real;
typedef signed long long int ai_int;
typedef unsigned long long int ai_uint;
#ifndef ASSIMP_AI_REAL_TEXT_PRECISION
#define ASSIMP_AI_REAL_TEXT_PRECISION 17
#endif // ASSIMP_AI_REAL_TEXT_PRECISION
#else // ASSIMP_DOUBLE_PRECISION
typedef float ai_real;
typedef signed int ai_int;
typedef unsigned int ai_uint;
#ifndef ASSIMP_AI_REAL_TEXT_PRECISION
#define ASSIMP_AI_REAL_TEXT_PRECISION 9
#endif // ASSIMP_AI_REAL_TEXT_PRECISION
#endif // ASSIMP_DOUBLE_PRECISION

//////////////////////////////////////////////////////////////////////////
/* Useful constants */
//////////////////////////////////////////////////////////////////////////

/* This is PI. Hi PI. */
#define AI_MATH_PI (3.141592653589793238462643383279)
#define AI_MATH_TWO_PI (AI_MATH_PI * 2.0)
#define AI_MATH_HALF_PI (AI_MATH_PI * 0.5)

/* And this is to avoid endless casts to float */
#define AI_MATH_PI_F (3.1415926538f)
#define AI_MATH_TWO_PI_F (AI_MATH_PI_F * 2.0f)
#define AI_MATH_HALF_PI_F (AI_MATH_PI_F * 0.5f)

/* Tiny macro to convert from radians to degrees and back */
#define AI_DEG_TO_RAD(x) ((x) * (ai_real) 0.0174532925)
#define AI_RAD_TO_DEG(x) ((x) * (ai_real) 57.2957795)

/* Numerical limits */
#ifdef __cplusplus
constexpr ai_real ai_epsilon = (ai_real) 1e-6;
#else
#define ai_epsilon ((ai_real)1e-6)
#endif

/* Support for big-endian builds */
#if defined(__BYTE_ORDER__)
#if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
#if !defined(__BIG_ENDIAN__)
#define __BIG_ENDIAN__
#endif
#else /* little endian */
#if defined(__BIG_ENDIAN__)
#undef __BIG_ENDIAN__
#endif
#endif
#endif
#if defined(__BIG_ENDIAN__)
#define AI_BUILD_BIG_ENDIAN
#endif

/**
 *  To avoid running out of memory
 *  This can be adjusted for specific use cases
 *  It's NOT a total limit, just a limit for individual allocations
 */
#define AI_MAX_ALLOC(type) ((256U * 1024 * 1024) / sizeof(type))

#ifndef _MSC_VER
#if __cplusplus >= 201103L // C++11
#define AI_NO_EXCEPT noexcept
#else
#define AI_NO_EXCEPT
#endif
#else
#if (_MSC_VER >= 1915)
#define AI_NO_EXCEPT noexcept
#else
#define AI_NO_EXCEPT
#endif
#endif // _MSC_VER

/**
 *  Helper macro to set a pointer to NULL in debug builds
 */
#if (defined ASSIMP_BUILD_DEBUG)
#define AI_DEBUG_INVALIDATE_PTR(x) x = NULL;
#else
#define AI_DEBUG_INVALIDATE_PTR(x)
#endif

#define AI_COUNT_OF(X) (sizeof(X) / sizeof((X)[0]))

#endif // !! AI_DEFINES_H_INC

============================================================
File Path: project/externals/assimp/include/assimp/fast_atof.h
============================================================
#pragma once

// Copyright (C) 2002-2007 Nikolaus Gebhardt
// This file is part of the "Irrlicht Engine" and the "irrXML" project.
// For conditions of distribution and use, see copyright notice in irrlicht.h and irrXML.h

// ------------------------------------------------------------------------------------
// Original description: (Schrompf)
// Adapted to the ASSIMP library because the builtin atof indeed takes AGES to parse a
// float inside a large string. Before parsing, it does a strlen on the given point.
// Changes:
//  22nd October 08 (Aramis_acg): Added temporary cast to double, added strtoul10_64
//     to ensure long numbers are handled correctly
// ------------------------------------------------------------------------------------

#pragma once
#ifndef FAST_A_TO_F_H_INCLUDED
#define FAST_A_TO_F_H_INCLUDED

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <cmath>
#include <limits>
#include <stdint.h>
#include <assimp/defs.h>

#include "StringComparison.h"
#include <assimp/DefaultLogger.hpp>
#include <assimp/Exceptional.h>
#include <assimp/StringUtils.h>

#ifdef _MSC_VER
#  include <stdint.h>
#else
#  include <assimp/Compiler/pstdint.h>
#endif

namespace Assimp {

static constexpr size_t NumItems = 16;

constexpr double fast_atof_table[NumItems] =  {  // we write [16] here instead of [] to work around a swig bug
    0.0,
    0.1,
    0.01,
    0.001,
    0.0001,
    0.00001,
    0.000001,
    0.0000001,
    0.00000001,
    0.000000001,
    0.0000000001,
    0.00000000001,
    0.000000000001,
    0.0000000000001,
    0.00000000000001,
    0.000000000000001
};

// ------------------------------------------------------------------------------------
// Convert a string in decimal format to a number
// ------------------------------------------------------------------------------------
inline unsigned int strtoul10( const char* in, const char** out=0) {
    unsigned int value = 0;

    for ( ;; ) {
        if ( *in < '0' || *in > '9' ) {
            break;
        }

        value = ( value * 10 ) + ( *in - '0' );
        ++in;
    }
    if ( out ) {
        *out = in;
    }
    return value;
}

// ------------------------------------------------------------------------------------
// Convert a string in octal format to a number
// ------------------------------------------------------------------------------------
inline unsigned int strtoul8( const char* in, const char** out=0) {
    unsigned int value( 0 );
    for ( ;; ) {
        if ( *in < '0' || *in > '7' ) {
            break;
        }

        value = ( value << 3 ) + ( *in - '0' );
        ++in;
    }
    if ( out ) {
        *out = in;
    }
    return value;
}

// ------------------------------------------------------------------------------------
// Convert a string in hex format to a number
// ------------------------------------------------------------------------------------
inline unsigned int strtoul16( const char* in, const char** out=0) {
    unsigned int value( 0 );
    for ( ;; ) {
        if ( *in >= '0' && *in <= '9' ) {
            value = ( value << 4u ) + ( *in - '0' );
        } else if (*in >= 'A' && *in <= 'F') {
            value = ( value << 4u ) + ( *in - 'A' ) + 10;
        } else if (*in >= 'a' && *in <= 'f') {
            value = ( value << 4u ) + ( *in - 'a' ) + 10;
        } else {
            break;
        }
        ++in;
    }
    if ( out ) {
        *out = in;
    }
    return value;
}

// ------------------------------------------------------------------------------------
// Convert just one hex digit
// Return value is UINT_MAX if the input character is not a hex digit.
// ------------------------------------------------------------------------------------
inline unsigned int HexDigitToDecimal(char in) {
    unsigned int out( UINT_MAX );
    if ( in >= '0' && in <= '9' ) {
        out = in - '0';
    } else if ( in >= 'a' && in <= 'f' ) {
        out = 10u + in - 'a';
    } else if ( in >= 'A' && in <= 'F' ) {
        out = 10u + in - 'A';
    }

    // return value is UINT_MAX if the input is not a hex digit
    return out;
}

// ------------------------------------------------------------------------------------
// Convert a hex-encoded octet (2 characters, i.e. df or 1a).
// ------------------------------------------------------------------------------------
inline uint8_t HexOctetToDecimal(const char* in) {
    return ((uint8_t)HexDigitToDecimal(in[0])<<4)+(uint8_t)HexDigitToDecimal(in[1]);
}

// ------------------------------------------------------------------------------------
// signed variant of strtoul10
// ------------------------------------------------------------------------------------
inline int strtol10( const char* in, const char** out=0) {
    bool inv = (*in=='-');
    if ( inv || *in == '+' ) {
        ++in;
    }

    int value = strtoul10(in,out);
    if (inv) {
        if (value < INT_MAX) {
            value = -value;
        } else {
            ASSIMP_LOG_WARN( "Converting the string \"", in, "\" into an inverted value resulted in overflow." );
        }
    }
    return value;
}

// ------------------------------------------------------------------------------------
// Parse a C++-like integer literal - hex and oct prefixes.
// 0xNNNN - hex
// 0NNN   - oct
// NNN    - dec
// ------------------------------------------------------------------------------------
inline unsigned int strtoul_cppstyle( const char* in, const char** out=0) {
    if ('0' == in[0]) {
        return 'x' == in[1] ? strtoul16(in+2,out) : strtoul8(in+1,out);
    }
    return strtoul10(in, out);
}

// ------------------------------------------------------------------------------------
// Special version of the function, providing higher accuracy and safety
// It is mainly used by fast_atof to prevent ugly and unwanted integer overflows.
// ------------------------------------------------------------------------------------
template<typename ExceptionType = DeadlyImportError>
inline uint64_t strtoul10_64( const char* in, const char** out=0, unsigned int* max_inout=0) {
    unsigned int cur = 0;
    uint64_t value = 0;

    if ( *in < '0' || *in > '9' ) {
        // The string is known to be bad, so don't risk printing the whole thing.
        throw ExceptionType("The string \"", ai_str_toprintable(in, (int)strlen(in)), "\" cannot be converted into a value." );
    }

    for ( ;; ) {
        if ( *in < '0' || *in > '9' ) {
            break;
        }

        const uint64_t new_value = ( value * (uint64_t) 10 ) + ( (uint64_t) ( *in - '0' ) );

        // numeric overflow, we rely on you
        if ( new_value < value ) {
            ASSIMP_LOG_WARN( "Converting the string \"", in, "\" into a value resulted in overflow." );
            return 0;
        }

        value = new_value;

        ++in;
        ++cur;

        if (max_inout && *max_inout == cur) {
            if (out) { /* skip to end */
                while ( *in >= '0' && *in <= '9' ) {
                    ++in;
                }
                *out = in;
            }

            return value;
        }
    }
    if ( out ) {
        *out = in;
    }

    if ( max_inout ) {
        *max_inout = cur;
    }

    return value;
}

// ------------------------------------------------------------------------------------
// signed variant of strtoul10_64
// ------------------------------------------------------------------------------------
template<typename ExceptionType = DeadlyImportError>
inline int64_t strtol10_64(const char* in, const char** out = 0, unsigned int* max_inout = 0) {
    bool inv = (*in == '-');
    if ( inv || *in == '+' ) {
        ++in;
    }

    int64_t value = strtoul10_64<ExceptionType>(in, out, max_inout);
    if (inv) {
        value = -value;
    }
    return value;
}

// Number of relevant decimals for floating-point parsing.
#define AI_FAST_ATOF_RELAVANT_DECIMALS 15

// ------------------------------------------------------------------------------------
//! Provides a fast function for converting a string into a float,
//! about 6 times faster than atof in win32.
// If you find any bugs, please send them to me, niko (at) irrlicht3d.org.
// ------------------------------------------------------------------------------------
template<typename Real, typename ExceptionType = DeadlyImportError>
inline const char* fast_atoreal_move(const char* c, Real& out, bool check_comma = true) {
    Real f = 0;

    bool inv = (*c == '-');
    if (inv || *c == '+') {
        ++c;
    }

    if ((c[0] == 'N' || c[0] == 'n') && ASSIMP_strincmp(c, "nan", 3) == 0) {
        out = std::numeric_limits<Real>::quiet_NaN();
        c += 3;
        return c;
    }

    if ((c[0] == 'I' || c[0] == 'i') && ASSIMP_strincmp(c, "inf", 3) == 0) {
        out = std::numeric_limits<Real>::infinity();
        if (inv) {
            out = -out;
        }
        c += 3;
        if ((c[0] == 'I' || c[0] == 'i') && ASSIMP_strincmp(c, "inity", 5) == 0) {
            c += 5;
        }
        return c;
     }

    if (!(c[0] >= '0' && c[0] <= '9') &&
            !((c[0] == '.' || (check_comma && c[0] == ',')) && c[1] >= '0' && c[1] <= '9')) {
        // The string is known to be bad, so don't risk printing the whole thing.
        throw ExceptionType("Cannot parse string \"", ai_str_toprintable(c, (int)strlen(c)),
                                    "\" as a real number: does not start with digit "
                                    "or decimal point followed by digit.");
    }

    if (*c != '.' && (! check_comma || c[0] != ',')) {
        f = static_cast<Real>( strtoul10_64<ExceptionType> ( c, &c) );
    }

    if ((*c == '.' || (check_comma && c[0] == ',')) && c[1] >= '0' && c[1] <= '9') {
        ++c;

        // NOTE: The original implementation is highly inaccurate here. The precision of a single
        // IEEE 754 float is not high enough, everything behind the 6th digit tends to be more
        // inaccurate than it would need to be. Casting to double seems to solve the problem.
        // strtol_64 is used to prevent integer overflow.

        // Another fix: this tends to become 0 for long numbers if we don't limit the maximum
        // number of digits to be read. AI_FAST_ATOF_RELAVANT_DECIMALS can be a value between
        // 1 and 15.
        unsigned int diff = AI_FAST_ATOF_RELAVANT_DECIMALS;
        double pl = static_cast<double>( strtoul10_64<ExceptionType> ( c, &c, &diff ));

        pl *= fast_atof_table[diff];
        f += static_cast<Real>( pl );
    }
    // For backwards compatibility: eat trailing dots, but not trailing commas.
    else if (*c == '.') {
        ++c;
    }

    // A major 'E' must be allowed. Necessary for proper reading of some DXF files.
    // Thanks to Zhao Lei to point out that this if() must be outside the if (*c == '.' ..)
    if (*c == 'e' || *c == 'E') {
        ++c;
        const bool einv = (*c=='-');
        if (einv || *c=='+') {
            ++c;
        }

        // The reason float constants are used here is that we've seen cases where compilers
        // would perform such casts on compile-time constants at runtime, which would be
        // bad considering how frequently fast_atoreal_move<float> is called in Assimp.
        Real exp = static_cast<Real>( strtoul10_64<ExceptionType>(c, &c) );
        if (einv) {
            exp = -exp;
        }
        f *= std::pow(static_cast<Real>(10.0), exp);
    }

    if (inv) {
        f = -f;
    }
    out = f;
    return c;
}

// ------------------------------------------------------------------------------------
// The same but more human.
template<typename ExceptionType = DeadlyImportError>
inline ai_real fast_atof(const char* c) {
    ai_real ret(0.0);
    fast_atoreal_move<ai_real, ExceptionType>(c, ret);

    return ret;
}

template<typename ExceptionType = DeadlyImportError>
inline
ai_real fast_atof( const char* c, const char** cout) {
    ai_real ret(0.0);
    *cout = fast_atoreal_move<ai_real, ExceptionType>(c, ret);

    return ret;
}

template<typename ExceptionType = DeadlyImportError>
inline ai_real fast_atof( const char** inout) {
    ai_real ret(0.0);
    *inout = fast_atoreal_move<ai_real, ExceptionType>(*inout, ret);

    return ret;
}

} //! namespace Assimp

#endif // FAST_A_TO_F_H_INCLUDED


============================================================
File Path: project/externals/assimp/include/assimp/importerdesc.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file importerdesc.h
 *  @brief #aiImporterFlags, aiImporterDesc implementation.
 */
#pragma once
#ifndef AI_IMPORTER_DESC_H_INC
#define AI_IMPORTER_DESC_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/types.h>

#ifdef __cplusplus
extern "C" {
#endif

/** Mixed set of flags for #aiImporterDesc, indicating some features
  *  common to many importers*/
enum aiImporterFlags {
    /** Indicates that there is a textual encoding of the
     *  file format; and that it is supported.*/
    aiImporterFlags_SupportTextFlavour = 0x1,

    /** Indicates that there is a binary encoding of the
     *  file format; and that it is supported.*/
    aiImporterFlags_SupportBinaryFlavour = 0x2,

    /** Indicates that there is a compressed encoding of the
     *  file format; and that it is supported.*/
    aiImporterFlags_SupportCompressedFlavour = 0x4,

    /** Indicates that the importer reads only a very particular
      * subset of the file format. This happens commonly for
      * declarative or procedural formats which cannot easily
      * be mapped to #aiScene */
    aiImporterFlags_LimitedSupport = 0x8,

    /** Indicates that the importer is highly experimental and
      * should be used with care. This only happens for trunk
      * (i.e. SVN) versions, experimental code is not included
      * in releases. */
    aiImporterFlags_Experimental = 0x10
};

/** Meta information about a particular importer. Importers need to fill
 *  this structure, but they can freely decide how talkative they are.
 *  A common use case for loader meta info is a user interface
 *  in which the user can choose between various import/export file
 *  formats. Building such an UI by hand means a lot of maintenance
 *  as importers/exporters are added to Assimp, so it might be useful
 *  to have a common mechanism to query some rough importer
 *  characteristics. */
struct aiImporterDesc {
    /** Full name of the importer (i.e. Blender3D importer)*/
    const char *mName;

    /** Original author (left blank if unknown or whole assimp team) */
    const char *mAuthor;

    /** Current maintainer, left blank if the author maintains */
    const char *mMaintainer;

    /** Implementation comments, i.e. unimplemented features*/
    const char *mComments;

    /** These flags indicate some characteristics common to many
        importers. */
    unsigned int mFlags;

    /** Minimum format version that can be loaded im major.minor format,
        both are set to 0 if there is either no version scheme
        or if the loader doesn't care. */
    unsigned int mMinMajor;
    unsigned int mMinMinor;

    /** Maximum format version that can be loaded im major.minor format,
        both are set to 0 if there is either no version scheme
        or if the loader doesn't care. Loaders that expect to be
        forward-compatible to potential future format versions should
        indicate  zero, otherwise they should specify the current
        maximum version.*/
    unsigned int mMaxMajor;
    unsigned int mMaxMinor;

    /** List of file extensions this importer can handle.
        List entries are separated by space characters.
        All entries are lower case without a leading dot (i.e.
        "xml dae" would be a valid value. Note that multiple
        importers may respond to the same file extension -
        assimp calls all importers in the order in which they
        are registered and each importer gets the opportunity
        to load the file until one importer "claims" the file. Apart
        from file extension checks, importers typically use
        other methods to quickly reject files (i.e. magic
        words) so this does not mean that common or generic
        file extensions such as XML would be tediously slow. */
    const char *mFileExtensions;
};

/** \brief  Returns the Importer description for a given extension.

Will return a nullptr if no assigned importer desc. was found for the given extension
    \param  extension   [in] The extension to look for
    \return A pointer showing to the ImporterDesc, \see aiImporterDesc.
*/
ASSIMP_API const C_STRUCT aiImporterDesc *aiGetImporterDesc(const char *extension);

#ifdef __cplusplus
} // end of extern "C"
#endif

#endif // AI_IMPORTER_DESC_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/light.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file light.h
 *  @brief Defines the aiLight data structure
 */

#pragma once
#ifndef AI_LIGHT_H_INC
#define AI_LIGHT_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/types.h>

#ifdef __cplusplus
extern "C" {
#endif

// ---------------------------------------------------------------------------
/** Enumerates all supported types of light sources.
 */
enum aiLightSourceType {
    aiLightSource_UNDEFINED     = 0x0,

    //! A directional light source has a well-defined direction
    //! but is infinitely far away. That's quite a good
    //! approximation for sun light.
    aiLightSource_DIRECTIONAL   = 0x1,

    //! A point light source has a well-defined position
    //! in space but no direction - it emits light in all
    //! directions. A normal bulb is a point light.
    aiLightSource_POINT         = 0x2,

    //! A spot light source emits light in a specific
    //! angle. It has a position and a direction it is pointing to.
    //! A good example for a spot light is a light spot in
    //! sport arenas.
    aiLightSource_SPOT          = 0x3,

    //! The generic light level of the world, including the bounces
    //! of all other light sources.
    //! Typically, there's at most one ambient light in a scene.
    //! This light type doesn't have a valid position, direction, or
    //! other properties, just a color.
    aiLightSource_AMBIENT       = 0x4,

    //! An area light is a rectangle with predefined size that uniformly
    //! emits light from one of its sides. The position is center of the
    //! rectangle and direction is its normal vector.
    aiLightSource_AREA          = 0x5,

    /** This value is not used. It is just there to force the
     *  compiler to map this enum to a 32 Bit integer.
     */
#ifndef SWIG
    _aiLightSource_Force32Bit = INT_MAX
#endif
};

// ---------------------------------------------------------------------------
/** Helper structure to describe a light source.
 *
 *  Assimp supports multiple sorts of light sources, including
 *  directional, point and spot lights. All of them are defined with just
 *  a single structure and distinguished by their parameters.
 *  Note - some file formats (such as 3DS, ASE) export a "target point" -
 *  the point a spot light is looking at (it can even be animated). Assimp
 *  writes the target point as a sub-node of a spot-lights's main node,
 *  called "<spotName>.Target". However, this is just additional information
 *  then, the transformation tracks of the main node make the
 *  spot light already point in the right direction.
*/
struct aiLight {
    /** The name of the light source.
     *
     *  There must be a node in the scene-graph with the same name.
     *  This node specifies the position of the light in the scene
     *  hierarchy and can be animated.
     */
    C_STRUCT aiString mName;

    /** The type of the light source.
     *
     * aiLightSource_UNDEFINED is not a valid value for this member.
     */
    C_ENUM aiLightSourceType mType;

    /** Position of the light source in space. Relative to the
     *  transformation of the node corresponding to the light.
     *
     *  The position is undefined for directional lights.
     */
    C_STRUCT aiVector3D mPosition;

    /** Direction of the light source in space. Relative to the
     *  transformation of the node corresponding to the light.
     *
     *  The direction is undefined for point lights. The vector
     *  may be normalized, but it needn't.
     */
    C_STRUCT aiVector3D mDirection;

    /** Up direction of the light source in space. Relative to the
     *  transformation of the node corresponding to the light.
     *
     *  The direction is undefined for point lights. The vector
     *  may be normalized, but it needn't.
     */
    C_STRUCT aiVector3D mUp;

    /** Constant light attenuation factor.
     *
     *  The intensity of the light source at a given distance 'd' from
     *  the light's position is
     *  @code
     *  Atten = 1/( att0 + att1 * d + att2 * d*d)
     *  @endcode
     *  This member corresponds to the att0 variable in the equation.
     *  Naturally undefined for directional lights.
     */
    float mAttenuationConstant;

    /** Linear light attenuation factor.
     *
     *  The intensity of the light source at a given distance 'd' from
     *  the light's position is
     *  @code
     *  Atten = 1/( att0 + att1 * d + att2 * d*d)
     *  @endcode
     *  This member corresponds to the att1 variable in the equation.
     *  Naturally undefined for directional lights.
     */
    float mAttenuationLinear;

    /** Quadratic light attenuation factor.
     *
     *  The intensity of the light source at a given distance 'd' from
     *  the light's position is
     *  @code
     *  Atten = 1/( att0 + att1 * d + att2 * d*d)
     *  @endcode
     *  This member corresponds to the att2 variable in the equation.
     *  Naturally undefined for directional lights.
     */
    float mAttenuationQuadratic;

    /** Diffuse color of the light source
     *
     *  The diffuse light color is multiplied with the diffuse
     *  material color to obtain the final color that contributes
     *  to the diffuse shading term.
     */
    C_STRUCT aiColor3D mColorDiffuse;

    /** Specular color of the light source
     *
     *  The specular light color is multiplied with the specular
     *  material color to obtain the final color that contributes
     *  to the specular shading term.
     */
    C_STRUCT aiColor3D mColorSpecular;

    /** Ambient color of the light source
     *
     *  The ambient light color is multiplied with the ambient
     *  material color to obtain the final color that contributes
     *  to the ambient shading term. Most renderers will ignore
     *  this value it, is just a remaining of the fixed-function pipeline
     *  that is still supported by quite many file formats.
     */
    C_STRUCT aiColor3D mColorAmbient;

    /** Inner angle of a spot light's light cone.
     *
     *  The spot light has maximum influence on objects inside this
     *  angle. The angle is given in radians. It is 2PI for point
     *  lights and undefined for directional lights.
     */
    float mAngleInnerCone;

    /** Outer angle of a spot light's light cone.
     *
     *  The spot light does not affect objects outside this angle.
     *  The angle is given in radians. It is 2PI for point lights and
     *  undefined for directional lights. The outer angle must be
     *  greater than or equal to the inner angle.
     *  It is assumed that the application uses a smooth
     *  interpolation between the inner and the outer cone of the
     *  spot light.
     */
    float mAngleOuterCone;

    /** Size of area light source. */
    C_STRUCT aiVector2D mSize;

#ifdef __cplusplus

    aiLight() AI_NO_EXCEPT
        :   mType                 (aiLightSource_UNDEFINED)
        ,   mAttenuationConstant  (0.f)
        ,   mAttenuationLinear    (1.f)
        ,   mAttenuationQuadratic (0.f)
        ,   mAngleInnerCone       ((float)AI_MATH_TWO_PI)
        ,   mAngleOuterCone       ((float)AI_MATH_TWO_PI)
        ,   mSize                 (0.f, 0.f)
    {
    }

#endif
};

#ifdef __cplusplus
}
#endif

#endif // !! AI_LIGHT_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/material.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file material.h
 *  @brief Defines the material system of the library
 */
#pragma once
#ifndef AI_MATERIAL_H_INC
#define AI_MATERIAL_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#include <assimp/types.h>

#ifdef __cplusplus
extern "C" {
#endif

// Name for default materials (2nd is used if meshes have UV coords)
#define AI_DEFAULT_MATERIAL_NAME "DefaultMaterial"

// ---------------------------------------------------------------------------
/** @brief Defines how the Nth texture of a specific type is combined with
 *  the result of all previous layers.
 *
 *  Example (left: key, right: value): <br>
 *  @code
 *  DiffColor0     - gray
 *  DiffTextureOp0 - aiTextureOpMultiply
 *  DiffTexture0   - tex1.png
 *  DiffTextureOp0 - aiTextureOpAdd
 *  DiffTexture1   - tex2.png
 *  @endcode
 *  Written as equation, the final diffuse term for a specific pixel would be:
 *  @code
 *  diffFinal = DiffColor0 * sampleTex(DiffTexture0,UV0) +
 *     sampleTex(DiffTexture1,UV0) * diffContrib;
 *  @endcode
 *  where 'diffContrib' is the intensity of the incoming light for that pixel.
 */
enum aiTextureOp {
    /** T = T1 * T2 */
    aiTextureOp_Multiply = 0x0,

    /** T = T1 + T2 */
    aiTextureOp_Add = 0x1,

    /** T = T1 - T2 */
    aiTextureOp_Subtract = 0x2,

    /** T = T1 / T2 */
    aiTextureOp_Divide = 0x3,

    /** T = (T1 + T2) - (T1 * T2) */
    aiTextureOp_SmoothAdd = 0x4,

    /** T = T1 + (T2-0.5) */
    aiTextureOp_SignedAdd = 0x5,

#ifndef SWIG
    _aiTextureOp_Force32Bit = INT_MAX
#endif
};

// ---------------------------------------------------------------------------
/** @brief Defines how UV coordinates outside the [0...1] range are handled.
 *
 *  Commonly referred to as 'wrapping mode'.
 */
enum aiTextureMapMode {
    /** A texture coordinate u|v is translated to u%1|v%1
     */
    aiTextureMapMode_Wrap = 0x0,

    /** Texture coordinates outside [0...1]
     *  are clamped to the nearest valid value.
     */
    aiTextureMapMode_Clamp = 0x1,

    /** If the texture coordinates for a pixel are outside [0...1]
     *  the texture is not applied to that pixel
     */
    aiTextureMapMode_Decal = 0x3,

    /** A texture coordinate u|v becomes u%1|v%1 if (u-(u%1))%2 is zero and
     *  1-(u%1)|1-(v%1) otherwise
     */
    aiTextureMapMode_Mirror = 0x2,

#ifndef SWIG
    _aiTextureMapMode_Force32Bit = INT_MAX
#endif
};

// ---------------------------------------------------------------------------
/** @brief Defines how the mapping coords for a texture are generated.
 *
 *  Real-time applications typically require full UV coordinates, so the use of
 *  the aiProcess_GenUVCoords step is highly recommended. It generates proper
 *  UV channels for non-UV mapped objects, as long as an accurate description
 *  how the mapping should look like (e.g spherical) is given.
 *  See the #AI_MATKEY_MAPPING property for more details.
 */
enum aiTextureMapping {
    /** The mapping coordinates are taken from an UV channel.
     *
     *  #AI_MATKEY_UVWSRC property specifies from which UV channel
     *  the texture coordinates are to be taken from (remember,
     *  meshes can have more than one UV channel).
    */
    aiTextureMapping_UV = 0x0,

    /** Spherical mapping */
    aiTextureMapping_SPHERE = 0x1,

    /** Cylindrical mapping */
    aiTextureMapping_CYLINDER = 0x2,

    /** Cubic mapping */
    aiTextureMapping_BOX = 0x3,

    /** Planar mapping */
    aiTextureMapping_PLANE = 0x4,

    /** Undefined mapping. Have fun. */
    aiTextureMapping_OTHER = 0x5,

#ifndef SWIG
    _aiTextureMapping_Force32Bit = INT_MAX
#endif
};

// ---------------------------------------------------------------------------
/** @brief Defines the purpose of a texture
 *
 *  This is a very difficult topic. Different 3D packages support different
 *  kinds of textures. For very common texture types, such as bumpmaps, the
 *  rendering results depend on implementation details in the rendering
 *  pipelines of these applications. Assimp loads all texture references from
 *  the model file and tries to determine which of the predefined texture
 *  types below is the best choice to match the original use of the texture
 *  as closely as possible.<br>
 *
 *  In content pipelines you'll usually define how textures have to be handled,
 *  and the artists working on models have to conform to this specification,
 *  regardless which 3D tool they're using.
 */
enum aiTextureType {
    /** Dummy value.
     *
     *  No texture, but the value to be used as 'texture semantic'
     *  (#aiMaterialProperty::mSemantic) for all material properties
     *  *not* related to textures.
     */
    aiTextureType_NONE = 0,

    /** LEGACY API MATERIALS
     * Legacy refers to materials which
     * Were originally implemented in the specifications around 2000.
     * These must never be removed, as most engines support them.
     */

    /** The texture is combined with the result of the diffuse
     *  lighting equation.
     *  OR
     *  PBR Specular/Glossiness
     */
    aiTextureType_DIFFUSE = 1,

    /** The texture is combined with the result of the specular
     *  lighting equation.
     *  OR
     *  PBR Specular/Glossiness
     */
    aiTextureType_SPECULAR = 2,

    /** The texture is combined with the result of the ambient
     *  lighting equation.
     */
    aiTextureType_AMBIENT = 3,

    /** The texture is added to the result of the lighting
     *  calculation. It isn't influenced by incoming light.
     */
    aiTextureType_EMISSIVE = 4,

    /** The texture is a height map.
     *
     *  By convention, higher gray-scale values stand for
     *  higher elevations from the base height.
     */
    aiTextureType_HEIGHT = 5,

    /** The texture is a (tangent space) normal-map.
     *
     *  Again, there are several conventions for tangent-space
     *  normal maps. Assimp does (intentionally) not
     *  distinguish here.
     */
    aiTextureType_NORMALS = 6,

    /** The texture defines the glossiness of the material.
     *
     *  The glossiness is in fact the exponent of the specular
     *  (phong) lighting equation. Usually there is a conversion
     *  function defined to map the linear color values in the
     *  texture to a suitable exponent. Have fun.
    */
    aiTextureType_SHININESS = 7,

    /** The texture defines per-pixel opacity.
     *
     *  Usually 'white' means opaque and 'black' means
     *  'transparency'. Or quite the opposite. Have fun.
    */
    aiTextureType_OPACITY = 8,

    /** Displacement texture
     *
     *  The exact purpose and format is application-dependent.
     *  Higher color values stand for higher vertex displacements.
    */
    aiTextureType_DISPLACEMENT = 9,

    /** Lightmap texture (aka Ambient Occlusion)
     *
     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are
     *  covered by this material property. The texture contains a
     *  scaling value for the final color value of a pixel. Its
     *  intensity is not affected by incoming light.
    */
    aiTextureType_LIGHTMAP = 10,

    /** Reflection texture
     *
     * Contains the color of a perfect mirror reflection.
     * Rarely used, almost never for real-time applications.
    */
    aiTextureType_REFLECTION = 11,

    /** PBR Materials
     * PBR definitions from maya and other modelling packages now use this standard.
     * This was originally introduced around 2012.
     * Support for this is in game engines like Godot, Unreal or Unity3D.
     * Modelling packages which use this are very common now.
     */

    aiTextureType_BASE_COLOR = 12,
    aiTextureType_NORMAL_CAMERA = 13,
    aiTextureType_EMISSION_COLOR = 14,
    aiTextureType_METALNESS = 15,
    aiTextureType_DIFFUSE_ROUGHNESS = 16,
    aiTextureType_AMBIENT_OCCLUSION = 17,

    /** PBR Material Modifiers
    * Some modern renderers have further PBR modifiers that may be overlaid
    * on top of the 'base' PBR materials for additional realism.
    * These use multiple texture maps, so only the base type is directly defined
    */

    /** Sheen
    * Generally used to simulate textiles that are covered in a layer of microfibers
    * eg velvet
    * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen
    */
    aiTextureType_SHEEN = 19,

    /** Clearcoat
    * Simulates a layer of 'polish' or 'lacquer' layered on top of a PBR substrate
    * https://autodesk.github.io/standard-surface/#closures/coating
    * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
    */
    aiTextureType_CLEARCOAT = 20,

    /** Transmission
    * Simulates transmission through the surface
    * May include further information such as wall thickness
    */
    aiTextureType_TRANSMISSION = 21,

    /** Unknown texture
     *
     *  A texture reference that does not match any of the definitions
     *  above is considered to be 'unknown'. It is still imported,
     *  but is excluded from any further post-processing.
    */
    aiTextureType_UNKNOWN = 18,

#ifndef SWIG
    _aiTextureType_Force32Bit = INT_MAX
#endif
};

#define AI_TEXTURE_TYPE_MAX aiTextureType_TRANSMISSION

// -------------------------------------------------------------------------------
// Get a string for a given aiTextureType
ASSIMP_API const char *aiTextureTypeToString(enum aiTextureType in);

// ---------------------------------------------------------------------------
/** @brief Defines all shading models supported by the library
 *
 *  Property: #AI_MATKEY_SHADING_MODEL
 *
 *  The list of shading modes has been taken from Blender.
 *  See Blender documentation for more information. The API does
 *  not distinguish between "specular" and "diffuse" shaders (thus the
 *  specular term for diffuse shading models like Oren-Nayar remains
 *  undefined). <br>
 *  Again, this value is just a hint. Assimp tries to select the shader whose
 *  most common implementation matches the original rendering results of the
 *  3D modeler which wrote a particular model as closely as possible.
 *
 */
enum aiShadingMode {
    /** Flat shading. Shading is done on per-face base,
     *  diffuse only. Also known as 'faceted shading'.
     */
    aiShadingMode_Flat = 0x1,

    /** Simple Gouraud shading.
     */
    aiShadingMode_Gouraud = 0x2,

    /** Phong-Shading -
     */
    aiShadingMode_Phong = 0x3,

    /** Phong-Blinn-Shading
     */
    aiShadingMode_Blinn = 0x4,

    /** Toon-Shading per pixel
     *
     *  Also known as 'comic' shader.
     */
    aiShadingMode_Toon = 0x5,

    /** OrenNayar-Shading per pixel
     *
     *  Extension to standard Lambertian shading, taking the
     *  roughness of the material into account
     */
    aiShadingMode_OrenNayar = 0x6,

    /** Minnaert-Shading per pixel
     *
     *  Extension to standard Lambertian shading, taking the
     *  "darkness" of the material into account
     */
    aiShadingMode_Minnaert = 0x7,

    /** CookTorrance-Shading per pixel
     *
     *  Special shader for metallic surfaces.
     */
    aiShadingMode_CookTorrance = 0x8,

    /** No shading at all. Constant light influence of 1.0.
    * Also known as "Unlit"
    */
    aiShadingMode_NoShading = 0x9,
    aiShadingMode_Unlit = aiShadingMode_NoShading, // Alias

    /** Fresnel shading
     */
    aiShadingMode_Fresnel = 0xa,

    /** Physically-Based Rendering (PBR) shading using
    * Bidirectional scattering/reflectance distribution function (BSDF/BRDF)
    * There are multiple methods under this banner, and model files may provide
    * data for more than one PBR-BRDF method.
    * Applications should use the set of provided properties to determine which
    * of their preferred PBR rendering methods are likely to be available
    * eg:
    * - If AI_MATKEY_METALLIC_FACTOR is set, then a Metallic/Roughness is available
    * - If AI_MATKEY_GLOSSINESS_FACTOR is set, then a Specular/Glossiness is available
    * Note that some PBR methods allow layering of techniques
    */
    aiShadingMode_PBR_BRDF = 0xb,

#ifndef SWIG
    _aiShadingMode_Force32Bit = INT_MAX
#endif
};

// ---------------------------------------------------------------------------
/** @brief Defines some mixed flags for a particular texture.
 *
 *  Usually you'll instruct your cg artists how textures have to look like ...
 *  and how they will be processed in your application. However, if you use
 *  Assimp for completely generic loading purposes you might also need to
 *  process these flags in order to display as many 'unknown' 3D models as
 *  possible correctly.
 *
 *  This corresponds to the #AI_MATKEY_TEXFLAGS property.
*/
enum aiTextureFlags {
    /** The texture's color values have to be inverted (component-wise 1-n)
     */
    aiTextureFlags_Invert = 0x1,

    /** Explicit request to the application to process the alpha channel
     *  of the texture.
     *
     *  Mutually exclusive with #aiTextureFlags_IgnoreAlpha. These
     *  flags are set if the library can say for sure that the alpha
     *  channel is used/is not used. If the model format does not
     *  define this, it is left to the application to decide whether
     *  the texture alpha channel - if any - is evaluated or not.
     */
    aiTextureFlags_UseAlpha = 0x2,

    /** Explicit request to the application to ignore the alpha channel
     *  of the texture.
     *
     *  Mutually exclusive with #aiTextureFlags_UseAlpha.
     */
    aiTextureFlags_IgnoreAlpha = 0x4,

#ifndef SWIG
    _aiTextureFlags_Force32Bit = INT_MAX
#endif
};

// ---------------------------------------------------------------------------
/** @brief Defines alpha-blend flags.
 *
 *  If you're familiar with OpenGL or D3D, these flags aren't new to you.
 *  They define *how* the final color value of a pixel is computed, basing
 *  on the previous color at that pixel and the new color value from the
 *  material.
 *  The blend formula is:
 *  @code
 *    SourceColor * SourceBlend + DestColor * DestBlend
 *  @endcode
 *  where DestColor is the previous color in the frame-buffer at this
 *  position and SourceColor is the material color before the transparency
 *  calculation.<br>
 *  This corresponds to the #AI_MATKEY_BLEND_FUNC property.
*/
enum aiBlendMode {
    /**
     *  Formula:
     *  @code
     *  SourceColor*SourceAlpha + DestColor*(1-SourceAlpha)
     *  @endcode
     */
    aiBlendMode_Default = 0x0,

    /** Additive blending
     *
     *  Formula:
     *  @code
     *  SourceColor*1 + DestColor*1
     *  @endcode
     */
    aiBlendMode_Additive = 0x1,

// we don't need more for the moment, but we might need them
// in future versions ...

#ifndef SWIG
    _aiBlendMode_Force32Bit = INT_MAX
#endif
};

#include "./Compiler/pushpack1.h"

// ---------------------------------------------------------------------------
/** @brief Defines how an UV channel is transformed.
 *
 *  This is just a helper structure for the #AI_MATKEY_UVTRANSFORM key.
 *  See its documentation for more details.
 *
 *  Typically you'll want to build a matrix of this information. However,
 *  we keep separate scaling/translation/rotation values to make it
 *  easier to process and optimize UV transformations internally.
 */
struct aiUVTransform {
    /** Translation on the u and v axes.
     *
     *  The default value is (0|0).
     */
    C_STRUCT aiVector2D mTranslation;

    /** Scaling on the u and v axes.
     *
     *  The default value is (1|1).
     */
    C_STRUCT aiVector2D mScaling;

    /** Rotation - in counter-clockwise direction.
     *
     *  The rotation angle is specified in radians. The
     *  rotation center is 0.5f|0.5f. The default value
     *  0.f.
     */
    ai_real mRotation;

#ifdef __cplusplus
    aiUVTransform() AI_NO_EXCEPT
            : mTranslation(0.0, 0.0),
              mScaling(1.0, 1.0),
              mRotation(0.0) {
        // nothing to be done here ...
    }
#endif
};

#include "./Compiler/poppack1.h"

//! @cond AI_DOX_INCLUDE_INTERNAL
// ---------------------------------------------------------------------------
/** @brief A very primitive RTTI system for the contents of material
 *  properties.
 */
enum aiPropertyTypeInfo {
    /** Array of single-precision (32 Bit) floats
     *
     *  It is possible to use aiGetMaterialInteger[Array]() (or the C++-API
     *  aiMaterial::Get()) to query properties stored in floating-point format.
     *  The material system performs the type conversion automatically.
    */
    aiPTI_Float = 0x1,

    /** Array of double-precision (64 Bit) floats
     *
     *  It is possible to use aiGetMaterialInteger[Array]() (or the C++-API
     *  aiMaterial::Get()) to query properties stored in floating-point format.
     *  The material system performs the type conversion automatically.
    */
    aiPTI_Double = 0x2,

    /** The material property is an aiString.
     *
     *  Arrays of strings aren't possible, aiGetMaterialString() (or the
     *  C++-API aiMaterial::Get()) *must* be used to query a string property.
    */
    aiPTI_String = 0x3,

    /** Array of (32 Bit) integers
     *
     *  It is possible to use aiGetMaterialFloat[Array]() (or the C++-API
     *  aiMaterial::Get()) to query properties stored in integer format.
     *  The material system performs the type conversion automatically.
    */
    aiPTI_Integer = 0x4,

    /** Simple binary buffer, content undefined. Not convertible to anything.
    */
    aiPTI_Buffer = 0x5,

/** This value is not used. It is just there to force the
     *  compiler to map this enum to a 32 Bit integer.
     */
#ifndef SWIG
    _aiPTI_Force32Bit = INT_MAX
#endif
};

// ---------------------------------------------------------------------------
/** @brief Data structure for a single material property
 *
 *  As an user, you'll probably never need to deal with this data structure.
 *  Just use the provided aiGetMaterialXXX() or aiMaterial::Get() family
 *  of functions to query material properties easily. Processing them
 *  manually is faster, but it is not the recommended way. It isn't worth
 *  the effort. <br>
 *  Material property names follow a simple scheme:
 *  @code
 *    $<name>
 *    ?<name>
 *       A public property, there must be corresponding AI_MATKEY_XXX define
 *       2nd: Public, but ignored by the #aiProcess_RemoveRedundantMaterials
 *       post-processing step.
 *    ~<name>
 *       A temporary property for internal use.
 *  @endcode
 *  @see aiMaterial
 */
struct aiMaterialProperty {
    /** Specifies the name of the property (key)
     *  Keys are generally case insensitive.
     */
    C_STRUCT aiString mKey;

    /** Textures: Specifies their exact usage semantic.
     * For non-texture properties, this member is always 0
     * (or, better-said, #aiTextureType_NONE).
     */
    unsigned int mSemantic;

    /** Textures: Specifies the index of the texture.
     *  For non-texture properties, this member is always 0.
     */
    unsigned int mIndex;

    /** Size of the buffer mData is pointing to, in bytes.
     *  This value may not be 0.
     */
    unsigned int mDataLength;

    /** Type information for the property.
     *
     * Defines the data layout inside the data buffer. This is used
     * by the library internally to perform debug checks and to
     * utilize proper type conversions.
     * (It's probably a hacky solution, but it works.)
     */
    C_ENUM aiPropertyTypeInfo mType;

    /** Binary buffer to hold the property's value.
     * The size of the buffer is always mDataLength.
     */
    char *mData;

#ifdef __cplusplus

    aiMaterialProperty() AI_NO_EXCEPT
            : mSemantic(0),
              mIndex(0),
              mDataLength(0),
              mType(aiPTI_Float),
              mData(nullptr) {
        // empty
    }

    ~aiMaterialProperty() {
        delete[] mData;
        mData = nullptr;
    }

#endif
};
//! @endcond

#ifdef __cplusplus
} // We need to leave the "C" block here to allow template member functions
#endif

// ---------------------------------------------------------------------------
/** @brief Data structure for a material
*
*  Material data is stored using a key-value structure. A single key-value
*  pair is called a 'material property'. C++ users should use the provided
*  member functions of aiMaterial to process material properties, C users
*  have to stick with the aiMaterialGetXXX family of unbound functions.
*  The library defines a set of standard keys (AI_MATKEY_XXX).
*/
#ifdef __cplusplus
struct ASSIMP_API aiMaterial
#else
struct aiMaterial
#endif
{

#ifdef __cplusplus

public:
    aiMaterial();
    ~aiMaterial();

    // -------------------------------------------------------------------
    /**
      * @brief  Returns the name of the material.
      * @return The name of the material.
      */
    // -------------------------------------------------------------------
    aiString GetName() const;

    // -------------------------------------------------------------------
    /** @brief Retrieve an array of Type values with a specific key
     *  from the material
     *
     * @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
     * @param type .. set by AI_MATKEY_XXX
     * @param idx .. set by AI_MATKEY_XXX
     * @param pOut Pointer to a buffer to receive the result.
     * @param pMax Specifies the size of the given buffer, in Type's.
     * Receives the number of values (not bytes!) read.
     * NULL is a valid value for this parameter.
     */
    template <typename Type>
    aiReturn Get(const char *pKey, unsigned int type,
            unsigned int idx, Type *pOut, unsigned int *pMax) const;

    aiReturn Get(const char *pKey, unsigned int type,
            unsigned int idx, int *pOut, unsigned int *pMax) const;

    aiReturn Get(const char *pKey, unsigned int type,
            unsigned int idx, ai_real *pOut, unsigned int *pMax) const;

    // -------------------------------------------------------------------
    /** @brief Retrieve a Type value with a specific key
     *  from the material
     *
     * @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
    * @param type Specifies the type of the texture to be retrieved (
    *    e.g. diffuse, specular, height map ...)
    * @param idx Index of the texture to be retrieved.
     * @param pOut Reference to receive the output value
     */
    template <typename Type>
    aiReturn Get(const char *pKey, unsigned int type,
            unsigned int idx, Type &pOut) const;

    aiReturn Get(const char *pKey, unsigned int type,
            unsigned int idx, int &pOut) const;

    aiReturn Get(const char *pKey, unsigned int type,
            unsigned int idx, ai_real &pOut) const;

    aiReturn Get(const char *pKey, unsigned int type,
            unsigned int idx, aiString &pOut) const;

    aiReturn Get(const char *pKey, unsigned int type,
            unsigned int idx, aiColor3D &pOut) const;

    aiReturn Get(const char *pKey, unsigned int type,
            unsigned int idx, aiColor4D &pOut) const;

    aiReturn Get(const char *pKey, unsigned int type,
            unsigned int idx, aiUVTransform &pOut) const;

    // -------------------------------------------------------------------
    /** Get the number of textures for a particular texture type.
     *  @param type Texture type to check for
     *  @return Number of textures for this type.
     *  @note A texture can be easily queried using #GetTexture() */
    unsigned int GetTextureCount(aiTextureType type) const;

    // -------------------------------------------------------------------
    /** Helper function to get all parameters pertaining to a
     *  particular texture slot from a material.
     *
     *  This function is provided just for convenience, you could also
     *  read the single material properties manually.
     *  @param type Specifies the type of the texture to be retrieved (
     *    e.g. diffuse, specular, height map ...)
     *  @param index Index of the texture to be retrieved. The function fails
     *    if there is no texture of that type with this index.
     *    #GetTextureCount() can be used to determine the number of textures
     *    per texture type.
     *  @param path Receives the path to the texture.
     *    Use aiScene::GetEmbeddedTexture() method to determine if returned path
     *    is an image file to be opened or a string key of embedded texture stored in the corresponding scene
     *    (could be a '*' followed by the id of the texture in case of no name)
     *    NULL is a valid value.
     *  @param mapping The texture mapping.
     *    NULL is allowed as value.
     *  @param uvindex Receives the UV index of the texture.
     *    NULL is a valid value.
     *  @param blend Receives the blend factor for the texture
     *    NULL is a valid value.
     *  @param op Receives the texture operation to be performed between
     *    this texture and the previous texture. NULL is allowed as value.
     *  @param mapmode Receives the mapping modes to be used for the texture.
     *    The parameter may be NULL but if it is a valid pointer it MUST
     *    point to an array of 3 aiTextureMapMode's (one for each
     *    axis: UVW order (=XYZ)).
     */
    // -------------------------------------------------------------------
    aiReturn GetTexture(aiTextureType type,
            unsigned int index,
            C_STRUCT aiString *path,
            aiTextureMapping *mapping = NULL,
            unsigned int *uvindex = NULL,
            ai_real *blend = NULL,
            aiTextureOp *op = NULL,
            aiTextureMapMode *mapmode = NULL) const;

    // Setters

    // ------------------------------------------------------------------------------
    /** @brief Add a property with a given key and type info to the material
     *  structure
     *
     *  @param pInput Pointer to input data
     *  @param pSizeInBytes Size of input data
     *  @param pKey Key/Usage of the property (AI_MATKEY_XXX)
     *  @param type Set by the AI_MATKEY_XXX macro
     *  @param index Set by the AI_MATKEY_XXX macro
     *  @param pType Type information hint */
    aiReturn AddBinaryProperty(const void *pInput,
            unsigned int pSizeInBytes,
            const char *pKey,
            unsigned int type,
            unsigned int index,
            aiPropertyTypeInfo pType);

    // ------------------------------------------------------------------------------
    /** @brief Add a string property with a given key and type info to the
     *  material structure
     *
     *  @param pInput Input string
     *  @param pKey Key/Usage of the property (AI_MATKEY_XXX)
     *  @param type Set by the AI_MATKEY_XXX macro
     *  @param index Set by the AI_MATKEY_XXX macro */
    aiReturn AddProperty(const aiString *pInput,
            const char *pKey,
            unsigned int type = 0,
            unsigned int index = 0);

    // ------------------------------------------------------------------------------
    /** @brief Add a property with a given key to the material structure
     *  @param pInput Pointer to the input data
     *  @param pNumValues Number of values in the array
     *  @param pKey Key/Usage of the property (AI_MATKEY_XXX)
     *  @param type Set by the AI_MATKEY_XXX macro
     *  @param index Set by the AI_MATKEY_XXX macro  */
    template <class TYPE>
    aiReturn AddProperty(const TYPE *pInput,
            unsigned int pNumValues,
            const char *pKey,
            unsigned int type = 0,
            unsigned int index = 0);

    aiReturn AddProperty(const aiVector3D *pInput,
            unsigned int pNumValues,
            const char *pKey,
            unsigned int type = 0,
            unsigned int index = 0);

    aiReturn AddProperty(const aiColor3D *pInput,
            unsigned int pNumValues,
            const char *pKey,
            unsigned int type = 0,
            unsigned int index = 0);

    aiReturn AddProperty(const aiColor4D *pInput,
            unsigned int pNumValues,
            const char *pKey,
            unsigned int type = 0,
            unsigned int index = 0);

    aiReturn AddProperty(const int *pInput,
            unsigned int pNumValues,
            const char *pKey,
            unsigned int type = 0,
            unsigned int index = 0);

    aiReturn AddProperty(const float *pInput,
            unsigned int pNumValues,
            const char *pKey,
            unsigned int type = 0,
            unsigned int index = 0);

    aiReturn AddProperty(const double *pInput,
            unsigned int pNumValues,
            const char *pKey,
            unsigned int type = 0,
            unsigned int index = 0);

    aiReturn AddProperty(const aiUVTransform *pInput,
            unsigned int pNumValues,
            const char *pKey,
            unsigned int type = 0,
            unsigned int index = 0);

    // ------------------------------------------------------------------------------
    /** @brief Remove a given key from the list.
     *
     *  The function fails if the key isn't found
     *  @param pKey Key to be deleted
     *  @param type Set by the AI_MATKEY_XXX macro
     *  @param index Set by the AI_MATKEY_XXX macro  */
    aiReturn RemoveProperty(const char *pKey,
            unsigned int type = 0,
            unsigned int index = 0);

    // ------------------------------------------------------------------------------
    /** @brief Removes all properties from the material.
     *
     *  The data array remains allocated so adding new properties is quite fast.  */
    void Clear();

    // ------------------------------------------------------------------------------
    /** Copy the property list of a material
     *  @param pcDest Destination material
     *  @param pcSrc Source material
     */
    static void CopyPropertyList(aiMaterial *pcDest,
            const aiMaterial *pcSrc);

#endif

    /** List of all material properties loaded. */
    C_STRUCT aiMaterialProperty **mProperties;

    /** Number of properties in the data base */
    unsigned int mNumProperties;

    /** Storage allocated */
    unsigned int mNumAllocated;
};

// Go back to extern "C" again
#ifdef __cplusplus
extern "C" {
#endif

// ---------------------------------------------------------------------------
#define AI_MATKEY_NAME "?mat.name", 0, 0
#define AI_MATKEY_TWOSIDED "$mat.twosided", 0, 0
#define AI_MATKEY_SHADING_MODEL "$mat.shadingm", 0, 0
#define AI_MATKEY_ENABLE_WIREFRAME "$mat.wireframe", 0, 0
#define AI_MATKEY_BLEND_FUNC "$mat.blend", 0, 0
#define AI_MATKEY_OPACITY "$mat.opacity", 0, 0
#define AI_MATKEY_TRANSPARENCYFACTOR "$mat.transparencyfactor", 0, 0
#define AI_MATKEY_BUMPSCALING "$mat.bumpscaling", 0, 0
#define AI_MATKEY_SHININESS "$mat.shininess", 0, 0
#define AI_MATKEY_REFLECTIVITY "$mat.reflectivity", 0, 0
#define AI_MATKEY_SHININESS_STRENGTH "$mat.shinpercent", 0, 0
#define AI_MATKEY_REFRACTI "$mat.refracti", 0, 0
#define AI_MATKEY_COLOR_DIFFUSE "$clr.diffuse", 0, 0
#define AI_MATKEY_COLOR_AMBIENT "$clr.ambient", 0, 0
#define AI_MATKEY_COLOR_SPECULAR "$clr.specular", 0, 0
#define AI_MATKEY_COLOR_EMISSIVE "$clr.emissive", 0, 0
#define AI_MATKEY_COLOR_TRANSPARENT "$clr.transparent", 0, 0
#define AI_MATKEY_COLOR_REFLECTIVE "$clr.reflective", 0, 0
#define AI_MATKEY_GLOBAL_BACKGROUND_IMAGE "?bg.global", 0, 0
#define AI_MATKEY_GLOBAL_SHADERLANG "?sh.lang", 0, 0
#define AI_MATKEY_SHADER_VERTEX "?sh.vs", 0, 0
#define AI_MATKEY_SHADER_FRAGMENT "?sh.fs", 0, 0
#define AI_MATKEY_SHADER_GEO "?sh.gs", 0, 0
#define AI_MATKEY_SHADER_TESSELATION "?sh.ts", 0, 0
#define AI_MATKEY_SHADER_PRIMITIVE "?sh.ps", 0, 0
#define AI_MATKEY_SHADER_COMPUTE "?sh.cs", 0, 0

// ---------------------------------------------------------------------------
// PBR material support
// --------------------
// Properties defining PBR rendering techniques
#define AI_MATKEY_USE_COLOR_MAP "$mat.useColorMap", 0, 0

// Metallic/Roughness Workflow
// ---------------------------
// Base RGBA color factor. Will be multiplied by final base color texture values if extant
// Note: Importers may choose to copy this into AI_MATKEY_COLOR_DIFFUSE for compatibility
// with renderers and formats that do not support Metallic/Roughness PBR
#define AI_MATKEY_BASE_COLOR "$clr.base", 0, 0
#define AI_MATKEY_BASE_COLOR_TEXTURE aiTextureType_BASE_COLOR, 0
#define AI_MATKEY_USE_METALLIC_MAP "$mat.useMetallicMap", 0, 0
// Metallic factor. 0.0 = Full Dielectric, 1.0 = Full Metal
#define AI_MATKEY_METALLIC_FACTOR "$mat.metallicFactor", 0, 0
#define AI_MATKEY_METALLIC_TEXTURE aiTextureType_METALNESS, 0
#define AI_MATKEY_USE_ROUGHNESS_MAP "$mat.useRoughnessMap", 0, 0
// Roughness factor. 0.0 = Perfectly Smooth, 1.0 = Completely Rough
#define AI_MATKEY_ROUGHNESS_FACTOR "$mat.roughnessFactor", 0, 0
#define AI_MATKEY_ROUGHNESS_TEXTURE aiTextureType_DIFFUSE_ROUGHNESS, 0
// Anisotropy factor. 0.0 = isotropic, 1.0 = anisotropy along tangent direction,
// -1.0 = anisotropy along bitangent direction
#define AI_MATKEY_ANISOTROPY_FACTOR "$mat.anisotropyFactor", 0, 0

// Specular/Glossiness Workflow
// ---------------------------
// Diffuse/Albedo Color. Note: Pure Metals have a diffuse of {0,0,0}
// AI_MATKEY_COLOR_DIFFUSE
// Specular Color.
// Note: Metallic/Roughness may also have a Specular Color
// AI_MATKEY_COLOR_SPECULAR
#define AI_MATKEY_SPECULAR_FACTOR "$mat.specularFactor", 0, 0
// Glossiness factor. 0.0 = Completely Rough, 1.0 = Perfectly Smooth
#define AI_MATKEY_GLOSSINESS_FACTOR "$mat.glossinessFactor", 0, 0

// Sheen
// -----
// Sheen base RGB color. Default {0,0,0}
#define AI_MATKEY_SHEEN_COLOR_FACTOR "$clr.sheen.factor", 0, 0
// Sheen Roughness Factor.
#define AI_MATKEY_SHEEN_ROUGHNESS_FACTOR "$mat.sheen.roughnessFactor", 0, 0
#define AI_MATKEY_SHEEN_COLOR_TEXTURE aiTextureType_SHEEN, 0
#define AI_MATKEY_SHEEN_ROUGHNESS_TEXTURE aiTextureType_SHEEN, 1

// Clearcoat
// ---------
// Clearcoat layer intensity. 0.0 = none (disabled)
#define AI_MATKEY_CLEARCOAT_FACTOR "$mat.clearcoat.factor", 0, 0
#define AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR "$mat.clearcoat.roughnessFactor", 0, 0
#define AI_MATKEY_CLEARCOAT_TEXTURE aiTextureType_CLEARCOAT, 0
#define AI_MATKEY_CLEARCOAT_ROUGHNESS_TEXTURE aiTextureType_CLEARCOAT, 1
#define AI_MATKEY_CLEARCOAT_NORMAL_TEXTURE aiTextureType_CLEARCOAT, 2

// Transmission
// ------------
// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
// Base percentage of light transmitted through the surface. 0.0 = Opaque, 1.0 = Fully transparent
#define AI_MATKEY_TRANSMISSION_FACTOR "$mat.transmission.factor", 0, 0
// Texture defining percentage of light transmitted through the surface.
// Multiplied by AI_MATKEY_TRANSMISSION_FACTOR
#define AI_MATKEY_TRANSMISSION_TEXTURE aiTextureType_TRANSMISSION, 0

// Volume
// ------------
// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_volume
// The thickness of the volume beneath the surface. If the value is 0 the material is thin-walled. Otherwise the material is a volume boundary.
#define AI_MATKEY_VOLUME_THICKNESS_FACTOR "$mat.volume.thicknessFactor", 0, 0
// Texture that defines the thickness.
// Multiplied by AI_MATKEY_THICKNESS_FACTOR
#define AI_MATKEY_VOLUME_THICKNESS_TEXTURE aiTextureType_TRANSMISSION, 1
// Density of the medium given as the average distance that light travels in the medium before interacting with a particle.
#define AI_MATKEY_VOLUME_ATTENUATION_DISTANCE "$mat.volume.attenuationDistance", 0, 0
// The color that white light turns into due to absorption when reaching the attenuation distance.
#define AI_MATKEY_VOLUME_ATTENUATION_COLOR "$mat.volume.attenuationColor", 0, 0

// Emissive
// --------
#define AI_MATKEY_USE_EMISSIVE_MAP "$mat.useEmissiveMap", 0, 0
#define AI_MATKEY_EMISSIVE_INTENSITY "$mat.emissiveIntensity", 0, 0
#define AI_MATKEY_USE_AO_MAP "$mat.useAOMap", 0, 0

// ---------------------------------------------------------------------------
// Pure key names for all texture-related properties
//! @cond MATS_DOC_FULL
#define _AI_MATKEY_TEXTURE_BASE "$tex.file"
#define _AI_MATKEY_UVWSRC_BASE "$tex.uvwsrc"
#define _AI_MATKEY_TEXOP_BASE "$tex.op"
#define _AI_MATKEY_MAPPING_BASE "$tex.mapping"
#define _AI_MATKEY_TEXBLEND_BASE "$tex.blend"
#define _AI_MATKEY_MAPPINGMODE_U_BASE "$tex.mapmodeu"
#define _AI_MATKEY_MAPPINGMODE_V_BASE "$tex.mapmodev"
#define _AI_MATKEY_TEXMAP_AXIS_BASE "$tex.mapaxis"
#define _AI_MATKEY_UVTRANSFORM_BASE "$tex.uvtrafo"
#define _AI_MATKEY_TEXFLAGS_BASE "$tex.flags"
//! @endcond

// ---------------------------------------------------------------------------
#define AI_MATKEY_TEXTURE(type, N) _AI_MATKEY_TEXTURE_BASE, type, N

// For backward compatibility and simplicity
//! @cond MATS_DOC_FULL
#define AI_MATKEY_TEXTURE_DIFFUSE(N) \
    AI_MATKEY_TEXTURE(aiTextureType_DIFFUSE, N)

#define AI_MATKEY_TEXTURE_SPECULAR(N) \
    AI_MATKEY_TEXTURE(aiTextureType_SPECULAR, N)

#define AI_MATKEY_TEXTURE_AMBIENT(N) \
    AI_MATKEY_TEXTURE(aiTextureType_AMBIENT, N)

#define AI_MATKEY_TEXTURE_EMISSIVE(N) \
    AI_MATKEY_TEXTURE(aiTextureType_EMISSIVE, N)

#define AI_MATKEY_TEXTURE_NORMALS(N) \
    AI_MATKEY_TEXTURE(aiTextureType_NORMALS, N)

#define AI_MATKEY_TEXTURE_HEIGHT(N) \
    AI_MATKEY_TEXTURE(aiTextureType_HEIGHT, N)

#define AI_MATKEY_TEXTURE_SHININESS(N) \
    AI_MATKEY_TEXTURE(aiTextureType_SHININESS, N)

#define AI_MATKEY_TEXTURE_OPACITY(N) \
    AI_MATKEY_TEXTURE(aiTextureType_OPACITY, N)

#define AI_MATKEY_TEXTURE_DISPLACEMENT(N) \
    AI_MATKEY_TEXTURE(aiTextureType_DISPLACEMENT, N)

#define AI_MATKEY_TEXTURE_LIGHTMAP(N) \
    AI_MATKEY_TEXTURE(aiTextureType_LIGHTMAP, N)

#define AI_MATKEY_TEXTURE_REFLECTION(N) \
    AI_MATKEY_TEXTURE(aiTextureType_REFLECTION, N)

//! @endcond

// ---------------------------------------------------------------------------
#define AI_MATKEY_UVWSRC(type, N) _AI_MATKEY_UVWSRC_BASE, type, N

// For backward compatibility and simplicity
//! @cond MATS_DOC_FULL
#define AI_MATKEY_UVWSRC_DIFFUSE(N) \
    AI_MATKEY_UVWSRC(aiTextureType_DIFFUSE, N)

#define AI_MATKEY_UVWSRC_SPECULAR(N) \
    AI_MATKEY_UVWSRC(aiTextureType_SPECULAR, N)

#define AI_MATKEY_UVWSRC_AMBIENT(N) \
    AI_MATKEY_UVWSRC(aiTextureType_AMBIENT, N)

#define AI_MATKEY_UVWSRC_EMISSIVE(N) \
    AI_MATKEY_UVWSRC(aiTextureType_EMISSIVE, N)

#define AI_MATKEY_UVWSRC_NORMALS(N) \
    AI_MATKEY_UVWSRC(aiTextureType_NORMALS, N)

#define AI_MATKEY_UVWSRC_HEIGHT(N) \
    AI_MATKEY_UVWSRC(aiTextureType_HEIGHT, N)

#define AI_MATKEY_UVWSRC_SHININESS(N) \
    AI_MATKEY_UVWSRC(aiTextureType_SHININESS, N)

#define AI_MATKEY_UVWSRC_OPACITY(N) \
    AI_MATKEY_UVWSRC(aiTextureType_OPACITY, N)

#define AI_MATKEY_UVWSRC_DISPLACEMENT(N) \
    AI_MATKEY_UVWSRC(aiTextureType_DISPLACEMENT, N)

#define AI_MATKEY_UVWSRC_LIGHTMAP(N) \
    AI_MATKEY_UVWSRC(aiTextureType_LIGHTMAP, N)

#define AI_MATKEY_UVWSRC_REFLECTION(N) \
    AI_MATKEY_UVWSRC(aiTextureType_REFLECTION, N)

//! @endcond
// ---------------------------------------------------------------------------
#define AI_MATKEY_TEXOP(type, N) _AI_MATKEY_TEXOP_BASE, type, N

// For backward compatibility and simplicity
//! @cond MATS_DOC_FULL
#define AI_MATKEY_TEXOP_DIFFUSE(N) \
    AI_MATKEY_TEXOP(aiTextureType_DIFFUSE, N)

#define AI_MATKEY_TEXOP_SPECULAR(N) \
    AI_MATKEY_TEXOP(aiTextureType_SPECULAR, N)

#define AI_MATKEY_TEXOP_AMBIENT(N) \
    AI_MATKEY_TEXOP(aiTextureType_AMBIENT, N)

#define AI_MATKEY_TEXOP_EMISSIVE(N) \
    AI_MATKEY_TEXOP(aiTextureType_EMISSIVE, N)

#define AI_MATKEY_TEXOP_NORMALS(N) \
    AI_MATKEY_TEXOP(aiTextureType_NORMALS, N)

#define AI_MATKEY_TEXOP_HEIGHT(N) \
    AI_MATKEY_TEXOP(aiTextureType_HEIGHT, N)

#define AI_MATKEY_TEXOP_SHININESS(N) \
    AI_MATKEY_TEXOP(aiTextureType_SHININESS, N)

#define AI_MATKEY_TEXOP_OPACITY(N) \
    AI_MATKEY_TEXOP(aiTextureType_OPACITY, N)

#define AI_MATKEY_TEXOP_DISPLACEMENT(N) \
    AI_MATKEY_TEXOP(aiTextureType_DISPLACEMENT, N)

#define AI_MATKEY_TEXOP_LIGHTMAP(N) \
    AI_MATKEY_TEXOP(aiTextureType_LIGHTMAP, N)

#define AI_MATKEY_TEXOP_REFLECTION(N) \
    AI_MATKEY_TEXOP(aiTextureType_REFLECTION, N)

//! @endcond
// ---------------------------------------------------------------------------
#define AI_MATKEY_MAPPING(type, N) _AI_MATKEY_MAPPING_BASE, type, N

// For backward compatibility and simplicity
//! @cond MATS_DOC_FULL
#define AI_MATKEY_MAPPING_DIFFUSE(N) \
    AI_MATKEY_MAPPING(aiTextureType_DIFFUSE, N)

#define AI_MATKEY_MAPPING_SPECULAR(N) \
    AI_MATKEY_MAPPING(aiTextureType_SPECULAR, N)

#define AI_MATKEY_MAPPING_AMBIENT(N) \
    AI_MATKEY_MAPPING(aiTextureType_AMBIENT, N)

#define AI_MATKEY_MAPPING_EMISSIVE(N) \
    AI_MATKEY_MAPPING(aiTextureType_EMISSIVE, N)

#define AI_MATKEY_MAPPING_NORMALS(N) \
    AI_MATKEY_MAPPING(aiTextureType_NORMALS, N)

#define AI_MATKEY_MAPPING_HEIGHT(N) \
    AI_MATKEY_MAPPING(aiTextureType_HEIGHT, N)

#define AI_MATKEY_MAPPING_SHININESS(N) \
    AI_MATKEY_MAPPING(aiTextureType_SHININESS, N)

#define AI_MATKEY_MAPPING_OPACITY(N) \
    AI_MATKEY_MAPPING(aiTextureType_OPACITY, N)

#define AI_MATKEY_MAPPING_DISPLACEMENT(N) \
    AI_MATKEY_MAPPING(aiTextureType_DISPLACEMENT, N)

#define AI_MATKEY_MAPPING_LIGHTMAP(N) \
    AI_MATKEY_MAPPING(aiTextureType_LIGHTMAP, N)

#define AI_MATKEY_MAPPING_REFLECTION(N) \
    AI_MATKEY_MAPPING(aiTextureType_REFLECTION, N)

//! @endcond
// ---------------------------------------------------------------------------
#define AI_MATKEY_TEXBLEND(type, N) _AI_MATKEY_TEXBLEND_BASE, type, N

// For backward compatibility and simplicity
//! @cond MATS_DOC_FULL
#define AI_MATKEY_TEXBLEND_DIFFUSE(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_DIFFUSE, N)

#define AI_MATKEY_TEXBLEND_SPECULAR(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_SPECULAR, N)

#define AI_MATKEY_TEXBLEND_AMBIENT(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_AMBIENT, N)

#define AI_MATKEY_TEXBLEND_EMISSIVE(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_EMISSIVE, N)

#define AI_MATKEY_TEXBLEND_NORMALS(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_NORMALS, N)

#define AI_MATKEY_TEXBLEND_HEIGHT(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_HEIGHT, N)

#define AI_MATKEY_TEXBLEND_SHININESS(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_SHININESS, N)

#define AI_MATKEY_TEXBLEND_OPACITY(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_OPACITY, N)

#define AI_MATKEY_TEXBLEND_DISPLACEMENT(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_DISPLACEMENT, N)

#define AI_MATKEY_TEXBLEND_LIGHTMAP(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_LIGHTMAP, N)

#define AI_MATKEY_TEXBLEND_REFLECTION(N) \
    AI_MATKEY_TEXBLEND(aiTextureType_REFLECTION, N)

//! @endcond
// ---------------------------------------------------------------------------
#define AI_MATKEY_MAPPINGMODE_U(type, N) _AI_MATKEY_MAPPINGMODE_U_BASE, type, N

// For backward compatibility and simplicity
//! @cond MATS_DOC_FULL
#define AI_MATKEY_MAPPINGMODE_U_DIFFUSE(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_DIFFUSE, N)

#define AI_MATKEY_MAPPINGMODE_U_SPECULAR(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_SPECULAR, N)

#define AI_MATKEY_MAPPINGMODE_U_AMBIENT(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_AMBIENT, N)

#define AI_MATKEY_MAPPINGMODE_U_EMISSIVE(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_EMISSIVE, N)

#define AI_MATKEY_MAPPINGMODE_U_NORMALS(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_NORMALS, N)

#define AI_MATKEY_MAPPINGMODE_U_HEIGHT(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_HEIGHT, N)

#define AI_MATKEY_MAPPINGMODE_U_SHININESS(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_SHININESS, N)

#define AI_MATKEY_MAPPINGMODE_U_OPACITY(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_OPACITY, N)

#define AI_MATKEY_MAPPINGMODE_U_DISPLACEMENT(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_DISPLACEMENT, N)

#define AI_MATKEY_MAPPINGMODE_U_LIGHTMAP(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_LIGHTMAP, N)

#define AI_MATKEY_MAPPINGMODE_U_REFLECTION(N) \
    AI_MATKEY_MAPPINGMODE_U(aiTextureType_REFLECTION, N)

//! @endcond
// ---------------------------------------------------------------------------
#define AI_MATKEY_MAPPINGMODE_V(type, N) _AI_MATKEY_MAPPINGMODE_V_BASE, type, N

// For backward compatibility and simplicity
//! @cond MATS_DOC_FULL
#define AI_MATKEY_MAPPINGMODE_V_DIFFUSE(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_DIFFUSE, N)

#define AI_MATKEY_MAPPINGMODE_V_SPECULAR(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_SPECULAR, N)

#define AI_MATKEY_MAPPINGMODE_V_AMBIENT(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_AMBIENT, N)

#define AI_MATKEY_MAPPINGMODE_V_EMISSIVE(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_EMISSIVE, N)

#define AI_MATKEY_MAPPINGMODE_V_NORMALS(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_NORMALS, N)

#define AI_MATKEY_MAPPINGMODE_V_HEIGHT(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_HEIGHT, N)

#define AI_MATKEY_MAPPINGMODE_V_SHININESS(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_SHININESS, N)

#define AI_MATKEY_MAPPINGMODE_V_OPACITY(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_OPACITY, N)

#define AI_MATKEY_MAPPINGMODE_V_DISPLACEMENT(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_DISPLACEMENT, N)

#define AI_MATKEY_MAPPINGMODE_V_LIGHTMAP(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_LIGHTMAP, N)

#define AI_MATKEY_MAPPINGMODE_V_REFLECTION(N) \
    AI_MATKEY_MAPPINGMODE_V(aiTextureType_REFLECTION, N)

//! @endcond
// ---------------------------------------------------------------------------
#define AI_MATKEY_TEXMAP_AXIS(type, N) _AI_MATKEY_TEXMAP_AXIS_BASE, type, N

// For backward compatibility and simplicity
//! @cond MATS_DOC_FULL
#define AI_MATKEY_TEXMAP_AXIS_DIFFUSE(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_DIFFUSE, N)

#define AI_MATKEY_TEXMAP_AXIS_SPECULAR(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_SPECULAR, N)

#define AI_MATKEY_TEXMAP_AXIS_AMBIENT(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_AMBIENT, N)

#define AI_MATKEY_TEXMAP_AXIS_EMISSIVE(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_EMISSIVE, N)

#define AI_MATKEY_TEXMAP_AXIS_NORMALS(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_NORMALS, N)

#define AI_MATKEY_TEXMAP_AXIS_HEIGHT(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_HEIGHT, N)

#define AI_MATKEY_TEXMAP_AXIS_SHININESS(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_SHININESS, N)

#define AI_MATKEY_TEXMAP_AXIS_OPACITY(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_OPACITY, N)

#define AI_MATKEY_TEXMAP_AXIS_DISPLACEMENT(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_DISPLACEMENT, N)

#define AI_MATKEY_TEXMAP_AXIS_LIGHTMAP(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_LIGHTMAP, N)

#define AI_MATKEY_TEXMAP_AXIS_REFLECTION(N) \
    AI_MATKEY_TEXMAP_AXIS(aiTextureType_REFLECTION, N)

//! @endcond
// ---------------------------------------------------------------------------
#define AI_MATKEY_UVTRANSFORM(type, N) _AI_MATKEY_UVTRANSFORM_BASE, type, N

// For backward compatibility and simplicity
//! @cond MATS_DOC_FULL
#define AI_MATKEY_UVTRANSFORM_DIFFUSE(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_DIFFUSE, N)

#define AI_MATKEY_UVTRANSFORM_SPECULAR(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_SPECULAR, N)

#define AI_MATKEY_UVTRANSFORM_AMBIENT(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_AMBIENT, N)

#define AI_MATKEY_UVTRANSFORM_EMISSIVE(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_EMISSIVE, N)

#define AI_MATKEY_UVTRANSFORM_NORMALS(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_NORMALS, N)

#define AI_MATKEY_UVTRANSFORM_HEIGHT(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_HEIGHT, N)

#define AI_MATKEY_UVTRANSFORM_SHININESS(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_SHININESS, N)

#define AI_MATKEY_UVTRANSFORM_OPACITY(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_OPACITY, N)

#define AI_MATKEY_UVTRANSFORM_DISPLACEMENT(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_DISPLACEMENT, N)

#define AI_MATKEY_UVTRANSFORM_LIGHTMAP(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_LIGHTMAP, N)

#define AI_MATKEY_UVTRANSFORM_REFLECTION(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_REFLECTION, N)

#define AI_MATKEY_UVTRANSFORM_UNKNOWN(N) \
    AI_MATKEY_UVTRANSFORM(aiTextureType_UNKNOWN, N)

//! @endcond
// ---------------------------------------------------------------------------
#define AI_MATKEY_TEXFLAGS(type, N) _AI_MATKEY_TEXFLAGS_BASE, type, N

// For backward compatibility and simplicity
//! @cond MATS_DOC_FULL
#define AI_MATKEY_TEXFLAGS_DIFFUSE(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_DIFFUSE, N)

#define AI_MATKEY_TEXFLAGS_SPECULAR(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_SPECULAR, N)

#define AI_MATKEY_TEXFLAGS_AMBIENT(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_AMBIENT, N)

#define AI_MATKEY_TEXFLAGS_EMISSIVE(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_EMISSIVE, N)

#define AI_MATKEY_TEXFLAGS_NORMALS(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_NORMALS, N)

#define AI_MATKEY_TEXFLAGS_HEIGHT(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_HEIGHT, N)

#define AI_MATKEY_TEXFLAGS_SHININESS(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_SHININESS, N)

#define AI_MATKEY_TEXFLAGS_OPACITY(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_OPACITY, N)

#define AI_MATKEY_TEXFLAGS_DISPLACEMENT(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_DISPLACEMENT, N)

#define AI_MATKEY_TEXFLAGS_LIGHTMAP(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_LIGHTMAP, N)

#define AI_MATKEY_TEXFLAGS_REFLECTION(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_REFLECTION, N)

#define AI_MATKEY_TEXFLAGS_UNKNOWN(N) \
    AI_MATKEY_TEXFLAGS(aiTextureType_UNKNOWN, N)

//! @endcond
//!
// ---------------------------------------------------------------------------
/** @brief Retrieve a material property with a specific key from the material
 *
 * @param pMat Pointer to the input material. May not be NULL
 * @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
 * @param type Specifies the type of the texture to be retrieved (
 *    e.g. diffuse, specular, height map ...)
 * @param index Index of the texture to be retrieved.
 * @param pPropOut Pointer to receive a pointer to a valid aiMaterialProperty
 *        structure or NULL if the key has not been found. */
// ---------------------------------------------------------------------------
ASSIMP_API C_ENUM aiReturn aiGetMaterialProperty(
        const C_STRUCT aiMaterial *pMat,
        const char *pKey,
        unsigned int type,
        unsigned int index,
        const C_STRUCT aiMaterialProperty **pPropOut);

// ---------------------------------------------------------------------------
/** @brief Retrieve an array of float values with a specific key
 *  from the material
 *
 * Pass one of the AI_MATKEY_XXX constants for the last three parameters (the
 * example reads the #AI_MATKEY_UVTRANSFORM property of the first diffuse texture)
 * @code
 * aiUVTransform trafo;
 * unsigned int max = sizeof(aiUVTransform);
 * if (AI_SUCCESS != aiGetMaterialFloatArray(mat, AI_MATKEY_UVTRANSFORM(aiTextureType_DIFFUSE,0),
 *    (float*)&trafo, &max) || sizeof(aiUVTransform) != max)
 * {
 *   // error handling
 * }
 * @endcode
 *
 * @param pMat Pointer to the input material. May not be NULL
 * @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
 * @param pOut Pointer to a buffer to receive the result.
 * @param pMax Specifies the size of the given buffer, in float's.
 *        Receives the number of values (not bytes!) read.
 * @param type (see the code sample above)
 * @param index (see the code sample above)
 * @return Specifies whether the key has been found. If not, the output
 *   arrays remains unmodified and pMax is set to 0.*/
// ---------------------------------------------------------------------------
ASSIMP_API C_ENUM aiReturn aiGetMaterialFloatArray(
        const C_STRUCT aiMaterial *pMat,
        const char *pKey,
        unsigned int type,
        unsigned int index,
        ai_real *pOut,
        unsigned int *pMax);

// ---------------------------------------------------------------------------
/** @brief Retrieve a single float property with a specific key from the material.
*
* Pass one of the AI_MATKEY_XXX constants for the last three parameters (the
* example reads the #AI_MATKEY_SHININESS_STRENGTH property of the first diffuse texture)
* @code
* float specStrength = 1.f; // default value, remains unmodified if we fail.
* aiGetMaterialFloat(mat, AI_MATKEY_SHININESS_STRENGTH,
*    (float*)&specStrength);
* @endcode
*
* @param pMat Pointer to the input material. May not be NULL
* @param pKey Key to search for. One of the AI_MATKEY_XXX constants.
* @param pOut Receives the output float.
* @param type (see the code sample above)
* @param index (see the code sample above)
* @return Specifies whether the key has been found. If not, the output
*   float remains unmodified.*/
// ---------------------------------------------------------------------------
inline aiReturn aiGetMaterialFloat(const C_STRUCT aiMaterial *pMat,
        const char *pKey,
        unsigned int type,
        unsigned int index,
        ai_real *pOut) {
    return aiGetMaterialFloatArray(pMat, pKey, type, index, pOut, (unsigned int *)0x0);
}

// ---------------------------------------------------------------------------
/** @brief Retrieve an array of integer values with a specific key
 *  from a material
 *
 * See the sample for aiGetMaterialFloatArray for more information.*/
ASSIMP_API C_ENUM aiReturn aiGetMaterialIntegerArray(const C_STRUCT aiMaterial *pMat,
        const char *pKey,
        unsigned int type,
        unsigned int index,
        int *pOut,
        unsigned int *pMax);

// ---------------------------------------------------------------------------
/** @brief Retrieve an integer property with a specific key from a material
 *
 * See the sample for aiGetMaterialFloat for more information.*/
// ---------------------------------------------------------------------------
inline aiReturn aiGetMaterialInteger(const C_STRUCT aiMaterial *pMat,
        const char *pKey,
        unsigned int type,
        unsigned int index,
        int *pOut) {
    return aiGetMaterialIntegerArray(pMat, pKey, type, index, pOut, (unsigned int *)0x0);
}

// ---------------------------------------------------------------------------
/** @brief Retrieve a color value from the material property table
*
* See the sample for aiGetMaterialFloat for more information*/
// ---------------------------------------------------------------------------
ASSIMP_API C_ENUM aiReturn aiGetMaterialColor(const C_STRUCT aiMaterial *pMat,
        const char *pKey,
        unsigned int type,
        unsigned int index,
        C_STRUCT aiColor4D *pOut);

// ---------------------------------------------------------------------------
/** @brief Retrieve a aiUVTransform value from the material property table
*
* See the sample for aiGetMaterialFloat for more information*/
// ---------------------------------------------------------------------------
ASSIMP_API C_ENUM aiReturn aiGetMaterialUVTransform(const C_STRUCT aiMaterial *pMat,
        const char *pKey,
        unsigned int type,
        unsigned int index,
        C_STRUCT aiUVTransform *pOut);

// ---------------------------------------------------------------------------
/** @brief Retrieve a string from the material property table
*
* See the sample for aiGetMaterialFloat for more information.*/
// ---------------------------------------------------------------------------
ASSIMP_API C_ENUM aiReturn aiGetMaterialString(const C_STRUCT aiMaterial *pMat,
        const char *pKey,
        unsigned int type,
        unsigned int index,
        C_STRUCT aiString *pOut);

// ---------------------------------------------------------------------------
/** Get the number of textures for a particular texture type.
 *  @param[in] pMat Pointer to the input material. May not be NULL
 *  @param type Texture type to check for
 *  @return Number of textures for this type.
 *  @note A texture can be easily queried using #aiGetMaterialTexture() */
// ---------------------------------------------------------------------------
ASSIMP_API unsigned int aiGetMaterialTextureCount(const C_STRUCT aiMaterial *pMat,
        C_ENUM aiTextureType type);

// ---------------------------------------------------------------------------
/** @brief Helper function to get all values pertaining to a particular
 *  texture slot from a material structure.
 *
 *  This function is provided just for convenience. You could also read the
 *  texture by parsing all of its properties manually. This function bundles
 *  all of them in a huge function monster.
 *
 *  @param[in] mat Pointer to the input material. May not be NULL
 *  @param[in] type Specifies the texture stack to read from (e.g. diffuse,
 *     specular, height map ...).
 *  @param[in] index Index of the texture. The function fails if the
 *     requested index is not available for this texture type.
 *     #aiGetMaterialTextureCount() can be used to determine the number of
 *     textures in a particular texture stack.
 *  @param[out] path Receives the output path
 *     If the texture is embedded, receives a '*' followed by the id of
 *     the texture (for the textures stored in the corresponding scene) which
 *     can be converted to an int using a function like atoi.
 *     This parameter must be non-null.
 *  @param mapping The texture mapping mode to be used.
 *      Pass NULL if you're not interested in this information.
 *  @param[out] uvindex For UV-mapped textures: receives the index of the UV
 *      source channel. Unmodified otherwise.
 *      Pass NULL if you're not interested in this information.
 *  @param[out] blend Receives the blend factor for the texture
 *      Pass NULL if you're not interested in this information.
 *  @param[out] op Receives the texture blend operation to be perform between
 *      this texture and the previous texture.
 *      Pass NULL if you're not interested in this information.
 *  @param[out] mapmode Receives the mapping modes to be used for the texture.
 *      Pass NULL if you're not interested in this information. Otherwise,
 *      pass a pointer to an array of two aiTextureMapMode's (one for each
 *      axis, UV order).
 *  @param[out] flags Receives the the texture flags.
 *  @return AI_SUCCESS on success, otherwise something else. Have fun.*/
// ---------------------------------------------------------------------------
#ifdef __cplusplus
ASSIMP_API aiReturn aiGetMaterialTexture(const C_STRUCT aiMaterial *mat,
        aiTextureType type,
        unsigned int index,
        aiString *path,
        aiTextureMapping *mapping = NULL,
        unsigned int *uvindex = NULL,
        ai_real *blend = NULL,
        aiTextureOp *op = NULL,
        aiTextureMapMode *mapmode = NULL,
        unsigned int *flags = NULL);
#else
C_ENUM aiReturn aiGetMaterialTexture(const C_STRUCT aiMaterial *mat,
        C_ENUM aiTextureType type,
        unsigned int index,
        C_STRUCT aiString *path,
        C_ENUM aiTextureMapping *mapping /*= NULL*/,
        unsigned int *uvindex /*= NULL*/,
        ai_real *blend /*= NULL*/,
        C_ENUM aiTextureOp *op /*= NULL*/,
        C_ENUM aiTextureMapMode *mapmode /*= NULL*/,
        unsigned int *flags /*= NULL*/);
#endif // !#ifdef __cplusplus

#ifdef __cplusplus
}

#include "material.inl"

#endif //!__cplusplus

#endif //!!AI_MATERIAL_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/matrix3x3.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file matrix3x3.h
 *  @brief Definition of a 3x3 matrix, including operators when compiling in C++
 */
#pragma once
#ifndef AI_MATRIX3X3_H_INC
#define AI_MATRIX3X3_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/defs.h>

#ifdef __cplusplus

template <typename T> class aiMatrix4x4t;
template <typename T> class aiVector2t;
template <typename T> class aiVector3t;

// ---------------------------------------------------------------------------
/** @brief Represents a row-major 3x3 matrix
 *
 *  There's much confusion about matrix layouts (column vs. row order).
 *  This is *always* a row-major matrix. Not even with the
 *  #aiProcess_ConvertToLeftHanded flag, which absolutely does not affect
 *  matrix order - it just affects the handedness of the coordinate system
 *  defined thereby.
 */
template <typename TReal>
class aiMatrix3x3t {
public:
    aiMatrix3x3t() AI_NO_EXCEPT :
        a1(static_cast<TReal>(1.0f)), a2(), a3(),
        b1(), b2(static_cast<TReal>(1.0f)), b3(),
        c1(), c2(), c3(static_cast<TReal>(1.0f)) {}

    aiMatrix3x3t (  TReal _a1, TReal _a2, TReal _a3,
                    TReal _b1, TReal _b2, TReal _b3,
                    TReal _c1, TReal _c2, TReal _c3) :
        a1(_a1), a2(_a2), a3(_a3),
        b1(_b1), b2(_b2), b3(_b3),
        c1(_c1), c2(_c2), c3(_c3)
    {}

    // matrix multiplication.
    aiMatrix3x3t& operator *= (const aiMatrix3x3t& m);
    aiMatrix3x3t  operator  * (const aiMatrix3x3t& m) const;

    // array access operators
    TReal* operator[]       (unsigned int p_iIndex);
    const TReal* operator[] (unsigned int p_iIndex) const;

    // comparison operators
    bool operator== (const aiMatrix3x3t<TReal>& m) const;
    bool operator!= (const aiMatrix3x3t<TReal>& m) const;

    bool Equal(const aiMatrix3x3t<TReal> &m, TReal epsilon = ai_epsilon) const;

    template <typename TOther>
    operator aiMatrix3x3t<TOther> () const;

    // -------------------------------------------------------------------
    /** @brief Construction from a 4x4 matrix. The remaining parts
     *  of the matrix are ignored.
     */
    explicit aiMatrix3x3t( const aiMatrix4x4t<TReal>& pMatrix);

    // -------------------------------------------------------------------
    /** @brief Transpose the matrix
     */
    aiMatrix3x3t& Transpose();

    // -------------------------------------------------------------------
    /** @brief Invert the matrix.
     *  If the matrix is not invertible all elements are set to qnan.
     *  Beware, use (f != f) to check whether a TReal f is qnan.
     */
    aiMatrix3x3t& Inverse();
    TReal Determinant() const;

    // -------------------------------------------------------------------
    /** @brief Returns a rotation matrix for a rotation around z
     *  @param a Rotation angle, in radians
     *  @param out Receives the output matrix
     *  @return Reference to the output matrix
     */
    static aiMatrix3x3t& RotationZ(TReal a, aiMatrix3x3t& out);

    // -------------------------------------------------------------------
    /** @brief Returns a rotation matrix for a rotation around
     *    an arbitrary axis.
     *
     *  @param a Rotation angle, in radians
     *  @param axis Axis to rotate around
     *  @param out To be filled
     */
    static aiMatrix3x3t& Rotation( TReal a, const aiVector3t<TReal>& axis, aiMatrix3x3t& out);

    // -------------------------------------------------------------------
    /** @brief Returns a translation matrix
     *  @param v Translation vector
     *  @param out Receives the output matrix
     *  @return Reference to the output matrix
     */
    static aiMatrix3x3t& Translation( const aiVector2t<TReal>& v, aiMatrix3x3t& out);

    // -------------------------------------------------------------------
    /** @brief A function for creating a rotation matrix that rotates a
     *  vector called "from" into another vector called "to".
     * Input : from[3], to[3] which both must be *normalized* non-zero vectors
     * Output: mtx[3][3] -- a 3x3 matrix in column-major form
     * Authors: Tomas MÃ¶ller, John Hughes
     *          "Efficiently Building a Matrix to Rotate One Vector to Another"
     *          Journal of Graphics Tools, 4(4):1-4, 1999
     */
    static aiMatrix3x3t& FromToMatrix(const aiVector3t<TReal>& from,
        const aiVector3t<TReal>& to, aiMatrix3x3t& out);

public:
    TReal a1, a2, a3;
    TReal b1, b2, b3;
    TReal c1, c2, c3;
};

typedef aiMatrix3x3t<ai_real> aiMatrix3x3;

#else

struct aiMatrix3x3 {
    ai_real a1, a2, a3;
    ai_real b1, b2, b3;
    ai_real c1, c2, c3;
};

#endif // __cplusplus

#endif // AI_MATRIX3X3_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/matrix4x4.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team



All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/
/** @file matrix4x4.h
 *  @brief 4x4 matrix structure, including operators when compiling in C++
 */
#pragma once
#ifndef AI_MATRIX4X4_H_INC
#define AI_MATRIX4X4_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/vector3.h>
#include <assimp/defs.h>

#ifdef __cplusplus

template<typename TReal> class aiMatrix3x3t;
template<typename TReal> class aiQuaterniont;

// ---------------------------------------------------------------------------
/** @brief Represents a row-major 4x4 matrix, use this for homogeneous
 *   coordinates.
 *
 *  There's much confusion about matrix layouts (column vs. row order).
 *  This is *always* a row-major matrix. Not even with the
 *  #aiProcess_ConvertToLeftHanded flag, which absolutely does not affect
 *  matrix order - it just affects the handedness of the coordinate system
 *  defined thereby.
 */
template<typename TReal>
class aiMatrix4x4t {
public:

    /** set to identity */
    aiMatrix4x4t() AI_NO_EXCEPT;

    /** construction from single values */
    aiMatrix4x4t (  TReal _a1, TReal _a2, TReal _a3, TReal _a4,
                    TReal _b1, TReal _b2, TReal _b3, TReal _b4,
                    TReal _c1, TReal _c2, TReal _c3, TReal _c4,
                    TReal _d1, TReal _d2, TReal _d3, TReal _d4);


    /** construction from 3x3 matrix, remaining elements are set to identity */
    explicit aiMatrix4x4t( const aiMatrix3x3t<TReal>& m);

    /** construction from position, rotation and scaling components
     * @param scaling The scaling for the x,y,z axes
     * @param rotation The rotation as a hamilton quaternion
     * @param position The position for the x,y,z axes
     */
    aiMatrix4x4t(const aiVector3t<TReal>& scaling, const aiQuaterniont<TReal>& rotation,
        const aiVector3t<TReal>& position);

    // array access operators
	/** @fn TReal* operator[] (unsigned int p_iIndex)
	 *  @param [in] p_iIndex - index of the row.
	 *  @return pointer to pointed row.
	 */
    TReal* operator[]       (unsigned int p_iIndex);

	/** @fn const TReal* operator[] (unsigned int p_iIndex) const
	 *  @overload TReal* operator[] (unsigned int p_iIndex)
	 */
    const TReal* operator[] (unsigned int p_iIndex) const;

    // comparison operators
    bool operator== (const aiMatrix4x4t& m) const;
    bool operator!= (const aiMatrix4x4t& m) const;

    bool Equal(const aiMatrix4x4t &m, TReal epsilon = ai_epsilon) const;

    // matrix multiplication.
    aiMatrix4x4t& operator *= (const aiMatrix4x4t& m);
    aiMatrix4x4t  operator *  (const aiMatrix4x4t& m) const;
    aiMatrix4x4t operator * (const TReal& aFloat) const;
    aiMatrix4x4t operator + (const aiMatrix4x4t& aMatrix) const;

    template <typename TOther>
    operator aiMatrix4x4t<TOther> () const;

    // -------------------------------------------------------------------
    /** @brief Transpose the matrix */
    aiMatrix4x4t& Transpose();

    // -------------------------------------------------------------------
    /** @brief Invert the matrix.
     *  If the matrix is not invertible all elements are set to qnan.
     *  Beware, use (f != f) to check whether a TReal f is qnan.
     */
    aiMatrix4x4t& Inverse();
    TReal Determinant() const;


    // -------------------------------------------------------------------
    /** @brief Returns true of the matrix is the identity matrix.
     *  The check is performed against a not so small epsilon.
     */
    inline bool IsIdentity() const;

    // -------------------------------------------------------------------
    /** @brief Decompose a trafo matrix into its original components
     *  @param scaling Receives the output scaling for the x,y,z axes
     *  @param rotation Receives the output rotation as a hamilton
     *   quaternion
     *  @param position Receives the output position for the x,y,z axes
     */
    void Decompose (aiVector3t<TReal>& scaling, aiQuaterniont<TReal>& rotation,
        aiVector3t<TReal>& position) const;

	// -------------------------------------------------------------------
	/** @fn void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotation, aiVector3t<TReal>& pPosition) const
     *  @brief Decompose a trafo matrix into its original components.
     * Thx to good FAQ at http://www.gamedev.ru/code/articles/faq_matrix_quat
     *  @param [out] pScaling - Receives the output scaling for the x,y,z axes.
     *  @param [out] pRotation - Receives the output rotation as a Euler angles.
     *  @param [out] pPosition - Receives the output position for the x,y,z axes.
     */
    void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotation, aiVector3t<TReal>& pPosition) const;

	// -------------------------------------------------------------------
	/** @fn void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotationAxis, TReal& pRotationAngle, aiVector3t<TReal>& pPosition) const
     *  @brief Decompose a trafo matrix into its original components
	 * Thx to good FAQ at http://www.gamedev.ru/code/articles/faq_matrix_quat
     *  @param [out] pScaling - Receives the output scaling for the x,y,z axes.
     *  @param [out] pRotationAxis - Receives the output rotation axis.
	 *  @param [out] pRotationAngle - Receives the output rotation angle for @ref pRotationAxis.
     *  @param [out] pPosition - Receives the output position for the x,y,z axes.
     */
    void Decompose(aiVector3t<TReal>& pScaling, aiVector3t<TReal>& pRotationAxis, TReal& pRotationAngle, aiVector3t<TReal>& pPosition) const;

    // -------------------------------------------------------------------
    /** @brief Decompose a trafo matrix with no scaling into its
     *    original components
     *  @param rotation Receives the output rotation as a hamilton
     *    quaternion
     *  @param position Receives the output position for the x,y,z axes
     */
    void DecomposeNoScaling (aiQuaterniont<TReal>& rotation,
        aiVector3t<TReal>& position) const;

    // -------------------------------------------------------------------
    /** @brief Creates a trafo matrix from a set of euler angles
     *  @param x Rotation angle for the x-axis, in radians
     *  @param y Rotation angle for the y-axis, in radians
     *  @param z Rotation angle for the z-axis, in radians
     */
    aiMatrix4x4t& FromEulerAnglesXYZ(TReal x, TReal y, TReal z);
    aiMatrix4x4t& FromEulerAnglesXYZ(const aiVector3t<TReal>& blubb);

    // -------------------------------------------------------------------
    /** @brief Returns a rotation matrix for a rotation around the x axis
     *  @param a Rotation angle, in radians
     *  @param out Receives the output matrix
     *  @return Reference to the output matrix
     */
    static aiMatrix4x4t& RotationX(TReal a, aiMatrix4x4t& out);

    // -------------------------------------------------------------------
    /** @brief Returns a rotation matrix for a rotation around the y axis
     *  @param a Rotation angle, in radians
     *  @param out Receives the output matrix
     *  @return Reference to the output matrix
     */
    static aiMatrix4x4t& RotationY(TReal a, aiMatrix4x4t& out);

    // -------------------------------------------------------------------
    /** @brief Returns a rotation matrix for a rotation around the z axis
     *  @param a Rotation angle, in radians
     *  @param out Receives the output matrix
     *  @return Reference to the output matrix
     */
    static aiMatrix4x4t& RotationZ(TReal a, aiMatrix4x4t& out);

    // -------------------------------------------------------------------
    /** Returns a rotation matrix for a rotation around an arbitrary axis.
     *  @param a Rotation angle, in radians
     *  @param axis Rotation axis, should be a normalized vector.
     *  @param out Receives the output matrix
     *  @return Reference to the output matrix
     */
    static aiMatrix4x4t& Rotation(TReal a, const aiVector3t<TReal>& axis,
            aiMatrix4x4t& out);

    // -------------------------------------------------------------------
    /** @brief Returns a translation matrix
     *  @param v Translation vector
     *  @param out Receives the output matrix
     *  @return Reference to the output matrix
     */
    static aiMatrix4x4t& Translation( const aiVector3t<TReal>& v,
            aiMatrix4x4t& out);

    // -------------------------------------------------------------------
    /** @brief Returns a scaling matrix
     *  @param v Scaling vector
     *  @param out Receives the output matrix
     *  @return Reference to the output matrix
     */
    static aiMatrix4x4t& Scaling( const aiVector3t<TReal>& v, aiMatrix4x4t& out);

    // -------------------------------------------------------------------
    /** @brief A function for creating a rotation matrix that rotates a
     *  vector called "from" into another vector called "to".
     * Input : from[3], to[3] which both must be *normalized* non-zero vectors
     * Output: mtx[3][3] -- a 3x3 matrix in column-major form
     * Authors: Tomas Mueller, John Hughes
     *          "Efficiently Building a Matrix to Rotate One Vector to Another"
     *          Journal of Graphics Tools, 4(4):1-4, 1999
     */
    static aiMatrix4x4t& FromToMatrix(const aiVector3t<TReal>& from,
            const aiVector3t<TReal>& to, aiMatrix4x4t& out);

    TReal a1, a2, a3, a4;
    TReal b1, b2, b3, b4;
    TReal c1, c2, c3, c4;
    TReal d1, d2, d3, d4;
};

typedef aiMatrix4x4t<ai_real> aiMatrix4x4;

#else

struct aiMatrix4x4 {
    ai_real a1, a2, a3, a4;
    ai_real b1, b2, b3, b4;
    ai_real c1, c2, c3, c4;
    ai_real d1, d2, d3, d4;
};


#endif // __cplusplus

#endif // AI_MATRIX4X4_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/mesh.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2023, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file mesh.h
 *  @brief Declares the data structures in which the imported geometry is
    returned by ASSIMP: aiMesh, aiFace and aiBone data structures.
 */
#pragma once
#ifndef AI_MESH_H_INC
#define AI_MESH_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#ifdef _MSC_VER
#pragma warning(disable : 4351)
#endif // _MSC_VER

#include <assimp/aabb.h>
#include <assimp/types.h>

#ifdef __cplusplus
extern "C" {
#endif

// ---------------------------------------------------------------------------
// Limits. These values are required to match the settings Assimp was
// compiled against. Therefore, do not redefine them unless you build the
// library from source using the same definitions.
// ---------------------------------------------------------------------------

/** @def AI_MAX_FACE_INDICES
 *  Maximum number of indices per face (polygon). */

#ifndef AI_MAX_FACE_INDICES
#define AI_MAX_FACE_INDICES 0x7fff
#endif

/** @def AI_MAX_BONE_WEIGHTS
 *  Maximum number of indices per face (polygon). */

#ifndef AI_MAX_BONE_WEIGHTS
#define AI_MAX_BONE_WEIGHTS 0x7fffffff
#endif

/** @def AI_MAX_VERTICES
 *  Maximum number of vertices per mesh.  */

#ifndef AI_MAX_VERTICES
#define AI_MAX_VERTICES 0x7fffffff
#endif

/** @def AI_MAX_FACES
 *  Maximum number of faces per mesh. */

#ifndef AI_MAX_FACES
#define AI_MAX_FACES 0x7fffffff
#endif

/** @def AI_MAX_NUMBER_OF_COLOR_SETS
 *  Supported number of vertex color sets per mesh. */

#ifndef AI_MAX_NUMBER_OF_COLOR_SETS
#define AI_MAX_NUMBER_OF_COLOR_SETS 0x8
#endif // !! AI_MAX_NUMBER_OF_COLOR_SETS

/** @def AI_MAX_NUMBER_OF_TEXTURECOORDS
 *  Supported number of texture coord sets (UV(W) channels) per mesh */

#ifndef AI_MAX_NUMBER_OF_TEXTURECOORDS
#define AI_MAX_NUMBER_OF_TEXTURECOORDS 0x8
#endif // !! AI_MAX_NUMBER_OF_TEXTURECOORDS

// ---------------------------------------------------------------------------
/**
 * @brief A single face in a mesh, referring to multiple vertices.
 *
 * If mNumIndices is 3, we call the face 'triangle', for mNumIndices > 3
 * it's called 'polygon' (hey, that's just a definition!).
 * <br>
 * aiMesh::mPrimitiveTypes can be queried to quickly examine which types of
 * primitive are actually present in a mesh. The #aiProcess_SortByPType flag
 * executes a special post-processing algorithm which splits meshes with
 * *different* primitive types mixed up (e.g. lines and triangles) in several
 * 'clean' sub-meshes. Furthermore there is a configuration option (
 * #AI_CONFIG_PP_SBP_REMOVE) to force #aiProcess_SortByPType to remove
 * specific kinds of primitives from the imported scene, completely and forever.
 * In many cases you'll probably want to set this setting to
 * @code
 * aiPrimitiveType_LINE|aiPrimitiveType_POINT
 * @endcode
 * Together with the #aiProcess_Triangulate flag you can then be sure that
 * #aiFace::mNumIndices is always 3.
 * @note Take a look at the @link data Data Structures page @endlink for
 * more information on the layout and winding order of a face.
 */
struct aiFace {
    //! Number of indices defining this face.
    //! The maximum value for this member is #AI_MAX_FACE_INDICES.
    unsigned int mNumIndices;

    //! Pointer to the indices array. Size of the array is given in numIndices.
    unsigned int *mIndices;

#ifdef __cplusplus

    //! @brief Default constructor.
    aiFace() AI_NO_EXCEPT
            : mNumIndices(0),
              mIndices(nullptr) {
        // empty
    }

    //! @brief Default destructor. Delete the index array
    ~aiFace() {
        delete[] mIndices;
    }

    //! @brief Copy constructor. Copy the index array
    aiFace(const aiFace &o) :
            mNumIndices(0), mIndices(nullptr) {
        *this = o;
    }

    //! @brief Assignment operator. Copy the index array
    aiFace &operator=(const aiFace &o) {
        if (&o == this) {
            return *this;
        }

        delete[] mIndices;
        mNumIndices = o.mNumIndices;
        if (mNumIndices) {
            mIndices = new unsigned int[mNumIndices];
            ::memcpy(mIndices, o.mIndices, mNumIndices * sizeof(unsigned int));
        } else {
            mIndices = nullptr;
        }

        return *this;
    }

    //! @brief Comparison operator. Checks whether the index array of two faces is identical.
    bool operator==(const aiFace &o) const {
        if (mIndices == o.mIndices) {
            return true;
        }

        if (nullptr != mIndices && mNumIndices != o.mNumIndices) {
            return false;
        }

        if (nullptr == mIndices) {
            return false;
        }

        for (unsigned int i = 0; i < this->mNumIndices; ++i) {
            if (mIndices[i] != o.mIndices[i]) {
                return false;
            }
        }

        return true;
    }

    //! @brief Inverse comparison operator. Checks whether the index
    //! array of two faces is NOT identical
    bool operator!=(const aiFace &o) const {
        return !(*this == o);
    }
#endif // __cplusplus
}; // struct aiFace

// ---------------------------------------------------------------------------
/** @brief A single influence of a bone on a vertex.
 */
struct aiVertexWeight {
    //! Index of the vertex which is influenced by the bone.
    unsigned int mVertexId;

    //! The strength of the influence in the range (0...1).
    //! The influence from all bones at one vertex amounts to 1.
    ai_real mWeight;

#ifdef __cplusplus

    //! @brief Default constructor
    aiVertexWeight() AI_NO_EXCEPT
            : mVertexId(0),
              mWeight(0.0f) {
        // empty
    }

    //! @brief Initialization from a given index and vertex weight factor
    //! \param pID ID
    //! \param pWeight Vertex weight factor
    aiVertexWeight(unsigned int pID, float pWeight) :
            mVertexId(pID), mWeight(pWeight) {
        // empty
    }

    bool operator==(const aiVertexWeight &rhs) const {
        return (mVertexId == rhs.mVertexId && mWeight == rhs.mWeight);
    }

    bool operator!=(const aiVertexWeight &rhs) const {
        return (*this == rhs);
    }

#endif // __cplusplus
};

// Forward declare aiNode (pointer use only)
struct aiNode;

// ---------------------------------------------------------------------------
/** @brief A single bone of a mesh.
 *
 *  A bone has a name by which it can be found in the frame hierarchy and by
 *  which it can be addressed by animations. In addition it has a number of
 *  influences on vertices, and a matrix relating the mesh position to the
 *  position of the bone at the time of binding.
 */
struct aiBone {
    /**
     * The name of the bone.
     */
    C_STRUCT aiString mName;

    /**
     * The number of vertices affected by this bone.
     * The maximum value for this member is #AI_MAX_BONE_WEIGHTS.
     */
    unsigned int mNumWeights;

#ifndef ASSIMP_BUILD_NO_ARMATUREPOPULATE_PROCESS
    /**
     * The bone armature node - used for skeleton conversion
     * you must enable aiProcess_PopulateArmatureData to populate this
     */
    C_STRUCT aiNode *mArmature;

    /**
     * The bone node in the scene - used for skeleton conversion
     * you must enable aiProcess_PopulateArmatureData to populate this
     */
    C_STRUCT aiNode *mNode;

#endif
    /**
     * The influence weights of this bone, by vertex index.
     */
    C_STRUCT aiVertexWeight *mWeights;

    /**
     * Matrix that transforms from mesh space to bone space in bind pose.
     *
     * This matrix describes the position of the mesh
     * in the local space of this bone when the skeleton was bound.
     * Thus it can be used directly to determine a desired vertex position,
     * given the world-space transform of the bone when animated,
     * and the position of the vertex in mesh space.
     *
     * It is sometimes called an inverse-bind matrix,
     * or inverse bind pose matrix.
     */
    C_STRUCT aiMatrix4x4 mOffsetMatrix;

#ifdef __cplusplus

    ///	@brief  Default constructor
    aiBone() AI_NO_EXCEPT
            : mName(),
              mNumWeights(0),
#ifndef ASSIMP_BUILD_NO_ARMATUREPOPULATE_PROCESS
              mArmature(nullptr),
              mNode(nullptr),
#endif
              mWeights(nullptr),
              mOffsetMatrix() {
        // empty
    }

    /// @brief  Copy constructor
    aiBone(const aiBone &other) :
            mName(other.mName),
            mNumWeights(other.mNumWeights),
#ifndef ASSIMP_BUILD_NO_ARMATUREPOPULATE_PROCESS
              mArmature(nullptr),
              mNode(nullptr),
#endif
            mWeights(nullptr),
            mOffsetMatrix(other.mOffsetMatrix) {
        copyVertexWeights(other);
    }

    void copyVertexWeights( const aiBone &other ) {
        if (other.mWeights == nullptr || other.mNumWeights == 0) {
            mWeights = nullptr;
            mNumWeights = 0;
            return;
        }

        mNumWeights = other.mNumWeights;
        if (mWeights) {
            delete[] mWeights;
        }

        mWeights = new aiVertexWeight[mNumWeights];
        ::memcpy(mWeights, other.mWeights, mNumWeights * sizeof(aiVertexWeight));
    }

    //! @brief Assignment operator
    aiBone &operator = (const aiBone &other) {
        if (this == &other) {
            return *this;
        }

        mName = other.mName;
        mNumWeights = other.mNumWeights;
        mOffsetMatrix = other.mOffsetMatrix;
        copyVertexWeights(other);

        return *this;
    }

    /// @brief Compare operator.
    bool operator==(const aiBone &rhs) const {
        if (mName != rhs.mName || mNumWeights != rhs.mNumWeights ) {
            return false;
        }

        for (size_t i = 0; i < mNumWeights; ++i) {
            if (mWeights[i] != rhs.mWeights[i]) {
                return false;
            }
        }

        return true;
    }
    //! @brief Destructor - deletes the array of vertex weights
    ~aiBone() {
        delete[] mWeights;
    }
#endif // __cplusplus
};

// ---------------------------------------------------------------------------
/** @brief Enumerates the types of geometric primitives supported by Assimp.
 *
 *  @see aiFace Face data structure
 *  @see aiProcess_SortByPType Per-primitive sorting of meshes
 *  @see aiProcess_Triangulate Automatic triangulation
 *  @see AI_CONFIG_PP_SBP_REMOVE Removal of specific primitive types.
 */
enum aiPrimitiveType {
    /**
     * @brief A point primitive.
     *
     * This is just a single vertex in the virtual world,
     * #aiFace contains just one index for such a primitive.
     */
    aiPrimitiveType_POINT = 0x1,

    /**
     * @brief A line primitive.
     *
     * This is a line defined through a start and an end position.
     * #aiFace contains exactly two indices for such a primitive.
     */
    aiPrimitiveType_LINE = 0x2,

    /**
     * @brief A triangular primitive.
     *
     * A triangle consists of three indices.
     */
    aiPrimitiveType_TRIANGLE = 0x4,

    /**
     * @brief A higher-level polygon with more than 3 edges.
     *
     * A triangle is a polygon, but polygon in this context means
     * "all polygons that are not triangles". The "Triangulate"-Step
     * is provided for your convenience, it splits all polygons in
     * triangles (which are much easier to handle).
     */
    aiPrimitiveType_POLYGON = 0x8,

    /**
     * @brief A flag to determine whether this triangles only mesh is NGON encoded.
     *
     * NGON encoding is a special encoding that tells whether 2 or more consecutive triangles
     * should be considered as a triangle fan. This is identified by looking at the first vertex index.
     * 2 consecutive triangles with the same 1st vertex index are part of the same
     * NGON.
     *
     * At the moment, only quads (concave or convex) are supported, meaning that polygons are 'seen' as
     * triangles, as usual after a triangulation pass.
     *
     * To get an NGON encoded mesh, please use the aiProcess_Triangulate post process.
     *
     * @see aiProcess_Triangulate
     * @link https://github.com/KhronosGroup/glTF/pull/1620
     */
    aiPrimitiveType_NGONEncodingFlag = 0x10,

    /**
     * This value is not used. It is just here to force the
     * compiler to map this enum to a 32 Bit integer.
     */
#ifndef SWIG
    _aiPrimitiveType_Force32Bit = INT_MAX
#endif
}; //! enum aiPrimitiveType

// Get the #aiPrimitiveType flag for a specific number of face indices
#define AI_PRIMITIVE_TYPE_FOR_N_INDICES(n) \
    ((n) > 3 ? aiPrimitiveType_POLYGON : (aiPrimitiveType)(1u << ((n)-1)))

// ---------------------------------------------------------------------------
/** @brief An AnimMesh is an attachment to an #aiMesh stores per-vertex
 *  animations for a particular frame.
 *
 *  You may think of an #aiAnimMesh as a `patch` for the host mesh, which
 *  replaces only certain vertex data streams at a particular time.
 *  Each mesh stores n attached attached meshes (#aiMesh::mAnimMeshes).
 *  The actual relationship between the time line and anim meshes is
 *  established by #aiMeshAnim, which references singular mesh attachments
 *  by their ID and binds them to a time offset.
*/
struct aiAnimMesh {
    /**Anim Mesh name */
    C_STRUCT aiString mName;

    /** Replacement for aiMesh::mVertices. If this array is non-nullptr,
     *  it *must* contain mNumVertices entries. The corresponding
     *  array in the host mesh must be non-nullptr as well - animation
     *  meshes may neither add or nor remove vertex components (if
     *  a replacement array is nullptr and the corresponding source
     *  array is not, the source data is taken instead)*/
    C_STRUCT aiVector3D *mVertices;

    /** Replacement for aiMesh::mNormals.  */
    C_STRUCT aiVector3D *mNormals;

    /** Replacement for aiMesh::mTangents. */
    C_STRUCT aiVector3D *mTangents;

    /** Replacement for aiMesh::mBitangents. */
    C_STRUCT aiVector3D *mBitangents;

    /** Replacement for aiMesh::mColors */
    C_STRUCT aiColor4D *mColors[AI_MAX_NUMBER_OF_COLOR_SETS];

    /** Replacement for aiMesh::mTextureCoords */
    C_STRUCT aiVector3D *mTextureCoords[AI_MAX_NUMBER_OF_TEXTURECOORDS];

    /** The number of vertices in the aiAnimMesh, and thus the length of all
     * the member arrays.
     *
     * This has always the same value as the mNumVertices property in the
     * corresponding aiMesh. It is duplicated here merely to make the length
     * of the member arrays accessible even if the aiMesh is not known, e.g.
     * from language bindings.
     */
    unsigned int mNumVertices;

    /**
     * Weight of the AnimMesh.
     */
    float mWeight;

#ifdef __cplusplus
    /// @brief  The class constructor.
    aiAnimMesh() AI_NO_EXCEPT :
            mVertices(nullptr),
            mNormals(nullptr),
            mTangents(nullptr),
            mBitangents(nullptr),
            mColors {nullptr},
            mTextureCoords{nullptr},
            mNumVertices(0),
            mWeight(0.0f) {
        // empty
    }

    /// @brief The class destructor.
    ~aiAnimMesh() {
        delete[] mVertices;
        delete[] mNormals;
        delete[] mTangents;
        delete[] mBitangents;
        for (unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS; a++) {
            delete[] mTextureCoords[a];
        }
        for (unsigned int a = 0; a < AI_MAX_NUMBER_OF_COLOR_SETS; a++) {
            delete[] mColors[a];
        }
    }

    /**
     *  @brief Check whether the anim-mesh overrides the vertex positions
     *         of its host mesh.
     *  @return true if positions are stored, false if not.
     */
    bool HasPositions() const {
        return mVertices != nullptr;
    }

    /**
     *  @brief Check whether the anim-mesh overrides the vertex normals
     *         of its host mesh
     *  @return true if normals are stored, false if not.
     */
    bool HasNormals() const {
        return mNormals != nullptr;
    }

    /**
     *  @brief Check whether the anim-mesh overrides the vertex tangents
     *         and bitangents of its host mesh. As for aiMesh,
     *         tangents and bitangents always go together.
     *  @return true if tangents and bi-tangents are stored, false if not.
     */
    bool HasTangentsAndBitangents() const {
        return mTangents != nullptr;
    }

    /**
     *  @brief Check whether the anim mesh overrides a particular
     *         set of vertex colors on his host mesh.
     *  @param pIndex 0<index<AI_MAX_NUMBER_OF_COLOR_SETS
     *  @return true if vertex colors are stored, false if not.
     */

    bool HasVertexColors(unsigned int pIndex) const {
        return pIndex >= AI_MAX_NUMBER_OF_COLOR_SETS ? false : mColors[pIndex] != nullptr;
    }

    /**
     *  @brief Check whether the anim mesh overrides a particular
     *        set of texture coordinates on his host mesh.
     *  @param pIndex 0<index<AI_MAX_NUMBER_OF_TEXTURECOORDS
     *  @return true if texture coordinates are stored, false if not.
     */
    bool HasTextureCoords(unsigned int pIndex) const {
        return pIndex >= AI_MAX_NUMBER_OF_TEXTURECOORDS ? false : mTextureCoords[pIndex] != nullptr;
    }

#endif
};

// ---------------------------------------------------------------------------
/** @brief Enumerates the methods of mesh morphing supported by Assimp.
 */
enum aiMorphingMethod {
    /** Morphing method to be determined */
    aiMorphingMethod_UNKNOWN = 0x0,

    /** Interpolation between morph targets */
    aiMorphingMethod_VERTEX_BLEND = 0x1,

    /** Normalized morphing between morph targets  */
    aiMorphingMethod_MORPH_NORMALIZED = 0x2,

    /** Relative morphing between morph targets  */
    aiMorphingMethod_MORPH_RELATIVE = 0x3,

/** This value is not used. It is just here to force the
     *  compiler to map this enum to a 32 Bit integer.
     */
#ifndef SWIG
    _aiMorphingMethod_Force32Bit = INT_MAX
#endif
}; //! enum aiMorphingMethod

// ---------------------------------------------------------------------------
/** @brief A mesh represents a geometry or model with a single material.
 *
 * It usually consists of a number of vertices and a series of primitives/faces
 * referencing the vertices. In addition there might be a series of bones, each
 * of them addressing a number of vertices with a certain weight. Vertex data
 * is presented in channels with each channel containing a single per-vertex
 * information such as a set of texture coordinates or a normal vector.
 * If a data pointer is non-null, the corresponding data stream is present.
 * From C++-programs you can also use the comfort functions Has*() to
 * test for the presence of various data streams.
 *
 * A Mesh uses only a single material which is referenced by a material ID.
 * @note The mPositions member is usually not optional. However, vertex positions
 * *could* be missing if the #AI_SCENE_FLAGS_INCOMPLETE flag is set in
 * @code
 * aiScene::mFlags
 * @endcode
 */
struct aiMesh {
    /**
     * Bitwise combination of the members of the #aiPrimitiveType enum.
     * This specifies which types of primitives are present in the mesh.
     * The "SortByPrimitiveType"-Step can be used to make sure the
     * output meshes consist of one primitive type each.
     */
    unsigned int mPrimitiveTypes;

    /**
     * The number of vertices in this mesh.
     * This is also the size of all of the per-vertex data arrays.
     * The maximum value for this member is #AI_MAX_VERTICES.
     */
    unsigned int mNumVertices;

    /**
     * The number of primitives (triangles, polygons, lines) in this  mesh.
     * This is also the size of the mFaces array.
     * The maximum value for this member is #AI_MAX_FACES.
     */
    unsigned int mNumFaces;

    /**
     * @brief Vertex positions.
     * 
     * This array is always present in a mesh. The array is
     * mNumVertices in size.
     */
    C_STRUCT aiVector3D *mVertices;

    /**
     * @brief Vertex normals.
     * 
     * The array contains normalized vectors, nullptr if not present.
     * The array is mNumVertices in size. Normals are undefined for
     * point and line primitives. A mesh consisting of points and
     * lines only may not have normal vectors. Meshes with mixed
     * primitive types (i.e. lines and triangles) may have normals,
     * but the normals for vertices that are only referenced by
     * point or line primitives are undefined and set to QNaN (WARN:
     * qNaN compares to inequal to *everything*, even to qNaN itself.
     * Using code like this to check whether a field is qnan is:
     * @code
     * #define IS_QNAN(f) (f != f)
     * @endcode
     * still dangerous because even 1.f == 1.f could evaluate to false! (
     * remember the subtleties of IEEE754 artithmetics). Use stuff like
     * @c fpclassify instead.
     * @note Normal vectors computed by Assimp are always unit-length.
     * However, this needn't apply for normals that have been taken
     * directly from the model file.
     */
    C_STRUCT aiVector3D *mNormals;

    /**
     * @brief Vertex tangents.
     * 
     * The tangent of a vertex points in the direction of the positive
     * X texture axis. The array contains normalized vectors, nullptr if
     * not present. The array is mNumVertices in size. A mesh consisting
     * of points and lines only may not have normal vectors. Meshes with
     * mixed primitive types (i.e. lines and triangles) may have
     * normals, but the normals for vertices that are only referenced by
     * point or line primitives are undefined and set to qNaN.  See
     * the #mNormals member for a detailed discussion of qNaNs.
     * @note If the mesh contains tangents, it automatically also
     * contains bitangents.
     */
    C_STRUCT aiVector3D *mTangents;

    /**
     * @brief Vertex bitangents.
     * 
     * The bitangent of a vertex points in the direction of the positive
     * Y texture axis. The array contains normalized vectors, nullptr if not
     * present. The array is mNumVertices in size.
     * @note If the mesh contains tangents, it automatically also contains
     * bitangents.
     */
    C_STRUCT aiVector3D *mBitangents;

    /**
     * @brief Vertex color sets.
     * 
     * A mesh may contain 0 to #AI_MAX_NUMBER_OF_COLOR_SETS vertex
     * colors per vertex. nullptr if not present. Each array is
     * mNumVertices in size if present.
     */
    C_STRUCT aiColor4D *mColors[AI_MAX_NUMBER_OF_COLOR_SETS];

    /**
     * @brief Vertex texture coordinates, also known as UV channels.
     * 
     * A mesh may contain 0 to AI_MAX_NUMBER_OF_TEXTURECOORDS per
     * vertex. nullptr if not present. The array is mNumVertices in size.
     */
    C_STRUCT aiVector3D *mTextureCoords[AI_MAX_NUMBER_OF_TEXTURECOORDS];

    /**
     * @brief Specifies the number of components for a given UV channel.
     * 
     * Up to three channels are supported (UVW, for accessing volume
     * or cube maps). If the value is 2 for a given channel n, the
     * component p.z of mTextureCoords[n][p] is set to 0.0f.
     * If the value is 1 for a given channel, p.y is set to 0.0f, too.
     * @note 4D coordinates are not supported
     */
    unsigned int mNumUVComponents[AI_MAX_NUMBER_OF_TEXTURECOORDS];

    /**
     * @brief The faces the mesh is constructed from.
     * 
     * Each face refers to a number of vertices by their indices.
     * This array is always present in a mesh, its size is given
     *  in mNumFaces. If the #AI_SCENE_FLAGS_NON_VERBOSE_FORMAT
     * is NOT set each face references an unique set of vertices.
     */
    C_STRUCT aiFace *mFaces;

    /**
    * The number of bones this mesh contains. Can be 0, in which case the mBones array is nullptr.
    */
    unsigned int mNumBones;

    /**
     * @brief The bones of this mesh.
     * 
     * A bone consists of a name by which it can be found in the
     * frame hierarchy and a set of vertex weights.
     */
    C_STRUCT aiBone **mBones;

    /**
     * @brief The material used by this mesh.
     * 
     * A mesh uses only a single material. If an imported model uses
     * multiple materials, the import splits up the mesh. Use this value
     * as index into the scene's material list.
     */
    unsigned int mMaterialIndex;

    /**
     *  Name of the mesh. Meshes can be named, but this is not a
     *  requirement and leaving this field empty is totally fine.
     *  There are mainly three uses for mesh names:
     *   - some formats name nodes and meshes independently.
     *   - importers tend to split meshes up to meet the
     *      one-material-per-mesh requirement. Assigning
     *      the same (dummy) name to each of the result meshes
     *      aids the caller at recovering the original mesh
     *      partitioning.
     *   - Vertex animations refer to meshes by their names.
     */
    C_STRUCT aiString mName;

    /**
     * The number of attachment meshes.
     * Currently known to work with loaders:
     * - Collada
     * - gltf
     */
    unsigned int mNumAnimMeshes;

    /**
     * Attachment meshes for this mesh, for vertex-based animation.
     * Attachment meshes carry replacement data for some of the
     * mesh'es vertex components (usually positions, normals).
     * Currently known to work with loaders:
     * - Collada
     * - gltf
     */
    C_STRUCT aiAnimMesh **mAnimMeshes;

    /**
     *  Method of morphing when anim-meshes are specified.
     *  @see aiMorphingMethod to learn more about the provided morphing targets.
     */
    enum aiMorphingMethod mMethod;

    /**
     *  The bounding box.
     */
    C_STRUCT aiAABB mAABB;

    /**
     * Vertex UV stream names. Pointer to array of size AI_MAX_NUMBER_OF_TEXTURECOORDS
     */
    C_STRUCT aiString **mTextureCoordsNames;

#ifdef __cplusplus

    //! The default class constructor.
    aiMesh() AI_NO_EXCEPT
            : mPrimitiveTypes(0),
              mNumVertices(0),
              mNumFaces(0),
              mVertices(nullptr),
              mNormals(nullptr),
              mTangents(nullptr),
              mBitangents(nullptr),
              mColors{nullptr},
              mTextureCoords{nullptr},
              mNumUVComponents{0},
              mFaces(nullptr),
              mNumBones(0),
              mBones(nullptr),
              mMaterialIndex(0),
              mNumAnimMeshes(0),
              mAnimMeshes(nullptr),
              mMethod(aiMorphingMethod_UNKNOWN),
              mAABB(),
              mTextureCoordsNames(nullptr) {
        // empty
    }

    //! @brief The class destructor.
    ~aiMesh() {
        delete[] mVertices;
        delete[] mNormals;
        delete[] mTangents;
        delete[] mBitangents;
        for (unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS; a++) {
            delete[] mTextureCoords[a];
        }

        if (mTextureCoordsNames) {
            for (unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS; a++) {
                delete mTextureCoordsNames[a];
            }
            delete[] mTextureCoordsNames;
        }

        for (unsigned int a = 0; a < AI_MAX_NUMBER_OF_COLOR_SETS; a++) {
            delete[] mColors[a];
        }

        // DO NOT REMOVE THIS ADDITIONAL CHECK
        if (mNumBones && mBones) {
            for (unsigned int a = 0; a < mNumBones; a++) {
                if (mBones[a]) {
                    delete mBones[a];
                }
            }
            delete[] mBones;
        }

        if (mNumAnimMeshes && mAnimMeshes) {
            for (unsigned int a = 0; a < mNumAnimMeshes; a++) {
                delete mAnimMeshes[a];
            }
            delete[] mAnimMeshes;
        }

        delete[] mFaces;
    }

    //! @brief Check whether the mesh contains positions. Provided no special
    //!        scene flags are set, this will always be true
    //! @return true, if positions are stored, false if not.
    bool HasPositions() const {
        return mVertices != nullptr && mNumVertices > 0;
    }

    //! @brief Check whether the mesh contains faces. If no special scene flags
    //!        are set this should always return true
    //! @return true, if faces are stored, false if not.
    bool HasFaces() const {
        return mFaces != nullptr && mNumFaces > 0;
    }

    //! @brief Check whether the mesh contains normal vectors
    //! @return true, if normals are stored, false if not.
    bool HasNormals() const {
        return mNormals != nullptr && mNumVertices > 0;
    }

    //! @brief Check whether the mesh contains tangent and bitangent vectors.
    //! 
    //! It is not possible that it contains tangents and no bitangents
    //! (or the other way round). The existence of one of them
    //! implies that the second is there, too.
    //! @return true, if tangents and bi-tangents are stored, false if not.
    bool HasTangentsAndBitangents() const {
        return mTangents != nullptr && mBitangents != nullptr && mNumVertices > 0;
    }

    //! @brief Check whether the mesh contains a vertex color set
    //! @param index    Index of the vertex color set
    //! @return true, if vertex colors are stored, false if not.
    bool HasVertexColors(unsigned int index) const {
        if (index >= AI_MAX_NUMBER_OF_COLOR_SETS) {
            return false;
        }
        return mColors[index] != nullptr && mNumVertices > 0;        
    }

    //! @brief Check whether the mesh contains a texture coordinate set
    //! @param index    Index of the texture coordinates set
    //! @return true, if texture coordinates are stored, false if not.
    bool HasTextureCoords(unsigned int index) const {
        if (index >= AI_MAX_NUMBER_OF_TEXTURECOORDS) {
            return false;
        }
        return (mTextureCoords[index] != nullptr && mNumVertices > 0);
    }

    //! @brief Get the number of UV channels the mesh contains.
    //! @return the number of stored uv-channels.
    unsigned int GetNumUVChannels() const {
        unsigned int n(0);
        while (n < AI_MAX_NUMBER_OF_TEXTURECOORDS && mTextureCoords[n]) {
            ++n;
        }

        return n;
    }

    //! @brief Get the number of vertex color channels the mesh contains.
    //! @return The number of stored color channels.
    unsigned int GetNumColorChannels() const {
        unsigned int n(0);
        while (n < AI_MAX_NUMBER_OF_COLOR_SETS && mColors[n]) {
            ++n;
        }
        return n;
    }

    //! @brief Check whether the mesh contains bones.
    //! @return true, if bones are stored.
    bool HasBones() const {
        return mBones != nullptr && mNumBones > 0;
    }

    //! @brief  Check whether the mesh contains a texture coordinate set name
    //! @param pIndex Index of the texture coordinates set
    //! @return true, if texture coordinates for the index exists.
    bool HasTextureCoordsName(unsigned int pIndex) const {
        if (mTextureCoordsNames == nullptr || pIndex >= AI_MAX_NUMBER_OF_TEXTURECOORDS) {
            return false;
        }
        return mTextureCoordsNames[pIndex] != nullptr;
    }

    //! @brief  Set a texture coordinate set name
    //! @param pIndex Index of the texture coordinates set
    //! @param texCoordsName name of the texture coordinate set
    void SetTextureCoordsName(unsigned int pIndex, const aiString &texCoordsName) {
        if (pIndex >= AI_MAX_NUMBER_OF_TEXTURECOORDS) {
            return;
        }

        if (mTextureCoordsNames == nullptr) {
            // Construct and null-init array
            mTextureCoordsNames = new aiString *[AI_MAX_NUMBER_OF_TEXTURECOORDS];
            for (size_t i=0; i<AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i) {
                mTextureCoordsNames[i] = nullptr;
            }
        }

        if (texCoordsName.length == 0) {
            delete mTextureCoordsNames[pIndex];
            mTextureCoordsNames[pIndex] = nullptr;
            return;
        }

        if (mTextureCoordsNames[pIndex] == nullptr) {
            mTextureCoordsNames[pIndex] = new aiString(texCoordsName);
            return;
        }

        *mTextureCoordsNames[pIndex] = texCoordsName;
    }

    //! @brief  Get a texture coordinate set name
    //! @param  pIndex Index of the texture coordinates set
    //! @return The texture coordinate name.
    const aiString *GetTextureCoordsName(unsigned int index) const {
        if (mTextureCoordsNames == nullptr || index >= AI_MAX_NUMBER_OF_TEXTURECOORDS) {
            return nullptr;
        }

        return mTextureCoordsNames[index];
    }

#endif // __cplusplus
};

/**
 * @brief  A skeleton bone represents a single bone is a skeleton structure.
 *
 * Skeleton-Animations can be represented via a skeleton struct, which describes
 * a hierarchical tree assembled from skeleton bones. A bone is linked to a mesh.
 * The bone knows its parent bone. If there is no parent bone the parent id is
 * marked with -1.
 * The skeleton-bone stores a pointer to its used armature. If there is no
 * armature this value if set to nullptr.
 * A skeleton bone stores its offset-matrix, which is the absolute transformation
 * for the bone. The bone stores the locale transformation to its parent as well.
 * You can compute the offset matrix by multiplying the hierarchy like:
 * Tree: s1 -> s2 -> s3
 * Offset-Matrix s3 = locale-s3 * locale-s2 * locale-s1
 */
struct aiSkeletonBone {
    /// The parent bone index, is -1 one if this bone represents the root bone.
    int mParent;


#ifndef ASSIMP_BUILD_NO_ARMATUREPOPULATE_PROCESS
    /// @brief The bone armature node - used for skeleton conversion
    /// you must enable aiProcess_PopulateArmatureData to populate this
    C_STRUCT aiNode *mArmature;

    /// @brief The bone node in the scene - used for skeleton conversion
    /// you must enable aiProcess_PopulateArmatureData to populate this
    C_STRUCT aiNode *mNode;

#endif
    /// @brief The number of weights
    unsigned int mNumnWeights;

    /// The mesh index, which will get influenced by the weight.
    C_STRUCT aiMesh *mMeshId;

    /// The influence weights of this bone, by vertex index.
    C_STRUCT aiVertexWeight *mWeights;

    /** Matrix that transforms from bone space to mesh space in bind pose.
     *
     * This matrix describes the position of the mesh
     * in the local space of this bone when the skeleton was bound.
     * Thus it can be used directly to determine a desired vertex position,
     * given the world-space transform of the bone when animated,
     * and the position of the vertex in mesh space.
     *
     * It is sometimes called an inverse-bind matrix,
     * or inverse bind pose matrix.
     */
    C_STRUCT aiMatrix4x4 mOffsetMatrix;

    /// Matrix that transforms the locale bone in bind pose.
    C_STRUCT aiMatrix4x4 mLocalMatrix;

#ifdef __cplusplus
    ///	@brief The class constructor.
    aiSkeletonBone() :
            mParent(-1),
#ifndef ASSIMP_BUILD_NO_ARMATUREPOPULATE_PROCESS
            mArmature(nullptr),
            mNode(nullptr),
#endif
            mNumnWeights(0),
            mMeshId(nullptr),
            mWeights(nullptr),
            mOffsetMatrix(),
            mLocalMatrix() {
        // empty
    }

    /// @brief The class constructor with its parent
    /// @param  parent      The parent node index.
    aiSkeletonBone(unsigned int parent) :
            mParent(parent),
#ifndef ASSIMP_BUILD_NO_ARMATUREPOPULATE_PROCESS
            mArmature(nullptr),
            mNode(nullptr),
#endif
            mNumnWeights(0),
            mMeshId(nullptr),
            mWeights(nullptr),
            mOffsetMatrix(),
            mLocalMatrix() {
        // empty
    }
    /// @brief The class destructor.
    ~aiSkeletonBone() {
        delete[] mWeights;
        mWeights = nullptr;
    }
#endif // __cplusplus
};
/**
 * @brief A skeleton represents the bone hierarchy of an animation.
 *
 * Skeleton animations can be described as a tree of bones:
 *                  root
 *                    |
 *                  node1
 *                  /   \
 *               node3  node4
 * If you want to calculate the transformation of node three you need to compute the
 * transformation hierarchy for the transformation chain of node3:
 * root->node1->node3
 * Each node is represented as a skeleton instance.
 */
struct aiSkeleton {
    /**
     *  @brief The name of the skeleton instance.
     */
    C_STRUCT aiString mName;

    /**
     *  @brief  The number of bones in the skeleton.
     */
    unsigned int mNumBones;

    /**
     *  @brief The bone instance in the skeleton.
     */
    C_STRUCT aiSkeletonBone **mBones;

#ifdef __cplusplus
    /**
     *  @brief The class constructor.
     */
    aiSkeleton() AI_NO_EXCEPT : mName(), mNumBones(0), mBones(nullptr) {
        // empty
    }

    /**
     *  @brief  The class destructor.
     */
    ~aiSkeleton() {
        delete[] mBones;
    }
#endif // __cplusplus
};
#ifdef __cplusplus
}
#endif //! extern "C"

#endif // AI_MESH_H_INC



============================================================
File Path: project/externals/assimp/include/assimp/metadata.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file metadata.h
 *  @brief Defines the data structures for holding node meta information.
 */
#pragma once
#ifndef AI_METADATA_H_INC
#define AI_METADATA_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

#if defined(_MSC_VER) && (_MSC_VER <= 1500)
#include "Compiler/pstdint.h"
#else
#include <stdint.h>
#endif

#include <assimp/quaternion.h>

// -------------------------------------------------------------------------------
/**
  * Enum used to distinguish data types
  */
// -------------------------------------------------------------------------------
typedef enum aiMetadataType {
    AI_BOOL = 0,
    AI_INT32 = 1,
    AI_UINT64 = 2,
    AI_FLOAT = 3,
    AI_DOUBLE = 4,
    AI_AISTRING = 5,
    AI_AIVECTOR3D = 6,
    AI_AIMETADATA = 7,
    AI_INT64 = 8,
    AI_UINT32 = 9,
    AI_META_MAX = 10,

#ifndef SWIG
    FORCE_32BIT = INT_MAX
#endif
} aiMetadataType;

// -------------------------------------------------------------------------------
/**
  * Metadata entry
  *
  * The type field uniquely identifies the underlying type of the data field
  */
// -------------------------------------------------------------------------------
struct aiMetadataEntry {
    aiMetadataType mType;
    void *mData;

#ifdef __cplusplus
    aiMetadataEntry() :
            mType(AI_META_MAX),
            mData( nullptr ) {
        // empty
    }
#endif
};

#ifdef __cplusplus

#include <string>

struct aiMetadata;

// -------------------------------------------------------------------------------
/**
  * Helper functions to get the aiType enum entry for a type
  */
// -------------------------------------------------------------------------------

inline aiMetadataType GetAiType(bool) {
    return AI_BOOL;
}
inline aiMetadataType GetAiType(int32_t) {
    return AI_INT32;
}
inline aiMetadataType GetAiType(uint64_t) {
    return AI_UINT64;
}
inline aiMetadataType GetAiType(float) {
    return AI_FLOAT;
}
inline aiMetadataType GetAiType(double) {
    return AI_DOUBLE;
}
inline aiMetadataType GetAiType(const aiString &) {
    return AI_AISTRING;
}
inline aiMetadataType GetAiType(const aiVector3D &) {
    return AI_AIVECTOR3D;
}
inline aiMetadataType GetAiType(const aiMetadata &) {
    return AI_AIMETADATA;
}
inline aiMetadataType GetAiType(int64_t) {
    return AI_INT64;
}
inline aiMetadataType GetAiType(uint32_t) {
    return AI_UINT32;
}

#endif // __cplusplus

// -------------------------------------------------------------------------------
/**
  * Container for holding metadata.
  *
  * Metadata is a key-value store using string keys and values.
  */
// -------------------------------------------------------------------------------
struct aiMetadata {
    /** Length of the mKeys and mValues arrays, respectively */
    unsigned int mNumProperties;

    /** Arrays of keys, may not be NULL. Entries in this array may not be NULL as well. */
    C_STRUCT aiString *mKeys;

    /** Arrays of values, may not be NULL. Entries in this array may be NULL if the
      * corresponding property key has no assigned value. */
    C_STRUCT aiMetadataEntry *mValues;

#ifdef __cplusplus

    /**
     *  @brief  The default constructor, set all members to zero by default.
     */
    aiMetadata() AI_NO_EXCEPT
            : mNumProperties(0),
              mKeys(nullptr),
              mValues(nullptr) {
        // empty
    }

    aiMetadata(const aiMetadata &rhs) :
            mNumProperties(rhs.mNumProperties), mKeys(nullptr), mValues(nullptr) {
        mKeys = new aiString[mNumProperties];
        for (size_t i = 0; i < static_cast<size_t>(mNumProperties); ++i) {
            mKeys[i] = rhs.mKeys[i];
        }
        mValues = new aiMetadataEntry[mNumProperties];
        for (size_t i = 0; i < static_cast<size_t>(mNumProperties); ++i) {
            mValues[i].mType = rhs.mValues[i].mType;
            switch (rhs.mValues[i].mType) {
            case AI_BOOL:
                mValues[i].mData = new bool;
                ::memcpy(mValues[i].mData, rhs.mValues[i].mData, sizeof(bool));
                break;
            case AI_INT32: {
                int32_t v;
                ::memcpy(&v, rhs.mValues[i].mData, sizeof(int32_t));
                mValues[i].mData = new int32_t(v);
            } break;
            case AI_UINT64: {
                uint64_t v;
                ::memcpy(&v, rhs.mValues[i].mData, sizeof(uint64_t));
                mValues[i].mData = new uint64_t(v);
            } break;
            case AI_FLOAT: {
                float v;
                ::memcpy(&v, rhs.mValues[i].mData, sizeof(float));
                mValues[i].mData = new float(v);
            } break;
            case AI_DOUBLE: {
                double v;
                ::memcpy(&v, rhs.mValues[i].mData, sizeof(double));
                mValues[i].mData = new double(v);
            } break;
            case AI_AISTRING: {
                aiString v;
                rhs.Get<aiString>(static_cast<unsigned int>(i), v);
                mValues[i].mData = new aiString(v);
            } break;
            case AI_AIVECTOR3D: {
                aiVector3D v;
                rhs.Get<aiVector3D>(static_cast<unsigned int>(i), v);
                mValues[i].mData = new aiVector3D(v);
            } break;
            case AI_AIMETADATA: {
                aiMetadata v;
                rhs.Get<aiMetadata>(static_cast<unsigned int>(i), v);
                mValues[i].mData = new aiMetadata(v);
            } break;
            case AI_INT64: {
                int64_t v;
                ::memcpy(&v, rhs.mValues[i].mData, sizeof(int64_t));
                mValues[i].mData = new int64_t(v);
            } break;
            case AI_UINT32: {
                uint32_t v;
                ::memcpy(&v, rhs.mValues[i].mData, sizeof(uint32_t));
                mValues[i].mData = new uint32_t(v);
            } break;
#ifndef SWIG
            case FORCE_32BIT:
#endif
            default:
                break;
            }
        }
    }

    aiMetadata &operator=(aiMetadata rhs) {
        using std::swap;
        swap(mNumProperties, rhs.mNumProperties);
        swap(mKeys, rhs.mKeys);
        swap(mValues, rhs.mValues);
        return *this;
    }

    /**
     *  @brief The destructor.
     */
    ~aiMetadata() {
        delete[] mKeys;
        mKeys = nullptr;
        if (mValues) {
            // Delete each metadata entry
            for (unsigned i = 0; i < mNumProperties; ++i) {
                void *data = mValues[i].mData;
                switch (mValues[i].mType) {
                case AI_BOOL:
                    delete static_cast<bool *>(data);
                    break;
                case AI_INT32:
                    delete static_cast<int32_t *>(data);
                    break;
                case AI_UINT64:
                    delete static_cast<uint64_t *>(data);
                    break;
                case AI_FLOAT:
                    delete static_cast<float *>(data);
                    break;
                case AI_DOUBLE:
                    delete static_cast<double *>(data);
                    break;
                case AI_AISTRING:
                    delete static_cast<aiString *>(data);
                    break;
                case AI_AIVECTOR3D:
                    delete static_cast<aiVector3D *>(data);
                    break;
                case AI_AIMETADATA:
                    delete static_cast<aiMetadata *>(data);
                    break;
                case AI_INT64:
                    delete static_cast<int64_t *>(data);
                    break;
                case AI_UINT32:
                    delete static_cast<uint32_t *>(data);
                    break;
#ifndef SWIG
                case FORCE_32BIT:
#endif
                default:
                    break;
                }
            }

            // Delete the metadata array
            delete[] mValues;
            mValues = nullptr;
        }
    }

    /**
     *  @brief Allocates property fields + keys.
     *  @param  numProperties   Number of requested properties.
     */
    static inline aiMetadata *Alloc(unsigned int numProperties) {
        if (0 == numProperties) {
            return nullptr;
        }

        aiMetadata *data = new aiMetadata;
        data->mNumProperties = numProperties;
        data->mKeys = new aiString[data->mNumProperties]();
        data->mValues = new aiMetadataEntry[data->mNumProperties]();

        return data;
    }

    /**
     *  @brief Deallocates property fields + keys.
     */
    static inline void Dealloc(aiMetadata *metadata) {
        delete metadata;
    }

    template <typename T>
    inline void Add(const std::string &key, const T &value) {
        aiString *new_keys = new aiString[mNumProperties + 1];
        aiMetadataEntry *new_values = new aiMetadataEntry[mNumProperties + 1];

        for (unsigned int i = 0; i < mNumProperties; ++i) {
            new_keys[i] = mKeys[i];
            new_values[i] = mValues[i];
        }

        delete[] mKeys;
        delete[] mValues;

        mKeys = new_keys;
        mValues = new_values;

        mNumProperties++;

        Set(mNumProperties - 1, key, value);
    }

    template <typename T>
    inline bool Set(unsigned index, const std::string &key, const T &value) {
        // In range assertion
        if (index >= mNumProperties) {
            return false;
        }

        // Ensure that we have a valid key.
        if (key.empty()) {
            return false;
        }

        // Set metadata key
        mKeys[index] = key;

        // Set metadata type
        mValues[index].mType = GetAiType(value);

        // Copy the given value to the dynamic storage
        if (nullptr != mValues[index].mData && AI_AIMETADATA != mValues[index].mType) {
            ::memcpy(mValues[index].mData, &value, sizeof(T));
        } else if (nullptr != mValues[index].mData && AI_AIMETADATA == mValues[index].mType) {
            *static_cast<T *>(mValues[index].mData) = value;
        } else {
            if (nullptr != mValues[index].mData) {
                delete static_cast<T *>(mValues[index].mData);
                mValues[index].mData = nullptr;
            }
            mValues[index].mData = new T(value);
        }

        return true;
    }

    template <typename T>
    inline bool Set(const std::string &key, const T &value) {
        if (key.empty()) {
            return false;
        }

        bool result = false;
        for (unsigned int i = 0; i < mNumProperties; ++i) {
            if (key == mKeys[i].C_Str()) {
                Set(i, key, value);
                result = true;
                break;
            }
        }

        return result;
    }

    template <typename T>
    inline bool Get(unsigned index, T &value) const {
        // In range assertion
        if (index >= mNumProperties) {
            return false;
        }

        // Return false if the output data type does
        // not match the found value's data type
        if (GetAiType(value) != mValues[index].mType) {
            return false;
        }

        // Otherwise, output the found value and
        // return true
        value = *static_cast<T *>(mValues[index].mData);

        return true;
    }

    template <typename T>
    inline bool Get(const aiString &key, T &value) const {
        // Search for the given key
        for (unsigned int i = 0; i < mNumProperties; ++i) {
            if (mKeys[i] == key) {
                return Get(i, value);
            }
        }
        return false;
    }

    template <typename T>
    inline bool Get(const std::string &key, T &value) const {
        return Get(aiString(key), value);
    }

    /// Return metadata entry for analyzing it by user.
    /// \param [in] pIndex - index of the entry.
    /// \param [out] pKey - pointer to the key value.
    /// \param [out] pEntry - pointer to the entry: type and value.
    /// \return false - if pIndex is out of range, else - true.
    inline bool Get(size_t index, const aiString *&key, const aiMetadataEntry *&entry) const {
        if (index >= mNumProperties) {
            return false;
        }

        key = &mKeys[index];
        entry = &mValues[index];

        return true;
    }

    /// Check whether there is a metadata entry for the given key.
    /// \param [in] Key - the key value value to check for.
    inline bool HasKey(const char *key) const {
        if (nullptr == key) {
            return false;
        }

        // Search for the given key
        for (unsigned int i = 0; i < mNumProperties; ++i) {
            if (0 == strncmp(mKeys[i].C_Str(), key, mKeys[i].length)) {
                return true;
            }
        }
        return false;
    }

    friend bool CompareKeys(const aiMetadata &lhs, const aiMetadata &rhs) {
        if (lhs.mNumProperties != rhs.mNumProperties) {
            return false;
        }

        for (unsigned int i = 0; i < lhs.mNumProperties; ++i) {
            if (lhs.mKeys[i] != rhs.mKeys[i]) {
                return false;
            }
        }
        return true;
    }

    friend bool CompareValues(const aiMetadata &lhs, const aiMetadata &rhs) {
        if (lhs.mNumProperties != rhs.mNumProperties) {
            return false;
        }

        for (unsigned int i = 0; i < lhs.mNumProperties; ++i) {
            if (lhs.mValues[i].mType != rhs.mValues[i].mType) {
                return false;
            }

            switch (lhs.mValues[i].mType) {
            case AI_BOOL: {
                if (*static_cast<bool *>(lhs.mValues[i].mData) != *static_cast<bool *>(rhs.mValues[i].mData)) {
                    return false;
                }
            } break;
            case AI_INT32: {
                if (*static_cast<int32_t *>(lhs.mValues[i].mData) != *static_cast<int32_t *>(rhs.mValues[i].mData)) {
                    return false;
                }
            } break;
            case AI_UINT64: {
                if (*static_cast<uint64_t *>(lhs.mValues[i].mData) != *static_cast<uint64_t *>(rhs.mValues[i].mData)) {
                    return false;
                }
            } break;
            case AI_FLOAT: {
                if (*static_cast<float *>(lhs.mValues[i].mData) != *static_cast<float *>(rhs.mValues[i].mData)) {
                    return false;
                }
            } break;
            case AI_DOUBLE: {
                if (*static_cast<double *>(lhs.mValues[i].mData) != *static_cast<double *>(rhs.mValues[i].mData)) {
                    return false;
                }
            } break;
            case AI_AISTRING: {
                if (*static_cast<aiString *>(lhs.mValues[i].mData) != *static_cast<aiString *>(rhs.mValues[i].mData)) {
                    return false;
                }
            } break;
            case AI_AIVECTOR3D: {
                if (*static_cast<aiVector3D *>(lhs.mValues[i].mData) != *static_cast<aiVector3D *>(rhs.mValues[i].mData)) {
                    return false;
                }
            } break;
            case AI_AIMETADATA: {
                if (*static_cast<aiMetadata *>(lhs.mValues[i].mData) != *static_cast<aiMetadata *>(rhs.mValues[i].mData)) {
                    return false;
                }
            } break;
            case AI_INT64: {
                if (*static_cast<int64_t *>(lhs.mValues[i].mData) != *static_cast<int64_t *>(rhs.mValues[i].mData)) {
                    return false;
                }
            } break;
            case AI_UINT32: {
                if (*static_cast<uint32_t *>(lhs.mValues[i].mData) != *static_cast<uint32_t *>(rhs.mValues[i].mData)) {
                    return false;
                }
            } break;
#ifndef SWIG
            case FORCE_32BIT:
#endif
            default:
                break;
            }
        }

        return true;
    }

    friend bool operator==(const aiMetadata &lhs, const aiMetadata &rhs) {
        return CompareKeys(lhs, rhs) && CompareValues(lhs, rhs);
    }

    friend bool operator!=(const aiMetadata &lhs, const aiMetadata &rhs) {
        return !(lhs == rhs);
    }

#endif // __cplusplus
};

#endif // AI_METADATA_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/pbrmaterial.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file pbrmaterial.h
 *  @brief Deprecated GLTF_PBR macros
 */
#pragma once
#ifndef AI_PBRMATERIAL_H_INC
#define AI_PBRMATERIAL_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#   warning pbrmaterial.h is deprecated. Please update to PBR materials in materials.h and glTF-specific items in GltfMaterial.h
#else if defined(_MSC_VER)
#   pragma message("pbrmaterial.h is deprecated. Please update to PBR materials in materials.h and glTF-specific items in GltfMaterial.h")
#endif

#include <assimp/material.h>
#include <assimp/GltfMaterial.h>

#define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_BASE_COLOR_FACTOR AI_MATKEY_BASE_COLOR
#define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_BASE_COLOR_TEXTURE AI_MATKEY_BASE_COLOR_TEXTURE
#define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_METALLIC_FACTOR AI_MATKEY_METALLIC_FACTOR
#define AI_MATKEY_GLTF_PBRMETALLICROUGHNESS_ROUGHNESS_FACTOR AI_MATKEY_ROUGHNESS_FACTOR

#define AI_MATKEY_GLTF_PBRSPECULARGLOSSINESS AI_MATKEY_GLOSSINESS_FACTOR
#define AI_MATKEY_GLTF_PBRSPECULARGLOSSINESS_GLOSSINESS_FACTOR AI_MATKEY_GLOSSINESS_FACTOR

// Use AI_MATKEY_SHADING_MODEL == aiShadingMode_Unlit instead
#define AI_MATKEY_GLTF_UNLIT "$mat.gltf.unlit", 0, 0

//AI_MATKEY_GLTF_MATERIAL_SHEEN
#define AI_MATKEY_GLTF_MATERIAL_SHEEN_COLOR_FACTOR AI_MATKEY_SHEEN_COLOR_FACTOR
#define AI_MATKEY_GLTF_MATERIAL_SHEEN_ROUGHNESS_FACTOR AI_MATKEY_SHEEN_ROUGHNESS_FACTOR
#define AI_MATKEY_GLTF_MATERIAL_SHEEN_COLOR_TEXTURE AI_MATKEY_SHEEN_COLOR_TEXTURE
#define AI_MATKEY_GLTF_MATERIAL_SHEEN_ROUGHNESS_TEXTURE AI_MATKEY_SHEEN_ROUGHNESS_TEXTURE

//AI_MATKEY_GLTF_MATERIAL_CLEARCOAT
#define AI_MATKEY_GLTF_MATERIAL_CLEARCOAT_FACTOR AI_MATKEY_CLEARCOAT_FACTOR
#define AI_MATKEY_GLTF_MATERIAL_CLEARCOAT_ROUGHNESS_FACTOR AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR
#define AI_MATKEY_GLTF_MATERIAL_CLEARCOAT_TEXTURE AI_MATKEY_CLEARCOAT_TEXTURE
#define AI_MATKEY_GLTF_MATERIAL_CLEARCOAT_ROUGHNESS_TEXTURE AI_MATKEY_CLEARCOAT_ROUGHNESS_TEXTURE
#define AI_MATKEY_GLTF_MATERIAL_CLEARCOAT_NORMAL_TEXTURE AI_MATKEY_CLEARCOAT_NORMAL_TEXTURE

//AI_MATKEY_GLTF_MATERIAL_TRANSMISSION
#define AI_MATKEY_GLTF_MATERIAL_TRANSMISSION_FACTOR AI_MATKEY_TRANSMISSION_FACTOR
#define AI_MATKEY_GLTF_MATERIAL_TRANSMISSION_TEXTURE AI_MATKEY_TRANSMISSION_TEXTURE

#define AI_MATKEY_GLTF_TEXTURE_TEXCOORD(type, N) AI_MATKEY_UVWSRC(type, N)

#endif //!!AI_PBRMATERIAL_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/port/AndroidJNI/AndroidJNIIOSystem.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2021, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Android implementation of IOSystem using the standard C file functions.
 * Aimed to ease the access to android assets */

#if __ANDROID__ and __ANDROID_API__ > 9 and defined(AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT)
#ifndef AI_ANDROIDJNIIOSYSTEM_H_INC
#define AI_ANDROIDJNIIOSYSTEM_H_INC

#include <assimp/DefaultIOSystem.h>
#include <android/asset_manager.h>
#include <android/asset_manager_jni.h>
#include <android/native_activity.h>

namespace Assimp	{

// ---------------------------------------------------------------------------
/** Android extension to DefaultIOSystem using the standard C file functions */
class ASSIMP_API AndroidJNIIOSystem : public DefaultIOSystem {
public:
	/** Initialize android activity data */
	std::string mApkWorkspacePath;
	AAssetManager* mApkAssetManager;

	/// Constructor.
	AndroidJNIIOSystem(ANativeActivity* activity);

    /// Class constructor with past and asset manager.
	AndroidJNIIOSystem(const char *internalPath, AAssetManager* assetManager);

	/// Destructor.
	~AndroidJNIIOSystem();

	/// Tests for the existence of a file at the given path.
	bool Exists( const char* pFile) const;

	/// Opens a file at the given path, with given mode
	IOStream* Open( const char* strFile, const char* strMode);

	/// Inits Android extractor
	void AndroidActivityInit(ANativeActivity* activity);

	/// Extracts android asset
	bool AndroidExtractAsset(std::string name);
};

} //!ns Assimp

#endif //AI_ANDROIDJNIIOSYSTEM_H_INC
#endif //__ANDROID__ and __ANDROID_API__ > 9 and defined(AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT)


============================================================
File Path: project/externals/assimp/include/assimp/port/AndroidJNI/BundledAssetIOSystem.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2021, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file Android implementation of IOSystem using the standard C file functions.
 * Aimed to ease the access to android assets */

#if __ANDROID__ and __ANDROID_API__ > 9 and defined(AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT)
#ifndef AI_BUNDLEDASSETIOSYSTEM_H_INC
#define AI_BUNDLEDASSETIOSYSTEM_H_INC

#include <android/asset_manager_jni.h>

#include <assimp/DefaultIOSystem.h>
#include <assimp/IOStream.hpp>

namespace Assimp        {

class BundledAssetIOSystem : public Assimp::DefaultIOSystem {

public:
    AAssetManager* mApkAssetManager;

    BundledAssetIOSystem(JNIEnv* env, jobject assetManager) { mApkAssetManager = AAssetManager_fromJava(env, assetManager); }
    ~BundledAssetIOSystem() {};

    bool Exists( const char* pFile) const;

    Assimp::IOStream* Open( const char* pFile, const char* pMode = "rb");

    void Close( Assimp::IOStream* pFile);

private:

    class AssetIOStream : public Assimp::IOStream {
        AAsset * asset;

    public:
        AssetIOStream(AAsset *asset) { this->asset = asset; };
        ~AssetIOStream() { AAsset_close(asset); }

        size_t Read(void* pvBuffer, size_t pSize, size_t pCount) { return AAsset_read(asset, pvBuffer, pSize * pCount);}
        size_t Write(const void* pvBuffer, size_t pSize, size_t pCount) { return 0; };
        aiReturn Seek(size_t pOffset, aiOrigin pOrigin) { return (AAsset_seek(asset, pOffset, pOrigin) >= 0 ? aiReturn_SUCCESS : aiReturn_FAILURE); }
        size_t Tell() const { return(AAsset_getLength(asset) - AAsset_getRemainingLength(asset)); };
        size_t FileSize() const  { return  AAsset_getLength(asset); }
        void Flush() { }
    };

};


} //!ns Assimp

#endif //AI_BUNDLEDASSETIOSYSTEM_H_INC
#endif //__ANDROID__ and __ANDROID_API__ > 9 and defined(AI_CONFIG_ANDROID_JNI_ASSIMP_MANAGER_SUPPORT)



============================================================
File Path: project/externals/assimp/include/assimp/postprocess.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team


All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file postprocess.h
 *  @brief Definitions for import post processing steps
 */
#pragma once
#ifndef AI_POSTPROCESS_H_INC
#define AI_POSTPROCESS_H_INC

#include <assimp/types.h>

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#ifdef __cplusplus
extern "C" {
#endif

// -----------------------------------------------------------------------------------
/** @enum  aiPostProcessSteps
 *  @brief Defines the flags for all possible post processing steps.
 *
 *  @note Some steps are influenced by properties set on the Assimp::Importer itself
 *
 *  @see Assimp::Importer::ReadFile()
 *  @see Assimp::Importer::SetPropertyInteger()
 *  @see aiImportFile
 *  @see aiImportFileEx
 */
// -----------------------------------------------------------------------------------
enum aiPostProcessSteps
{

    // -------------------------------------------------------------------------
    /** <hr>Calculates the tangents and bitangents for the imported meshes.
     *
     * Does nothing if a mesh does not have normals. You might want this post
     * processing step to be executed if you plan to use tangent space calculations
     * such as normal mapping  applied to the meshes. There's an importer property,
     * <tt>#AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE</tt>, which allows you to specify
     * a maximum smoothing angle for the algorithm. However, usually you'll
     * want to leave it at the default value.
     */
    aiProcess_CalcTangentSpace = 0x1,

    // -------------------------------------------------------------------------
    /** <hr>Identifies and joins identical vertex data sets within all
     *  imported meshes.
     *
     * After this step is run, each mesh contains unique vertices,
     * so a vertex may be used by multiple faces. You usually want
     * to use this post processing step. If your application deals with
     * indexed geometry, this step is compulsory or you'll just waste rendering
     * time. <b>If this flag is not specified</b>, no vertices are referenced by
     * more than one face and <b>no index buffer is required</b> for rendering.
     * Unless the importer (like ply) had to split vertices. Then you need one regardless.
     */
    aiProcess_JoinIdenticalVertices = 0x2,

    // -------------------------------------------------------------------------
    /** <hr>Converts all the imported data to a left-handed coordinate space.
     *
     * By default the data is returned in a right-handed coordinate space (which
     * OpenGL prefers). In this space, +X points to the right,
     * +Z points towards the viewer, and +Y points upwards. In the DirectX
     * coordinate space +X points to the right, +Y points upwards, and +Z points
     * away from the viewer.
     *
     * You'll probably want to consider this flag if you use Direct3D for
     * rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this
     * setting and bundles all conversions typically required for D3D-based
     * applications.
     */
    aiProcess_MakeLeftHanded = 0x4,

    // -------------------------------------------------------------------------
    /** <hr>Triangulates all faces of all meshes.
     *
     * By default the imported mesh data might contain faces with more than 3
     * indices. For rendering you'll usually want all faces to be triangles.
     * This post processing step splits up faces with more than 3 indices into
     * triangles. Line and point primitives are *not* modified! If you want
     * 'triangles only' with no other kinds of primitives, try the following
     * solution:
     * <ul>
     * <li>Specify both #aiProcess_Triangulate and #aiProcess_SortByPType </li>
     * <li>Ignore all point and line meshes when you process assimp's output</li>
     * </ul>
     */
    aiProcess_Triangulate = 0x8,

    // -------------------------------------------------------------------------
    /** <hr>Removes some parts of the data structure (animations, materials,
     *  light sources, cameras, textures, vertex components).
     *
     * The  components to be removed are specified in a separate
     * importer property, <tt>#AI_CONFIG_PP_RVC_FLAGS</tt>. This is quite useful
     * if you don't need all parts of the output structure. Vertex colors
     * are rarely used today for example... Calling this step to remove unneeded
     * data from the pipeline as early as possible results in increased
     * performance and a more optimized output data structure.
     * This step is also useful if you want to force Assimp to recompute
     * normals or tangents. The corresponding steps don't recompute them if
     * they're already there (loaded from the source asset). By using this
     * step you can make sure they are NOT there.
     *
     * This flag is a poor one, mainly because its purpose is usually
     * misunderstood. Consider the following case: a 3D model has been exported
     * from a CAD app, and it has per-face vertex colors. Vertex positions can't be
     * shared, thus the #aiProcess_JoinIdenticalVertices step fails to
     * optimize the data because of these nasty little vertex colors.
     * Most apps don't even process them, so it's all for nothing. By using
     * this step, unneeded components are excluded as early as possible
     * thus opening more room for internal optimizations.
     */
    aiProcess_RemoveComponent = 0x10,

    // -------------------------------------------------------------------------
    /** <hr>Generates normals for all faces of all meshes.
     *
     * This is ignored if normals are already there at the time this flag
     * is evaluated. Model importers try to load them from the source file, so
     * they're usually already there. Face normals are shared between all points
     * of a single face, so a single point can have multiple normals, which
     * forces the library to duplicate vertices in some cases.
     * #aiProcess_JoinIdenticalVertices is *senseless* then.
     *
     * This flag may not be specified together with #aiProcess_GenSmoothNormals.
     */
    aiProcess_GenNormals = 0x20,

    // -------------------------------------------------------------------------
    /** <hr>Generates smooth normals for all vertices in the mesh.
    *
    * This is ignored if normals are already there at the time this flag
    * is evaluated. Model importers try to load them from the source file, so
    * they're usually already there.
    *
    * This flag may not be specified together with
    * #aiProcess_GenNormals. There's a importer property,
    * <tt>#AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE</tt> which allows you to specify
    * an angle maximum for the normal smoothing algorithm. Normals exceeding
    * this limit are not smoothed, resulting in a 'hard' seam between two faces.
    * Using a decent angle here (e.g. 80 degrees) results in very good visual
    * appearance.
    */
    aiProcess_GenSmoothNormals = 0x40,

    // -------------------------------------------------------------------------
    /** <hr>Splits large meshes into smaller sub-meshes.
    *
    * This is quite useful for real-time rendering, where the number of triangles
    * which can be maximally processed in a single draw-call is limited
    * by the video driver/hardware. The maximum vertex buffer is usually limited
    * too. Both requirements can be met with this step: you may specify both a
    * triangle and vertex limit for a single mesh.
    *
    * The split limits can (and should!) be set through the
    * <tt>#AI_CONFIG_PP_SLM_VERTEX_LIMIT</tt> and <tt>#AI_CONFIG_PP_SLM_TRIANGLE_LIMIT</tt>
    * importer properties. The default values are <tt>#AI_SLM_DEFAULT_MAX_VERTICES</tt> and
    * <tt>#AI_SLM_DEFAULT_MAX_TRIANGLES</tt>.
    *
    * Note that splitting is generally a time-consuming task, but only if there's
    * something to split. The use of this step is recommended for most users.
    */
    aiProcess_SplitLargeMeshes = 0x80,

    // -------------------------------------------------------------------------
    /** <hr>Removes the node graph and pre-transforms all vertices with
    * the local transformation matrices of their nodes.
    *
    * If the resulting scene can be reduced to a single mesh, with a single
    * material, no lights, and no cameras, then the output scene will contain
    * only a root node (with no children) that references the single mesh.
    * Otherwise, the output scene will be reduced to a root node with a single
    * level of child nodes, each one referencing one mesh, and each mesh
    * referencing one material.
    *
    * In either case, for rendering, you can
    * simply render all meshes in order - you don't need to pay
    * attention to local transformations and the node hierarchy.
    * Animations are removed during this step.
    * This step is intended for applications without a scenegraph.
    * The step CAN cause some problems: if e.g. a mesh of the asset
    * contains normals and another, using the same material index, does not,
    * they will be brought together, but the first meshes's part of
    * the normal list is zeroed. However, these artifacts are rare.
    * @note The <tt>#AI_CONFIG_PP_PTV_NORMALIZE</tt> configuration property
    * can be set to normalize the scene's spatial dimension to the -1...1
    * range.
    */
    aiProcess_PreTransformVertices = 0x100,

    // -------------------------------------------------------------------------
    /** <hr>Limits the number of bones simultaneously affecting a single vertex
    *  to a maximum value.
    *
    * If any vertex is affected by more than the maximum number of bones, the least
    * important vertex weights are removed and the remaining vertex weights are
    * renormalized so that the weights still sum up to 1.
    * The default bone weight limit is 4 (defined as <tt>#AI_LMW_MAX_WEIGHTS</tt> in
    * config.h), but you can use the <tt>#AI_CONFIG_PP_LBW_MAX_WEIGHTS</tt> importer
    * property to supply your own limit to the post processing step.
    *
    * If you intend to perform the skinning in hardware, this post processing
    * step might be of interest to you.
    */
    aiProcess_LimitBoneWeights = 0x200,

    // -------------------------------------------------------------------------
    /** <hr>Validates the imported scene data structure.
     * This makes sure that all indices are valid, all animations and
     * bones are linked correctly, all material references are correct .. etc.
     *
     * It is recommended that you capture Assimp's log output if you use this flag,
     * so you can easily find out what's wrong if a file fails the
     * validation. The validator is quite strict and will find *all*
     * inconsistencies in the data structure... It is recommended that plugin
     * developers use it to debug their loaders. There are two types of
     * validation failures:
     * <ul>
     * <li>Error: There's something wrong with the imported data. Further
     *   postprocessing is not possible and the data is not usable at all.
     *   The import fails. #Importer::GetErrorString() or #aiGetErrorString()
     *   carry the error message around.</li>
     * <li>Warning: There are some minor issues (e.g. 1000000 animation
     *   keyframes with the same time), but further postprocessing and use
     *   of the data structure is still safe. Warning details are written
     *   to the log file, <tt>#AI_SCENE_FLAGS_VALIDATION_WARNING</tt> is set
     *   in #aiScene::mFlags</li>
     * </ul>
     *
     * This post-processing step is not time-consuming. Its use is not
     * compulsory, but recommended.
    */
    aiProcess_ValidateDataStructure = 0x400,

    // -------------------------------------------------------------------------
    /** <hr>Reorders triangles for better vertex cache locality.
     *
     * The step tries to improve the ACMR (average post-transform vertex cache
     * miss ratio) for all meshes. The implementation runs in O(n) and is
     * roughly based on the 'tipsify' algorithm (see <a href="
     * http://www.cs.princeton.edu/gfx/pubs/Sander_2007_%3ETR/tipsy.pdf">this
     * paper</a>).
     *
     * If you intend to render huge models in hardware, this step might
     * be of interest to you. The <tt>#AI_CONFIG_PP_ICL_PTCACHE_SIZE</tt>
     * importer property can be used to fine-tune the cache optimization.
     */
    aiProcess_ImproveCacheLocality = 0x800,

    // -------------------------------------------------------------------------
    /** <hr>Searches for redundant/unreferenced materials and removes them.
     *
     * This is especially useful in combination with the
     * #aiProcess_PreTransformVertices and #aiProcess_OptimizeMeshes flags.
     * Both join small meshes with equal characteristics, but they can't do
     * their work if two meshes have different materials. Because several
     * material settings are lost during Assimp's import filters,
     * (and because many exporters don't check for redundant materials), huge
     * models often have materials which are are defined several times with
     * exactly the same settings.
     *
     * Several material settings not contributing to the final appearance of
     * a surface are ignored in all comparisons (e.g. the material name).
     * So, if you're passing additional information through the
     * content pipeline (probably using *magic* material names), don't
     * specify this flag. Alternatively take a look at the
     * <tt>#AI_CONFIG_PP_RRM_EXCLUDE_LIST</tt> importer property.
     */
    aiProcess_RemoveRedundantMaterials = 0x1000,

    // -------------------------------------------------------------------------
    /** <hr>This step tries to determine which meshes have normal vectors
     * that are facing inwards and inverts them.
     *
     * The algorithm is simple but effective:
     * the bounding box of all vertices + their normals is compared against
     * the volume of the bounding box of all vertices without their normals.
     * This works well for most objects, problems might occur with planar
     * surfaces. However, the step tries to filter such cases.
     * The step inverts all in-facing normals. Generally it is recommended
     * to enable this step, although the result is not always correct.
    */
    aiProcess_FixInfacingNormals = 0x2000,



    // -------------------------------------------------------------------------
    /**
     * This step generically populates aiBone->mArmature and aiBone->mNode generically
     * The point of these is it saves you later having to calculate these elements
     * This is useful when handling rest information or skin information
     * If you have multiple armatures on your models we strongly recommend enabling this
     * Instead of writing your own multi-root, multi-armature lookups we have done the
     * hard work for you :)
   */
    aiProcess_PopulateArmatureData = 0x4000,

    // -------------------------------------------------------------------------
    /** <hr>This step splits meshes with more than one primitive type in
     *  homogeneous sub-meshes.
     *
     *  The step is executed after the triangulation step. After the step
     *  returns, just one bit is set in aiMesh::mPrimitiveTypes. This is
     *  especially useful for real-time rendering where point and line
     *  primitives are often ignored or rendered separately.
     *  You can use the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to
     *  specify which primitive types you need. This can be used to easily
     *  exclude lines and points, which are rarely used, from the import.
    */
    aiProcess_SortByPType = 0x8000,

    // -------------------------------------------------------------------------
    /** <hr>This step searches all meshes for degenerate primitives and
     *  converts them to proper lines or points.
     *
     * A face is 'degenerate' if one or more of its points are identical.
     * To have the degenerate stuff not only detected and collapsed but
     * removed, try one of the following procedures:
     * <br><b>1.</b> (if you support lines and points for rendering but don't
     *    want the degenerates)<br>
     * <ul>
     *   <li>Specify the #aiProcess_FindDegenerates flag.
     *   </li>
     *   <li>Set the <tt>#AI_CONFIG_PP_FD_REMOVE</tt> importer property to
     *       1. This will cause the step to remove degenerate triangles from the
     *       import as soon as they're detected. They won't pass any further
     *       pipeline steps.
     *   </li>
     * </ul>
     * <br><b>2.</b>(if you don't support lines and points at all)<br>
     * <ul>
     *   <li>Specify the #aiProcess_FindDegenerates flag.
     *   </li>
     *   <li>Specify the #aiProcess_SortByPType flag. This moves line and
     *     point primitives to separate meshes.
     *   </li>
     *   <li>Set the <tt>#AI_CONFIG_PP_SBP_REMOVE</tt> importer property to
     *       @code aiPrimitiveType_POINTS | aiPrimitiveType_LINES
     *       @endcode to cause SortByPType to reject point
     *       and line meshes from the scene.
     *   </li>
     * </ul>
     *
     * This step also removes very small triangles with a surface area smaller
     * than 10^-6. If you rely on having these small triangles, or notice holes
     * in your model, set the property <tt>#AI_CONFIG_PP_FD_CHECKAREA</tt> to
     * false.
     * @note Degenerate polygons are not necessarily evil and that's why
     * they're not removed by default. There are several file formats which
     * don't support lines or points, and some exporters bypass the
     * format specification and write them as degenerate triangles instead.
    */
    aiProcess_FindDegenerates = 0x10000,

    // -------------------------------------------------------------------------
    /** <hr>This step searches all meshes for invalid data, such as zeroed
     *  normal vectors or invalid UV coords and removes/fixes them. This is
     *  intended to get rid of some common exporter errors.
     *
     * This is especially useful for normals. If they are invalid, and
     * the step recognizes this, they will be removed and can later
     * be recomputed, i.e. by the #aiProcess_GenSmoothNormals flag.<br>
     * The step will also remove meshes that are infinitely small and reduce
     * animation tracks consisting of hundreds if redundant keys to a single
     * key. The <tt>AI_CONFIG_PP_FID_ANIM_ACCURACY</tt> config property decides
     * the accuracy of the check for duplicate animation tracks.
    */
    aiProcess_FindInvalidData = 0x20000,

    // -------------------------------------------------------------------------
    /** <hr>This step converts non-UV mappings (such as spherical or
     *  cylindrical mapping) to proper texture coordinate channels.
     *
     * Most applications will support UV mapping only, so you will
     * probably want to specify this step in every case. Note that Assimp is not
     * always able to match the original mapping implementation of the
     * 3D app which produced a model perfectly. It's always better to let the
     * modelling app compute the UV channels - 3ds max, Maya, Blender,
     * LightWave, and Modo do this for example.
     *
     * @note If this step is not requested, you'll need to process the
     * <tt>#AI_MATKEY_MAPPING</tt> material property in order to display all assets
     * properly.
     */
    aiProcess_GenUVCoords = 0x40000,

    // -------------------------------------------------------------------------
    /** <hr>This step applies per-texture UV transformations and bakes
     *  them into stand-alone vtexture coordinate channels.
     *
     * UV transformations are specified per-texture - see the
     * <tt>#AI_MATKEY_UVTRANSFORM</tt> material key for more information.
     * This step processes all textures with
     * transformed input UV coordinates and generates a new (pre-transformed) UV channel
     * which replaces the old channel. Most applications won't support UV
     * transformations, so you will probably want to specify this step.
     *
     * @note UV transformations are usually implemented in real-time apps by
     * transforming texture coordinates at vertex shader stage with a 3x3
     * (homogeneous) transformation matrix.
    */
    aiProcess_TransformUVCoords = 0x80000,

    // -------------------------------------------------------------------------
    /** <hr>This step searches for duplicate meshes and replaces them
     *  with references to the first mesh.
     *
     *  This step takes a while, so don't use it if speed is a concern.
     *  Its main purpose is to workaround the fact that many export
     *  file formats don't support instanced meshes, so exporters need to
     *  duplicate meshes. This step removes the duplicates again. Please
     *  note that Assimp does not currently support per-node material
     *  assignment to meshes, which means that identical meshes with
     *  different materials are currently *not* joined, although this is
     *  planned for future versions.
     */
    aiProcess_FindInstances = 0x100000,

    // -------------------------------------------------------------------------
    /** <hr>A post-processing step to reduce the number of meshes.
     *
     *  This will, in fact, reduce the number of draw calls.
     *
     *  This is a very effective optimization and is recommended to be used
     *  together with #aiProcess_OptimizeGraph, if possible. The flag is fully
     *  compatible with both #aiProcess_SplitLargeMeshes and #aiProcess_SortByPType.
    */
    aiProcess_OptimizeMeshes  = 0x200000,


    // -------------------------------------------------------------------------
    /** <hr>A post-processing step to optimize the scene hierarchy.
     *
     *  Nodes without animations, bones, lights or cameras assigned are
     *  collapsed and joined.
     *
     *  Node names can be lost during this step. If you use special 'tag nodes'
     *  to pass additional information through your content pipeline, use the
     *  <tt>#AI_CONFIG_PP_OG_EXCLUDE_LIST</tt> importer property to specify a
     *  list of node names you want to be kept. Nodes matching one of the names
     *  in this list won't be touched or modified.
     *
     *  Use this flag with caution. Most simple files will be collapsed to a
     *  single node, so complex hierarchies are usually completely lost. This is not
     *  useful for editor environments, but probably a very effective
     *  optimization if you just want to get the model data, convert it to your
     *  own format, and render it as fast as possible.
     *
     *  This flag is designed to be used with #aiProcess_OptimizeMeshes for best
     *  results.
     *
     *  @note 'Crappy' scenes with thousands of extremely small meshes packed
     *  in deeply nested nodes exist for almost all file formats.
     *  #aiProcess_OptimizeMeshes in combination with #aiProcess_OptimizeGraph
     *  usually fixes them all and makes them renderable.
    */
    aiProcess_OptimizeGraph  = 0x400000,

    // -------------------------------------------------------------------------
    /** <hr>This step flips all UV coordinates along the y-axis and adjusts
     * material settings and bitangents accordingly.
     *
     * <b>Output UV coordinate system:</b>
     * @code
     * 0y|0y ---------- 1x|0y
     * |                 |
     * |                 |
     * |                 |
     * 0x|1y ---------- 1x|1y
     * @endcode
     *
     * You'll probably want to consider this flag if you use Direct3D for
     * rendering. The #aiProcess_ConvertToLeftHanded flag supersedes this
     * setting and bundles all conversions typically required for D3D-based
     * applications.
    */
    aiProcess_FlipUVs = 0x800000,

    // -------------------------------------------------------------------------
    /** <hr>This step adjusts the output face winding order to be CW.
     *
     * The default face winding order is counter clockwise (CCW).
     *
     * <b>Output face order:</b>
     * @code
     *       x2
     *
     *                         x0
     *  x1
     * @endcode
    */
    aiProcess_FlipWindingOrder  = 0x1000000,

    // -------------------------------------------------------------------------
    /** <hr>This step splits meshes with many bones into sub-meshes so that each
     * sub-mesh has fewer or as many bones as a given limit.
    */
    aiProcess_SplitByBoneCount  = 0x2000000,

    // -------------------------------------------------------------------------
    /** <hr>This step removes bones losslessly or according to some threshold.
     *
     *  In some cases (i.e. formats that require it) exporters are forced to
     *  assign dummy bone weights to otherwise static meshes assigned to
     *  animated meshes. Full, weight-based skinning is expensive while
     *  animating nodes is extremely cheap, so this step is offered to clean up
     *  the data in that regard.
     *
     *  Use <tt>#AI_CONFIG_PP_DB_THRESHOLD</tt> to control this.
     *  Use <tt>#AI_CONFIG_PP_DB_ALL_OR_NONE</tt> if you want bones removed if and
     *  only if all bones within the scene qualify for removal.
    */
    aiProcess_Debone  = 0x4000000,



    // -------------------------------------------------------------------------
    /** <hr>This step will perform a global scale of the model.
    *
    *  Some importers are providing a mechanism to define a scaling unit for the
    *  model. This post processing step can be used to do so. You need to get the
    *  global scaling from your importer settings like in FBX. Use the flag
    *  AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY from the global property table to configure this.
    *
    *  Use <tt>#AI_CONFIG_GLOBAL_SCALE_FACTOR_KEY</tt> to setup the global scaling factor.
    */
    aiProcess_GlobalScale = 0x8000000,

    // -------------------------------------------------------------------------
    /** <hr>A postprocessing step to embed of textures.
     *
     *  This will remove external data dependencies for textures.
     *  If a texture's file does not exist at the specified path
     *  (due, for instance, to an absolute path generated on another system),
     *  it will check if a file with the same name exists at the root folder
     *  of the imported model. And if so, it uses that.
     */
    aiProcess_EmbedTextures  = 0x10000000,

    // aiProcess_GenEntityMeshes = 0x100000,
    // aiProcess_OptimizeAnimations = 0x200000
    // aiProcess_FixTexturePaths = 0x200000


    aiProcess_ForceGenNormals = 0x20000000,

    // -------------------------------------------------------------------------
    /** <hr>Drops normals for all faces of all meshes.
     *
     * This is ignored if no normals are present.
     * Face normals are shared between all points of a single face,
     * so a single point can have multiple normals, which
     * forces the library to duplicate vertices in some cases.
     * #aiProcess_JoinIdenticalVertices is *senseless* then.
     * This process gives sense back to aiProcess_JoinIdenticalVertices
     */
    aiProcess_DropNormals = 0x40000000,

    // -------------------------------------------------------------------------
    /**
     */
    aiProcess_GenBoundingBoxes = 0x80000000
};


// ---------------------------------------------------------------------------------------
/** @def aiProcess_ConvertToLeftHanded
 *  @brief Shortcut flag for Direct3D-based applications.
 *
 *  Supersedes the #aiProcess_MakeLeftHanded and #aiProcess_FlipUVs and
 *  #aiProcess_FlipWindingOrder flags.
 *  The output data matches Direct3D's conventions: left-handed geometry, upper-left
 *  origin for UV coordinates and finally clockwise face order, suitable for CCW culling.
 *
 *  @deprecated
 */
#define aiProcess_ConvertToLeftHanded ( \
    aiProcess_MakeLeftHanded     | \
    aiProcess_FlipUVs            | \
    aiProcess_FlipWindingOrder   | \
    0 )


// ---------------------------------------------------------------------------------------
/** @def aiProcessPreset_TargetRealtime_Fast
 *  @brief Default postprocess configuration optimizing the data for real-time rendering.
 *
 *  Applications would want to use this preset to load models on end-user PCs,
 *  maybe for direct use in game.
 *
 * If you're using DirectX, don't forget to combine this value with
 * the #aiProcess_ConvertToLeftHanded step. If you don't support UV transformations
 * in your application apply the #aiProcess_TransformUVCoords step, too.
 *  @note Please take the time to read the docs for the steps enabled by this preset.
 *  Some of them offer further configurable properties, while some of them might not be of
 *  use for you so it might be better to not specify them.
 */
#define aiProcessPreset_TargetRealtime_Fast ( \
    aiProcess_CalcTangentSpace      |  \
    aiProcess_GenNormals            |  \
    aiProcess_JoinIdenticalVertices |  \
    aiProcess_Triangulate           |  \
    aiProcess_GenUVCoords           |  \
    aiProcess_SortByPType           |  \
    0 )

 // ---------------------------------------------------------------------------------------
 /** @def aiProcessPreset_TargetRealtime_Quality
  *  @brief Default postprocess configuration optimizing the data for real-time rendering.
  *
  *  Unlike #aiProcessPreset_TargetRealtime_Fast, this configuration
  *  performs some extra optimizations to improve rendering speed and
  *  to minimize memory usage. It could be a good choice for a level editor
  *  environment where import speed is not so important.
  *
  *  If you're using DirectX, don't forget to combine this value with
  *  the #aiProcess_ConvertToLeftHanded step. If you don't support UV transformations
  *  in your application apply the #aiProcess_TransformUVCoords step, too.
  *  @note Please take the time to read the docs for the steps enabled by this preset.
  *  Some of them offer further configurable properties, while some of them might not be
  *  of use for you so it might be better to not specify them.
  */
#define aiProcessPreset_TargetRealtime_Quality ( \
    aiProcess_CalcTangentSpace              |  \
    aiProcess_GenSmoothNormals              |  \
    aiProcess_JoinIdenticalVertices         |  \
    aiProcess_ImproveCacheLocality          |  \
    aiProcess_LimitBoneWeights              |  \
    aiProcess_RemoveRedundantMaterials      |  \
    aiProcess_SplitLargeMeshes              |  \
    aiProcess_Triangulate                   |  \
    aiProcess_GenUVCoords                   |  \
    aiProcess_SortByPType                   |  \
    aiProcess_FindDegenerates               |  \
    aiProcess_FindInvalidData               |  \
    0 )

 // ---------------------------------------------------------------------------------------
 /** @def aiProcessPreset_TargetRealtime_MaxQuality
  *  @brief Default postprocess configuration optimizing the data for real-time rendering.
  *
  *  This preset enables almost every optimization step to achieve perfectly
  *  optimized data. It's your choice for level editor environments where import speed
  *  is not important.
  *
  *  If you're using DirectX, don't forget to combine this value with
  *  the #aiProcess_ConvertToLeftHanded step. If you don't support UV transformations
  *  in your application, apply the #aiProcess_TransformUVCoords step, too.
  *  @note Please take the time to read the docs for the steps enabled by this preset.
  *  Some of them offer further configurable properties, while some of them might not be
  *  of use for you so it might be better to not specify them.
  */
#define aiProcessPreset_TargetRealtime_MaxQuality ( \
    aiProcessPreset_TargetRealtime_Quality   |  \
    aiProcess_FindInstances                  |  \
    aiProcess_ValidateDataStructure          |  \
    aiProcess_OptimizeMeshes                 |  \
    0 )


#ifdef __cplusplus
} // end of extern "C"
#endif

#endif // AI_POSTPROCESS_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/qnan.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team



All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/**  @file  qnan.h
 *   @brief Some utilities for our dealings with qnans.
 *
 *   @note Some loaders use qnans to mark invalid values tempoarily, also
 *     Assimp explicitly enforces undefined normals to be set to qnan.
 *     qnan utilities are available in standard libraries (C99 for example)
 *     but last time I checked compiler coverage was so bad that I decided
 *     to reinvent the wheel.
 */
#pragma once
#ifndef AI_QNAN_H_INCLUDED
#define AI_QNAN_H_INCLUDED

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/defs.h>

#include <limits>
#include <stdint.h>

// ---------------------------------------------------------------------------
/** Data structure to represent the bit pattern of a 32 Bit
 *         IEEE 754 floating-point number. */
union _IEEESingle {
    float Float;
    struct
    {
        uint32_t Frac : 23;
        uint32_t Exp  : 8;
        uint32_t Sign : 1;
    } IEEE;
};

// ---------------------------------------------------------------------------
/** Data structure to represent the bit pattern of a 64 Bit
 *         IEEE 754 floating-point number. */
union _IEEEDouble {
    double Double;
    struct
    {
        uint64_t Frac : 52;
        uint64_t Exp  : 11;
        uint64_t Sign : 1;
    } IEEE;
};

// ---------------------------------------------------------------------------
/** Check whether a given float is qNaN.
 *  @param in Input value */
AI_FORCE_INLINE bool is_qnan(float in) {
    // the straightforward solution does not work:
    //   return (in != in);
    // compiler generates code like this
    //   load <in> to <register-with-different-width>
    //   compare <register-with-different-width> against <in>

    // FIXME: Use <float> stuff instead? I think fpclassify needs C99
    _IEEESingle temp;
    memcpy(&temp, &in, sizeof(float));
    return (temp.IEEE.Exp == (1u << 8)-1 &&
        temp.IEEE.Frac);
}

// ---------------------------------------------------------------------------
/** Check whether a given double is qNaN.
 *  @param in Input value */
AI_FORCE_INLINE bool is_qnan(double in) {
    // the straightforward solution does not work:
    //   return (in != in);
    // compiler generates code like this
    //   load <in> to <register-with-different-width>
    //   compare <register-with-different-width> against <in>

    // FIXME: Use <float> stuff instead? I think fpclassify needs C99
    _IEEEDouble temp;
    memcpy(&temp, &in, sizeof(in));
    return (temp.IEEE.Exp == (1u << 11)-1 &&
        temp.IEEE.Frac);
}

// ---------------------------------------------------------------------------
/** @brief check whether a float is either NaN or (+/-) INF.
 *
 *  Denorms return false, they're treated like normal values.
 *  @param in Input value */
AI_FORCE_INLINE bool is_special_float(float in) {
    _IEEESingle temp;
    memcpy(&temp, &in, sizeof(float));
    return (temp.IEEE.Exp == (1u << 8)-1);
}

// ---------------------------------------------------------------------------
/** @brief check whether a double is either NaN or (+/-) INF.
 *
 *  Denorms return false, they're treated like normal values.
 *  @param in Input value */
AI_FORCE_INLINE bool is_special_float(double in) {
   _IEEESingle temp;
    memcpy(&temp, &in, sizeof(float));
    return (temp.IEEE.Exp == (1u << 11)-1);
}

// ---------------------------------------------------------------------------
/** Check whether a float is NOT qNaN.
 *  @param in Input value */
template<class TReal>
AI_FORCE_INLINE bool is_not_qnan(TReal in) {
    return !is_qnan(in);
}

// ---------------------------------------------------------------------------
/** @brief Get a fresh qnan.  */
AI_FORCE_INLINE ai_real get_qnan() {
    return std::numeric_limits<ai_real>::quiet_NaN();
}

#endif // !! AI_QNAN_H_INCLUDED


============================================================
File Path: project/externals/assimp/include/assimp/quaternion.h
============================================================
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
----------------------------------------------------------------------
*/

/** @file quaternion.h
 *  @brief Quaternion structure, including operators when compiling in C++
 */
#pragma once
#ifndef AI_QUATERNION_H_INC
#define AI_QUATERNION_H_INC

#ifdef __cplusplus

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/defs.h>

// Forward declarations
template <typename TReal> class aiVector3t;
template <typename TReal> class aiMatrix3x3t;
template <typename TReal> class aiMatrix4x4t;

// ---------------------------------------------------------------------------
/**
 *  @brief  This class represents a quaternion as a 4D vector.
 */
template <typename TReal>
class aiQuaterniont {
public:
    aiQuaterniont() AI_NO_EXCEPT : w(1.0), x(), y(), z() {}
    aiQuaterniont(TReal pw, TReal px, TReal py, TReal pz)
        : w(pw), x(px), y(py), z(pz) {}

    /**
     *  @brief  Construct from rotation matrix. Result is undefined if the matrix is not orthonormal.
     */
    explicit aiQuaterniont( const aiMatrix3x3t<TReal>& pRotMatrix);

    /** Construct from euler angles */
    aiQuaterniont( TReal roty, TReal rotz, TReal rotx);

    /** Construct from an axis-angle pair */
    aiQuaterniont( aiVector3t<TReal> axis, TReal angle);

    /** Construct from a normalized quaternion stored in a vec3 */
    explicit aiQuaterniont( aiVector3t<TReal> normalized);

    /** Returns a matrix representation of the quaternion */
    aiMatrix3x3t<TReal> GetMatrix() const;

    bool operator== (const aiQuaterniont& o) const;
    bool operator!= (const aiQuaterniont& o) const;

    // transform vector by matrix
    aiQuaterniont& operator *= (const aiMatrix4x4t<TReal>& mat);

    bool Equal(const aiQuaterniont &o, TReal epsilon = ai_epsilon) const;

    /**
     *  @brief  Will normalize the quaternion representation.
     */
    aiQuaterniont& Normalize();

    /**
     *  @brief  Will compute the quaternion conjugate. The result will be stored in the instance.
     */
    aiQuaterniont& Conjugate();

    /**
     *  @brief  Rotate a point by this quaternion
     */
    aiVector3t<TReal> Rotate(const aiVector3t<TReal>& in) const;

    /**
     *  @brief Multiply two quaternions
     *  @param  two   The other quaternion.
     *  @return The result of the multiplication.
     */
    aiQuaterniont operator * (const aiQuaterniont& two) const;

    /**
     * @brief Performs a spherical interpolation between two quaternions and writes the result into the third.
     * @param pOut Target object to received the interpolated rotation.
     * @param pStart Start rotation of the interpolation at factor == 0.
     * @param pEnd End rotation, factor == 1.
     * @param pFactor Interpolation factor between 0 and 1. Values outside of this range yield undefined results.
     */
    static void Interpolate( aiQuaterniont& pOut, const aiQuaterniont& pStart,
        const aiQuaterniont& pEnd, TReal pFactor);

    //! w,x,y,z components of the quaternion
    TReal w, x, y, z;
} ;

using aiQuaternion = aiQuaterniont<ai_real>;

#else

struct aiQuaternion {
    ai_real w, x, y, z;
};

#endif

#endif // AI_QUATERNION_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/scene.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file scene.h
 *  @brief Defines the data structures in which the imported scene is returned.
 */
#pragma once
#ifndef AI_SCENE_H_INC
#define AI_SCENE_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/types.h>
#include <assimp/texture.h>
#include <assimp/mesh.h>
#include <assimp/light.h>
#include <assimp/camera.h>
#include <assimp/material.h>
#include <assimp/anim.h>
#include <assimp/metadata.h>

#ifdef __cplusplus
#  include <cstdlib>
extern "C" {
#endif

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wattributes"
#endif

// -------------------------------------------------------------------------------
/**
 * A node in the imported hierarchy.
 *
 * Each node has name, a parent node (except for the root node),
 * a transformation relative to its parent and possibly several child nodes.
 * Simple file formats don't support hierarchical structures - for these formats
 * the imported scene does consist of only a single root node without children.
 */
// -------------------------------------------------------------------------------
struct ASSIMP_API aiNode {
    /** The name of the node.
     *
     * The name might be empty (length of zero) but all nodes which
     * need to be referenced by either bones or animations are named.
     * Multiple nodes may have the same name, except for nodes which are referenced
     * by bones (see #aiBone and #aiMesh::mBones). Their names *must* be unique.
     *
     * Cameras and lights reference a specific node by name - if there
     * are multiple nodes with this name, they are assigned to each of them.
     * <br>
     * There are no limitations with regard to the characters contained in
     * the name string as it is usually taken directly from the source file.
     *
     * Implementations should be able to handle tokens such as whitespace, tabs,
     * line feeds, quotation marks, ampersands etc.
     *
     * Sometimes assimp introduces new nodes not present in the source file
     * into the hierarchy (usually out of necessity because sometimes the
     * source hierarchy format is simply not compatible). Their names are
     * surrounded by @verbatim <> @endverbatim e.g.
     *  @verbatim<DummyRootNode> @endverbatim.
     */
    C_STRUCT aiString mName;

    /** The transformation relative to the node's parent. */
    C_STRUCT aiMatrix4x4 mTransformation;

    /** Parent node. nullptr if this node is the root node. */
    C_STRUCT aiNode* mParent;

    /** The number of child nodes of this node. */
    unsigned int mNumChildren;

    /** The child nodes of this node. nullptr if mNumChildren is 0. */
    C_STRUCT aiNode** mChildren;

    /** The number of meshes of this node. */
    unsigned int mNumMeshes;

    /** The meshes of this node. Each entry is an index into the
      * mesh list of the #aiScene.
      */
    unsigned int* mMeshes;

    /** Metadata associated with this node or nullptr if there is no metadata.
      *  Whether any metadata is generated depends on the source file format. See the
      * @link importer_notes @endlink page for more information on every source file
      * format. Importers that don't document any metadata don't write any.
      */
    C_STRUCT aiMetadata* mMetaData;

#ifdef __cplusplus
    /** Constructor */
    aiNode();

    /** Construction from a specific name */
    explicit aiNode(const std::string& name);

    /** Destructor */
    ~aiNode();

    /** Searches for a node with a specific name, beginning at this
     *  nodes. Normally you will call this method on the root node
     *  of the scene.
     *
     *  @param name Name to search for
     *  @return nullptr or a valid Node if the search was successful.
     */
    inline
    const aiNode* FindNode(const aiString& name) const {
        return FindNode(name.data);
    }

    inline
    aiNode* FindNode(const aiString& name) {
        return FindNode(name.data);
    }

    const aiNode* FindNode(const char* name) const;

    aiNode* FindNode(const char* name);

    /**
     * @brief   Will add new children.
     * @param   numChildren  Number of children to add.
     * @param   children     The array with pointers showing to the children.
     */
    void addChildren(unsigned int numChildren, aiNode **children);
#endif // __cplusplus
};

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

// -------------------------------------------------------------------------------
/**
 * Specifies that the scene data structure that was imported is not complete.
 * This flag bypasses some internal validations and allows the import
 * of animation skeletons, material libraries or camera animation paths
 * using Assimp. Most applications won't support such data.
 */
#define AI_SCENE_FLAGS_INCOMPLETE   0x1

/**
 * This flag is set by the validation postprocess-step (aiPostProcess_ValidateDS)
 * if the validation is successful. In a validated scene you can be sure that
 * any cross references in the data structure (e.g. vertex indices) are valid.
 */
#define AI_SCENE_FLAGS_VALIDATED    0x2

/**
 * This flag is set by the validation postprocess-step (aiPostProcess_ValidateDS)
 * if the validation is successful but some issues have been found.
 * This can for example mean that a texture that does not exist is referenced
 * by a material or that the bone weights for a vertex don't sum to 1.0 ... .
 * In most cases you should still be able to use the import. This flag could
 * be useful for applications which don't capture Assimp's log output.
 */
#define AI_SCENE_FLAGS_VALIDATION_WARNING   0x4

/**
 * This flag is currently only set by the aiProcess_JoinIdenticalVertices step.
 * It indicates that the vertices of the output meshes aren't in the internal
 * verbose format anymore. In the verbose format all vertices are unique,
 * no vertex is ever referenced by more than one face.
 */
#define AI_SCENE_FLAGS_NON_VERBOSE_FORMAT   0x8

 /**
 * Denotes pure height-map terrain data. Pure terrains usually consist of quads,
 * sometimes triangles, in a regular grid. The x,y coordinates of all vertex
 * positions refer to the x,y coordinates on the terrain height map, the z-axis
 * stores the elevation at a specific point.
 *
 * TER (Terragen) and HMP (3D Game Studio) are height map formats.
 * @note Assimp is probably not the best choice for loading *huge* terrains -
 * fully triangulated data takes extremely much free store and should be avoided
 * as long as possible (typically you'll do the triangulation when you actually
 * need to render it).
 */
#define AI_SCENE_FLAGS_TERRAIN 0x10

 /**
 * Specifies that the scene data can be shared between structures. For example:
 * one vertex in few faces. \ref AI_SCENE_FLAGS_NON_VERBOSE_FORMAT can not be
 * used for this because \ref AI_SCENE_FLAGS_NON_VERBOSE_FORMAT has internal
 * meaning about postprocessing steps.
 */
#define AI_SCENE_FLAGS_ALLOW_SHARED			0x20

// -------------------------------------------------------------------------------
/** The root structure of the imported data.
 *
 *  Everything that was imported from the given file can be accessed from here.
 *  Objects of this class are generally maintained and owned by Assimp, not
 *  by the caller. You shouldn't want to instance it, nor should you ever try to
 *  delete a given scene on your own.
 */
// -------------------------------------------------------------------------------
struct aiScene
{
    /** Any combination of the AI_SCENE_FLAGS_XXX flags. By default
    * this value is 0, no flags are set. Most applications will
    * want to reject all scenes with the AI_SCENE_FLAGS_INCOMPLETE
    * bit set.
    */
    unsigned int mFlags;

    /** The root node of the hierarchy.
    *
    * There will always be at least the root node if the import
    * was successful (and no special flags have been set).
    * Presence of further nodes depends on the format and content
    * of the imported file.
    */
    C_STRUCT aiNode* mRootNode;

    /** The number of meshes in the scene. */
    unsigned int mNumMeshes;

    /** The array of meshes.
    *
    * Use the indices given in the aiNode structure to access
    * this array. The array is mNumMeshes in size. If the
    * AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
    * be at least ONE material.
    */
    C_STRUCT aiMesh** mMeshes;

    /** The number of materials in the scene. */
    unsigned int mNumMaterials;

    /** The array of materials.
    *
    * Use the index given in each aiMesh structure to access this
    * array. The array is mNumMaterials in size. If the
    * AI_SCENE_FLAGS_INCOMPLETE flag is not set there will always
    * be at least ONE material.
    */
    C_STRUCT aiMaterial** mMaterials;

    /** The number of animations in the scene. */
    unsigned int mNumAnimations;

    /** The array of animations.
    *
    * All animations imported from the given file are listed here.
    * The array is mNumAnimations in size.
    */
    C_STRUCT aiAnimation** mAnimations;

    /** The number of textures embedded into the file */
    unsigned int mNumTextures;

    /** The array of embedded textures.
    *
    * Not many file formats embed their textures into the file.
    * An example is Quake's MDL format (which is also used by
    * some GameStudio versions)
    */
    C_STRUCT aiTexture** mTextures;

    /** The number of light sources in the scene. Light sources
    * are fully optional, in most cases this attribute will be 0
        */
    unsigned int mNumLights;

    /** The array of light sources.
    *
    * All light sources imported from the given file are
    * listed here. The array is mNumLights in size.
    */
    C_STRUCT aiLight** mLights;

    /** The number of cameras in the scene. Cameras
    * are fully optional, in most cases this attribute will be 0
        */
    unsigned int mNumCameras;

    /** The array of cameras.
    *
    * All cameras imported from the given file are listed here.
    * The array is mNumCameras in size. The first camera in the
    * array (if existing) is the default camera view into
    * the scene.
    */
    C_STRUCT aiCamera** mCameras;

    /**
     *  @brief  The global metadata assigned to the scene itself.
     *
     *  This data contains global metadata which belongs to the scene like
     *  unit-conversions, versions, vendors or other model-specific data. This
     *  can be used to store format-specific metadata as well.
     */
    C_STRUCT aiMetadata* mMetaData;

    /** The name of the scene itself.
     */
    C_STRUCT aiString mName;

    /**
     *
     */
    unsigned int mNumSkeletons;

    /**
     *
     */
    C_STRUCT aiSkeleton **mSkeletons;

#ifdef __cplusplus

    //! Default constructor - set everything to 0/nullptr
    ASSIMP_API aiScene();

    //! Destructor
    ASSIMP_API ~aiScene();

    //! Check whether the scene contains meshes
    //! Unless no special scene flags are set this will always be true.
    inline bool HasMeshes() const {
        return mMeshes != nullptr && mNumMeshes > 0;
    }

    //! Check whether the scene contains materials
    //! Unless no special scene flags are set this will always be true.
    inline bool HasMaterials() const {
        return mMaterials != nullptr && mNumMaterials > 0;
    }

    //! Check whether the scene contains lights
    inline bool HasLights() const {
        return mLights != nullptr && mNumLights > 0;
    }

    //! Check whether the scene contains textures
    inline bool HasTextures() const {
        return mTextures != nullptr && mNumTextures > 0;
    }

    //! Check whether the scene contains cameras
    inline bool HasCameras() const {
        return mCameras != nullptr && mNumCameras > 0;
    }

    //! Check whether the scene contains animations
    inline bool HasAnimations() const {
        return mAnimations != nullptr && mNumAnimations > 0;
    }

    bool hasSkeletons() const {
        return mSkeletons != nullptr && mNumSkeletons > 0;
    }

    //! Returns a short filename from a full path
    static const char* GetShortFilename(const char* filename) {
        const char* lastSlash = strrchr(filename, '/');
        if (lastSlash == nullptr) {
            lastSlash = strrchr(filename, '\\');
        }
        const char* shortFilename = lastSlash != nullptr ? lastSlash + 1 : filename;
        return shortFilename;
    }

    //! Returns an embedded texture
    const aiTexture* GetEmbeddedTexture(const char* filename) const {
        return GetEmbeddedTextureAndIndex(filename).first;
    }

    //! Returns an embedded texture and its index
    std::pair<const aiTexture*, int> GetEmbeddedTextureAndIndex(const char* filename) const {
        if (nullptr==filename) {
            return std::make_pair(nullptr, -1);
        }
        // lookup using texture ID (if referenced like: "*1", "*2", etc.)
        if ('*' == *filename) {
            int index = std::atoi(filename + 1);
            if (0 > index || mNumTextures <= static_cast<unsigned>(index)) {
                return std::make_pair(nullptr, -1);
            }
            return std::make_pair(mTextures[index], index);
        }
        // lookup using filename
        const char* shortFilename = GetShortFilename(filename);
        if (nullptr == shortFilename) {
            return std::make_pair(nullptr, -1);
        }

        for (unsigned int i = 0; i < mNumTextures; i++) {
            const char* shortTextureFilename = GetShortFilename(mTextures[i]->mFilename.C_Str());
            if (strcmp(shortTextureFilename, shortFilename) == 0) {
                return std::make_pair(mTextures[i], static_cast<int>(i));
            }
        }
        return std::make_pair(nullptr, -1);
    }
#endif // __cplusplus

    /**  Internal data, do not touch */
#ifdef __cplusplus
    void* mPrivate;
#else
    char* mPrivate;
#endif

};

#ifdef __cplusplus
}
#endif //! extern "C"

#endif // AI_SCENE_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/texture.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file texture.h
 *  @brief Defines texture helper structures for the library
 *
 * Used for file formats which embed their textures into the model file.
 * Supported are both normal textures, which are stored as uncompressed
 * pixels, and "compressed" textures, which are stored in a file format
 * such as PNG or TGA.
 */
#pragma once
#ifndef AI_TEXTURE_H_INC
#define AI_TEXTURE_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#include <assimp/types.h>

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------------

/** \def AI_EMBEDDED_TEXNAME_PREFIX
 * \ref AI_MAKE_EMBEDDED_TEXNAME
 */
#ifndef AI_EMBEDDED_TEXNAME_PREFIX
#   define AI_EMBEDDED_TEXNAME_PREFIX	"*"
#endif

/** @def AI_MAKE_EMBEDDED_TEXNAME
 *  Used to build the reserved path name used by the material system to
 *  reference textures that are embedded into their corresponding
 *  model files. The parameter specifies the index of the texture
 *  (zero-based, in the aiScene::mTextures array)
 */
#if (!defined AI_MAKE_EMBEDDED_TEXNAME)
#   define AI_MAKE_EMBEDDED_TEXNAME(_n_) AI_EMBEDDED_TEXNAME_PREFIX # _n_
#endif

#include "./Compiler/pushpack1.h"

// --------------------------------------------------------------------------------
/** @brief Helper structure to represent a texel in a ARGB8888 format
*
*  Used by aiTexture.
*/
struct aiTexel {
    unsigned char b,g,r,a;

#ifdef __cplusplus
    //! Comparison operator
    bool operator== (const aiTexel& other) const {
        return b == other.b && r == other.r &&
               g == other.g && a == other.a;
    }

    //! Inverse comparison operator
    bool operator!= (const aiTexel& other) const {
        return b != other.b || r != other.r ||
               g != other.g || a != other.a;
    }

    //! Conversion to a floating-point 4d color
    operator aiColor4D() const {
        return aiColor4D(r/255.f,g/255.f,b/255.f,a/255.f);
    }
#endif // __cplusplus

} PACK_STRUCT;

#include "./Compiler/poppack1.h"

#define HINTMAXTEXTURELEN 9

// --------------------------------------------------------------------------------
/** Helper structure to describe an embedded texture
 *
 * Normally textures are contained in external files but some file formats embed
 * them directly in the model file. There are two types of embedded textures:
 * 1. Uncompressed textures. The color data is given in an uncompressed format.
 * 2. Compressed textures stored in a file format like png or jpg. The raw file
 * bytes are given so the application must utilize an image decoder (e.g. DevIL) to
 * get access to the actual color data.
 *
 * Embedded textures are referenced from materials using strings like "*0", "*1", etc.
 * as the texture paths (a single asterisk character followed by the
 * zero-based index of the texture in the aiScene::mTextures array).
 */
struct aiTexture {
    /** Width of the texture, in pixels
     *
     * If mHeight is zero the texture is compressed in a format
     * like JPEG. In this case mWidth specifies the size of the
     * memory area pcData is pointing to, in bytes.
     */
    unsigned int mWidth;

    /** Height of the texture, in pixels
     *
     * If this value is zero, pcData points to an compressed texture
     * in any format (e.g. JPEG).
     */
    unsigned int mHeight;

    /** A hint from the loader to make it easier for applications
     *  to determine the type of embedded textures.
     *
     * If mHeight != 0 this member is show how data is packed. Hint will consist of
     * two parts: channel order and channel bitness (count of the bits for every
     * color channel). For simple parsing by the viewer it's better to not omit
     * absent color channel and just use 0 for bitness. For example:
     * 1. Image contain RGBA and 8 bit per channel, achFormatHint == "rgba8888";
     * 2. Image contain ARGB and 8 bit per channel, achFormatHint == "argb8888";
     * 3. Image contain RGB and 5 bit for R and B channels and 6 bit for G channel, achFormatHint == "rgba5650";
     * 4. One color image with B channel and 1 bit for it, achFormatHint == "rgba0010";
     * If mHeight == 0 then achFormatHint is set set to '\\0\\0\\0\\0' if the loader has no additional
     * information about the texture file format used OR the
     * file extension of the format without a trailing dot. If there
     * are multiple file extensions for a format, the shortest
     * extension is chosen (JPEG maps to 'jpg', not to 'jpeg').
     * E.g. 'dds\\0', 'pcx\\0', 'jpg\\0'.  All characters are lower-case.
     * The fourth character will always be '\\0'.
     */
    char achFormatHint[ HINTMAXTEXTURELEN ];// 8 for string + 1 for terminator.

    /** Data of the texture.
     *
     * Points to an array of mWidth * mHeight aiTexel's.
     * The format of the texture data is always ARGB8888 to
     * make the implementation for user of the library as easy
     * as possible. If mHeight = 0 this is a pointer to a memory
     * buffer of size mWidth containing the compressed texture
     * data. Good luck, have fun!
     */
    C_STRUCT aiTexel* pcData;

    /** Texture original filename
    *
    * Used to get the texture reference
    */
    C_STRUCT aiString mFilename;

#ifdef __cplusplus

    //! For compressed textures (mHeight == 0): compare the
    //! format hint against a given string.
    //! @param s Input string. 3 characters are maximally processed.
    //!        Example values: "jpg", "png"
    //! @return true if the given string matches the format hint
    bool CheckFormat(const char* s) const {
        if (nullptr == s) {
            return false;
        }

		return (0 == ::strncmp(achFormatHint, s, sizeof(achFormatHint)));
    }

    // Construction
    aiTexture() AI_NO_EXCEPT :
            mWidth(0),
            mHeight(0),
            pcData(nullptr),
            mFilename() {
        memset(achFormatHint, 0, sizeof(achFormatHint));
    }

    // Destruction
    ~aiTexture () {
        delete[] pcData;
    }
#endif
};


#ifdef __cplusplus
}
#endif

#endif // AI_TEXTURE_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/types.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file types.h
 *  Basic data types and primitives, such as vectors or colors.
 */
#pragma once
#ifndef AI_TYPES_H_INC
#define AI_TYPES_H_INC

#ifdef __GNUC__
#pragma GCC system_header
#endif

// Some runtime headers
#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>

// Our compile configuration
#include <assimp/defs.h>

// Some types moved to separate header due to size of operators
#include <assimp/vector2.h>
#include <assimp/vector3.h>
#include <assimp/color4.h>
#include <assimp/matrix3x3.h>
#include <assimp/matrix4x4.h>
#include <assimp/quaternion.h>

typedef int32_t ai_int32;
typedef uint32_t ai_uint32;

#ifdef __cplusplus

#include <cstring>
#include <new>    // for std::nothrow_t
#include <string> // for aiString::Set(const std::string&)

namespace Assimp {
//! @cond never
namespace Intern {
// --------------------------------------------------------------------
/** @brief Internal helper class to utilize our internal new/delete
 *    routines for allocating object of this and derived classes.
 *
 * By doing this you can safely share class objects between Assimp
 * and the application - it works even over DLL boundaries. A good
 * example is the #IOSystem where the application allocates its custom
 * #IOSystem, then calls #Importer::SetIOSystem(). When the Importer
 * destructs, Assimp calls operator delete on the stored #IOSystem.
 * If it lies on a different heap than Assimp is working with,
 * the application is determined to crash.
 */
// --------------------------------------------------------------------
#ifndef SWIG
struct ASSIMP_API AllocateFromAssimpHeap {
    // http://www.gotw.ca/publications/mill15.htm

    // new/delete overload
    void *operator new(size_t num_bytes) /* throw( std::bad_alloc ) */;
    void *operator new(size_t num_bytes, const std::nothrow_t &) throw();
    void operator delete(void *data);

    // array new/delete overload
    void *operator new[](size_t num_bytes) /* throw( std::bad_alloc ) */;
    void *operator new[](size_t num_bytes, const std::nothrow_t &) throw();
    void operator delete[](void *data);

}; // struct AllocateFromAssimpHeap
#endif
} // namespace Intern
//! @endcond
} // namespace Assimp

extern "C" {
#endif

/** Maximum dimension for strings, ASSIMP strings are zero terminated. */
#ifdef __cplusplus
static const size_t MAXLEN = 1024;
#else
#define MAXLEN 1024
#endif

// ----------------------------------------------------------------------------------
/** Represents a plane in a three-dimensional, euclidean space
*/
struct aiPlane {
#ifdef __cplusplus
    aiPlane() AI_NO_EXCEPT : a(0.f), b(0.f), c(0.f), d(0.f) {}
    aiPlane(ai_real _a, ai_real _b, ai_real _c, ai_real _d) :
            a(_a), b(_b), c(_c), d(_d) {}

    aiPlane(const aiPlane &o) :
            a(o.a), b(o.b), c(o.c), d(o.d) {}

#endif // !__cplusplus

    //! Plane equation
    ai_real a, b, c, d;
}; // !struct aiPlane

// ----------------------------------------------------------------------------------
/** Represents a ray
*/
struct aiRay {
#ifdef __cplusplus
    aiRay() AI_NO_EXCEPT {}
    aiRay(const aiVector3D &_pos, const aiVector3D &_dir) :
            pos(_pos), dir(_dir) {}

    aiRay(const aiRay &o) :
            pos(o.pos), dir(o.dir) {}

#endif // !__cplusplus

    //! Position and direction of the ray
    C_STRUCT aiVector3D pos, dir;
}; // !struct aiRay

// ----------------------------------------------------------------------------------
/** Represents a color in Red-Green-Blue space.
*/
struct aiColor3D {
#ifdef __cplusplus
    aiColor3D() AI_NO_EXCEPT : r(0.0f), g(0.0f), b(0.0f) {}
    aiColor3D(ai_real _r, ai_real _g, ai_real _b) :
            r(_r), g(_g), b(_b) {}
    explicit aiColor3D(ai_real _r) :
            r(_r), g(_r), b(_r) {}
    aiColor3D(const aiColor3D &o) :
            r(o.r), g(o.g), b(o.b) {}

    aiColor3D &operator=(const aiColor3D &o) {
        r = o.r;
        g = o.g;
        b = o.b;
        return *this;
    }

    /** Component-wise comparison */
    // TODO: add epsilon?
    bool operator==(const aiColor3D &other) const { return r == other.r && g == other.g && b == other.b; }

    /** Component-wise inverse comparison */
    // TODO: add epsilon?
    bool operator!=(const aiColor3D &other) const { return r != other.r || g != other.g || b != other.b; }

    /** Component-wise comparison */
    // TODO: add epsilon?
    bool operator<(const aiColor3D &other) const {
        return r < other.r || (r == other.r && (g < other.g || (g == other.g && b < other.b)));
    }

    /** Component-wise addition */
    aiColor3D operator+(const aiColor3D &c) const {
        return aiColor3D(r + c.r, g + c.g, b + c.b);
    }

    /** Component-wise subtraction */
    aiColor3D operator-(const aiColor3D &c) const {
        return aiColor3D(r - c.r, g - c.g, b - c.b);
    }

    /** Component-wise multiplication */
    aiColor3D operator*(const aiColor3D &c) const {
        return aiColor3D(r * c.r, g * c.g, b * c.b);
    }

    /** Multiply with a scalar */
    aiColor3D operator*(ai_real f) const {
        return aiColor3D(r * f, g * f, b * f);
    }

    /** Access a specific color component */
    ai_real operator[](unsigned int i) const {
        return *(&r + i);
    }

    /** Access a specific color component */
    ai_real &operator[](unsigned int i) {
        if (0 == i) {
            return r;
        } else if (1 == i) {
            return g;
        } else if (2 == i) {
            return b;
        }
        return r;
    }

    /** Check whether a color is black */
    bool IsBlack() const {
        static const ai_real epsilon = ai_real(10e-3);
        return std::fabs(r) < epsilon && std::fabs(g) < epsilon && std::fabs(b) < epsilon;
    }

#endif // !__cplusplus

    //! Red, green and blue color values
    ai_real r, g, b;
}; // !struct aiColor3D

// ----------------------------------------------------------------------------------
/** Represents an UTF-8 string, zero byte terminated.
 *
 *  The character set of an aiString is explicitly defined to be UTF-8. This Unicode
 *  transformation was chosen in the belief that most strings in 3d files are limited
 *  to ASCII, thus the character set needed to be strictly ASCII compatible.
 *
 *  Most text file loaders provide proper Unicode input file handling, special unicode
 *  characters are correctly transcoded to UTF8 and are kept throughout the libraries'
 *  import pipeline.
 *
 *  For most applications, it will be absolutely sufficient to interpret the
 *  aiString as ASCII data and work with it as one would work with a plain char*.
 *  Windows users in need of proper support for i.e asian characters can use the
 *  MultiByteToWideChar(), WideCharToMultiByte() WinAPI functionality to convert the
 *  UTF-8 strings to their working character set (i.e. MBCS, WideChar).
 *
 *  We use this representation instead of std::string to be C-compatible. The
 *  (binary) length of such a string is limited to MAXLEN characters (including the
 *  the terminating zero).
*/
struct aiString {
#ifdef __cplusplus
    /** Default constructor, the string is set to have zero length */
    aiString() AI_NO_EXCEPT
            : length(0) {
        data[0] = '\0';

#ifdef ASSIMP_BUILD_DEBUG
        // Debug build: overwrite the string on its full length with ESC (27)
        memset(data + 1, 27, MAXLEN - 1);
#endif
    }

    /** Copy constructor */
    aiString(const aiString &rOther) :
            length(rOther.length) {
        // Crop the string to the maximum length
        length = length >= MAXLEN ? MAXLEN - 1 : length;
        memcpy(data, rOther.data, length);
        data[length] = '\0';
    }

    /** Constructor from std::string */
    explicit aiString(const std::string &pString) :
            length((ai_uint32)pString.length()) {
        length = length >= MAXLEN ? MAXLEN - 1 : length;
        memcpy(data, pString.c_str(), length);
        data[length] = '\0';
    }

    /** Copy a std::string to the aiString */
    void Set(const std::string &pString) {
        if (pString.length() > MAXLEN - 1) {
            return;
        }
        length = (ai_uint32)pString.length();
        memcpy(data, pString.c_str(), length);
        data[length] = 0;
    }

    /** Copy a const char* to the aiString */
    void Set(const char *sz) {
        ai_int32 len = (ai_uint32)::strlen(sz);
        if (len > (ai_int32)MAXLEN - 1) {
            len = (ai_int32) MAXLEN - 1;
        }
        length = len;
        memcpy(data, sz, len);
        data[len] = 0;
    }

    /** Assignment operator */
    aiString &operator=(const aiString &rOther) {
        if (this == &rOther) {
            return *this;
        }

        length = rOther.length;
        if (length >(MAXLEN - 1)) {
            length = (ai_int32) MAXLEN - 1;
        }

        memcpy(data, rOther.data, length);
        data[length] = '\0';
        return *this;
    }

    /** Assign a const char* to the string */
    aiString &operator=(const char *sz) {
        Set(sz);
        return *this;
    }

    /** Assign a cstd::string to the string */
    aiString &operator=(const std::string &pString) {
        Set(pString);
        return *this;
    }

    /** Comparison operator */
    bool operator==(const aiString &other) const {
        return (length == other.length && 0 == memcmp(data, other.data, length));
    }

    /** Inverse comparison operator */
    bool operator!=(const aiString &other) const {
        return (length != other.length || 0 != memcmp(data, other.data, length));
    }

    /** Append a string to the string */
    void Append(const char *app) {
        const ai_uint32 len = (ai_uint32)::strlen(app);
        if (!len) {
            return;
        }
        if (length + len >= MAXLEN) {
            return;
        }

        memcpy(&data[length], app, len + 1);
        length += len;
    }

    /** Clear the string - reset its length to zero */
    void Clear() {
        length = 0;
        data[0] = '\0';

#ifdef ASSIMP_BUILD_DEBUG
        // Debug build: overwrite the string on its full length with ESC (27)
        memset(data + 1, 27, MAXLEN - 1);
#endif
    }

    /** Returns a pointer to the underlying zero-terminated array of characters */
    const char *C_Str() const {
        return data;
    }

#endif // !__cplusplus

    /** Binary length of the string excluding the terminal 0. This is NOT the
     *  logical length of strings containing UTF-8 multi-byte sequences! It's
     *  the number of bytes from the beginning of the string to its end.*/
    ai_uint32 length;

    /** String buffer. Size limit is MAXLEN */
    char data[MAXLEN];
}; // !struct aiString

// ----------------------------------------------------------------------------------
/** Standard return type for some library functions.
 * Rarely used, and if, mostly in the C API.
 */
typedef enum aiReturn {
    /** Indicates that a function was successful */
    aiReturn_SUCCESS = 0x0,

    /** Indicates that a function failed */
    aiReturn_FAILURE = -0x1,

    /** Indicates that not enough memory was available
     * to perform the requested operation
     */
    aiReturn_OUTOFMEMORY = -0x3,

    /** @cond never
     *  Force 32-bit size enum
     */
    _AI_ENFORCE_ENUM_SIZE = 0x7fffffff

    /// @endcond
} aiReturn; // !enum aiReturn

// just for backwards compatibility, don't use these constants anymore
#define AI_SUCCESS aiReturn_SUCCESS
#define AI_FAILURE aiReturn_FAILURE
#define AI_OUTOFMEMORY aiReturn_OUTOFMEMORY

// ----------------------------------------------------------------------------------
/** Seek origins (for the virtual file system API).
 *  Much cooler than using SEEK_SET, SEEK_CUR or SEEK_END.
 */
enum aiOrigin {
    /** Beginning of the file */
    aiOrigin_SET = 0x0,

    /** Current position of the file pointer */
    aiOrigin_CUR = 0x1,

    /** End of the file, offsets must be negative */
    aiOrigin_END = 0x2,

    /**  @cond never
     *   Force 32-bit size enum
     */
    _AI_ORIGIN_ENFORCE_ENUM_SIZE = 0x7fffffff

    /// @endcond
}; // !enum aiOrigin

// ----------------------------------------------------------------------------------
/** @brief Enumerates predefined log streaming destinations.
 *  Logging to these streams can be enabled with a single call to
 *   #LogStream::createDefaultStream.
 */
enum aiDefaultLogStream {
    /** Stream the log to a file */
    aiDefaultLogStream_FILE = 0x1,

    /** Stream the log to std::cout */
    aiDefaultLogStream_STDOUT = 0x2,

    /** Stream the log to std::cerr */
    aiDefaultLogStream_STDERR = 0x4,

    /** MSVC only: Stream the log the the debugger
     * (this relies on OutputDebugString from the Win32 SDK)
     */
    aiDefaultLogStream_DEBUGGER = 0x8,

    /** @cond never
     *  Force 32-bit size enum
     */
    _AI_DLS_ENFORCE_ENUM_SIZE = 0x7fffffff
    /// @endcond
}; // !enum aiDefaultLogStream

// just for backwards compatibility, don't use these constants anymore
#define DLS_FILE aiDefaultLogStream_FILE
#define DLS_STDOUT aiDefaultLogStream_STDOUT
#define DLS_STDERR aiDefaultLogStream_STDERR
#define DLS_DEBUGGER aiDefaultLogStream_DEBUGGER

// ----------------------------------------------------------------------------------
/** Stores the memory requirements for different components (e.g. meshes, materials,
 *  animations) of an import. All sizes are in bytes.
 *  @see Importer::GetMemoryRequirements()
*/
struct aiMemoryInfo {
#ifdef __cplusplus

    /** Default constructor */
    aiMemoryInfo() AI_NO_EXCEPT
            : textures(0),
              materials(0),
              meshes(0),
              nodes(0),
              animations(0),
              cameras(0),
              lights(0),
              total(0) {}

#endif

    /** Storage allocated for texture data */
    unsigned int textures;

    /** Storage allocated for material data  */
    unsigned int materials;

    /** Storage allocated for mesh data */
    unsigned int meshes;

    /** Storage allocated for node data */
    unsigned int nodes;

    /** Storage allocated for animation data */
    unsigned int animations;

    /** Storage allocated for camera data */
    unsigned int cameras;

    /** Storage allocated for light data */
    unsigned int lights;

    /** Total storage allocated for the full import. */
    unsigned int total;
}; // !struct aiMemoryInfo

#ifdef __cplusplus
}
#endif //!  __cplusplus

// Include implementation files
#include "vector2.inl"
#include "vector3.inl"
#include "color4.inl"
#include "matrix3x3.inl"
#include "matrix4x4.inl"
#include "quaternion.inl"

#endif // AI_TYPES_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/vector2.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/
/** @file vector2.h
 *  @brief 2D vector structure, including operators when compiling in C++
 */
#pragma once
#ifndef AI_VECTOR2D_H_INC
#define AI_VECTOR2D_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#ifdef __cplusplus
#   include <cmath>
#else
#   include <math.h>
#endif

#include "defs.h"

// ----------------------------------------------------------------------------------
/** Represents a two-dimensional vector.
 */

#ifdef __cplusplus
template <typename TReal>
class aiVector2t {
public:
    aiVector2t () : x(), y() {}
    aiVector2t (TReal _x, TReal _y) : x(_x), y(_y) {}
    explicit aiVector2t (TReal _xyz) : x(_xyz), y(_xyz) {}
    aiVector2t (const aiVector2t& o) = default;

    void Set( TReal pX, TReal pY);
    TReal SquareLength() const ;
    TReal Length() const ;
    aiVector2t& Normalize();

    const aiVector2t& operator += (const aiVector2t& o);
    const aiVector2t& operator -= (const aiVector2t& o);
    const aiVector2t& operator *= (TReal f);
    const aiVector2t& operator /= (TReal f);

    TReal operator[](unsigned int i) const;

    bool operator== (const aiVector2t& other) const;
    bool operator!= (const aiVector2t& other) const;

    bool Equal(const aiVector2t &other, TReal epsilon = ai_epsilon) const;

    aiVector2t& operator= (TReal f);
    const aiVector2t SymMul(const aiVector2t& o);

    template <typename TOther>
    operator aiVector2t<TOther> () const;

    TReal x, y;
};

typedef aiVector2t<ai_real> aiVector2D;

#else

struct aiVector2D {
    ai_real x, y;
};

#endif // __cplusplus

#endif // AI_VECTOR2D_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/vector3.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2022, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/
/** @file vector3.h
 *  @brief 3D vector structure, including operators when compiling in C++
 */
#pragma once
#ifndef AI_VECTOR3D_H_INC
#define AI_VECTOR3D_H_INC

#ifdef __GNUC__
#   pragma GCC system_header
#endif

#ifdef __cplusplus
#   include <cmath>
#else
#   include <math.h>
#endif

#include <assimp/defs.h>

#ifdef __cplusplus

template<typename TReal> class aiMatrix3x3t;
template<typename TReal> class aiMatrix4x4t;

// ---------------------------------------------------------------------------
/// @brief  Represents a three-dimensional vector.
// ---------------------------------------------------------------------------
template <typename TReal>
class aiVector3t {
public:
    /// @brief  The default class constructor.
    aiVector3t() AI_NO_EXCEPT : x(), y(), z() {}

    /// @brief  The class constructor with the components.
    /// @param  _x  The x-component for the vector.
    /// @param  _y  The y-component for the vector.
    /// @param  _z  The z-component for the vector.
    aiVector3t(TReal _x, TReal _y, TReal _z) : x(_x), y(_y), z(_z) {}

    /// @brief  The class constructor with a default value.
    /// @param  _xyz  The value for x, y and z.
    explicit aiVector3t (TReal _xyz ) : x(_xyz), y(_xyz), z(_xyz) {}

    /// @brief  The copy constructor.
    /// @param  o The instance to copy from.
    aiVector3t( const aiVector3t& o ) = default;

    /// @brief  combined operators
    /// @brief  The copy constructor.
    const aiVector3t& operator += (const aiVector3t& o);

    /// @brief  The copy constructor.
    const aiVector3t& operator -= (const aiVector3t& o);

    /// @brief  The copy constructor.
    const aiVector3t& operator *= (TReal f);

    /// @brief  The copy constructor.
    const aiVector3t& operator /= (TReal f);

    /// @brief  Transform vector by matrix
    aiVector3t& operator *= (const aiMatrix3x3t<TReal>& mat);
    aiVector3t& operator *= (const aiMatrix4x4t<TReal>& mat);

    /// @brief  access a single element, const.
    TReal operator[](unsigned int i) const;

    /// @brief  access a single element, non-const.
    TReal& operator[](unsigned int i);

    // comparison
    bool operator== (const aiVector3t& other) const;
    bool operator!= (const aiVector3t& other) const;
    bool operator < (const aiVector3t& other) const;

    /// @brief
    bool Equal(const aiVector3t &other, TReal epsilon = ai_epsilon) const;

    template <typename TOther>
    operator aiVector3t<TOther> () const;

    /** @brief Set the components of a vector
     *  @param pX X component
     *  @param pY Y component
     *  @param pZ Z component  */
    void Set( TReal pX, TReal pY, TReal pZ);

    /** @brief Get the squared length of the vector
     *  @return Square length */
    TReal SquareLength() const;

    /** @brief Get the length of the vector
     *  @return length */
    TReal Length() const;


    /** @brief Normalize the vector */
    aiVector3t& Normalize();

    /** @brief Normalize the vector with extra check for zero vectors */
    aiVector3t& NormalizeSafe();

    /** @brief Componentwise multiplication of two vectors
     *
     *  Note that vec*vec yields the dot product.
     *  @param o Second factor */
    const aiVector3t SymMul(const aiVector3t& o);

    TReal x, y, z;
};


typedef aiVector3t<ai_real> aiVector3D;

#else

struct aiVector3D {
    ai_real x, y, z;
};

#endif // __cplusplus

#ifdef __cplusplus

#endif // __cplusplus

#endif // AI_VECTOR3D_H_INC


============================================================
File Path: project/externals/assimp/include/assimp/version.h
============================================================
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2023, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  version.h
 *  @brief Functions to query the version of the Assimp runtime, check
 *    compile flags, ...
 */
#pragma once
#ifndef AI_VERSION_H_INC
#define AI_VERSION_H_INC

#include <assimp/defs.h>

#ifdef __cplusplus
extern "C" {
#endif

// ---------------------------------------------------------------------------
/** @brief Returns a string with legal copyright and licensing information
 *  about Assimp. The string may include multiple lines.
 *  @return Pointer to static string.
 */
ASSIMP_API const char*  aiGetLegalString  (void);

// ---------------------------------------------------------------------------
/** @brief Returns the current patch version number of Assimp.
 *  @return Patch version of the Assimp runtime the application was
 *    linked/built against
 */
ASSIMP_API unsigned int aiGetVersionPatch(void);

// ---------------------------------------------------------------------------
/** @brief Returns the current minor version number of Assimp.
 *  @return Minor version of the Assimp runtime the application was
 *    linked/built against
 */
ASSIMP_API unsigned int aiGetVersionMinor (void);

// ---------------------------------------------------------------------------
/** @brief Returns the current major version number of Assimp.
 *  @return Major version of the Assimp runtime the application was
 *    linked/built against
 */
ASSIMP_API unsigned int aiGetVersionMajor (void);

// ---------------------------------------------------------------------------
/** @brief Returns the repository revision of the Assimp runtime.
 *  @return SVN Repository revision number of the Assimp runtime the
 *          application was linked/built against.
 */
ASSIMP_API unsigned int aiGetVersionRevision (void);

// ---------------------------------------------------------------------------
/** @brief Returns the branch-name of the Assimp runtime.
 *  @return The current branch name.
 */
ASSIMP_API const char *aiGetBranchName();

//! Assimp was compiled as a shared object (Windows: DLL)
#define ASSIMP_CFLAGS_SHARED  0x1
//! Assimp was compiled against STLport
#define ASSIMP_CFLAGS_STLPORT 0x2
//! Assimp was compiled as a debug build
#define ASSIMP_CFLAGS_DEBUG   0x4

//! Assimp was compiled with ASSIMP_BUILD_BOOST_WORKAROUND defined
#define ASSIMP_CFLAGS_NOBOOST           0x8
//! Assimp was compiled with ASSIMP_BUILD_SINGLETHREADED defined
#define ASSIMP_CFLAGS_SINGLETHREADED    0x10
//! Assimp was compiled with ASSIMP_BUILD_SINGLETHREADED defined
#define ASSIMP_CFLAGS_DOUBLE_SUPPORT 0x20

// ---------------------------------------------------------------------------
/** @brief Returns assimp's compile flags
 *  @return Any bitwise combination of the ASSIMP_CFLAGS_xxx constants.
 */
ASSIMP_API unsigned int aiGetCompileFlags(void);

#ifdef __cplusplus
} // end extern "C"
#endif

#endif // !! #ifndef AI_VERSION_H_INC



============================================================
File Path: project/externals/nlohmann/json.hpp
============================================================
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

/****************************************************************************\
 * Note on documentation: The source files contain links to the online      *
 * documentation of the public API at https://json.nlohmann.me. This URL    *
 * contains the most recent documentation and should also be applicable to  *
 * previous versions; documentation for deprecated functions is not         *
 * removed, but marked deprecated. See "Generate documentation" section in  *
 * file docs/README.md.                                                     *
\****************************************************************************/

#ifndef INCLUDE_NLOHMANN_JSON_HPP_
#define INCLUDE_NLOHMANN_JSON_HPP_

#include <algorithm> // all_of, find, for_each
#include <cstddef> // nullptr_t, ptrdiff_t, size_t
#include <functional> // hash, less
#include <initializer_list> // initializer_list
#ifndef JSON_NO_IO
    #include <iosfwd> // istream, ostream
#endif  // JSON_NO_IO
#include <iterator> // random_access_iterator_tag
#include <memory> // unique_ptr
#include <string> // string, stoi, to_string
#include <utility> // declval, forward, move, pair, swap
#include <vector> // vector

// #include <nlohmann/adl_serializer.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <utility>

// #include <nlohmann/detail/abi_macros.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// This file contains all macro definitions affecting or depending on the ABI

#ifndef JSON_SKIP_LIBRARY_VERSION_CHECK
    #if defined(NLOHMANN_JSON_VERSION_MAJOR) && defined(NLOHMANN_JSON_VERSION_MINOR) && defined(NLOHMANN_JSON_VERSION_PATCH)
        #if NLOHMANN_JSON_VERSION_MAJOR != 3 || NLOHMANN_JSON_VERSION_MINOR != 12 || NLOHMANN_JSON_VERSION_PATCH != 0
            #warning "Already included a different version of the library!"
        #endif
    #endif
#endif

#define NLOHMANN_JSON_VERSION_MAJOR 3   // NOLINT(modernize-macro-to-enum)
#define NLOHMANN_JSON_VERSION_MINOR 12  // NOLINT(modernize-macro-to-enum)
#define NLOHMANN_JSON_VERSION_PATCH 0   // NOLINT(modernize-macro-to-enum)

#ifndef JSON_DIAGNOSTICS
    #define JSON_DIAGNOSTICS 0
#endif

#ifndef JSON_DIAGNOSTIC_POSITIONS
    #define JSON_DIAGNOSTIC_POSITIONS 0
#endif

#ifndef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    #define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 0
#endif

#if JSON_DIAGNOSTICS
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS _diag
#else
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS
#endif

#if JSON_DIAGNOSTIC_POSITIONS
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTIC_POSITIONS _dp
#else
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTIC_POSITIONS
#endif

#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON _ldvcmp
#else
    #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_NO_VERSION
    #define NLOHMANN_JSON_NAMESPACE_NO_VERSION 0
#endif

// Construct the namespace ABI tags component
#define NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b, c) json_abi ## a ## b ## c
#define NLOHMANN_JSON_ABI_TAGS_CONCAT(a, b, c) \
    NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b, c)

#define NLOHMANN_JSON_ABI_TAGS                                       \
    NLOHMANN_JSON_ABI_TAGS_CONCAT(                                   \
            NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS,                       \
            NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON, \
            NLOHMANN_JSON_ABI_TAG_DIAGNOSTIC_POSITIONS)

// Construct the namespace version component
#define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch) \
    _v ## major ## _ ## minor ## _ ## patch
#define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(major, minor, patch) \
    NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch)

#if NLOHMANN_JSON_NAMESPACE_NO_VERSION
#define NLOHMANN_JSON_NAMESPACE_VERSION
#else
#define NLOHMANN_JSON_NAMESPACE_VERSION                                 \
    NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(NLOHMANN_JSON_VERSION_MAJOR, \
                                           NLOHMANN_JSON_VERSION_MINOR, \
                                           NLOHMANN_JSON_VERSION_PATCH)
#endif

// Combine namespace components
#define NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b) a ## b
#define NLOHMANN_JSON_NAMESPACE_CONCAT(a, b) \
    NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b)

#ifndef NLOHMANN_JSON_NAMESPACE
#define NLOHMANN_JSON_NAMESPACE               \
    nlohmann::NLOHMANN_JSON_NAMESPACE_CONCAT( \
            NLOHMANN_JSON_ABI_TAGS,           \
            NLOHMANN_JSON_NAMESPACE_VERSION)
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_BEGIN
#define NLOHMANN_JSON_NAMESPACE_BEGIN                \
    namespace nlohmann                               \
    {                                                \
    inline namespace NLOHMANN_JSON_NAMESPACE_CONCAT( \
                NLOHMANN_JSON_ABI_TAGS,              \
                NLOHMANN_JSON_NAMESPACE_VERSION)     \
    {
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_END
#define NLOHMANN_JSON_NAMESPACE_END                                     \
    }  /* namespace (inline namespace) NOLINT(readability/namespace) */ \
    }  // namespace nlohmann
#endif

// #include <nlohmann/detail/conversions/from_json.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // transform
#include <array> // array
#include <forward_list> // forward_list
#include <iterator> // inserter, front_inserter, end
#include <map> // map
#include <string> // string
#include <tuple> // tuple, make_tuple
#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
#include <unordered_map> // unordered_map
#include <utility> // pair, declval
#include <valarray> // valarray

// #include <nlohmann/detail/exceptions.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // nullptr_t
#include <exception> // exception
#if JSON_DIAGNOSTICS
    #include <numeric> // accumulate
#endif
#include <stdexcept> // runtime_error
#include <string> // to_string
#include <vector> // vector

// #include <nlohmann/detail/value_t.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <array> // array
#include <cstddef> // size_t
#include <cstdint> // uint8_t
#include <string> // string

// #include <nlohmann/detail/macro_scope.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <utility> // declval, pair
// #include <nlohmann/detail/meta/detected.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <type_traits>

// #include <nlohmann/detail/meta/void_t.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename ...Ts> struct make_void
{
    using type = void;
};
template<typename ...Ts> using void_t = typename make_void<Ts...>::type;

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// https://en.cppreference.com/w/cpp/experimental/is_detected
struct nonesuch
{
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&) = delete;
    nonesuch(nonesuch const&&) = delete;
    void operator=(nonesuch const&) = delete;
    void operator=(nonesuch&&) = delete;
};

template<class Default,
         class AlwaysVoid,
         template<class...> class Op,
         class... Args>
struct detector
{
    using value_t = std::false_type;
    using type = Default;
};

template<class Default, template<class...> class Op, class... Args>
struct detector<Default, void_t<Op<Args...>>, Op, Args...>
{
    using value_t = std::true_type;
    using type = Op<Args...>;
};

template<template<class...> class Op, class... Args>
using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;

template<template<class...> class Op, class... Args>
struct is_detected_lazy : is_detected<Op, Args...> { };

template<template<class...> class Op, class... Args>
using detected_t = typename detector<nonesuch, void, Op, Args...>::type;

template<class Default, template<class...> class Op, class... Args>
using detected_or = detector<Default, void, Op, Args...>;

template<class Default, template<class...> class Op, class... Args>
using detected_or_t = typename detected_or<Default, Op, Args...>::type;

template<class Expected, template<class...> class Op, class... Args>
using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;

template<class To, template<class...> class Op, class... Args>
using is_detected_convertible =
    std::is_convertible<detected_t<Op, Args...>, To>;

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/thirdparty/hedley/hedley.hpp>


//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-FileCopyrightText: 2016 - 2021 Evan Nemerson <evan@nemerson.com>
// SPDX-License-Identifier: MIT

/* Hedley - https://nemequ.github.io/hedley
 * Created by Evan Nemerson <evan@nemerson.com>
 */

#if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 15)
#if defined(JSON_HEDLEY_VERSION)
    #undef JSON_HEDLEY_VERSION
#endif
#define JSON_HEDLEY_VERSION 15

#if defined(JSON_HEDLEY_STRINGIFY_EX)
    #undef JSON_HEDLEY_STRINGIFY_EX
#endif
#define JSON_HEDLEY_STRINGIFY_EX(x) #x

#if defined(JSON_HEDLEY_STRINGIFY)
    #undef JSON_HEDLEY_STRINGIFY
#endif
#define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)

#if defined(JSON_HEDLEY_CONCAT_EX)
    #undef JSON_HEDLEY_CONCAT_EX
#endif
#define JSON_HEDLEY_CONCAT_EX(a,b) a##b

#if defined(JSON_HEDLEY_CONCAT)
    #undef JSON_HEDLEY_CONCAT
#endif
#define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)

#if defined(JSON_HEDLEY_CONCAT3_EX)
    #undef JSON_HEDLEY_CONCAT3_EX
#endif
#define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c

#if defined(JSON_HEDLEY_CONCAT3)
    #undef JSON_HEDLEY_CONCAT3
#endif
#define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)

#if defined(JSON_HEDLEY_VERSION_ENCODE)
    #undef JSON_HEDLEY_VERSION_ENCODE
#endif
#define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))

#if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)

#if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MINOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)

#if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
    #undef JSON_HEDLEY_VERSION_DECODE_REVISION
#endif
#define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)

#if defined(JSON_HEDLEY_GNUC_VERSION)
    #undef JSON_HEDLEY_GNUC_VERSION
#endif
#if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#elif defined(__GNUC__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
#endif

#if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
    #undef JSON_HEDLEY_GNUC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GNUC_VERSION)
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION)
    #undef JSON_HEDLEY_MSVC_VERSION
#endif
#if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000) && !defined(__ICL)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
#elif defined(_MSC_FULL_VER) && !defined(__ICL)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
#elif defined(_MSC_VER) && !defined(__ICL)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
    #undef JSON_HEDLEY_MSVC_VERSION_CHECK
#endif
#if !defined(JSON_HEDLEY_MSVC_VERSION)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
#elif defined(_MSC_VER) && (_MSC_VER >= 1200)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
#else
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION)
    #undef JSON_HEDLEY_INTEL_VERSION
#endif
#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && !defined(__ICL)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
#elif defined(__INTEL_COMPILER) && !defined(__ICL)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
    #undef JSON_HEDLEY_INTEL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_INTEL_VERSION)
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_INTEL_CL_VERSION)
    #undef JSON_HEDLEY_INTEL_CL_VERSION
#endif
#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && defined(__ICL)
    #define JSON_HEDLEY_INTEL_CL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)
#endif

#if defined(JSON_HEDLEY_INTEL_CL_VERSION_CHECK)
    #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_INTEL_CL_VERSION)
    #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_CL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION)
    #undef JSON_HEDLEY_PGI_VERSION
#endif
#if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)
    #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
    #undef JSON_HEDLEY_PGI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PGI_VERSION)
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #undef JSON_HEDLEY_SUNPRO_VERSION
#endif
#if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)
#elif defined(__SUNPRO_C)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)
#elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)
#elif defined(__SUNPRO_CC)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
    #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#endif
#if defined(__EMSCRIPTEN__)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION)
    #undef JSON_HEDLEY_ARM_VERSION
#endif
#if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
#elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
    #undef JSON_HEDLEY_ARM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_ARM_VERSION)
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION)
    #undef JSON_HEDLEY_IBM_VERSION
#endif
#if defined(__ibmxl__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
#elif defined(__xlC__) && defined(__xlC_ver__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
#elif defined(__xlC__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
    #undef JSON_HEDLEY_IBM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IBM_VERSION)
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_VERSION)
    #undef JSON_HEDLEY_TI_VERSION
#endif
#if \
    defined(__TI_COMPILER_VERSION__) && \
    ( \
      defined(__TMS470__) || defined(__TI_ARM__) || \
      defined(__MSP430__) || \
      defined(__TMS320C2000__) \
    )
#if (__TI_COMPILER_VERSION__ >= 16000000)
    #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif
#endif

#if defined(JSON_HEDLEY_TI_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_VERSION)
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
    #undef JSON_HEDLEY_TI_CL2000_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)
    #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL430_VERSION)
    #undef JSON_HEDLEY_TI_CL430_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)
    #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL430_VERSION)
    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
    #undef JSON_HEDLEY_TI_ARMCL_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && (defined(__TMS470__) || defined(__TI_ARM__))
    #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
    #undef JSON_HEDLEY_TI_CL6X_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)
    #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
    #undef JSON_HEDLEY_TI_CL7X_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)
    #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
    #undef JSON_HEDLEY_TI_CLPRU_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)
    #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION)
    #undef JSON_HEDLEY_CRAY_VERSION
#endif
#if defined(_CRAYC)
    #if defined(_RELEASE_PATCHLEVEL)
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
    #else
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
    #undef JSON_HEDLEY_CRAY_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_CRAY_VERSION)
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IAR_VERSION)
    #undef JSON_HEDLEY_IAR_VERSION
#endif
#if defined(__IAR_SYSTEMS_ICC__)
    #if __VER__ > 1000
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
    #else
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(__VER__ / 100, __VER__ % 100, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
    #undef JSON_HEDLEY_IAR_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IAR_VERSION)
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION)
    #undef JSON_HEDLEY_TINYC_VERSION
#endif
#if defined(__TINYC__)
    #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
    #undef JSON_HEDLEY_TINYC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION)
    #undef JSON_HEDLEY_DMC_VERSION
#endif
#if defined(__DMC__)
    #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
    #undef JSON_HEDLEY_DMC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_DMC_VERSION)
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #undef JSON_HEDLEY_COMPCERT_VERSION
#endif
#if defined(__COMPCERT_VERSION__)
    #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
    #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION)
    #undef JSON_HEDLEY_PELLES_VERSION
#endif
#if defined(__POCC__)
    #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
    #undef JSON_HEDLEY_PELLES_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PELLES_VERSION)
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_MCST_LCC_VERSION)
    #undef JSON_HEDLEY_MCST_LCC_VERSION
#endif
#if defined(__LCC__) && defined(__LCC_MINOR__)
    #define JSON_HEDLEY_MCST_LCC_VERSION JSON_HEDLEY_VERSION_ENCODE(__LCC__ / 100, __LCC__ % 100, __LCC_MINOR__)
#endif

#if defined(JSON_HEDLEY_MCST_LCC_VERSION_CHECK)
    #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_MCST_LCC_VERSION)
    #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_MCST_LCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_GCC_VERSION)
    #undef JSON_HEDLEY_GCC_VERSION
#endif
#if \
    defined(JSON_HEDLEY_GNUC_VERSION) && \
    !defined(__clang__) && \
    !defined(JSON_HEDLEY_INTEL_VERSION) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_ARM_VERSION) && \
    !defined(JSON_HEDLEY_CRAY_VERSION) && \
    !defined(JSON_HEDLEY_TI_VERSION) && \
    !defined(JSON_HEDLEY_TI_ARMCL_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL430_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL2000_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL6X_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL7X_VERSION) && \
    !defined(JSON_HEDLEY_TI_CLPRU_VERSION) && \
    !defined(__COMPCERT__) && \
    !defined(JSON_HEDLEY_MCST_LCC_VERSION)
    #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
#endif

#if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GCC_VERSION)
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_ATTRIBUTE
#endif
#if \
  defined(__has_attribute) && \
  ( \
    (!defined(JSON_HEDLEY_IAR_VERSION) || JSON_HEDLEY_IAR_VERSION_CHECK(8,5,9)) \
  )
#  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
#else
#  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#endif
#if \
    defined(__has_cpp_attribute) && \
    defined(__cplusplus) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
#endif
#if !defined(__cplusplus) || !defined(__has_cpp_attribute)
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
#elif \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_IAR_VERSION) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \
    (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_BUILTIN)
    #undef JSON_HEDLEY_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GCC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_FEATURE)
    #undef JSON_HEDLEY_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
#else
    #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
    #undef JSON_HEDLEY_GNUC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
    #undef JSON_HEDLEY_GCC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_EXTENSION)
    #undef JSON_HEDLEY_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
#else
    #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GCC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_WARNING)
    #undef JSON_HEDLEY_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
#else
    #define JSON_HEDLEY_HAS_WARNING(warning) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
    #undef JSON_HEDLEY_GNUC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_WARNING)
    #undef JSON_HEDLEY_GCC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    defined(__clang__) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))
    #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
#else
    #define JSON_HEDLEY_PRAGMA(value)
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
    #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#endif
#if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
    #undef JSON_HEDLEY_DIAGNOSTIC_POP
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
    #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
#elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH
    #define JSON_HEDLEY_DIAGNOSTIC_POP
#endif

/* JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_ is for
   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
#endif
#if defined(__cplusplus)
#  if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat")
#    if JSON_HEDLEY_HAS_WARNING("-Wc++17-extensions")
#      if JSON_HEDLEY_HAS_WARNING("-Wc++1z-extensions")
#        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
    _Pragma("clang diagnostic ignored \"-Wc++1z-extensions\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#      else
#        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#      endif
#    else
#      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    endif
#  endif
#endif
#if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
#endif

#if defined(JSON_HEDLEY_CONST_CAST)
    #undef JSON_HEDLEY_CONST_CAST
#endif
#if defined(__cplusplus)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
#elif \
  JSON_HEDLEY_HAS_WARNING("-Wcast-qual") || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_REINTERPRET_CAST)
    #undef JSON_HEDLEY_REINTERPRET_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
#else
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_STATIC_CAST)
    #undef JSON_HEDLEY_STATIC_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
#else
    #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_CPP_CAST)
    #undef JSON_HEDLEY_CPP_CAST
#endif
#if defined(__cplusplus)
#  if JSON_HEDLEY_HAS_WARNING("-Wold-style-cast")
#    define JSON_HEDLEY_CPP_CAST(T, expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wold-style-cast\"") \
    ((T) (expr)) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)
#    define JSON_HEDLEY_CPP_CAST(T, expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("diag_suppress=Pe137") \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  else
#    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))
#  endif
#else
#  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warning(disable:1478 1786)")
#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:1478 1786))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1216,1444,1445")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress=Pe1444,Pe1215")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("warning(disable:161)")
#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:161))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 161")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-attributes")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("clang diagnostic ignored \"-Wunknown-attributes\"")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("warning(disable:1292)")
#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:1292))
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097,1098")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("error_messages(off,attrskipunsup)")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1173")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress=Pe1097")
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wcast-qual")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("warning(disable:2203 2331)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunused-function")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("clang diagnostic ignored \"-Wunused-function\"")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("GCC diagnostic ignored \"-Wunused-function\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(1,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION __pragma(warning(disable:4505))
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("diag_suppress 3142")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
#endif

#if defined(JSON_HEDLEY_DEPRECATED)
    #undef JSON_HEDLEY_DEPRECATED
#endif
#if defined(JSON_HEDLEY_DEPRECATED_FOR)
    #undef JSON_HEDLEY_DEPRECATED_FOR
#endif
#if \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " # since))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated("Since " #since "; use " #replacement))
#elif \
    (JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__("Since " #since)))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__("Since " #since "; use " #replacement)))
#elif defined(__cplusplus) && (__cplusplus >= 201402L)
    #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since)]])
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since "; use " #replacement)]])
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DEPRECATED(since) _Pragma("deprecated")
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
#else
    #define JSON_HEDLEY_DEPRECATED(since)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
#endif

#if defined(JSON_HEDLEY_UNAVAILABLE)
    #undef JSON_HEDLEY_UNAVAILABLE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__("Not available until " #available_since)))
#else
    #define JSON_HEDLEY_UNAVAILABLE(available_since)
#endif

#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT
#endif
#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))
#elif (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
#elif defined(_Check_return_) /* SAL */
    #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
#else
    #define JSON_HEDLEY_WARN_UNUSED_RESULT
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
#endif

#if defined(JSON_HEDLEY_SENTINEL)
    #undef JSON_HEDLEY_SENTINEL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
#else
    #define JSON_HEDLEY_SENTINEL(position)
#endif

#if defined(JSON_HEDLEY_NO_RETURN)
    #undef JSON_HEDLEY_NO_RETURN
#endif
#if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NO_RETURN __noreturn
#elif \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
    #define JSON_HEDLEY_NO_RETURN _Noreturn
#elif defined(__cplusplus) && (__cplusplus >= 201103L)
    #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_NO_RETURN _Pragma("does_not_return")
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#else
    #define JSON_HEDLEY_NO_RETURN
#endif

#if defined(JSON_HEDLEY_NO_ESCAPE)
    #undef JSON_HEDLEY_NO_ESCAPE
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)
    #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))
#else
    #define JSON_HEDLEY_NO_ESCAPE
#endif

#if defined(JSON_HEDLEY_UNREACHABLE)
    #undef JSON_HEDLEY_UNREACHABLE
#endif
#if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
    #undef JSON_HEDLEY_UNREACHABLE_RETURN
#endif
#if defined(JSON_HEDLEY_ASSUME)
    #undef JSON_HEDLEY_ASSUME
#endif
#if \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
#elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
    #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
#elif \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
    #if defined(__cplusplus)
        #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
    #else
        #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
    #endif
#endif
#if \
    (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(10,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
#elif defined(JSON_HEDLEY_ASSUME)
    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
#endif
#if !defined(JSON_HEDLEY_ASSUME)
    #if defined(JSON_HEDLEY_UNREACHABLE)
        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))
    #else
        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)
    #endif
#endif
#if defined(JSON_HEDLEY_UNREACHABLE)
    #if  \
        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))
    #else
        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
    #endif
#else
    #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)
#endif
#if !defined(JSON_HEDLEY_UNREACHABLE)
    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
#endif

JSON_HEDLEY_DIAGNOSTIC_PUSH
#if JSON_HEDLEY_HAS_WARNING("-Wpedantic")
    #pragma clang diagnostic ignored "-Wpedantic"
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic") && defined(__cplusplus)
    #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#endif
#if JSON_HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros",4,0,0)
    #if defined(__clang__)
        #pragma clang diagnostic ignored "-Wvariadic-macros"
    #elif defined(JSON_HEDLEY_GCC_VERSION)
        #pragma GCC diagnostic ignored "-Wvariadic-macros"
    #endif
#endif
#if defined(JSON_HEDLEY_NON_NULL)
    #undef JSON_HEDLEY_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
#else
    #define JSON_HEDLEY_NON_NULL(...)
#endif
JSON_HEDLEY_DIAGNOSTIC_POP

#if defined(JSON_HEDLEY_PRINTF_FORMAT)
    #undef JSON_HEDLEY_PRINTF_FORMAT
#endif
#if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
#elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
#else
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
#endif

#if defined(JSON_HEDLEY_CONSTEXPR)
    #undef JSON_HEDLEY_CONSTEXPR
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
    #endif
#endif
#if !defined(JSON_HEDLEY_CONSTEXPR)
    #define JSON_HEDLEY_CONSTEXPR
#endif

#if defined(JSON_HEDLEY_PREDICT)
    #undef JSON_HEDLEY_PREDICT
#endif
#if defined(JSON_HEDLEY_LIKELY)
    #undef JSON_HEDLEY_LIKELY
#endif
#if defined(JSON_HEDLEY_UNLIKELY)
    #undef JSON_HEDLEY_UNLIKELY
#endif
#if defined(JSON_HEDLEY_UNPREDICTABLE)
    #undef JSON_HEDLEY_UNPREDICTABLE
#endif
#if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
#endif
#if \
  (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) && !defined(JSON_HEDLEY_PGI_VERSION)) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))
#  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )
#  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )
#elif \
  (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \
  JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
    (((probability) >= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
    (__extension__ ({ \
        double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
    }))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
    (__extension__ ({ \
        double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
    }))
#  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
#  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
#else
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
#  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
#endif
#if !defined(JSON_HEDLEY_UNPREDICTABLE)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
#endif

#if defined(JSON_HEDLEY_MALLOC)
    #undef JSON_HEDLEY_MALLOC
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_MALLOC _Pragma("returns_new_memory")
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_MALLOC __declspec(restrict)
#else
    #define JSON_HEDLEY_MALLOC
#endif

#if defined(JSON_HEDLEY_PURE)
    #undef JSON_HEDLEY_PURE
#endif
#if \
  JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#  define JSON_HEDLEY_PURE __attribute__((__pure__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
#  define JSON_HEDLEY_PURE _Pragma("does_not_write_global_data")
#elif defined(__cplusplus) && \
    ( \
      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \
      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \
    )
#  define JSON_HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
#else
#  define JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_CONST)
    #undef JSON_HEDLEY_CONST
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_CONST __attribute__((__const__))
#elif \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_CONST _Pragma("no_side_effect")
#else
    #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_RESTRICT)
    #undef JSON_HEDLEY_RESTRICT
#endif
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT restrict
#elif \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    defined(__clang__) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_RESTRICT __restrict
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT _Restrict
#else
    #define JSON_HEDLEY_RESTRICT
#endif

#if defined(JSON_HEDLEY_INLINE)
    #undef JSON_HEDLEY_INLINE
#endif
#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    (defined(__cplusplus) && (__cplusplus >= 199711L))
    #define JSON_HEDLEY_INLINE inline
#elif \
    defined(JSON_HEDLEY_GCC_VERSION) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
    #define JSON_HEDLEY_INLINE __inline__
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_INLINE __inline
#else
    #define JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_ALWAYS_INLINE)
    #undef JSON_HEDLEY_ALWAYS_INLINE
#endif
#if \
  JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
  JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
#  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
#elif \
  JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
#  define JSON_HEDLEY_ALWAYS_INLINE __forceinline
#elif defined(__cplusplus) && \
    ( \
      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \
    )
#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
#else
#  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_NEVER_INLINE)
    #undef JSON_HEDLEY_NEVER_INLINE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("noinline")
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("inline=never")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#else
    #define JSON_HEDLEY_NEVER_INLINE
#endif

#if defined(JSON_HEDLEY_PRIVATE)
    #undef JSON_HEDLEY_PRIVATE
#endif
#if defined(JSON_HEDLEY_PUBLIC)
    #undef JSON_HEDLEY_PUBLIC
#endif
#if defined(JSON_HEDLEY_IMPORT)
    #undef JSON_HEDLEY_IMPORT
#endif
#if defined(_WIN32) || defined(__CYGWIN__)
#  define JSON_HEDLEY_PRIVATE
#  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
#  define JSON_HEDLEY_IMPORT   __declspec(dllimport)
#else
#  if \
    JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    ( \
      defined(__TI_EABI__) && \
      ( \
        (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \
      ) \
    ) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
#    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__("default")))
#  else
#    define JSON_HEDLEY_PRIVATE
#    define JSON_HEDLEY_PUBLIC
#  endif
#  define JSON_HEDLEY_IMPORT    extern
#endif

#if defined(JSON_HEDLEY_NO_THROW)
    #undef JSON_HEDLEY_NO_THROW
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
#else
    #define JSON_HEDLEY_NO_THROW
#endif

#if defined(JSON_HEDLEY_FALL_THROUGH)
    #undef JSON_HEDLEY_FALL_THROUGH
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)
    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
#elif defined(__fallthrough) /* SAL */
    #define JSON_HEDLEY_FALL_THROUGH __fallthrough
#else
    #define JSON_HEDLEY_FALL_THROUGH
#endif

#if defined(JSON_HEDLEY_RETURNS_NON_NULL)
    #undef JSON_HEDLEY_RETURNS_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
#elif defined(_Ret_notnull_) /* SAL */
    #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
#else
    #define JSON_HEDLEY_RETURNS_NON_NULL
#endif

#if defined(JSON_HEDLEY_ARRAY_PARAM)
    #undef JSON_HEDLEY_ARRAY_PARAM
#endif
#if \
    defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \
    !defined(__STDC_NO_VLA__) && \
    !defined(__cplusplus) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
#else
    #define JSON_HEDLEY_ARRAY_PARAM(name)
#endif

#if defined(JSON_HEDLEY_IS_CONSTANT)
    #undef JSON_HEDLEY_IS_CONSTANT
#endif
#if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
    #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#endif
/* JSON_HEDLEY_IS_CONSTEXPR_ is for
   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
    #undef JSON_HEDLEY_IS_CONSTEXPR_
#endif
#if \
    JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) && !defined(__cplusplus)) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
#endif
#if !defined(__cplusplus)
#  if \
       JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
       JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
       JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
#else
    #include <stdint.h>
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
#endif
#  elif \
       ( \
          defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \
          !defined(JSON_HEDLEY_SUNPRO_VERSION) && \
          !defined(JSON_HEDLEY_PGI_VERSION) && \
          !defined(JSON_HEDLEY_IAR_VERSION)) || \
       (JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
#else
    #include <stdint.h>
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
#endif
#  elif \
       defined(JSON_HEDLEY_GCC_VERSION) || \
       defined(JSON_HEDLEY_INTEL_VERSION) || \
       defined(JSON_HEDLEY_TINYC_VERSION) || \
       defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \
       JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \
       defined(JSON_HEDLEY_TI_CL2000_VERSION) || \
       defined(JSON_HEDLEY_TI_CL6X_VERSION) || \
       defined(JSON_HEDLEY_TI_CL7X_VERSION) || \
       defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \
       defined(__clang__)
#    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \
        sizeof(void) != \
        sizeof(*( \
                  1 ? \
                  ((void*) ((expr) * 0L) ) : \
((struct { char v[sizeof(void) * 2]; } *) 1) \
                ) \
              ) \
                                            )
#  endif
#endif
#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
#else
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
#endif

#if defined(JSON_HEDLEY_BEGIN_C_DECLS)
    #undef JSON_HEDLEY_BEGIN_C_DECLS
#endif
#if defined(JSON_HEDLEY_END_C_DECLS)
    #undef JSON_HEDLEY_END_C_DECLS
#endif
#if defined(JSON_HEDLEY_C_DECL)
    #undef JSON_HEDLEY_C_DECL
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_BEGIN_C_DECLS extern "C" {
    #define JSON_HEDLEY_END_C_DECLS }
    #define JSON_HEDLEY_C_DECL extern "C"
#else
    #define JSON_HEDLEY_BEGIN_C_DECLS
    #define JSON_HEDLEY_END_C_DECLS
    #define JSON_HEDLEY_C_DECL
#endif

#if defined(JSON_HEDLEY_STATIC_ASSERT)
    #undef JSON_HEDLEY_STATIC_ASSERT
#endif
#if \
  !defined(__cplusplus) && ( \
      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \
      (JSON_HEDLEY_HAS_FEATURE(c_static_assert) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
      JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
      defined(_Static_assert) \
    )
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
#elif \
  (defined(__cplusplus) && (__cplusplus >= 201103L)) || \
  JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \
  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
#else
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
#endif

#if defined(JSON_HEDLEY_NULL)
    #undef JSON_HEDLEY_NULL
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
    #elif defined(NULL)
        #define JSON_HEDLEY_NULL NULL
    #else
        #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)
    #endif
#elif defined(NULL)
    #define JSON_HEDLEY_NULL NULL
#else
    #define JSON_HEDLEY_NULL ((void*) 0)
#endif

#if defined(JSON_HEDLEY_MESSAGE)
    #undef JSON_HEDLEY_MESSAGE
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_MESSAGE(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(message msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
#elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_WARNING)
    #undef JSON_HEDLEY_WARNING
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_WARNING(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(clang warning msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
#elif \
  JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_REQUIRE)
    #undef JSON_HEDLEY_REQUIRE
#endif
#if defined(JSON_HEDLEY_REQUIRE_MSG)
    #undef JSON_HEDLEY_REQUIRE_MSG
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
#  if JSON_HEDLEY_HAS_WARNING("-Wgcc-compat")
#    define JSON_HEDLEY_REQUIRE(expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((diagnose_if(!(expr), #expr, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((diagnose_if(!(expr), msg, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  else
#    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, "error")))
#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, "error")))
#  endif
#else
#  define JSON_HEDLEY_REQUIRE(expr)
#  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)
#endif

#if defined(JSON_HEDLEY_FLAGS)
    #undef JSON_HEDLEY_FLAGS
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum) && (!defined(__cplusplus) || JSON_HEDLEY_HAS_WARNING("-Wbitfield-enum-conversion"))
    #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
#else
    #define JSON_HEDLEY_FLAGS
#endif

#if defined(JSON_HEDLEY_FLAGS_CAST)
    #undef JSON_HEDLEY_FLAGS_CAST
#endif
#if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        _Pragma("warning(disable:188)") \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
#endif

#if defined(JSON_HEDLEY_EMPTY_BASES)
    #undef JSON_HEDLEY_EMPTY_BASES
#endif
#if \
    (JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) && !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)
#else
    #define JSON_HEDLEY_EMPTY_BASES
#endif

/* Remaining macros are deprecated. */

#if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
#else
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
    #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#endif
#define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)

#if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
    #undef JSON_HEDLEY_CLANG_HAS_FEATURE
#endif
#define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)

#if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
    #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#endif
#define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)

#if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
    #undef JSON_HEDLEY_CLANG_HAS_WARNING
#endif
#define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)

#endif /* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */


// This file contains all internal macro definitions (except those affecting ABI)
// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them

// #include <nlohmann/detail/abi_macros.hpp>


// exclude unsupported compilers
#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
    #if defined(__clang__)
        #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
            #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
        #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
            #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #endif
#endif

// C++ language standard detection
// if the user manually specified the used C++ version, this is skipped
#if !defined(JSON_HAS_CPP_26) && !defined(JSON_HAS_CPP_23) && !defined(JSON_HAS_CPP_20) && !defined(JSON_HAS_CPP_17) && !defined(JSON_HAS_CPP_14) && !defined(JSON_HAS_CPP_11)
    #if (defined(__cplusplus) && __cplusplus > 202302L) || (defined(_MSVC_LANG) && _MSVC_LANG > 202302L)
        #define JSON_HAS_CPP_26
        #define JSON_HAS_CPP_23
        #define JSON_HAS_CPP_20
        #define JSON_HAS_CPP_17
        #define JSON_HAS_CPP_14
    #elif (defined(__cplusplus) && __cplusplus > 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG > 202002L)
        #define JSON_HAS_CPP_23
        #define JSON_HAS_CPP_20
        #define JSON_HAS_CPP_17
        #define JSON_HAS_CPP_14
    #elif (defined(__cplusplus) && __cplusplus > 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG > 201703L)
        #define JSON_HAS_CPP_20
        #define JSON_HAS_CPP_17
        #define JSON_HAS_CPP_14
    #elif (defined(__cplusplus) && __cplusplus > 201402L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
        #define JSON_HAS_CPP_17
        #define JSON_HAS_CPP_14
    #elif (defined(__cplusplus) && __cplusplus > 201103L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
        #define JSON_HAS_CPP_14
    #endif
    // the cpp 11 flag is always specified because it is the minimal required version
    #define JSON_HAS_CPP_11
#endif

#ifdef __has_include
    #if __has_include(<version>)
        #include <version>
    #endif
#endif

#if !defined(JSON_HAS_FILESYSTEM) && !defined(JSON_HAS_EXPERIMENTAL_FILESYSTEM)
    #ifdef JSON_HAS_CPP_17
        #if defined(__cpp_lib_filesystem)
            #define JSON_HAS_FILESYSTEM 1
        #elif defined(__cpp_lib_experimental_filesystem)
            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
        #elif !defined(__has_include)
            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
        #elif __has_include(<filesystem>)
            #define JSON_HAS_FILESYSTEM 1
        #elif __has_include(<experimental/filesystem>)
            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
        #endif

        // std::filesystem does not work on MinGW GCC 8: https://sourceforge.net/p/mingw-w64/bugs/737/
        #if defined(__MINGW32__) && defined(__GNUC__) && __GNUC__ == 8
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before GCC 8: https://en.cppreference.com/w/cpp/compiler_support
        #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ < 8
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before Clang 7: https://en.cppreference.com/w/cpp/compiler_support
        #if defined(__clang_major__) && __clang_major__ < 7
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before MSVC 19.14: https://en.cppreference.com/w/cpp/compiler_support
        #if defined(_MSC_VER) && _MSC_VER < 1914
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before iOS 13
        #if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < 130000
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before macOS Catalina
        #if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < 101500
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif
    #endif
#endif

#ifndef JSON_HAS_EXPERIMENTAL_FILESYSTEM
    #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 0
#endif

#ifndef JSON_HAS_FILESYSTEM
    #define JSON_HAS_FILESYSTEM 0
#endif

#ifndef JSON_HAS_THREE_WAY_COMPARISON
    #if defined(__cpp_impl_three_way_comparison) && __cpp_impl_three_way_comparison >= 201907L \
        && defined(__cpp_lib_three_way_comparison) && __cpp_lib_three_way_comparison >= 201907L
        #define JSON_HAS_THREE_WAY_COMPARISON 1
    #else
        #define JSON_HAS_THREE_WAY_COMPARISON 0
    #endif
#endif

#ifndef JSON_HAS_RANGES
    // ranges header shipping in GCC 11.1.0 (released 2021-04-27) has a syntax error
    #if defined(__GLIBCXX__) && __GLIBCXX__ == 20210427
        #define JSON_HAS_RANGES 0
    #elif defined(__cpp_lib_ranges)
        #define JSON_HAS_RANGES 1
    #else
        #define JSON_HAS_RANGES 0
    #endif
#endif

#ifndef JSON_HAS_STATIC_RTTI
    #if !defined(_HAS_STATIC_RTTI) || _HAS_STATIC_RTTI != 0
        #define JSON_HAS_STATIC_RTTI 1
    #else
        #define JSON_HAS_STATIC_RTTI 0
    #endif
#endif

#ifdef JSON_HAS_CPP_17
    #define JSON_INLINE_VARIABLE inline
#else
    #define JSON_INLINE_VARIABLE
#endif

#if JSON_HEDLEY_HAS_ATTRIBUTE(no_unique_address)
    #define JSON_NO_UNIQUE_ADDRESS [[no_unique_address]]
#else
    #define JSON_NO_UNIQUE_ADDRESS
#endif

// disable documentation warnings on clang
#if defined(__clang__)
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wdocumentation"
    #pragma clang diagnostic ignored "-Wdocumentation-unknown-command"
#endif

// allow disabling exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
    #define JSON_THROW(exception) throw exception
    #define JSON_TRY try
    #define JSON_CATCH(exception) catch(exception)
    #define JSON_INTERNAL_CATCH(exception) catch(exception)
#else
    #include <cstdlib>
    #define JSON_THROW(exception) std::abort()
    #define JSON_TRY if(true)
    #define JSON_CATCH(exception) if(false)
    #define JSON_INTERNAL_CATCH(exception) if(false)
#endif

// override exception macros
#if defined(JSON_THROW_USER)
    #undef JSON_THROW
    #define JSON_THROW JSON_THROW_USER
#endif
#if defined(JSON_TRY_USER)
    #undef JSON_TRY
    #define JSON_TRY JSON_TRY_USER
#endif
#if defined(JSON_CATCH_USER)
    #undef JSON_CATCH
    #define JSON_CATCH JSON_CATCH_USER
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_CATCH_USER
#endif
#if defined(JSON_INTERNAL_CATCH_USER)
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
#endif

// allow overriding assert
#if !defined(JSON_ASSERT)
    #include <cassert> // assert
    #define JSON_ASSERT(x) assert(x)
#endif

// allow accessing some private functions (needed by the test suite)
#if defined(JSON_TESTS_PRIVATE)
    #define JSON_PRIVATE_UNLESS_TESTED public
#else
    #define JSON_PRIVATE_UNLESS_TESTED private
#endif

/*!
@brief macro to briefly define a mapping between an enum and JSON
@def NLOHMANN_JSON_SERIALIZE_ENUM
@since version 3.4.0
*/
#define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
    template<typename BasicJsonType>                                                            \
    inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \
    {                                                                                           \
        /* NOLINTNEXTLINE(modernize-type-traits) we use C++11 */                                \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
        /* NOLINTNEXTLINE(modernize-avoid-c-arrays) we don't want to depend on <array> */       \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
        auto it = std::find_if(std::begin(m), std::end(m),                                      \
                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \
        {                                                                                       \
            return ej_pair.first == e;                                                          \
        });                                                                                     \
        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \
    }                                                                                           \
    template<typename BasicJsonType>                                                            \
    inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \
    {                                                                                           \
        /* NOLINTNEXTLINE(modernize-type-traits) we use C++11 */                                \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
        /* NOLINTNEXTLINE(modernize-avoid-c-arrays) we don't want to depend on <array> */       \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
        auto it = std::find_if(std::begin(m), std::end(m),                                      \
                               [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
        {                                                                                       \
            return ej_pair.second == j;                                                         \
        });                                                                                     \
        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \
    }

// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
// may be removed in the future once the class is split.

#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
    template<template<typename, typename, typename...> class ObjectType,   \
             template<typename, typename...> class ArrayType,              \
             class StringType, class BooleanType, class NumberIntegerType, \
             class NumberUnsignedType, class NumberFloatType,              \
             template<typename> class AllocatorType,                       \
             template<typename, typename = void> class JSONSerializer,     \
             class BinaryType,                                             \
             class CustomBaseClass>

#define NLOHMANN_BASIC_JSON_TPL                                            \
    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
    AllocatorType, JSONSerializer, BinaryType, CustomBaseClass>

// Macros to simplify conversion from/to types

#define NLOHMANN_JSON_EXPAND( x ) x
#define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME
#define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \
        NLOHMANN_JSON_PASTE64, \
        NLOHMANN_JSON_PASTE63, \
        NLOHMANN_JSON_PASTE62, \
        NLOHMANN_JSON_PASTE61, \
        NLOHMANN_JSON_PASTE60, \
        NLOHMANN_JSON_PASTE59, \
        NLOHMANN_JSON_PASTE58, \
        NLOHMANN_JSON_PASTE57, \
        NLOHMANN_JSON_PASTE56, \
        NLOHMANN_JSON_PASTE55, \
        NLOHMANN_JSON_PASTE54, \
        NLOHMANN_JSON_PASTE53, \
        NLOHMANN_JSON_PASTE52, \
        NLOHMANN_JSON_PASTE51, \
        NLOHMANN_JSON_PASTE50, \
        NLOHMANN_JSON_PASTE49, \
        NLOHMANN_JSON_PASTE48, \
        NLOHMANN_JSON_PASTE47, \
        NLOHMANN_JSON_PASTE46, \
        NLOHMANN_JSON_PASTE45, \
        NLOHMANN_JSON_PASTE44, \
        NLOHMANN_JSON_PASTE43, \
        NLOHMANN_JSON_PASTE42, \
        NLOHMANN_JSON_PASTE41, \
        NLOHMANN_JSON_PASTE40, \
        NLOHMANN_JSON_PASTE39, \
        NLOHMANN_JSON_PASTE38, \
        NLOHMANN_JSON_PASTE37, \
        NLOHMANN_JSON_PASTE36, \
        NLOHMANN_JSON_PASTE35, \
        NLOHMANN_JSON_PASTE34, \
        NLOHMANN_JSON_PASTE33, \
        NLOHMANN_JSON_PASTE32, \
        NLOHMANN_JSON_PASTE31, \
        NLOHMANN_JSON_PASTE30, \
        NLOHMANN_JSON_PASTE29, \
        NLOHMANN_JSON_PASTE28, \
        NLOHMANN_JSON_PASTE27, \
        NLOHMANN_JSON_PASTE26, \
        NLOHMANN_JSON_PASTE25, \
        NLOHMANN_JSON_PASTE24, \
        NLOHMANN_JSON_PASTE23, \
        NLOHMANN_JSON_PASTE22, \
        NLOHMANN_JSON_PASTE21, \
        NLOHMANN_JSON_PASTE20, \
        NLOHMANN_JSON_PASTE19, \
        NLOHMANN_JSON_PASTE18, \
        NLOHMANN_JSON_PASTE17, \
        NLOHMANN_JSON_PASTE16, \
        NLOHMANN_JSON_PASTE15, \
        NLOHMANN_JSON_PASTE14, \
        NLOHMANN_JSON_PASTE13, \
        NLOHMANN_JSON_PASTE12, \
        NLOHMANN_JSON_PASTE11, \
        NLOHMANN_JSON_PASTE10, \
        NLOHMANN_JSON_PASTE9, \
        NLOHMANN_JSON_PASTE8, \
        NLOHMANN_JSON_PASTE7, \
        NLOHMANN_JSON_PASTE6, \
        NLOHMANN_JSON_PASTE5, \
        NLOHMANN_JSON_PASTE4, \
        NLOHMANN_JSON_PASTE3, \
        NLOHMANN_JSON_PASTE2, \
        NLOHMANN_JSON_PASTE1)(__VA_ARGS__))
#define NLOHMANN_JSON_PASTE2(func, v1) func(v1)
#define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)
#define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)
#define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)
#define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)
#define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)
#define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)
#define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)
#define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)
#define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)
#define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
#define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
#define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)
#define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)
#define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
#define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)
#define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)
#define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
#define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
#define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
#define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
#define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)
#define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)
#define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)
#define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)
#define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
#define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)
#define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)
#define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)
#define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)
#define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)
#define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)
#define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)
#define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)
#define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
#define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)
#define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)
#define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)
#define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)
#define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)
#define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)
#define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)
#define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
#define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)
#define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)
#define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)
#define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)
#define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)
#define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)
#define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)
#define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
#define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)
#define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)
#define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)
#define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)
#define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)
#define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)
#define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)
#define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)
#define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)
#define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)
#define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)
#define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)

#define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;
#define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);
#define NLOHMANN_JSON_FROM_WITH_DEFAULT(v1) nlohmann_json_t.v1 = !nlohmann_json_j.is_null() ? nlohmann_json_j.value(#v1, nlohmann_json_default_obj.v1) : nlohmann_json_default_obj.v1;

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_INTRUSIVE
@since version 3.9.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT
@since version 3.11.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE
@since version 3.11.3
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE
@since version 3.9.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_non_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT
@since version 3.11.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_non_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE
@since version 3.11.3
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_non_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType &>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { nlohmann::from_json(nlohmann_json_j, static_cast<BaseType&>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType&>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { nlohmann::from_json(nlohmann_json_j, static_cast<BaseType&>(nlohmann_json_t)); const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType &>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType &>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { nlohmann::from_json(nlohmann_json_j, static_cast<BaseType&>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType &>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { nlohmann::from_json(nlohmann_json_j, static_cast<BaseType&>(nlohmann_json_t)); const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType &>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) }

// inspired from https://stackoverflow.com/a/26745591
// allows calling any std function as if (e.g., with begin):
// using std::begin; begin(x);
//
// it allows using the detected idiom to retrieve the return type
// of such an expression
#define NLOHMANN_CAN_CALL_STD_FUNC_IMPL(std_name)                                 \
    namespace detail {                                                            \
    using std::std_name;                                                          \
    \
    template<typename... T>                                                       \
    using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \
    }                                                                             \
    \
    namespace detail2 {                                                           \
    struct std_name##_tag                                                         \
    {                                                                             \
    };                                                                            \
    \
    template<typename... T>                                                       \
    std_name##_tag std_name(T&&...);                                              \
    \
    template<typename... T>                                                       \
    using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \
    \
    template<typename... T>                                                       \
    struct would_call_std_##std_name                                              \
    {                                                                             \
        static constexpr auto const value = ::nlohmann::detail::                  \
                                            is_detected_exact<std_name##_tag, result_of_##std_name, T...>::value; \
    };                                                                            \
    } /* namespace detail2 */ \
    \
    template<typename... T>                                                       \
    struct would_call_std_##std_name : detail2::would_call_std_##std_name<T...>   \
    {                                                                             \
    }

#ifndef JSON_USE_IMPLICIT_CONVERSIONS
    #define JSON_USE_IMPLICIT_CONVERSIONS 1
#endif

#if JSON_USE_IMPLICIT_CONVERSIONS
    #define JSON_EXPLICIT
#else
    #define JSON_EXPLICIT explicit
#endif

#ifndef JSON_DISABLE_ENUM_SERIALIZATION
    #define JSON_DISABLE_ENUM_SERIALIZATION 0
#endif

#ifndef JSON_USE_GLOBAL_UDLS
    #define JSON_USE_GLOBAL_UDLS 1
#endif

#if JSON_HAS_THREE_WAY_COMPARISON
    #include <compare> // partial_ordering
#endif

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

///////////////////////////
// JSON type enumeration //
///////////////////////////

/*!
@brief the JSON type enumeration

This enumeration collects the different JSON types. It is internally used to
distinguish the stored values, and the functions @ref basic_json::is_null(),
@ref basic_json::is_object(), @ref basic_json::is_array(),
@ref basic_json::is_string(), @ref basic_json::is_boolean(),
@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
@ref basic_json::is_structured() rely on it.

@note There are three enumeration entries (number_integer, number_unsigned, and
number_float), because the library distinguishes these three types for numbers:
@ref basic_json::number_unsigned_t is used for unsigned integers,
@ref basic_json::number_integer_t is used for signed integers, and
@ref basic_json::number_float_t is used for floating-point numbers or to
approximate integers which do not fit in the limits of their respective type.

@sa see @ref basic_json::basic_json(const value_t value_type) -- create a JSON
value with the default value for a given type

@since version 1.0.0
*/
enum class value_t : std::uint8_t
{
    null,             ///< null value
    object,           ///< object (unordered set of name/value pairs)
    array,            ///< array (ordered collection of values)
    string,           ///< string value
    boolean,          ///< boolean value
    number_integer,   ///< number value (signed integer)
    number_unsigned,  ///< number value (unsigned integer)
    number_float,     ///< number value (floating-point)
    binary,           ///< binary array (ordered collection of bytes)
    discarded         ///< discarded by the parser callback function
};

/*!
@brief comparison operator for JSON types

Returns an ordering that is similar to Python:
- order: null < boolean < number < object < array < string < binary
- furthermore, each type is not smaller than itself
- discarded values are not comparable
- binary is represented as a b"" string in python and directly comparable to a
  string; however, making a binary array directly comparable with a string would
  be surprising behavior in a JSON file.

@since version 1.0.0
*/
#if JSON_HAS_THREE_WAY_COMPARISON
    inline std::partial_ordering operator<=>(const value_t lhs, const value_t rhs) noexcept // *NOPAD*
#else
    inline bool operator<(const value_t lhs, const value_t rhs) noexcept
#endif
{
    static constexpr std::array<std::uint8_t, 9> order = {{
            0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
            1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */,
            6 /* binary */
        }
    };

    const auto l_index = static_cast<std::size_t>(lhs);
    const auto r_index = static_cast<std::size_t>(rhs);
#if JSON_HAS_THREE_WAY_COMPARISON
    if (l_index < order.size() && r_index < order.size())
    {
        return order[l_index] <=> order[r_index]; // *NOPAD*
    }
    return std::partial_ordering::unordered;
#else
    return l_index < order.size() && r_index < order.size() && order[l_index] < order[r_index];
#endif
}

// GCC selects the built-in operator< over an operator rewritten from
// a user-defined spaceship operator
// Clang, MSVC, and ICC select the rewritten candidate
// (see GCC bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105200)
#if JSON_HAS_THREE_WAY_COMPARISON && defined(__GNUC__)
inline bool operator<(const value_t lhs, const value_t rhs) noexcept
{
    return std::is_lt(lhs <=> rhs); // *NOPAD*
}
#endif

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/string_escape.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief replace all occurrences of a substring by another string

@param[in,out] s  the string to manipulate; changed so that all
               occurrences of @a f are replaced with @a t
@param[in]     f  the substring to replace with @a t
@param[in]     t  the string to replace @a f

@pre The search string @a f must not be empty. **This precondition is
enforced with an assertion.**

@since version 2.0.0
*/
template<typename StringType>
inline void replace_substring(StringType& s, const StringType& f,
                              const StringType& t)
{
    JSON_ASSERT(!f.empty());
    for (auto pos = s.find(f);                // find the first occurrence of f
            pos != StringType::npos;          // make sure f was found
            s.replace(pos, f.size(), t),      // replace with t, and
            pos = s.find(f, pos + t.size()))  // find the next occurrence of f
    {}
}

/*!
 * @brief string escaping as described in RFC 6901 (Sect. 4)
 * @param[in] s string to escape
 * @return    escaped string
 *
 * Note the order of escaping "~" to "~0" and "/" to "~1" is important.
 */
template<typename StringType>
inline StringType escape(StringType s)
{
    replace_substring(s, StringType{"~"}, StringType{"~0"});
    replace_substring(s, StringType{"/"}, StringType{"~1"});
    return s;
}

/*!
 * @brief string unescaping as described in RFC 6901 (Sect. 4)
 * @param[in] s string to unescape
 * @return    unescaped string
 *
 * Note the order of escaping "~1" to "/" and "~0" to "~" is important.
 */
template<typename StringType>
inline void unescape(StringType& s)
{
    replace_substring(s, StringType{"~1"}, StringType{"/"});
    replace_substring(s, StringType{"~0"}, StringType{"~"});
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/input/position_t.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // size_t

// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// struct to capture the start position of the current token
struct position_t
{
    /// the total number of characters read
    std::size_t chars_read_total = 0;
    /// the number of characters read in the current line
    std::size_t chars_read_current_line = 0;
    /// the number of lines read
    std::size_t lines_read = 0;

    /// conversion to size_t to preserve SAX interface
    constexpr operator size_t() const
    {
        return chars_read_total;
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-FileCopyrightText: 2018 The Abseil Authors
// SPDX-License-Identifier: MIT



#include <array> // array
#include <cstddef> // size_t
#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type
#include <utility> // index_sequence, make_index_sequence, index_sequence_for

// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename T>
using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

#ifdef JSON_HAS_CPP_14

// the following utilities are natively available in C++14
using std::enable_if_t;
using std::index_sequence;
using std::make_index_sequence;
using std::index_sequence_for;

#else

// alias templates to reduce boilerplate
template<bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;

// The following code is taken from https://github.com/abseil/abseil-cpp/blob/10cb35e459f5ecca5b2ff107635da0bfa41011b4/absl/utility/utility.h
// which is part of Google Abseil (https://github.com/abseil/abseil-cpp), licensed under the Apache License 2.0.

//// START OF CODE FROM GOOGLE ABSEIL

// integer_sequence
//
// Class template representing a compile-time integer sequence. An instantiation
// of `integer_sequence<T, Ints...>` has a sequence of integers encoded in its
// type through its template arguments (which is a common need when
// working with C++11 variadic templates). `absl::integer_sequence` is designed
// to be a drop-in replacement for C++14's `std::integer_sequence`.
//
// Example:
//
//   template< class T, T... Ints >
//   void user_function(integer_sequence<T, Ints...>);
//
//   int main()
//   {
//     // user_function's `T` will be deduced to `int` and `Ints...`
//     // will be deduced to `0, 1, 2, 3, 4`.
//     user_function(make_integer_sequence<int, 5>());
//   }
template <typename T, T... Ints>
struct integer_sequence
{
    using value_type = T;
    static constexpr std::size_t size() noexcept
    {
        return sizeof...(Ints);
    }
};

// index_sequence
//
// A helper template for an `integer_sequence` of `size_t`,
// `absl::index_sequence` is designed to be a drop-in replacement for C++14's
// `std::index_sequence`.
template <size_t... Ints>
using index_sequence = integer_sequence<size_t, Ints...>;

namespace utility_internal
{

template <typename Seq, size_t SeqSize, size_t Rem>
struct Extend;

// Note that SeqSize == sizeof...(Ints). It's passed explicitly for efficiency.
template <typename T, T... Ints, size_t SeqSize>
struct Extend<integer_sequence<T, Ints...>, SeqSize, 0>
{
    using type = integer_sequence < T, Ints..., (Ints + SeqSize)... >;
};

template <typename T, T... Ints, size_t SeqSize>
struct Extend<integer_sequence<T, Ints...>, SeqSize, 1>
{
    using type = integer_sequence < T, Ints..., (Ints + SeqSize)..., 2 * SeqSize >;
};

// Recursion helper for 'make_integer_sequence<T, N>'.
// 'Gen<T, N>::type' is an alias for 'integer_sequence<T, 0, 1, ... N-1>'.
template <typename T, size_t N>
struct Gen
{
    using type =
        typename Extend < typename Gen < T, N / 2 >::type, N / 2, N % 2 >::type;
};

template <typename T>
struct Gen<T, 0>
{
    using type = integer_sequence<T>;
};

}  // namespace utility_internal

// Compile-time sequences of integers

// make_integer_sequence
//
// This template alias is equivalent to
// `integer_sequence<int, 0, 1, ..., N-1>`, and is designed to be a drop-in
// replacement for C++14's `std::make_integer_sequence`.
template <typename T, T N>
using make_integer_sequence = typename utility_internal::Gen<T, N>::type;

// make_index_sequence
//
// This template alias is equivalent to `index_sequence<0, 1, ..., N-1>`,
// and is designed to be a drop-in replacement for C++14's
// `std::make_index_sequence`.
template <size_t N>
using make_index_sequence = make_integer_sequence<size_t, N>;

// index_sequence_for
//
// Converts a typename pack into an index sequence of the same length, and
// is designed to be a drop-in replacement for C++14's
// `std::index_sequence_for()`
template <typename... Ts>
using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

//// END OF CODE FROM GOOGLE ABSEIL

#endif

// dispatch utility (taken from ranges-v3)
template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
template<> struct priority_tag<0> {};

// taken from ranges-v3
template<typename T>
struct static_const
{
    static JSON_INLINE_VARIABLE constexpr T value{};
};

#ifndef JSON_HAS_CPP_17
    template<typename T>
    constexpr T static_const<T>::value;
#endif

template<typename T, typename... Args>
constexpr std::array<T, sizeof...(Args)> make_array(Args&& ... args)
{
    return std::array<T, sizeof...(Args)> {{static_cast<T>(std::forward<Args>(args))...}};
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/type_traits.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <limits> // numeric_limits
#include <string> // char_traits
#include <tuple> // tuple
#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type
#include <utility> // declval
#if defined(__cpp_lib_byte) && __cpp_lib_byte >= 201603L
    #include <cstddef> // byte
#endif
// #include <nlohmann/detail/iterators/iterator_traits.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <iterator> // random_access_iterator_tag

// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/meta/void_t.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename It, typename = void>
struct iterator_types {};

template<typename It>
struct iterator_types <
    It,
    void_t<typename It::difference_type, typename It::value_type, typename It::pointer,
    typename It::reference, typename It::iterator_category >>
{
    using difference_type = typename It::difference_type;
    using value_type = typename It::value_type;
    using pointer = typename It::pointer;
    using reference = typename It::reference;
    using iterator_category = typename It::iterator_category;
};

// This is required as some compilers implement std::iterator_traits in a way that
// doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.
template<typename T, typename = void>
struct iterator_traits
{
};

template<typename T>
struct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>
    : iterator_types<T>
{
};

template<typename T>
struct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>
{
    using iterator_category = std::random_access_iterator_tag;
    using value_type = T;
    using difference_type = ptrdiff_t;
    using pointer = T*;
    using reference = T&;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/call_std/begin.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

NLOHMANN_CAN_CALL_STD_FUNC_IMPL(begin);

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/call_std/end.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

NLOHMANN_CAN_CALL_STD_FUNC_IMPL(end);

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/detected.hpp>

// #include <nlohmann/json_fwd.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
    #define INCLUDE_NLOHMANN_JSON_FWD_HPP_

    #include <cstdint> // int64_t, uint64_t
    #include <map> // map
    #include <memory> // allocator
    #include <string> // string
    #include <vector> // vector

    // #include <nlohmann/detail/abi_macros.hpp>


    /*!
    @brief namespace for Niels Lohmann
    @see https://github.com/nlohmann
    @since version 1.0.0
    */
    NLOHMANN_JSON_NAMESPACE_BEGIN

    /*!
    @brief default JSONSerializer template argument

    This serializer ignores the template arguments and uses ADL
    ([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
    for serialization.
    */
    template<typename T = void, typename SFINAE = void>
    struct adl_serializer;

    /// a class to store JSON values
    /// @sa https://json.nlohmann.me/api/basic_json/
    template<template<typename U, typename V, typename... Args> class ObjectType =
    std::map,
    template<typename U, typename... Args> class ArrayType = std::vector,
    class StringType = std::string, class BooleanType = bool,
    class NumberIntegerType = std::int64_t,
    class NumberUnsignedType = std::uint64_t,
    class NumberFloatType = double,
    template<typename U> class AllocatorType = std::allocator,
    template<typename T, typename SFINAE = void> class JSONSerializer =
    adl_serializer,
    class BinaryType = std::vector<std::uint8_t>, // cppcheck-suppress syntaxError
    class CustomBaseClass = void>
    class basic_json;

    /// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document
    /// @sa https://json.nlohmann.me/api/json_pointer/
    template<typename RefStringType>
    class json_pointer;

    /*!
    @brief default specialization
    @sa https://json.nlohmann.me/api/json/
    */
    using json = basic_json<>;

    /// @brief a minimal map-like container that preserves insertion order
    /// @sa https://json.nlohmann.me/api/ordered_map/
    template<class Key, class T, class IgnoredLess, class Allocator>
    struct ordered_map;

    /// @brief specialization that maintains the insertion order of object keys
    /// @sa https://json.nlohmann.me/api/ordered_json/
    using ordered_json = basic_json<nlohmann::ordered_map>;

    NLOHMANN_JSON_NAMESPACE_END

#endif  // INCLUDE_NLOHMANN_JSON_FWD_HPP_


NLOHMANN_JSON_NAMESPACE_BEGIN
/*!
@brief detail namespace with internal helper functions

This namespace collects functions that should not be exposed,
implementations of some @ref basic_json methods, and meta-programming helpers.

@since version 2.1.0
*/
namespace detail
{

/////////////
// helpers //
/////////////

// Note to maintainers:
//
// Every trait in this file expects a non-CV-qualified type.
// The only exceptions are in the 'aliases for detected' section
// (i.e., those of the form: decltype(T::member_function(std::declval<T>())))
//
// In this case, T has to be properly CV-qualified to constraint the function arguments
// (e.g., to_json(BasicJsonType&, const T&))

template<typename> struct is_basic_json : std::false_type {};

NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};

// used by exceptions create() member functions
// true_type for the pointer to possibly cv-qualified basic_json or std::nullptr_t
// false_type otherwise
template<typename BasicJsonContext>
struct is_basic_json_context :
    std::integral_constant < bool,
    is_basic_json<typename std::remove_cv<typename std::remove_pointer<BasicJsonContext>::type>::type>::value
    || std::is_same<BasicJsonContext, std::nullptr_t>::value >
{};

//////////////////////
// json_ref helpers //
//////////////////////

template<typename>
class json_ref;

template<typename>
struct is_json_ref : std::false_type {};

template<typename T>
struct is_json_ref<json_ref<T>> : std::true_type {};

//////////////////////////
// aliases for detected //
//////////////////////////

template<typename T>
using mapped_type_t = typename T::mapped_type;

template<typename T>
using key_type_t = typename T::key_type;

template<typename T>
using value_type_t = typename T::value_type;

template<typename T>
using difference_type_t = typename T::difference_type;

template<typename T>
using pointer_t = typename T::pointer;

template<typename T>
using reference_t = typename T::reference;

template<typename T>
using iterator_category_t = typename T::iterator_category;

template<typename T, typename... Args>
using to_json_function = decltype(T::to_json(std::declval<Args>()...));

template<typename T, typename... Args>
using from_json_function = decltype(T::from_json(std::declval<Args>()...));

template<typename T, typename U>
using get_template_function = decltype(std::declval<T>().template get<U>());

// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
template<typename BasicJsonType, typename T, typename = void>
struct has_from_json : std::false_type {};

// trait checking if j.get<T> is valid
// use this trait instead of std::is_constructible or std::is_convertible,
// both rely on, or make use of implicit conversions, and thus fail when T
// has several constructors/operator= (see https://github.com/nlohmann/json/issues/958)
template <typename BasicJsonType, typename T>
struct is_getable
{
    static constexpr bool value = is_detected<get_template_function, const BasicJsonType&, T>::value;
};

template<typename BasicJsonType, typename T>
struct has_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, from_json_function, serializer,
        const BasicJsonType&, T&>::value;
};

// This trait checks if JSONSerializer<T>::from_json(json const&) exists
// this overload is used for non-default-constructible user-defined-types
template<typename BasicJsonType, typename T, typename = void>
struct has_non_default_from_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_non_default_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<T, from_json_function, serializer,
        const BasicJsonType&>::value;
};

// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.
template<typename BasicJsonType, typename T, typename = void>
struct has_to_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_to_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
        T>::value;
};

template<typename T>
using detect_key_compare = typename T::key_compare;

template<typename T>
struct has_key_compare : std::integral_constant<bool, is_detected<detect_key_compare, T>::value> {};

// obtains the actual object key comparator
template<typename BasicJsonType>
struct actual_object_comparator
{
    using object_t = typename BasicJsonType::object_t;
    using object_comparator_t = typename BasicJsonType::default_object_comparator_t;
    using type = typename std::conditional < has_key_compare<object_t>::value,
          typename object_t::key_compare, object_comparator_t>::type;
};

template<typename BasicJsonType>
using actual_object_comparator_t = typename actual_object_comparator<BasicJsonType>::type;

/////////////////
// char_traits //
/////////////////

// Primary template of char_traits calls std char_traits
template<typename T>
struct char_traits : std::char_traits<T>
{};

// Explicitly define char traits for unsigned char since it is not standard
template<>
struct char_traits<unsigned char> : std::char_traits<char>
{
    using char_type = unsigned char;
    using int_type = uint64_t;

    // Redefine to_int_type function
    static int_type to_int_type(char_type c) noexcept
    {
        return static_cast<int_type>(c);
    }

    static char_type to_char_type(int_type i) noexcept
    {
        return static_cast<char_type>(i);
    }

    static constexpr int_type eof() noexcept
    {
        return static_cast<int_type>(std::char_traits<char>::eof());
    }
};

// Explicitly define char traits for signed char since it is not standard
template<>
struct char_traits<signed char> : std::char_traits<char>
{
    using char_type = signed char;
    using int_type = uint64_t;

    // Redefine to_int_type function
    static int_type to_int_type(char_type c) noexcept
    {
        return static_cast<int_type>(c);
    }

    static char_type to_char_type(int_type i) noexcept
    {
        return static_cast<char_type>(i);
    }

    static constexpr int_type eof() noexcept
    {
        return static_cast<int_type>(std::char_traits<char>::eof());
    }
};

#if defined(__cpp_lib_byte) && __cpp_lib_byte >= 201603L
template<>
struct char_traits<std::byte> : std::char_traits<char>
{
    using char_type = std::byte;
    using int_type = uint64_t;

    static int_type to_int_type(char_type c) noexcept
    {
        return static_cast<int_type>(std::to_integer<unsigned char>(c));
    }

    static char_type to_char_type(int_type i) noexcept
    {
        return std::byte(static_cast<unsigned char>(i));
    }

    static constexpr int_type eof() noexcept
    {
        return static_cast<int_type>(std::char_traits<char>::eof());
    }
};
#endif

///////////////////
// is_ functions //
///////////////////

// https://en.cppreference.com/w/cpp/types/conjunction
template<class...> struct conjunction : std::true_type { };
template<class B> struct conjunction<B> : B { };
template<class B, class... Bn>
struct conjunction<B, Bn...>
: std::conditional<static_cast<bool>(B::value), conjunction<Bn...>, B>::type {};

// https://en.cppreference.com/w/cpp/types/negation
template<class B> struct negation : std::integral_constant < bool, !B::value > { };

// Reimplementation of is_constructible and is_default_constructible, due to them being broken for
// std::pair and std::tuple until LWG 2367 fix (see https://cplusplus.github.io/LWG/lwg-defects.html#2367).
// This causes compile errors in e.g., Clang 3.5 or GCC 4.9.
template <typename T>
struct is_default_constructible : std::is_default_constructible<T> {};

template <typename T1, typename T2>
struct is_default_constructible<std::pair<T1, T2>>
    : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};

template <typename T1, typename T2>
struct is_default_constructible<const std::pair<T1, T2>>
    : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};

template <typename... Ts>
struct is_default_constructible<std::tuple<Ts...>>
    : conjunction<is_default_constructible<Ts>...> {};

template <typename... Ts>
struct is_default_constructible<const std::tuple<Ts...>>
    : conjunction<is_default_constructible<Ts>...> {};

template <typename T, typename... Args>
struct is_constructible : std::is_constructible<T, Args...> {};

template <typename T1, typename T2>
struct is_constructible<std::pair<T1, T2>> : is_default_constructible<std::pair<T1, T2>> {};

template <typename T1, typename T2>
struct is_constructible<const std::pair<T1, T2>> : is_default_constructible<const std::pair<T1, T2>> {};

template <typename... Ts>
struct is_constructible<std::tuple<Ts...>> : is_default_constructible<std::tuple<Ts...>> {};

template <typename... Ts>
struct is_constructible<const std::tuple<Ts...>> : is_default_constructible<const std::tuple<Ts...>> {};

template<typename T, typename = void>
struct is_iterator_traits : std::false_type {};

template<typename T>
struct is_iterator_traits<iterator_traits<T>>
{
  private:
    using traits = iterator_traits<T>;

  public:
    static constexpr auto value =
        is_detected<value_type_t, traits>::value &&
        is_detected<difference_type_t, traits>::value &&
        is_detected<pointer_t, traits>::value &&
        is_detected<iterator_category_t, traits>::value &&
        is_detected<reference_t, traits>::value;
};

template<typename T>
struct is_range
{
  private:
    using t_ref = typename std::add_lvalue_reference<T>::type;

    using iterator = detected_t<result_of_begin, t_ref>;
    using sentinel = detected_t<result_of_end, t_ref>;

    // to be 100% correct, it should use https://en.cppreference.com/w/cpp/iterator/input_or_output_iterator
    // and https://en.cppreference.com/w/cpp/iterator/sentinel_for
    // but reimplementing these would be too much work, as a lot of other concepts are used underneath
    static constexpr auto is_iterator_begin =
        is_iterator_traits<iterator_traits<iterator>>::value;

  public:
    static constexpr bool value = !std::is_same<iterator, nonesuch>::value && !std::is_same<sentinel, nonesuch>::value && is_iterator_begin;
};

template<typename R>
using iterator_t = enable_if_t<is_range<R>::value, result_of_begin<decltype(std::declval<R&>())>>;

template<typename T>
using range_value_t = value_type_t<iterator_traits<iterator_t<T>>>;

// The following implementation of is_complete_type is taken from
// https://blogs.msdn.microsoft.com/vcblog/2015/12/02/partial-support-for-expression-sfinae-in-vs-2015-update-1/
// and is written by Xiang Fan who agreed to use it in this library.

template<typename T, typename = void>
struct is_complete_type : std::false_type {};

template<typename T>
struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};

template<typename BasicJsonType, typename CompatibleObjectType,
         typename = void>
struct is_compatible_object_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type_impl <
    BasicJsonType, CompatibleObjectType,
    enable_if_t < is_detected<mapped_type_t, CompatibleObjectType>::value&&
    is_detected<key_type_t, CompatibleObjectType>::value >>
{
    using object_t = typename BasicJsonType::object_t;

    // macOS's is_constructible does not play well with nonesuch...
    static constexpr bool value =
        is_constructible<typename object_t::key_type,
        typename CompatibleObjectType::key_type>::value &&
        is_constructible<typename object_t::mapped_type,
        typename CompatibleObjectType::mapped_type>::value;
};

template<typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type
    : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};

template<typename BasicJsonType, typename ConstructibleObjectType,
         typename = void>
struct is_constructible_object_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type_impl <
    BasicJsonType, ConstructibleObjectType,
    enable_if_t < is_detected<mapped_type_t, ConstructibleObjectType>::value&&
    is_detected<key_type_t, ConstructibleObjectType>::value >>
{
    using object_t = typename BasicJsonType::object_t;

    static constexpr bool value =
        (is_default_constructible<ConstructibleObjectType>::value &&
         (std::is_move_assignable<ConstructibleObjectType>::value ||
          std::is_copy_assignable<ConstructibleObjectType>::value) &&
         (is_constructible<typename ConstructibleObjectType::key_type,
          typename object_t::key_type>::value &&
          std::is_same <
          typename object_t::mapped_type,
          typename ConstructibleObjectType::mapped_type >::value)) ||
        (has_from_json<BasicJsonType,
         typename ConstructibleObjectType::mapped_type>::value ||
         has_non_default_from_json <
         BasicJsonType,
         typename ConstructibleObjectType::mapped_type >::value);
};

template<typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type
    : is_constructible_object_type_impl<BasicJsonType,
      ConstructibleObjectType> {};

template<typename BasicJsonType, typename CompatibleStringType>
struct is_compatible_string_type
{
    static constexpr auto value =
        is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
};

template<typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type
{
    // launder type through decltype() to fix compilation failure on ICPC
#ifdef __INTEL_COMPILER
    using laundered_type = decltype(std::declval<ConstructibleStringType>());
#else
    using laundered_type = ConstructibleStringType;
#endif

    static constexpr auto value =
        conjunction <
        is_constructible<laundered_type, typename BasicJsonType::string_t>,
        is_detected_exact<typename BasicJsonType::string_t::value_type,
        value_type_t, laundered_type >>::value;
};

template<typename BasicJsonType, typename CompatibleArrayType, typename = void>
struct is_compatible_array_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type_impl <
    BasicJsonType, CompatibleArrayType,
    enable_if_t <
    is_detected<iterator_t, CompatibleArrayType>::value&&
    is_iterator_traits<iterator_traits<detected_t<iterator_t, CompatibleArrayType>>>::value&&
// special case for types like std::filesystem::path whose iterator's value_type are themselves
// c.f. https://github.com/nlohmann/json/pull/3073
    !std::is_same<CompatibleArrayType, detected_t<range_value_t, CompatibleArrayType>>::value >>
{
    static constexpr bool value =
        is_constructible<BasicJsonType,
        range_value_t<CompatibleArrayType>>::value;
};

template<typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type
    : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};

template<typename BasicJsonType, typename ConstructibleArrayType, typename = void>
struct is_constructible_array_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t<std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value >>
            : std::true_type {};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t < !std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value&&
    !is_compatible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
    is_default_constructible<ConstructibleArrayType>::value&&
(std::is_move_assignable<ConstructibleArrayType>::value ||
 std::is_copy_assignable<ConstructibleArrayType>::value)&&
is_detected<iterator_t, ConstructibleArrayType>::value&&
is_iterator_traits<iterator_traits<detected_t<iterator_t, ConstructibleArrayType>>>::value&&
is_detected<range_value_t, ConstructibleArrayType>::value&&
// special case for types like std::filesystem::path whose iterator's value_type are themselves
// c.f. https://github.com/nlohmann/json/pull/3073
!std::is_same<ConstructibleArrayType, detected_t<range_value_t, ConstructibleArrayType>>::value&&
is_complete_type <
detected_t<range_value_t, ConstructibleArrayType >>::value >>
{
    using value_type = range_value_t<ConstructibleArrayType>;

    static constexpr bool value =
        std::is_same<value_type,
        typename BasicJsonType::array_t::value_type>::value ||
        has_from_json<BasicJsonType,
        value_type>::value ||
        has_non_default_from_json <
        BasicJsonType,
        value_type >::value;
};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type
    : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType,
         typename = void>
struct is_compatible_integer_type_impl : std::false_type {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type_impl <
    RealIntegerType, CompatibleNumberIntegerType,
    enable_if_t < std::is_integral<RealIntegerType>::value&&
    std::is_integral<CompatibleNumberIntegerType>::value&&
    !std::is_same<bool, CompatibleNumberIntegerType>::value >>
{
    // is there an assert somewhere on overflows?
    using RealLimits = std::numeric_limits<RealIntegerType>;
    using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;

    static constexpr auto value =
        is_constructible<RealIntegerType,
        CompatibleNumberIntegerType>::value &&
        CompatibleLimits::is_integer &&
        RealLimits::is_signed == CompatibleLimits::is_signed;
};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type
    : is_compatible_integer_type_impl<RealIntegerType,
      CompatibleNumberIntegerType> {};

template<typename BasicJsonType, typename CompatibleType, typename = void>
struct is_compatible_type_impl: std::false_type {};

template<typename BasicJsonType, typename CompatibleType>
struct is_compatible_type_impl <
    BasicJsonType, CompatibleType,
    enable_if_t<is_complete_type<CompatibleType>::value >>
{
    static constexpr bool value =
        has_to_json<BasicJsonType, CompatibleType>::value;
};

template<typename BasicJsonType, typename CompatibleType>
struct is_compatible_type
    : is_compatible_type_impl<BasicJsonType, CompatibleType> {};

template<typename T1, typename T2>
struct is_constructible_tuple : std::false_type {};

template<typename T1, typename... Args>
struct is_constructible_tuple<T1, std::tuple<Args...>> : conjunction<is_constructible<T1, Args>...> {};

template<typename BasicJsonType, typename T>
struct is_json_iterator_of : std::false_type {};

template<typename BasicJsonType>
struct is_json_iterator_of<BasicJsonType, typename BasicJsonType::iterator> : std::true_type {};

template<typename BasicJsonType>
struct is_json_iterator_of<BasicJsonType, typename BasicJsonType::const_iterator> : std::true_type
{};

// checks if a given type T is a template specialization of Primary
template<template <typename...> class Primary, typename T>
struct is_specialization_of : std::false_type {};

template<template <typename...> class Primary, typename... Args>
struct is_specialization_of<Primary, Primary<Args...>> : std::true_type {};

template<typename T>
using is_json_pointer = is_specialization_of<::nlohmann::json_pointer, uncvref_t<T>>;

// checks if A and B are comparable using Compare functor
template<typename Compare, typename A, typename B, typename = void>
struct is_comparable : std::false_type {};

template<typename Compare, typename A, typename B>
struct is_comparable<Compare, A, B, void_t<
decltype(std::declval<Compare>()(std::declval<A>(), std::declval<B>())),
decltype(std::declval<Compare>()(std::declval<B>(), std::declval<A>()))
>> : std::true_type {};

template<typename T>
using detect_is_transparent = typename T::is_transparent;

// type trait to check if KeyType can be used as an object key (without a BasicJsonType)
// see is_usable_as_basic_json_key_type below
template<typename Comparator, typename ObjectKeyType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
         bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t<KeyTypeCVRef>>
using is_usable_as_key_type = typename std::conditional <
                              is_comparable<Comparator, ObjectKeyType, KeyTypeCVRef>::value
                              && !(ExcludeObjectKeyType && std::is_same<KeyType,
                                   ObjectKeyType>::value)
                              && (!RequireTransparentComparator
                                  || is_detected <detect_is_transparent, Comparator>::value)
                              && !is_json_pointer<KeyType>::value,
                              std::true_type,
                              std::false_type >::type;

// type trait to check if KeyType can be used as an object key
// true if:
//   - KeyType is comparable with BasicJsonType::object_t::key_type
//   - if ExcludeObjectKeyType is true, KeyType is not BasicJsonType::object_t::key_type
//   - the comparator is transparent or RequireTransparentComparator is false
//   - KeyType is not a JSON iterator or json_pointer
template<typename BasicJsonType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
         bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t<KeyTypeCVRef>>
using is_usable_as_basic_json_key_type = typename std::conditional <
    is_usable_as_key_type<typename BasicJsonType::object_comparator_t,
    typename BasicJsonType::object_t::key_type, KeyTypeCVRef,
    RequireTransparentComparator, ExcludeObjectKeyType>::value
    && !is_json_iterator_of<BasicJsonType, KeyType>::value,
    std::true_type,
    std::false_type >::type;

template<typename ObjectType, typename KeyType>
using detect_erase_with_key_type = decltype(std::declval<ObjectType&>().erase(std::declval<KeyType>()));

// type trait to check if object_t has an erase() member functions accepting KeyType
template<typename BasicJsonType, typename KeyType>
using has_erase_with_key_type = typename std::conditional <
                                is_detected <
                                detect_erase_with_key_type,
                                typename BasicJsonType::object_t, KeyType >::value,
                                std::true_type,
                                std::false_type >::type;

// a naive helper to check if a type is an ordered_map (exploits the fact that
// ordered_map inherits capacity() from std::vector)
template <typename T>
struct is_ordered_map
{
    using one = char;

    struct two
    {
        char x[2]; // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
    };

    template <typename C> static one test( decltype(&C::capacity) ) ;
    template <typename C> static two test(...);

    enum { value = sizeof(test<T>(nullptr)) == sizeof(char) }; // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
};

// to avoid useless casts (see https://github.com/nlohmann/json/issues/2893#issuecomment-889152324)
template < typename T, typename U, enable_if_t < !std::is_same<T, U>::value, int > = 0 >
T conditional_static_cast(U value)
{
    return static_cast<T>(value);
}

template<typename T, typename U, enable_if_t<std::is_same<T, U>::value, int> = 0>
T conditional_static_cast(U value)
{
    return value;
}

template<typename... Types>
using all_integral = conjunction<std::is_integral<Types>...>;

template<typename... Types>
using all_signed = conjunction<std::is_signed<Types>...>;

template<typename... Types>
using all_unsigned = conjunction<std::is_unsigned<Types>...>;

// there's a disjunction trait in another PR; replace when merged
template<typename... Types>
using same_sign = std::integral_constant < bool,
      all_signed<Types...>::value || all_unsigned<Types...>::value >;

template<typename OfType, typename T>
using never_out_of_range = std::integral_constant < bool,
      (std::is_signed<OfType>::value && (sizeof(T) < sizeof(OfType)))
      || (same_sign<OfType, T>::value && sizeof(OfType) == sizeof(T)) >;

template<typename OfType, typename T,
         bool OfTypeSigned = std::is_signed<OfType>::value,
         bool TSigned = std::is_signed<T>::value>
struct value_in_range_of_impl2;

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, false, false>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, true, false>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, false, true>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return val >= 0 && static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, true, true>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return static_cast<CommonType>(val) >= static_cast<CommonType>((std::numeric_limits<OfType>::min)())
               && static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T,
         bool NeverOutOfRange = never_out_of_range<OfType, T>::value,
         typename = detail::enable_if_t<all_integral<OfType, T>::value>>
struct value_in_range_of_impl1;

template<typename OfType, typename T>
struct value_in_range_of_impl1<OfType, T, false>
{
    static constexpr bool test(T val)
    {
        return value_in_range_of_impl2<OfType, T>::test(val);
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl1<OfType, T, true>
{
    static constexpr bool test(T /*val*/)
    {
        return true;
    }
};

template<typename OfType, typename T>
constexpr bool value_in_range_of(T val)
{
    return value_in_range_of_impl1<OfType, T>::test(val);
}

template<bool Value>
using bool_constant = std::integral_constant<bool, Value>;

///////////////////////////////////////////////////////////////////////////////
// is_c_string
///////////////////////////////////////////////////////////////////////////////

namespace impl
{

template<typename T>
constexpr bool is_c_string()
{
    using TUnExt = typename std::remove_extent<T>::type;
    using TUnCVExt = typename std::remove_cv<TUnExt>::type;
    using TUnPtr = typename std::remove_pointer<T>::type;
    using TUnCVPtr = typename std::remove_cv<TUnPtr>::type;
    return
        (std::is_array<T>::value && std::is_same<TUnCVExt, char>::value)
        || (std::is_pointer<T>::value && std::is_same<TUnCVPtr, char>::value);
}

}  // namespace impl

// checks whether T is a [cv] char */[cv] char[] C string
template<typename T>
struct is_c_string : bool_constant<impl::is_c_string<T>()> {};

template<typename T>
using is_c_string_uncvref = is_c_string<uncvref_t<T>>;

///////////////////////////////////////////////////////////////////////////////
// is_transparent
///////////////////////////////////////////////////////////////////////////////

namespace impl
{

template<typename T>
constexpr bool is_transparent()
{
    return is_detected<detect_is_transparent, T>::value;
}

}  // namespace impl

// checks whether T has a member named is_transparent
template<typename T>
struct is_transparent : bool_constant<impl::is_transparent<T>()> {};

///////////////////////////////////////////////////////////////////////////////

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/string_concat.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstring> // strlen
#include <string> // string
#include <utility> // forward

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/detected.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

inline std::size_t concat_length()
{
    return 0;
}

template<typename... Args>
inline std::size_t concat_length(const char* cstr, const Args& ... rest);

template<typename StringType, typename... Args>
inline std::size_t concat_length(const StringType& str, const Args& ... rest);

template<typename... Args>
inline std::size_t concat_length(const char /*c*/, const Args& ... rest)
{
    return 1 + concat_length(rest...);
}

template<typename... Args>
inline std::size_t concat_length(const char* cstr, const Args& ... rest)
{
    // cppcheck-suppress ignoredReturnValue
    return ::strlen(cstr) + concat_length(rest...);
}

template<typename StringType, typename... Args>
inline std::size_t concat_length(const StringType& str, const Args& ... rest)
{
    return str.size() + concat_length(rest...);
}

template<typename OutStringType>
inline void concat_into(OutStringType& /*out*/)
{}

template<typename StringType, typename Arg>
using string_can_append = decltype(std::declval<StringType&>().append(std::declval < Arg && > ()));

template<typename StringType, typename Arg>
using detect_string_can_append = is_detected<string_can_append, StringType, Arg>;

template<typename StringType, typename Arg>
using string_can_append_op = decltype(std::declval<StringType&>() += std::declval < Arg && > ());

template<typename StringType, typename Arg>
using detect_string_can_append_op = is_detected<string_can_append_op, StringType, Arg>;

template<typename StringType, typename Arg>
using string_can_append_iter = decltype(std::declval<StringType&>().append(std::declval<const Arg&>().begin(), std::declval<const Arg&>().end()));

template<typename StringType, typename Arg>
using detect_string_can_append_iter = is_detected<string_can_append_iter, StringType, Arg>;

template<typename StringType, typename Arg>
using string_can_append_data = decltype(std::declval<StringType&>().append(std::declval<const Arg&>().data(), std::declval<const Arg&>().size()));

template<typename StringType, typename Arg>
using detect_string_can_append_data = is_detected<string_can_append_data, StringType, Arg>;

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && detect_string_can_append_op<OutStringType, Arg>::value, int > = 0 >
inline void concat_into(OutStringType& out, Arg && arg, Args && ... rest);

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && detect_string_can_append_iter<OutStringType, Arg>::value, int > = 0 >
inline void concat_into(OutStringType& out, const Arg& arg, Args && ... rest);

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && !detect_string_can_append_iter<OutStringType, Arg>::value
                         && detect_string_can_append_data<OutStringType, Arg>::value, int > = 0 >
inline void concat_into(OutStringType& out, const Arg& arg, Args && ... rest);

template<typename OutStringType, typename Arg, typename... Args,
         enable_if_t<detect_string_can_append<OutStringType, Arg>::value, int> = 0>
inline void concat_into(OutStringType& out, Arg && arg, Args && ... rest)
{
    out.append(std::forward<Arg>(arg));
    concat_into(out, std::forward<Args>(rest)...);
}

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && detect_string_can_append_op<OutStringType, Arg>::value, int > >
inline void concat_into(OutStringType& out, Arg&& arg, Args&& ... rest)
{
    out += std::forward<Arg>(arg);
    concat_into(out, std::forward<Args>(rest)...);
}

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && detect_string_can_append_iter<OutStringType, Arg>::value, int > >
inline void concat_into(OutStringType& out, const Arg& arg, Args&& ... rest)
{
    out.append(arg.begin(), arg.end());
    concat_into(out, std::forward<Args>(rest)...);
}

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && !detect_string_can_append_iter<OutStringType, Arg>::value
                         && detect_string_can_append_data<OutStringType, Arg>::value, int > >
inline void concat_into(OutStringType& out, const Arg& arg, Args&& ... rest)
{
    out.append(arg.data(), arg.size());
    concat_into(out, std::forward<Args>(rest)...);
}

template<typename OutStringType = std::string, typename... Args>
inline OutStringType concat(Args && ... args)
{
    OutStringType str;
    str.reserve(concat_length(args...));
    concat_into(str, std::forward<Args>(args)...);
    return str;
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END


// With -Wweak-vtables, Clang will complain about the exception classes as they
// have no out-of-line virtual method definitions and their vtable will be
// emitted in every translation unit. This issue cannot be fixed with a
// header-only library as there is no implementation file to move these
// functions to. As a result, we suppress this warning here to avoid client
// code stumbling over this. See https://github.com/nlohmann/json/issues/4087
// for a discussion.
#if defined(__clang__)
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wweak-vtables"
#endif

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

////////////////
// exceptions //
////////////////

/// @brief general exception of the @ref basic_json class
/// @sa https://json.nlohmann.me/api/basic_json/exception/
class exception : public std::exception
{
  public:
    /// returns the explanatory string
    const char* what() const noexcept override
    {
        return m.what();
    }

    /// the id of the exception
    const int id; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes)

  protected:
    JSON_HEDLEY_NON_NULL(3)
    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {} // NOLINT(bugprone-throw-keyword-missing)

    static std::string name(const std::string& ename, int id_)
    {
        return concat("[json.exception.", ename, '.', std::to_string(id_), "] ");
    }

    static std::string diagnostics(std::nullptr_t /*leaf_element*/)
    {
        return "";
    }

    template<typename BasicJsonType>
    static std::string diagnostics(const BasicJsonType* leaf_element)
    {
#if JSON_DIAGNOSTICS
        std::vector<std::string> tokens;
        for (const auto* current = leaf_element; current != nullptr && current->m_parent != nullptr; current = current->m_parent)
        {
            switch (current->m_parent->type())
            {
                case value_t::array:
                {
                    for (std::size_t i = 0; i < current->m_parent->m_data.m_value.array->size(); ++i)
                    {
                        if (&current->m_parent->m_data.m_value.array->operator[](i) == current)
                        {
                            tokens.emplace_back(std::to_string(i));
                            break;
                        }
                    }
                    break;
                }

                case value_t::object:
                {
                    for (const auto& element : *current->m_parent->m_data.m_value.object)
                    {
                        if (&element.second == current)
                        {
                            tokens.emplace_back(element.first.c_str());
                            break;
                        }
                    }
                    break;
                }

                case value_t::null: // LCOV_EXCL_LINE
                case value_t::string: // LCOV_EXCL_LINE
                case value_t::boolean: // LCOV_EXCL_LINE
                case value_t::number_integer: // LCOV_EXCL_LINE
                case value_t::number_unsigned: // LCOV_EXCL_LINE
                case value_t::number_float: // LCOV_EXCL_LINE
                case value_t::binary: // LCOV_EXCL_LINE
                case value_t::discarded: // LCOV_EXCL_LINE
                default:   // LCOV_EXCL_LINE
                    break; // LCOV_EXCL_LINE
            }
        }

        if (tokens.empty())
        {
            return "";
        }

        auto str = std::accumulate(tokens.rbegin(), tokens.rend(), std::string{},
                                   [](const std::string & a, const std::string & b)
        {
            return concat(a, '/', detail::escape(b));
        });

        return concat('(', str, ") ", get_byte_positions(leaf_element));
#else
        return get_byte_positions(leaf_element);
#endif
    }

  private:
    /// an exception object as storage for error messages
    std::runtime_error m;
#if JSON_DIAGNOSTIC_POSITIONS
    template<typename BasicJsonType>
    static std::string get_byte_positions(const BasicJsonType* leaf_element)
    {
        if ((leaf_element->start_pos() != std::string::npos) && (leaf_element->end_pos() != std::string::npos))
        {
            return concat("(bytes ", std::to_string(leaf_element->start_pos()), "-", std::to_string(leaf_element->end_pos()), ") ");
        }
        return "";
    }
#else
    template<typename BasicJsonType>
    static std::string get_byte_positions(const BasicJsonType* leaf_element)
    {
        static_cast<void>(leaf_element);
        return "";
    }
#endif
};

/// @brief exception indicating a parse error
/// @sa https://json.nlohmann.me/api/basic_json/parse_error/
class parse_error : public exception
{
  public:
    /*!
    @brief create a parse error exception
    @param[in] id_       the id of the exception
    @param[in] pos       the position where the error occurred (or with
                         chars_read_total=0 if the position cannot be
                         determined)
    @param[in] what_arg  the explanatory string
    @return parse_error object
    */
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static parse_error create(int id_, const position_t& pos, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("parse_error", id_), "parse error",
                                     position_string(pos), ": ", exception::diagnostics(context), what_arg);
        return {id_, pos.chars_read_total, w.c_str()};
    }

    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static parse_error create(int id_, std::size_t byte_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("parse_error", id_), "parse error",
                                     (byte_ != 0 ? (concat(" at byte ", std::to_string(byte_))) : ""),
                                     ": ", exception::diagnostics(context), what_arg);
        return {id_, byte_, w.c_str()};
    }

    /*!
    @brief byte index of the parse error

    The byte index of the last read character in the input file.

    @note For an input with n bytes, 1 is the index of the first character and
          n+1 is the index of the terminating null byte or the end of file.
          This also holds true when reading a byte vector (CBOR or MessagePack).
    */
    const std::size_t byte;

  private:
    parse_error(int id_, std::size_t byte_, const char* what_arg)
        : exception(id_, what_arg), byte(byte_) {}

    static std::string position_string(const position_t& pos)
    {
        return concat(" at line ", std::to_string(pos.lines_read + 1),
                      ", column ", std::to_string(pos.chars_read_current_line));
    }
};

/// @brief exception indicating errors with iterators
/// @sa https://json.nlohmann.me/api/basic_json/invalid_iterator/
class invalid_iterator : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static invalid_iterator create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("invalid_iterator", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    invalid_iterator(int id_, const char* what_arg)
        : exception(id_, what_arg) {}
};

/// @brief exception indicating executing a member function with a wrong type
/// @sa https://json.nlohmann.me/api/basic_json/type_error/
class type_error : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static type_error create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("type_error", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/// @brief exception indicating access out of the defined range
/// @sa https://json.nlohmann.me/api/basic_json/out_of_range/
class out_of_range : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static out_of_range create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("out_of_range", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/// @brief exception indicating other library errors
/// @sa https://json.nlohmann.me/api/basic_json/other_error/
class other_error : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static other_error create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("other_error", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

#if defined(__clang__)
    #pragma clang diagnostic pop
#endif

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/identity_tag.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// dispatching helper struct
template <class T> struct identity_tag {};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/std_fs.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/macro_scope.hpp>


#if JSON_HAS_EXPERIMENTAL_FILESYSTEM
#include <experimental/filesystem>
NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{
namespace std_fs = std::experimental::filesystem;
}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END
#elif JSON_HAS_FILESYSTEM
#include <filesystem> // NOLINT(build/c++17)
NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{
namespace std_fs = std::filesystem;
}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END
#endif

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/value_t.hpp>


// include after macro_scope.hpp
#ifdef JSON_HAS_CPP_17
    #include <optional> // optional
#endif

#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
    #include <string_view> // u8string_view
#endif

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_null()))
    {
        JSON_THROW(type_error::create(302, concat("type must be null, but is ", j.type_name()), &j));
    }
    n = nullptr;
}

#ifdef JSON_HAS_CPP_17
template<typename BasicJsonType, typename T>
void from_json(const BasicJsonType& j, std::optional<T>& opt)
{
    if (j.is_null())
    {
        opt = std::nullopt;
    }
    else
    {
        opt.emplace(j.template get<T>());
    }
}
#endif // JSON_HAS_CPP_17

// overloads for basic_json template parameters
template < typename BasicJsonType, typename ArithmeticType,
           enable_if_t < std::is_arithmetic<ArithmeticType>::value&&
                         !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
                         int > = 0 >
void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }

        case value_t::null:
        case value_t::object:
        case value_t::array:
        case value_t::string:
        case value_t::boolean:
        case value_t::binary:
        case value_t::discarded:
        default:
            JSON_THROW(type_error::create(302, concat("type must be number, but is ", j.type_name()), &j));
    }
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))
    {
        JSON_THROW(type_error::create(302, concat("type must be boolean, but is ", j.type_name()), &j));
    }
    b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
    }
    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template <
    typename BasicJsonType, typename StringType,
    enable_if_t <
        std::is_assignable<StringType&, const typename BasicJsonType::string_t>::value
        && is_detected_exact<typename BasicJsonType::string_t::value_type, value_type_t, StringType>::value
        && !std::is_same<typename BasicJsonType::string_t, StringType>::value
        && !is_json_ref<StringType>::value, int > = 0 >
inline void from_json(const BasicJsonType& j, StringType& s)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
    }

    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
{
    get_arithmetic_value(j, val);
}

#if !JSON_DISABLE_ENUM_SERIALIZATION
template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
inline void from_json(const BasicJsonType& j, EnumType& e)
{
    typename std::underlying_type<EnumType>::type val;
    get_arithmetic_value(j, val);
    e = static_cast<EnumType>(val);
}
#endif  // JSON_DISABLE_ENUM_SERIALIZATION

// forward_list doesn't have an insert method
template<typename BasicJsonType, typename T, typename Allocator,
         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
inline void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    l.clear();
    std::transform(j.rbegin(), j.rend(),
                   std::front_inserter(l), [](const BasicJsonType & i)
    {
        return i.template get<T>();
    });
}

// valarray doesn't have an insert method
template<typename BasicJsonType, typename T,
         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
inline void from_json(const BasicJsonType& j, std::valarray<T>& l)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    l.resize(j.size());
    std::transform(j.begin(), j.end(), std::begin(l),
                   [](const BasicJsonType & elem)
    {
        return elem.template get<T>();
    });
}

template<typename BasicJsonType, typename T, std::size_t N>
auto from_json(const BasicJsonType& j, T (&arr)[N])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType, typename T, std::size_t N1, std::size_t N2>
auto from_json(const BasicJsonType& j, T (&arr)[N1][N2])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i1 = 0; i1 < N1; ++i1)
    {
        for (std::size_t i2 = 0; i2 < N2; ++i2)
        {
            arr[i1][i2] = j.at(i1).at(i2).template get<T>();
        }
    }
}

template<typename BasicJsonType, typename T, std::size_t N1, std::size_t N2, std::size_t N3>
auto from_json(const BasicJsonType& j, T (&arr)[N1][N2][N3])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i1 = 0; i1 < N1; ++i1)
    {
        for (std::size_t i2 = 0; i2 < N2; ++i2)
        {
            for (std::size_t i3 = 0; i3 < N3; ++i3)
            {
                arr[i1][i2][i3] = j.at(i1).at(i2).at(i3).template get<T>();
            }
        }
    }
}

template<typename BasicJsonType, typename T, std::size_t N1, std::size_t N2, std::size_t N3, std::size_t N4>
auto from_json(const BasicJsonType& j, T (&arr)[N1][N2][N3][N4])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i1 = 0; i1 < N1; ++i1)
    {
        for (std::size_t i2 = 0; i2 < N2; ++i2)
        {
            for (std::size_t i3 = 0; i3 < N3; ++i3)
            {
                for (std::size_t i4 = 0; i4 < N4; ++i4)
                {
                    arr[i1][i2][i3][i4] = j.at(i1).at(i2).at(i3).at(i4).template get<T>();
                }
            }
        }
    }
}

template<typename BasicJsonType>
inline void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)
{
    arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
}

template<typename BasicJsonType, typename T, std::size_t N>
auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
                          priority_tag<2> /*unused*/)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType, typename ConstructibleArrayType,
         enable_if_t<
             std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
             int> = 0>
auto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> /*unused*/)
-> decltype(
    arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
    j.template get<typename ConstructibleArrayType::value_type>(),
    void())
{
    using std::end;

    ConstructibleArrayType ret;
    ret.reserve(j.size());
    std::transform(j.begin(), j.end(),
                   std::inserter(ret, end(ret)), [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template<typename BasicJsonType, typename ConstructibleArrayType,
         enable_if_t<
             std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
             int> = 0>
inline void from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,
                                 priority_tag<0> /*unused*/)
{
    using std::end;

    ConstructibleArrayType ret;
    std::transform(
        j.begin(), j.end(), std::inserter(ret, end(ret)),
        [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template < typename BasicJsonType, typename ConstructibleArrayType,
           enable_if_t <
               is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value&&
               !is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value&&
               !is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
               !std::is_same<ConstructibleArrayType, typename BasicJsonType::binary_t>::value&&
               !is_basic_json<ConstructibleArrayType>::value,
               int > = 0 >
auto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)
-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
j.template get<typename ConstructibleArrayType::value_type>(),
void())
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }

    from_json_array_impl(j, arr, priority_tag<3> {});
}

template < typename BasicJsonType, typename T, std::size_t... Idx >
std::array<T, sizeof...(Idx)> from_json_inplace_array_impl(BasicJsonType&& j,
                     identity_tag<std::array<T, sizeof...(Idx)>> /*unused*/, index_sequence<Idx...> /*unused*/)
{
    return { { std::forward<BasicJsonType>(j).at(Idx).template get<T>()... } };
}

template < typename BasicJsonType, typename T, std::size_t N >
auto from_json(BasicJsonType&& j, identity_tag<std::array<T, N>> tag)
-> decltype(from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {}))
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }

    return from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {});
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))
    {
        JSON_THROW(type_error::create(302, concat("type must be binary, but is ", j.type_name()), &j));
    }

    bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();
}

template<typename BasicJsonType, typename ConstructibleObjectType,
         enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>
inline void from_json(const BasicJsonType& j, ConstructibleObjectType& obj)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
    {
        JSON_THROW(type_error::create(302, concat("type must be object, but is ", j.type_name()), &j));
    }

    ConstructibleObjectType ret;
    const auto* inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
    using value_type = typename ConstructibleObjectType::value_type;
    std::transform(
        inner_object->begin(), inner_object->end(),
        std::inserter(ret, ret.begin()),
        [](typename BasicJsonType::object_t::value_type const & p)
    {
        return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());
    });
    obj = std::move(ret);
}

// overload for arithmetic types, not chosen for basic_json template arguments
// (BooleanType, etc.); note: Is it really necessary to provide explicit
// overloads for boolean_t etc. in case of a custom BooleanType which is not
// an arithmetic type?
template < typename BasicJsonType, typename ArithmeticType,
           enable_if_t <
               std::is_arithmetic<ArithmeticType>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
               int > = 0 >
inline void from_json(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }
        case value_t::boolean:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
            break;
        }

        case value_t::null:
        case value_t::object:
        case value_t::array:
        case value_t::string:
        case value_t::binary:
        case value_t::discarded:
        default:
            JSON_THROW(type_error::create(302, concat("type must be number, but is ", j.type_name()), &j));
    }
}

template<typename BasicJsonType, typename... Args, std::size_t... Idx>
std::tuple<Args...> from_json_tuple_impl_base(BasicJsonType&& j, index_sequence<Idx...> /*unused*/)
{
    return std::make_tuple(std::forward<BasicJsonType>(j).at(Idx).template get<Args>()...);
}

template<typename BasicJsonType>
std::tuple<> from_json_tuple_impl_base(BasicJsonType& /*unused*/, index_sequence<> /*unused*/)
{
    return {};
}

template < typename BasicJsonType, class A1, class A2 >
std::pair<A1, A2> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::pair<A1, A2>> /*unused*/, priority_tag<0> /*unused*/)
{
    return {std::forward<BasicJsonType>(j).at(0).template get<A1>(),
            std::forward<BasicJsonType>(j).at(1).template get<A2>()};
}

template<typename BasicJsonType, typename A1, typename A2>
inline void from_json_tuple_impl(BasicJsonType&& j, std::pair<A1, A2>& p, priority_tag<1> /*unused*/)
{
    p = from_json_tuple_impl(std::forward<BasicJsonType>(j), identity_tag<std::pair<A1, A2>> {}, priority_tag<0> {});
}

template<typename BasicJsonType, typename... Args>
std::tuple<Args...> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::tuple<Args...>> /*unused*/, priority_tag<2> /*unused*/)
{
    return from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
}

template<typename BasicJsonType, typename... Args>
inline void from_json_tuple_impl(BasicJsonType&& j, std::tuple<Args...>& t, priority_tag<3> /*unused*/)
{
    t = from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
}

template<typename BasicJsonType, typename TupleRelated>
auto from_json(BasicJsonType&& j, TupleRelated&& t)
-> decltype(from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {}))
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }

    return from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {});
}

template < typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
           typename = enable_if_t < !std::is_constructible <
                                        typename BasicJsonType::string_t, Key >::value >>
inline void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
        {
            JSON_THROW(type_error::create(302, concat("type must be array, but is ", p.type_name()), &j));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

template < typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
           typename = enable_if_t < !std::is_constructible <
                                        typename BasicJsonType::string_t, Key >::value >>
inline void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
        {
            JSON_THROW(type_error::create(302, concat("type must be array, but is ", p.type_name()), &j));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, std_fs::path& p)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
    }
    const auto& s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
    // Checking for C++20 standard or later can be insufficient in case the
    // library support for char8_t is either incomplete or was disabled
    // altogether. Use the __cpp_lib_char8_t feature test instead.
#if defined(__cpp_lib_char8_t) && (__cpp_lib_char8_t >= 201907L)
    p = std_fs::path(std::u8string_view(reinterpret_cast<const char8_t*>(s.data()), s.size()));
#else
    p = std_fs::u8path(s); // accepts UTF-8 encoded std::string in C++17, deprecated in C++20
#endif
}
#endif

struct from_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(const BasicJsonType& j, T&& val) const
    noexcept(noexcept(from_json(j, std::forward<T>(val))))
    -> decltype(from_json(j, std::forward<T>(val)))
    {
        return from_json(j, std::forward<T>(val));
    }
};

}  // namespace detail

#ifndef JSON_HAS_CPP_17
/// namespace to hold default `from_json` function
/// to see why this is required:
/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
namespace // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)
{
#endif
JSON_INLINE_VARIABLE constexpr const auto& from_json = // NOLINT(misc-definitions-in-headers)
    detail::static_const<detail::from_json_fn>::value;
#ifndef JSON_HAS_CPP_17
}  // namespace
#endif

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/conversions/to_json.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/macro_scope.hpp>
// JSON_HAS_CPP_17
#ifdef JSON_HAS_CPP_17
    #include <optional> // optional
#endif

#include <algorithm> // copy
#include <iterator> // begin, end
#include <memory> // allocator_traits
#include <string> //  basic_string, char_traits
#include <tuple> // tuple, get
#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type
#include <utility> // move, forward, declval, pair
#include <valarray> // valarray
#include <vector> // vector

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // size_t
#include <iterator> // forward_iterator_tag
#include <tuple> // tuple_size, get, tuple_element
#include <utility> // move

#if JSON_HAS_RANGES
    #include <ranges> // enable_borrowed_range
#endif

// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/string_utils.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // size_t
#include <string> // string, to_string

// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename StringType>
void int_to_string(StringType& target, std::size_t value)
{
    // For ADL
    using std::to_string;
    target = to_string(value);
}

template<typename StringType>
StringType to_string(std::size_t value)
{
    StringType result;
    int_to_string(result, value);
    return result;
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename IteratorType> class iteration_proxy_value
{
  public:
    using difference_type = std::ptrdiff_t;
    using value_type = iteration_proxy_value;
    using pointer = value_type *;
    using reference = value_type &;
    using iterator_category = std::forward_iterator_tag;
    using string_type = typename std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().key() ) >::type >::type;

  private:
    /// the iterator
    IteratorType anchor{};
    /// an index for arrays (used to create key names)
    std::size_t array_index = 0;
    /// last stringified array index
    mutable std::size_t array_index_last = 0;
    /// a string representation of the array index
    mutable string_type array_index_str = "0";
    /// an empty string (to return a reference for primitive values)
    string_type empty_str{};

  public:
    explicit iteration_proxy_value() = default;
    explicit iteration_proxy_value(IteratorType it, std::size_t array_index_ = 0)
    noexcept(std::is_nothrow_move_constructible<IteratorType>::value
             && std::is_nothrow_default_constructible<string_type>::value)
        : anchor(std::move(it))
        , array_index(array_index_)
    {}

    iteration_proxy_value(iteration_proxy_value const&) = default;
    iteration_proxy_value& operator=(iteration_proxy_value const&) = default;
    // older GCCs are a bit fussy and require explicit noexcept specifiers on defaulted functions
    iteration_proxy_value(iteration_proxy_value&&)
    noexcept(std::is_nothrow_move_constructible<IteratorType>::value
             && std::is_nothrow_move_constructible<string_type>::value) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor,cppcoreguidelines-noexcept-move-operations)
    iteration_proxy_value& operator=(iteration_proxy_value&&)
    noexcept(std::is_nothrow_move_assignable<IteratorType>::value
             && std::is_nothrow_move_assignable<string_type>::value) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor,cppcoreguidelines-noexcept-move-operations)
    ~iteration_proxy_value() = default;

    /// dereference operator (needed for range-based for)
    const iteration_proxy_value& operator*() const
    {
        return *this;
    }

    /// increment operator (needed for range-based for)
    iteration_proxy_value& operator++()
    {
        ++anchor;
        ++array_index;

        return *this;
    }

    iteration_proxy_value operator++(int)& // NOLINT(cert-dcl21-cpp)
    {
        auto tmp = iteration_proxy_value(anchor, array_index);
        ++anchor;
        ++array_index;
        return tmp;
    }

    /// equality operator (needed for InputIterator)
    bool operator==(const iteration_proxy_value& o) const
    {
        return anchor == o.anchor;
    }

    /// inequality operator (needed for range-based for)
    bool operator!=(const iteration_proxy_value& o) const
    {
        return anchor != o.anchor;
    }

    /// return key of the iterator
    const string_type& key() const
    {
        JSON_ASSERT(anchor.m_object != nullptr);

        switch (anchor.m_object->type())
        {
            // use integer array index as key
            case value_t::array:
            {
                if (array_index != array_index_last)
                {
                    int_to_string( array_index_str, array_index );
                    array_index_last = array_index;
                }
                return array_index_str;
            }

            // use key from the object
            case value_t::object:
                return anchor.key();

            // use an empty key for all primitive types
            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return empty_str;
        }
    }

    /// return value of the iterator
    typename IteratorType::reference value() const
    {
        return anchor.value();
    }
};

/// proxy class for the items() function
template<typename IteratorType> class iteration_proxy
{
  private:
    /// the container to iterate
    typename IteratorType::pointer container = nullptr;

  public:
    explicit iteration_proxy() = default;

    /// construct iteration proxy from a container
    explicit iteration_proxy(typename IteratorType::reference cont) noexcept
        : container(&cont) {}

    iteration_proxy(iteration_proxy const&) = default;
    iteration_proxy& operator=(iteration_proxy const&) = default;
    iteration_proxy(iteration_proxy&&) noexcept = default;
    iteration_proxy& operator=(iteration_proxy&&) noexcept = default;
    ~iteration_proxy() = default;

    /// return iterator begin (needed for range-based for)
    iteration_proxy_value<IteratorType> begin() const noexcept
    {
        return iteration_proxy_value<IteratorType>(container->begin());
    }

    /// return iterator end (needed for range-based for)
    iteration_proxy_value<IteratorType> end() const noexcept
    {
        return iteration_proxy_value<IteratorType>(container->end());
    }
};

// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template<std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
{
    return i.key();
}
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template<std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
{
    return i.value();
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// The Addition to the STD Namespace is required to add
// Structured Bindings Support to the iteration_proxy_value class
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
namespace std
{

#if defined(__clang__)
    // Fix: https://github.com/nlohmann/json/issues/1401
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wmismatched-tags"
#endif
template<typename IteratorType>
class tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>> // NOLINT(cert-dcl58-cpp)
    : public std::integral_constant<std::size_t, 2> {};

template<std::size_t N, typename IteratorType>
class tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >> // NOLINT(cert-dcl58-cpp)
{
  public:
    using type = decltype(
                     get<N>(std::declval <
                            ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));
};
#if defined(__clang__)
    #pragma clang diagnostic pop
#endif

}  // namespace std

#if JSON_HAS_RANGES
    template <typename IteratorType>
    inline constexpr bool ::std::ranges::enable_borrowed_range<::nlohmann::detail::iteration_proxy<IteratorType>> = true;
#endif

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/std_fs.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

//////////////////
// constructors //
//////////////////

/*
 * Note all external_constructor<>::construct functions need to call
 * j.m_data.m_value.destroy(j.m_data.m_type) to avoid a memory leak in case j contains an
 * allocated value (e.g., a string). See bug issue
 * https://github.com/nlohmann/json/issues/2865 for more information.
 */

template<value_t> struct external_constructor;

template<>
struct external_constructor<value_t::boolean>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::boolean;
        j.m_data.m_value = b;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::string>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::string;
        j.m_data.m_value = s;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::string;
        j.m_data.m_value = std::move(s);
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleStringType,
               enable_if_t < !std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
                             int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleStringType& str)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::string;
        j.m_data.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::binary>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::binary_t& b)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::binary;
        j.m_data.m_value = typename BasicJsonType::binary_t(b);
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::binary_t&& b)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::binary;
        j.m_data.m_value = typename BasicJsonType::binary_t(std::move(b));
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_float>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::number_float;
        j.m_data.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_unsigned>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::number_unsigned;
        j.m_data.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_integer>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::number_integer;
        j.m_data.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::array>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = arr;
        j.set_parents();
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = std::move(arr);
        j.set_parents();
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleArrayType,
               enable_if_t < !std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
                             int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
    {
        using std::begin;
        using std::end;

        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
        j.set_parents();
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const std::vector<bool>& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = value_t::array;
        j.m_data.m_value.array->reserve(arr.size());
        for (const bool x : arr)
        {
            j.m_data.m_value.array->push_back(x);
            j.set_parent(j.m_data.m_value.array->back());
        }
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename T,
             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
    static void construct(BasicJsonType& j, const std::valarray<T>& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = value_t::array;
        j.m_data.m_value.array->resize(arr.size());
        if (arr.size() > 0)
        {
            std::copy(std::begin(arr), std::end(arr), j.m_data.m_value.array->begin());
        }
        j.set_parents();
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::object>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::object;
        j.m_data.m_value = obj;
        j.set_parents();
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::object;
        j.m_data.m_value = std::move(obj);
        j.set_parents();
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleObjectType,
               enable_if_t < !std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
    {
        using std::begin;
        using std::end;

        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::object;
        j.m_data.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
        j.set_parents();
        j.assert_invariant();
    }
};

/////////////
// to_json //
/////////////

#ifdef JSON_HAS_CPP_17
template<typename BasicJsonType, typename T,
         enable_if_t<std::is_constructible<BasicJsonType, T>::value, int> = 0>
void to_json(BasicJsonType& j, const std::optional<T>& opt) noexcept
{
    if (opt.has_value())
    {
        j = *opt;
    }
    else
    {
        j = nullptr;
    }
}
#endif

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
inline void to_json(BasicJsonType& j, T b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, b);
}

template < typename BasicJsonType, typename BoolRef,
           enable_if_t <
               ((std::is_same<std::vector<bool>::reference, BoolRef>::value
                 && !std::is_same <std::vector<bool>::reference, typename BasicJsonType::boolean_t&>::value)
                || (std::is_same<std::vector<bool>::const_reference, BoolRef>::value
                    && !std::is_same <detail::uncvref_t<std::vector<bool>::const_reference>,
                                      typename BasicJsonType::boolean_t >::value))
               && std::is_convertible<const BoolRef&, typename BasicJsonType::boolean_t>::value, int > = 0 >
inline void to_json(BasicJsonType& j, const BoolRef& b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, static_cast<typename BasicJsonType::boolean_t>(b));
}

template<typename BasicJsonType, typename CompatibleString,
         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
inline void to_json(BasicJsonType& j, const CompatibleString& s)
{
    external_constructor<value_t::string>::construct(j, s);
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
{
    external_constructor<value_t::string>::construct(j, std::move(s));
}

template<typename BasicJsonType, typename FloatType,
         enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
inline void to_json(BasicJsonType& j, FloatType val) noexcept
{
    external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
inline void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
{
    external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberIntegerType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
inline void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
{
    external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
}

#if !JSON_DISABLE_ENUM_SERIALIZATION
template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
inline void to_json(BasicJsonType& j, EnumType e) noexcept
{
    using underlying_type = typename std::underlying_type<EnumType>::type;
    static constexpr value_t integral_value_t = std::is_unsigned<underlying_type>::value ? value_t::number_unsigned : value_t::number_integer;
    external_constructor<integral_value_t>::construct(j, static_cast<underlying_type>(e));
}
#endif  // JSON_DISABLE_ENUM_SERIALIZATION

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, const std::vector<bool>& e)
{
    external_constructor<value_t::array>::construct(j, e);
}

template < typename BasicJsonType, typename CompatibleArrayType,
           enable_if_t < is_compatible_array_type<BasicJsonType,
                         CompatibleArrayType>::value&&
                         !is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value&&
                         !is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value&&
                         !std::is_same<typename BasicJsonType::binary_t, CompatibleArrayType>::value&&
                         !is_basic_json<CompatibleArrayType>::value,
                         int > = 0 >
inline void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, const typename BasicJsonType::binary_t& bin)
{
    external_constructor<value_t::binary>::construct(j, bin);
}

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
inline void to_json(BasicJsonType& j, const std::valarray<T>& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template < typename BasicJsonType, typename CompatibleObjectType,
           enable_if_t < is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value&& !is_basic_json<CompatibleObjectType>::value, int > = 0 >
inline void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
{
    external_constructor<value_t::object>::construct(j, obj);
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
{
    external_constructor<value_t::object>::construct(j, std::move(obj));
}

template <
    typename BasicJsonType, typename T, std::size_t N,
    enable_if_t < !std::is_constructible<typename BasicJsonType::string_t,
                  const T(&)[N]>::value, // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
                  int > = 0 >
inline void to_json(BasicJsonType& j, const T(&arr)[N]) // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template < typename BasicJsonType, typename T1, typename T2, enable_if_t < std::is_constructible<BasicJsonType, T1>::value&& std::is_constructible<BasicJsonType, T2>::value, int > = 0 >
inline void to_json(BasicJsonType& j, const std::pair<T1, T2>& p)
{
    j = { p.first, p.second };
}

// for https://github.com/nlohmann/json/pull/1134
template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>
inline void to_json(BasicJsonType& j, const T& b)
{
    j = { {b.key(), b.value()} };
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
inline void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> /*unused*/)
{
    j = { std::get<Idx>(t)... };
}

template<typename BasicJsonType, typename Tuple>
inline void to_json_tuple_impl(BasicJsonType& j, const Tuple& /*unused*/, index_sequence<> /*unused*/)
{
    using array_t = typename BasicJsonType::array_t;
    j = array_t();
}

template<typename BasicJsonType, typename T, enable_if_t<is_constructible_tuple<BasicJsonType, T>::value, int > = 0>
inline void to_json(BasicJsonType& j, const T& t)
{
    to_json_tuple_impl(j, t, make_index_sequence<std::tuple_size<T>::value> {});
}

#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
#if defined(__cpp_lib_char8_t)
template<typename BasicJsonType, typename Tr, typename Allocator>
inline void to_json(BasicJsonType& j, const std::basic_string<char8_t, Tr, Allocator>& s)
{
    using OtherAllocator = typename std::allocator_traits<Allocator>::template rebind_alloc<char>;
    j = std::basic_string<char, std::char_traits<char>, OtherAllocator>(s.begin(), s.end(), s.get_allocator());
}
#endif

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, const std_fs::path& p)
{
    // Returns either a std::string or a std::u8string depending whether library
    // support for char8_t is enabled.
    j = p.u8string();
}
#endif

struct to_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
    -> decltype(to_json(j, std::forward<T>(val)), void())
    {
        return to_json(j, std::forward<T>(val));
    }
};
}  // namespace detail

#ifndef JSON_HAS_CPP_17
/// namespace to hold default `to_json` function
/// to see why this is required:
/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
namespace // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)
{
#endif
JSON_INLINE_VARIABLE constexpr const auto& to_json = // NOLINT(misc-definitions-in-headers)
    detail::static_const<detail::to_json_fn>::value;
#ifndef JSON_HAS_CPP_17
}  // namespace
#endif

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/identity_tag.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

/// @sa https://json.nlohmann.me/api/adl_serializer/
template<typename ValueType, typename>
struct adl_serializer
{
    /// @brief convert a JSON value to any value type
    /// @sa https://json.nlohmann.me/api/adl_serializer/from_json/
    template<typename BasicJsonType, typename TargetType = ValueType>
    static auto from_json(BasicJsonType && j, TargetType& val) noexcept(
        noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
    {
        ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
    }

    /// @brief convert a JSON value to any value type
    /// @sa https://json.nlohmann.me/api/adl_serializer/from_json/
    template<typename BasicJsonType, typename TargetType = ValueType>
    static auto from_json(BasicJsonType && j) noexcept(
    noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {})))
    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {}))
    {
        return ::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {});
    }

    /// @brief convert any value type to a JSON value
    /// @sa https://json.nlohmann.me/api/adl_serializer/to_json/
    template<typename BasicJsonType, typename TargetType = ValueType>
    static auto to_json(BasicJsonType& j, TargetType && val) noexcept(
        noexcept(::nlohmann::to_json(j, std::forward<TargetType>(val))))
    -> decltype(::nlohmann::to_json(j, std::forward<TargetType>(val)), void())
    {
        ::nlohmann::to_json(j, std::forward<TargetType>(val));
    }
};

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/byte_container_with_subtype.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstdint> // uint8_t, uint64_t
#include <tuple> // tie
#include <utility> // move

// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

/// @brief an internal type for a backed binary type
/// @sa https://json.nlohmann.me/api/byte_container_with_subtype/
template<typename BinaryType>
class byte_container_with_subtype : public BinaryType
{
  public:
    using container_type = BinaryType;
    using subtype_type = std::uint64_t;

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype() noexcept(noexcept(container_type()))
        : container_type()
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(const container_type& b) noexcept(noexcept(container_type(b)))
        : container_type(b)
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(container_type&& b) noexcept(noexcept(container_type(std::move(b))))
        : container_type(std::move(b))
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(const container_type& b, subtype_type subtype_) noexcept(noexcept(container_type(b)))
        : container_type(b)
        , m_subtype(subtype_)
        , m_has_subtype(true)
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(container_type&& b, subtype_type subtype_) noexcept(noexcept(container_type(std::move(b))))
        : container_type(std::move(b))
        , m_subtype(subtype_)
        , m_has_subtype(true)
    {}

    bool operator==(const byte_container_with_subtype& rhs) const
    {
        return std::tie(static_cast<const BinaryType&>(*this), m_subtype, m_has_subtype) ==
               std::tie(static_cast<const BinaryType&>(rhs), rhs.m_subtype, rhs.m_has_subtype);
    }

    bool operator!=(const byte_container_with_subtype& rhs) const
    {
        return !(rhs == *this);
    }

    /// @brief sets the binary subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/set_subtype/
    void set_subtype(subtype_type subtype_) noexcept
    {
        m_subtype = subtype_;
        m_has_subtype = true;
    }

    /// @brief return the binary subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/subtype/
    constexpr subtype_type subtype() const noexcept
    {
        return m_has_subtype ? m_subtype : static_cast<subtype_type>(-1);
    }

    /// @brief return whether the value has a subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/has_subtype/
    constexpr bool has_subtype() const noexcept
    {
        return m_has_subtype;
    }

    /// @brief clears the binary subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/clear_subtype/
    void clear_subtype() noexcept
    {
        m_subtype = 0;
        m_has_subtype = false;
    }

  private:
    subtype_type m_subtype = 0;
    bool m_has_subtype = false;
};

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/conversions/from_json.hpp>

// #include <nlohmann/detail/conversions/to_json.hpp>

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/hash.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstdint> // uint8_t
#include <cstddef> // size_t
#include <functional> // hash

// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// boost::hash_combine
inline std::size_t combine(std::size_t seed, std::size_t h) noexcept
{
    seed ^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);
    return seed;
}

/*!
@brief hash a JSON value

The hash function tries to rely on std::hash where possible. Furthermore, the
type of the JSON value is taken into account to have different hash values for
null, 0, 0U, and false, etc.

@tparam BasicJsonType basic_json specialization
@param j JSON value to hash
@return hash value of j
*/
template<typename BasicJsonType>
std::size_t hash(const BasicJsonType& j)
{
    using string_t = typename BasicJsonType::string_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;

    const auto type = static_cast<std::size_t>(j.type());
    switch (j.type())
    {
        case BasicJsonType::value_t::null:
        case BasicJsonType::value_t::discarded:
        {
            return combine(type, 0);
        }

        case BasicJsonType::value_t::object:
        {
            auto seed = combine(type, j.size());
            for (const auto& element : j.items())
            {
                const auto h = std::hash<string_t> {}(element.key());
                seed = combine(seed, h);
                seed = combine(seed, hash(element.value()));
            }
            return seed;
        }

        case BasicJsonType::value_t::array:
        {
            auto seed = combine(type, j.size());
            for (const auto& element : j)
            {
                seed = combine(seed, hash(element));
            }
            return seed;
        }

        case BasicJsonType::value_t::string:
        {
            const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::boolean:
        {
            const auto h = std::hash<bool> {}(j.template get<bool>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_integer:
        {
            const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_unsigned:
        {
            const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_float:
        {
            const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::binary:
        {
            auto seed = combine(type, j.get_binary().size());
            const auto h = std::hash<bool> {}(j.get_binary().has_subtype());
            seed = combine(seed, h);
            seed = combine(seed, static_cast<std::size_t>(j.get_binary().subtype()));
            for (const auto byte : j.get_binary())
            {
                seed = combine(seed, std::hash<std::uint8_t> {}(byte));
            }
            return seed;
        }

        default:                   // LCOV_EXCL_LINE
            JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
            return 0;              // LCOV_EXCL_LINE
    }
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/input/binary_reader.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // generate_n
#include <array> // array
#include <cmath> // ldexp
#include <cstddef> // size_t
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstdio> // snprintf
#include <cstring> // memcpy
#include <iterator> // back_inserter
#include <limits> // numeric_limits
#include <string> // char_traits, string
#include <utility> // make_pair, move
#include <vector> // vector
#ifdef __cpp_lib_byteswap
    #include <bit>  //byteswap
#endif

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <array> // array
#include <cstddef> // size_t
#include <cstring> // strlen
#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next
#include <memory> // shared_ptr, make_shared, addressof
#include <numeric> // accumulate
#include <string> // string, char_traits
#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
#include <utility> // pair, declval

#ifndef JSON_NO_IO
    #include <cstdio>   // FILE *
    #include <istream>  // istream
#endif                  // JSON_NO_IO

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/iterators/iterator_traits.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// the supported input formats
enum class input_format_t { json, cbor, msgpack, ubjson, bson, bjdata };

////////////////////
// input adapters //
////////////////////

#ifndef JSON_NO_IO
/*!
Input adapter for stdio file access. This adapter read only 1 byte and do not use any
 buffer. This adapter is a very low level adapter.
*/
class file_input_adapter
{
  public:
    using char_type = char;

    JSON_HEDLEY_NON_NULL(2)
    explicit file_input_adapter(std::FILE* f) noexcept
        : m_file(f)
    {
        JSON_ASSERT(m_file != nullptr);
    }

    // make class move-only
    file_input_adapter(const file_input_adapter&) = delete;
    file_input_adapter(file_input_adapter&&) noexcept = default;
    file_input_adapter& operator=(const file_input_adapter&) = delete;
    file_input_adapter& operator=(file_input_adapter&&) = delete;
    ~file_input_adapter() = default;

    std::char_traits<char>::int_type get_character() noexcept
    {
        return std::fgetc(m_file);
    }

    // returns the number of characters successfully read
    template<class T>
    std::size_t get_elements(T* dest, std::size_t count = 1)
    {
        return fread(dest, 1, sizeof(T) * count, m_file);
    }

  private:
    /// the file pointer to read from
    std::FILE* m_file;
};

/*!
Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
beginning of input. Does not support changing the underlying std::streambuf
in mid-input. Maintains underlying std::istream and std::streambuf to support
subsequent use of standard std::istream operations to process any input
characters following those used in parsing the JSON input.  Clears the
std::istream flags; any input errors (e.g., EOF) will be detected by the first
subsequent call for input from the std::istream.
*/
class input_stream_adapter
{
  public:
    using char_type = char;

    ~input_stream_adapter()
    {
        // clear stream flags; we use underlying streambuf I/O, do not
        // maintain ifstream flags, except eof
        if (is != nullptr)
        {
            is->clear(is->rdstate() & std::ios::eofbit);
        }
    }

    explicit input_stream_adapter(std::istream& i)
        : is(&i), sb(i.rdbuf())
    {}

    // deleted because of pointer members
    input_stream_adapter(const input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&&) = delete;

    input_stream_adapter(input_stream_adapter&& rhs) noexcept
        : is(rhs.is), sb(rhs.sb)
    {
        rhs.is = nullptr;
        rhs.sb = nullptr;
    }

    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
    // ensure that std::char_traits<char>::eof() and the character 0xFF do not
    // end up as the same value, e.g., 0xFFFFFFFF.
    std::char_traits<char>::int_type get_character()
    {
        auto res = sb->sbumpc();
        // set eof manually, as we don't use the istream interface.
        if (JSON_HEDLEY_UNLIKELY(res == std::char_traits<char>::eof()))
        {
            is->clear(is->rdstate() | std::ios::eofbit);
        }
        return res;
    }

    template<class T>
    std::size_t get_elements(T* dest, std::size_t count = 1)
    {
        auto res = static_cast<std::size_t>(sb->sgetn(reinterpret_cast<char*>(dest), static_cast<std::streamsize>(count * sizeof(T))));
        if (JSON_HEDLEY_UNLIKELY(res < count * sizeof(T)))
        {
            is->clear(is->rdstate() | std::ios::eofbit);
        }
        return res;
    }

  private:
    /// the associated input stream
    std::istream* is = nullptr;
    std::streambuf* sb = nullptr;
};
#endif  // JSON_NO_IO

// General-purpose iterator-based adapter. It might not be as fast as
// theoretically possible for some containers, but it is extremely versatile.
template<typename IteratorType>
class iterator_input_adapter
{
  public:
    using char_type = typename std::iterator_traits<IteratorType>::value_type;

    iterator_input_adapter(IteratorType first, IteratorType last)
        : current(std::move(first)), end(std::move(last))
    {}

    typename char_traits<char_type>::int_type get_character()
    {
        if (JSON_HEDLEY_LIKELY(current != end))
        {
            auto result = char_traits<char_type>::to_int_type(*current);
            std::advance(current, 1);
            return result;
        }

        return char_traits<char_type>::eof();
    }

    // for general iterators, we cannot really do something better than falling back to processing the range one-by-one
    template<class T>
    std::size_t get_elements(T* dest, std::size_t count = 1)
    {
        auto* ptr = reinterpret_cast<char*>(dest);
        for (std::size_t read_index = 0; read_index < count * sizeof(T); ++read_index)
        {
            if (JSON_HEDLEY_LIKELY(current != end))
            {
                ptr[read_index] = static_cast<char>(*current);
                std::advance(current, 1);
            }
            else
            {
                return read_index;
            }
        }
        return count * sizeof(T);
    }

  private:
    IteratorType current;
    IteratorType end;

    template<typename BaseInputAdapter, size_t T>
    friend struct wide_string_input_helper;

    bool empty() const
    {
        return current == end;
    }
};

template<typename BaseInputAdapter, size_t T>
struct wide_string_input_helper;

template<typename BaseInputAdapter>
struct wide_string_input_helper<BaseInputAdapter, 4>
{
    // UTF-32
    static void fill_buffer(BaseInputAdapter& input,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (JSON_HEDLEY_UNLIKELY(input.empty()))
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = input.get_character();

            // UTF-32 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u) & 0x1Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (wc <= 0xFFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u) & 0x0Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else if (wc <= 0x10FFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((static_cast<unsigned int>(wc) >> 18u) & 0x07u));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 12u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 4;
            }
            else
            {
                // unknown character
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
        }
    }
};

template<typename BaseInputAdapter>
struct wide_string_input_helper<BaseInputAdapter, 2>
{
    // UTF-16
    static void fill_buffer(BaseInputAdapter& input,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (JSON_HEDLEY_UNLIKELY(input.empty()))
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = input.get_character();

            // UTF-16 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (0xD800 > wc || wc >= 0xE000)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else
            {
                if (JSON_HEDLEY_UNLIKELY(!input.empty()))
                {
                    const auto wc2 = static_cast<unsigned int>(input.get_character());
                    const auto charcode = 0x10000u + (((static_cast<unsigned int>(wc) & 0x3FFu) << 10u) | (wc2 & 0x3FFu));
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));
                    utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));
                    utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));
                    utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));
                    utf8_bytes_filled = 4;
                }
                else
                {
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                    utf8_bytes_filled = 1;
                }
            }
        }
    }
};

// Wraps another input adapter to convert wide character types into individual bytes.
template<typename BaseInputAdapter, typename WideCharType>
class wide_string_input_adapter
{
  public:
    using char_type = char;

    wide_string_input_adapter(BaseInputAdapter base)
        : base_adapter(base) {}

    typename std::char_traits<char>::int_type get_character() noexcept
    {
        // check if the buffer needs to be filled
        if (utf8_bytes_index == utf8_bytes_filled)
        {
            fill_buffer<sizeof(WideCharType)>();

            JSON_ASSERT(utf8_bytes_filled > 0);
            JSON_ASSERT(utf8_bytes_index == 0);
        }

        // use buffer
        JSON_ASSERT(utf8_bytes_filled > 0);
        JSON_ASSERT(utf8_bytes_index < utf8_bytes_filled);
        return utf8_bytes[utf8_bytes_index++];
    }

    // parsing binary with wchar doesn't make sense, but since the parsing mode can be runtime, we need something here
    template<class T>
    std::size_t get_elements(T* /*dest*/, std::size_t /*count*/ = 1)
    {
        JSON_THROW(parse_error::create(112, 1, "wide string type cannot be interpreted as binary data", nullptr));
    }

  private:
    BaseInputAdapter base_adapter;

    template<size_t T>
    void fill_buffer()
    {
        wide_string_input_helper<BaseInputAdapter, T>::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
    }

    /// a buffer for UTF-8 bytes
    std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};

    /// index to the utf8_codes array for the next valid byte
    std::size_t utf8_bytes_index = 0;
    /// number of valid bytes in the utf8_codes array
    std::size_t utf8_bytes_filled = 0;
};

template<typename IteratorType, typename Enable = void>
struct iterator_input_adapter_factory
{
    using iterator_type = IteratorType;
    using char_type = typename std::iterator_traits<iterator_type>::value_type;
    using adapter_type = iterator_input_adapter<iterator_type>;

    static adapter_type create(IteratorType first, IteratorType last)
    {
        return adapter_type(std::move(first), std::move(last));
    }
};

template<typename T>
struct is_iterator_of_multibyte
{
    using value_type = typename std::iterator_traits<T>::value_type;
    enum
    {
        value = sizeof(value_type) > 1
    };
};

template<typename IteratorType>
struct iterator_input_adapter_factory<IteratorType, enable_if_t<is_iterator_of_multibyte<IteratorType>::value>>
{
    using iterator_type = IteratorType;
    using char_type = typename std::iterator_traits<iterator_type>::value_type;
    using base_adapter_type = iterator_input_adapter<iterator_type>;
    using adapter_type = wide_string_input_adapter<base_adapter_type, char_type>;

    static adapter_type create(IteratorType first, IteratorType last)
    {
        return adapter_type(base_adapter_type(std::move(first), std::move(last)));
    }
};

// General purpose iterator-based input
template<typename IteratorType>
typename iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)
{
    using factory_type = iterator_input_adapter_factory<IteratorType>;
    return factory_type::create(first, last);
}

// Convenience shorthand from container to iterator
// Enables ADL on begin(container) and end(container)
// Encloses the using declarations in namespace for not to leak them to outside scope

namespace container_input_adapter_factory_impl
{

using std::begin;
using std::end;

template<typename ContainerType, typename Enable = void>
struct container_input_adapter_factory {};

template<typename ContainerType>
struct container_input_adapter_factory< ContainerType,
       void_t<decltype(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>()))>>
       {
           using adapter_type = decltype(input_adapter(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())));

           static adapter_type create(const ContainerType& container)
{
    return input_adapter(begin(container), end(container));
}
       };

}  // namespace container_input_adapter_factory_impl

template<typename ContainerType>
typename container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::adapter_type input_adapter(const ContainerType& container)
{
    return container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::create(container);
}

// specialization for std::string
using string_input_adapter_type = decltype(input_adapter(std::declval<std::string>()));

#ifndef JSON_NO_IO
// Special cases with fast paths
inline file_input_adapter input_adapter(std::FILE* file)
{
    if (file == nullptr)
    {
        JSON_THROW(parse_error::create(101, 0, "attempting to parse an empty input; check that your input string or stream contains the expected JSON", nullptr));
    }
    return file_input_adapter(file);
}

inline input_stream_adapter input_adapter(std::istream& stream)
{
    return input_stream_adapter(stream);
}

inline input_stream_adapter input_adapter(std::istream&& stream)
{
    return input_stream_adapter(stream);
}
#endif  // JSON_NO_IO

using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval<const char*>(), std::declval<const char*>()));

// Null-delimited strings, and the like.
template < typename CharT,
           typename std::enable_if <
               std::is_pointer<CharT>::value&&
               !std::is_array<CharT>::value&&
               std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
               sizeof(typename std::remove_pointer<CharT>::type) == 1,
               int >::type = 0 >
contiguous_bytes_input_adapter input_adapter(CharT b)
{
    if (b == nullptr)
    {
        JSON_THROW(parse_error::create(101, 0, "attempting to parse an empty input; check that your input string or stream contains the expected JSON", nullptr));
    }
    auto length = std::strlen(reinterpret_cast<const char*>(b));
    const auto* ptr = reinterpret_cast<const char*>(b);
    return input_adapter(ptr, ptr + length); // cppcheck-suppress[nullPointerArithmeticRedundantCheck]
}

template<typename T, std::size_t N>
auto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N)) // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
{
    return input_adapter(array, array + N);
}

// This class only handles inputs of input_buffer_adapter type.
// It's required so that expressions like {ptr, len} can be implicitly cast
// to the correct adapter.
class span_input_adapter
{
  public:
    template < typename CharT,
               typename std::enable_if <
                   std::is_pointer<CharT>::value&&
                   std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
                   sizeof(typename std::remove_pointer<CharT>::type) == 1,
                   int >::type = 0 >
    span_input_adapter(CharT b, std::size_t l)
        : ia(reinterpret_cast<const char*>(b), reinterpret_cast<const char*>(b) + l) {}

    template<class IteratorType,
             typename std::enable_if<
                 std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
                 int>::type = 0>
    span_input_adapter(IteratorType first, IteratorType last)
        : ia(input_adapter(first, last)) {}

    contiguous_bytes_input_adapter&& get()
    {
        return std::move(ia); // NOLINT(hicpp-move-const-arg,performance-move-const-arg)
    }

  private:
    contiguous_bytes_input_adapter ia;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/input/json_sax.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef>
#include <string> // string
#include <type_traits> // enable_if_t
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/lexer.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <array> // array
#include <clocale> // localeconv
#include <cstddef> // size_t
#include <cstdio> // snprintf
#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull
#include <initializer_list> // initializer_list
#include <string> // char_traits, string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/position_t.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

///////////
// lexer //
///////////

template<typename BasicJsonType>
class lexer_base
{
  public:
    /// token types for the parser
    enum class token_type
    {
        uninitialized,    ///< indicating the scanner is uninitialized
        literal_true,     ///< the `true` literal
        literal_false,    ///< the `false` literal
        literal_null,     ///< the `null` literal
        value_string,     ///< a string -- use get_string() for actual value
        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
        value_integer,    ///< a signed integer -- use get_number_integer() for actual value
        value_float,      ///< an floating point number -- use get_number_float() for actual value
        begin_array,      ///< the character for array begin `[`
        begin_object,     ///< the character for object begin `{`
        end_array,        ///< the character for array end `]`
        end_object,       ///< the character for object end `}`
        name_separator,   ///< the name separator `:`
        value_separator,  ///< the value separator `,`
        parse_error,      ///< indicating a parse error
        end_of_input,     ///< indicating the end of the input buffer
        literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
    };

    /// return name of values of type token_type (only used for errors)
    JSON_HEDLEY_RETURNS_NON_NULL
    JSON_HEDLEY_CONST
    static const char* token_type_name(const token_type t) noexcept
    {
        switch (t)
        {
            case token_type::uninitialized:
                return "<uninitialized>";
            case token_type::literal_true:
                return "true literal";
            case token_type::literal_false:
                return "false literal";
            case token_type::literal_null:
                return "null literal";
            case token_type::value_string:
                return "string literal";
            case token_type::value_unsigned:
            case token_type::value_integer:
            case token_type::value_float:
                return "number literal";
            case token_type::begin_array:
                return "'['";
            case token_type::begin_object:
                return "'{'";
            case token_type::end_array:
                return "']'";
            case token_type::end_object:
                return "'}'";
            case token_type::name_separator:
                return "':'";
            case token_type::value_separator:
                return "','";
            case token_type::parse_error:
                return "<parse error>";
            case token_type::end_of_input:
                return "end of input";
            case token_type::literal_or_value:
                return "'[', '{', or a literal";
            // LCOV_EXCL_START
            default: // catch non-enum values
                return "unknown token";
                // LCOV_EXCL_STOP
        }
    }
};
/*!
@brief lexical analysis

This class organizes the lexical analysis during JSON deserialization.
*/
template<typename BasicJsonType, typename InputAdapterType>
class lexer : public lexer_base<BasicJsonType>
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using char_type = typename InputAdapterType::char_type;
    using char_int_type = typename char_traits<char_type>::int_type;

  public:
    using token_type = typename lexer_base<BasicJsonType>::token_type;

    explicit lexer(InputAdapterType&& adapter, bool ignore_comments_ = false) noexcept
        : ia(std::move(adapter))
        , ignore_comments(ignore_comments_)
        , decimal_point_char(static_cast<char_int_type>(get_decimal_point()))
    {}

    // deleted because of pointer members
    lexer(const lexer&) = delete;
    lexer(lexer&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    lexer& operator=(lexer&) = delete;
    lexer& operator=(lexer&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~lexer() = default;

  private:
    /////////////////////
    // locales
    /////////////////////

    /// return the locale-dependent decimal point
    JSON_HEDLEY_PURE
    static char get_decimal_point() noexcept
    {
        const auto* loc = localeconv();
        JSON_ASSERT(loc != nullptr);
        return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
    }

    /////////////////////
    // scan functions
    /////////////////////

    /*!
    @brief get codepoint from 4 hex characters following `\u`

    For input "\u c1 c2 c3 c4" the codepoint is:
      (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
    = (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)

    Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
    must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
    conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
    between the ASCII value of the character and the desired integer value.

    @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
            non-hex character)
    */
    int get_codepoint()
    {
        // this function only makes sense after reading `\u`
        JSON_ASSERT(current == 'u');
        int codepoint = 0;

        const auto factors = { 12u, 8u, 4u, 0u };
        for (const auto factor : factors)
        {
            get();

            if (current >= '0' && current <= '9')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
            }
            else if (current >= 'A' && current <= 'F')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
            }
            else if (current >= 'a' && current <= 'f')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
            }
            else
            {
                return -1;
            }
        }

        JSON_ASSERT(0x0000 <= codepoint && codepoint <= 0xFFFF);
        return codepoint;
    }

    /*!
    @brief check if the next byte(s) are inside a given range

    Adds the current byte and, for each passed range, reads a new byte and
    checks if it is inside the range. If a violation was detected, set up an
    error message and return false. Otherwise, return true.

    @param[in] ranges  list of integers; interpreted as list of pairs of
                       inclusive lower and upper bound, respectively

    @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
         1, 2, or 3 pairs. This precondition is enforced by an assertion.

    @return true if and only if no range violation was detected
    */
    bool next_byte_in_range(std::initializer_list<char_int_type> ranges)
    {
        JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);
        add(current);

        for (auto range = ranges.begin(); range != ranges.end(); ++range)
        {
            get();
            if (JSON_HEDLEY_LIKELY(*range <= current && current <= *(++range))) // NOLINT(bugprone-inc-dec-in-conditions)
            {
                add(current);
            }
            else
            {
                error_message = "invalid string: ill-formed UTF-8 byte";
                return false;
            }
        }

        return true;
    }

    /*!
    @brief scan a string literal

    This function scans a string according to Sect. 7 of RFC 8259. While
    scanning, bytes are escaped and copied into buffer token_buffer. Then the
    function returns successfully, token_buffer is *not* null-terminated (as it
    may contain \0 bytes), and token_buffer.size() is the number of bytes in the
    string.

    @return token_type::value_string if string could be successfully scanned,
            token_type::parse_error otherwise

    @note In case of errors, variable error_message contains a textual
          description.
    */
    token_type scan_string()
    {
        // reset token_buffer (ignore opening quote)
        reset();

        // we entered the function by reading an open quote
        JSON_ASSERT(current == '\"');

        while (true)
        {
            // get the next character
            switch (get())
            {
                // end of file while parsing the string
                case char_traits<char_type>::eof():
                {
                    error_message = "invalid string: missing closing quote";
                    return token_type::parse_error;
                }

                // closing quote
                case '\"':
                {
                    return token_type::value_string;
                }

                // escapes
                case '\\':
                {
                    switch (get())
                    {
                        // quotation mark
                        case '\"':
                            add('\"');
                            break;
                        // reverse solidus
                        case '\\':
                            add('\\');
                            break;
                        // solidus
                        case '/':
                            add('/');
                            break;
                        // backspace
                        case 'b':
                            add('\b');
                            break;
                        // form feed
                        case 'f':
                            add('\f');
                            break;
                        // line feed
                        case 'n':
                            add('\n');
                            break;
                        // carriage return
                        case 'r':
                            add('\r');
                            break;
                        // tab
                        case 't':
                            add('\t');
                            break;

                        // unicode escapes
                        case 'u':
                        {
                            const int codepoint1 = get_codepoint();
                            int codepoint = codepoint1; // start with codepoint1

                            if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
                            {
                                error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                return token_type::parse_error;
                            }

                            // check if code point is a high surrogate
                            if (0xD800 <= codepoint1 && codepoint1 <= 0xDBFF)
                            {
                                // expect next \uxxxx entry
                                if (JSON_HEDLEY_LIKELY(get() == '\\' && get() == 'u'))
                                {
                                    const int codepoint2 = get_codepoint();

                                    if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
                                    {
                                        error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                        return token_type::parse_error;
                                    }

                                    // check if codepoint2 is a low surrogate
                                    if (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 && codepoint2 <= 0xDFFF))
                                    {
                                        // overwrite codepoint
                                        codepoint = static_cast<int>(
                                                        // high surrogate occupies the most significant 22 bits
                                                        (static_cast<unsigned int>(codepoint1) << 10u)
                                                        // low surrogate occupies the least significant 15 bits
                                                        + static_cast<unsigned int>(codepoint2)
                                                        // there is still the 0xD800, 0xDC00, and 0x10000 noise
                                                        // in the result, so we have to subtract with:
                                                        // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
                                                        - 0x35FDC00u);
                                    }
                                    else
                                    {
                                        error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                                        return token_type::parse_error;
                                    }
                                }
                                else
                                {
                                    error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                                    return token_type::parse_error;
                                }
                            }
                            else
                            {
                                if (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 && codepoint1 <= 0xDFFF))
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                                    return token_type::parse_error;
                                }
                            }

                            // the result of the above calculation yields a proper codepoint
                            JSON_ASSERT(0x00 <= codepoint && codepoint <= 0x10FFFF);

                            // translate codepoint into bytes
                            if (codepoint < 0x80)
                            {
                                // 1-byte characters: 0xxxxxxx (ASCII)
                                add(static_cast<char_int_type>(codepoint));
                            }
                            else if (codepoint <= 0x7FF)
                            {
                                // 2-byte characters: 110xxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else if (codepoint <= 0xFFFF)
                            {
                                // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else
                            {
                                // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }

                            break;
                        }

                        // other characters after escape
                        default:
                            error_message = "invalid string: forbidden character after backslash";
                            return token_type::parse_error;
                    }

                    break;
                }

                // invalid control characters
                case 0x00:
                {
                    error_message = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
                    return token_type::parse_error;
                }

                case 0x01:
                {
                    error_message = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
                    return token_type::parse_error;
                }

                case 0x02:
                {
                    error_message = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
                    return token_type::parse_error;
                }

                case 0x03:
                {
                    error_message = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
                    return token_type::parse_error;
                }

                case 0x04:
                {
                    error_message = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
                    return token_type::parse_error;
                }

                case 0x05:
                {
                    error_message = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
                    return token_type::parse_error;
                }

                case 0x06:
                {
                    error_message = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
                    return token_type::parse_error;
                }

                case 0x07:
                {
                    error_message = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
                    return token_type::parse_error;
                }

                case 0x08:
                {
                    error_message = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
                    return token_type::parse_error;
                }

                case 0x09:
                {
                    error_message = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
                    return token_type::parse_error;
                }

                case 0x0A:
                {
                    error_message = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
                    return token_type::parse_error;
                }

                case 0x0B:
                {
                    error_message = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
                    return token_type::parse_error;
                }

                case 0x0C:
                {
                    error_message = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
                    return token_type::parse_error;
                }

                case 0x0D:
                {
                    error_message = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
                    return token_type::parse_error;
                }

                case 0x0E:
                {
                    error_message = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
                    return token_type::parse_error;
                }

                case 0x0F:
                {
                    error_message = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
                    return token_type::parse_error;
                }

                case 0x10:
                {
                    error_message = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
                    return token_type::parse_error;
                }

                case 0x11:
                {
                    error_message = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
                    return token_type::parse_error;
                }

                case 0x12:
                {
                    error_message = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
                    return token_type::parse_error;
                }

                case 0x13:
                {
                    error_message = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
                    return token_type::parse_error;
                }

                case 0x14:
                {
                    error_message = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
                    return token_type::parse_error;
                }

                case 0x15:
                {
                    error_message = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
                    return token_type::parse_error;
                }

                case 0x16:
                {
                    error_message = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
                    return token_type::parse_error;
                }

                case 0x17:
                {
                    error_message = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
                    return token_type::parse_error;
                }

                case 0x18:
                {
                    error_message = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
                    return token_type::parse_error;
                }

                case 0x19:
                {
                    error_message = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
                    return token_type::parse_error;
                }

                case 0x1A:
                {
                    error_message = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
                    return token_type::parse_error;
                }

                case 0x1B:
                {
                    error_message = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
                    return token_type::parse_error;
                }

                case 0x1C:
                {
                    error_message = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
                    return token_type::parse_error;
                }

                case 0x1D:
                {
                    error_message = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
                    return token_type::parse_error;
                }

                case 0x1E:
                {
                    error_message = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
                    return token_type::parse_error;
                }

                case 0x1F:
                {
                    error_message = "invalid string: control character U+001F (US) must be escaped to \\u001F";
                    return token_type::parse_error;
                }

                // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
                case 0x20:
                case 0x21:
                case 0x23:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x27:
                case 0x28:
                case 0x29:
                case 0x2A:
                case 0x2B:
                case 0x2C:
                case 0x2D:
                case 0x2E:
                case 0x2F:
                case 0x30:
                case 0x31:
                case 0x32:
                case 0x33:
                case 0x34:
                case 0x35:
                case 0x36:
                case 0x37:
                case 0x38:
                case 0x39:
                case 0x3A:
                case 0x3B:
                case 0x3C:
                case 0x3D:
                case 0x3E:
                case 0x3F:
                case 0x40:
                case 0x41:
                case 0x42:
                case 0x43:
                case 0x44:
                case 0x45:
                case 0x46:
                case 0x47:
                case 0x48:
                case 0x49:
                case 0x4A:
                case 0x4B:
                case 0x4C:
                case 0x4D:
                case 0x4E:
                case 0x4F:
                case 0x50:
                case 0x51:
                case 0x52:
                case 0x53:
                case 0x54:
                case 0x55:
                case 0x56:
                case 0x57:
                case 0x58:
                case 0x59:
                case 0x5A:
                case 0x5B:
                case 0x5D:
                case 0x5E:
                case 0x5F:
                case 0x60:
                case 0x61:
                case 0x62:
                case 0x63:
                case 0x64:
                case 0x65:
                case 0x66:
                case 0x67:
                case 0x68:
                case 0x69:
                case 0x6A:
                case 0x6B:
                case 0x6C:
                case 0x6D:
                case 0x6E:
                case 0x6F:
                case 0x70:
                case 0x71:
                case 0x72:
                case 0x73:
                case 0x74:
                case 0x75:
                case 0x76:
                case 0x77:
                case 0x78:
                case 0x79:
                case 0x7A:
                case 0x7B:
                case 0x7C:
                case 0x7D:
                case 0x7E:
                case 0x7F:
                {
                    add(current);
                    break;
                }

                // U+0080..U+07FF: bytes C2..DF 80..BF
                case 0xC2:
                case 0xC3:
                case 0xC4:
                case 0xC5:
                case 0xC6:
                case 0xC7:
                case 0xC8:
                case 0xC9:
                case 0xCA:
                case 0xCB:
                case 0xCC:
                case 0xCD:
                case 0xCE:
                case 0xCF:
                case 0xD0:
                case 0xD1:
                case 0xD2:
                case 0xD3:
                case 0xD4:
                case 0xD5:
                case 0xD6:
                case 0xD7:
                case 0xD8:
                case 0xD9:
                case 0xDA:
                case 0xDB:
                case 0xDC:
                case 0xDD:
                case 0xDE:
                case 0xDF:
                {
                    if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+0800..U+0FFF: bytes E0 A0..BF 80..BF
                case 0xE0:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
                // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
                case 0xE1:
                case 0xE2:
                case 0xE3:
                case 0xE4:
                case 0xE5:
                case 0xE6:
                case 0xE7:
                case 0xE8:
                case 0xE9:
                case 0xEA:
                case 0xEB:
                case 0xEC:
                case 0xEE:
                case 0xEF:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+D000..U+D7FF: bytes ED 80..9F 80..BF
                case 0xED:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
                case 0xF0:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
                case 0xF1:
                case 0xF2:
                case 0xF3:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
                case 0xF4:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // the remaining bytes (80..C1 and F5..FF) are ill-formed
                default:
                {
                    error_message = "invalid string: ill-formed UTF-8 byte";
                    return token_type::parse_error;
                }
            }
        }
    }

    /*!
     * @brief scan a comment
     * @return whether comment could be scanned successfully
     */
    bool scan_comment()
    {
        switch (get())
        {
            // single-line comments skip input until a newline or EOF is read
            case '/':
            {
                while (true)
                {
                    switch (get())
                    {
                        case '\n':
                        case '\r':
                        case char_traits<char_type>::eof():
                        case '\0':
                            return true;

                        default:
                            break;
                    }
                }
            }

            // multi-line comments skip input until */ is read
            case '*':
            {
                while (true)
                {
                    switch (get())
                    {
                        case char_traits<char_type>::eof():
                        case '\0':
                        {
                            error_message = "invalid comment; missing closing '*/'";
                            return false;
                        }

                        case '*':
                        {
                            switch (get())
                            {
                                case '/':
                                    return true;

                                default:
                                {
                                    unget();
                                    continue;
                                }
                            }
                        }

                        default:
                            continue;
                    }
                }
            }

            // unexpected character after reading '/'
            default:
            {
                error_message = "invalid comment; expecting '/' or '*' after '/'";
                return false;
            }
        }
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(float& f, const char* str, char** endptr) noexcept
    {
        f = std::strtof(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtod(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(long double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtold(str, endptr);
    }

    /*!
    @brief scan a number literal

    This function scans a string according to Sect. 6 of RFC 8259.

    The function is realized with a deterministic finite state machine derived
    from the grammar described in RFC 8259. Starting in state "init", the
    input is read and used to determined the next state. Only state "done"
    accepts the number. State "error" is a trap state to model errors. In the
    table below, "anything" means any character but the ones listed before.

    state    | 0        | 1-9      | e E      | +       | -       | .        | anything
    ---------|----------|----------|----------|---------|---------|----------|-----------
    init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
    minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
    zero     | done     | done     | exponent | done    | done    | decimal1 | done
    any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
    decimal1 | decimal2 | decimal2 | [error]  | [error] | [error] | [error]  | [error]
    decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
    exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
    sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
    any2     | any2     | any2     | done     | done    | done    | done     | done

    The state machine is realized with one label per state (prefixed with
    "scan_number_") and `goto` statements between them. The state machine
    contains cycles, but any cycle can be left when EOF is read. Therefore,
    the function is guaranteed to terminate.

    During scanning, the read bytes are stored in token_buffer. This string is
    then converted to a signed integer, an unsigned integer, or a
    floating-point number.

    @return token_type::value_unsigned, token_type::value_integer, or
            token_type::value_float if number could be successfully scanned,
            token_type::parse_error otherwise

    @note The scanner is independent of the current locale. Internally, the
          locale's decimal point is used instead of `.` to work with the
          locale-dependent converters.
    */
    token_type scan_number()  // lgtm [cpp/use-of-goto] `goto` is used in this function to implement the number-parsing state machine described above. By design, any finite input will eventually reach the "done" state or return token_type::parse_error. In each intermediate state, 1 byte of the input is appended to the token_buffer vector, and only the already initialized variables token_buffer, number_type, and error_message are manipulated.
    {
        // reset token_buffer to store the number's bytes
        reset();

        // the type of the parsed number; initially set to unsigned; will be
        // changed if minus sign, decimal point, or exponent is read
        token_type number_type = token_type::value_unsigned;

        // state (init): we just found out we need to scan a number
        switch (current)
        {
            case '-':
            {
                add(current);
                goto scan_number_minus;
            }

            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            // all other characters are rejected outside scan_number()
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }

scan_number_minus:
        // state: we just parsed a leading minus sign
        number_type = token_type::value_integer;
        switch (get())
        {
            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            default:
            {
                error_message = "invalid number; expected digit after '-'";
                return token_type::parse_error;
            }
        }

scan_number_zero:
        // state: we just parse a zero (maybe with a leading minus sign)
        switch (get())
        {
            case '.':
            {
                add(decimal_point_char);
                decimal_point_position = token_buffer.size() - 1;
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_any1:
        // state: we just parsed a number 0-9 (maybe with a leading minus sign)
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            case '.':
            {
                add(decimal_point_char);
                decimal_point_position = token_buffer.size() - 1;
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_decimal1:
        // state: we just parsed a decimal point
        number_type = token_type::value_float;
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            default:
            {
                error_message = "invalid number; expected digit after '.'";
                return token_type::parse_error;
            }
        }

scan_number_decimal2:
        // we just parsed at least one number after a decimal point
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_exponent:
        // we just parsed an exponent
        number_type = token_type::value_float;
        switch (get())
        {
            case '+':
            case '-':
            {
                add(current);
                goto scan_number_sign;
            }

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message =
                    "invalid number; expected '+', '-', or digit after exponent";
                return token_type::parse_error;
            }
        }

scan_number_sign:
        // we just parsed an exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message = "invalid number; expected digit after exponent sign";
                return token_type::parse_error;
            }
        }

scan_number_any2:
        // we just parsed a number after the exponent or exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
                goto scan_number_done;
        }

scan_number_done:
        // unget the character after the number (we only read it to know that
        // we are done scanning a number)
        unget();

        char* endptr = nullptr; // NOLINT(misc-const-correctness,cppcoreguidelines-pro-type-vararg,hicpp-vararg)
        errno = 0;

        // try to parse integers first and fall back to floats
        if (number_type == token_type::value_unsigned)
        {
            const auto x = std::strtoull(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

            if (errno != ERANGE)
            {
                value_unsigned = static_cast<number_unsigned_t>(x);
                if (value_unsigned == x)
                {
                    return token_type::value_unsigned;
                }
            }
        }
        else if (number_type == token_type::value_integer)
        {
            const auto x = std::strtoll(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

            if (errno != ERANGE)
            {
                value_integer = static_cast<number_integer_t>(x);
                if (value_integer == x)
                {
                    return token_type::value_integer;
                }
            }
        }

        // this code is reached if we parse a floating-point number or if an
        // integer conversion above failed
        strtof(value_float, token_buffer.data(), &endptr);

        // we checked the number format before
        JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

        return token_type::value_float;
    }

    /*!
    @param[in] literal_text  the literal text to expect
    @param[in] length        the length of the passed literal text
    @param[in] return_type   the token type to return on success
    */
    JSON_HEDLEY_NON_NULL(2)
    token_type scan_literal(const char_type* literal_text, const std::size_t length,
                            token_type return_type)
    {
        JSON_ASSERT(char_traits<char_type>::to_char_type(current) == literal_text[0]);
        for (std::size_t i = 1; i < length; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(char_traits<char_type>::to_char_type(get()) != literal_text[i]))
            {
                error_message = "invalid literal";
                return token_type::parse_error;
            }
        }
        return return_type;
    }

    /////////////////////
    // input management
    /////////////////////

    /// reset token_buffer; current character is beginning of token
    void reset() noexcept
    {
        token_buffer.clear();
        token_string.clear();
        decimal_point_position = std::string::npos;
        token_string.push_back(char_traits<char_type>::to_char_type(current));
    }

    /*
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a
    `char_traits<char>::eof()` in that case.  Stores the scanned characters
    for use in error messages.

    @return character read from the input
    */
    char_int_type get()
    {
        ++position.chars_read_total;
        ++position.chars_read_current_line;

        if (next_unget)
        {
            // only reset the next_unget variable and work with current
            next_unget = false;
        }
        else
        {
            current = ia.get_character();
        }

        if (JSON_HEDLEY_LIKELY(current != char_traits<char_type>::eof()))
        {
            token_string.push_back(char_traits<char_type>::to_char_type(current));
        }

        if (current == '\n')
        {
            ++position.lines_read;
            position.chars_read_current_line = 0;
        }

        return current;
    }

    /*!
    @brief unget current character (read it again on next get)

    We implement unget by setting variable next_unget to true. The input is not
    changed - we just simulate ungetting by modifying chars_read_total,
    chars_read_current_line, and token_string. The next call to get() will
    behave as if the unget character is read again.
    */
    void unget()
    {
        next_unget = true;

        --position.chars_read_total;

        // in case we "unget" a newline, we have to also decrement the lines_read
        if (position.chars_read_current_line == 0)
        {
            if (position.lines_read > 0)
            {
                --position.lines_read;
            }
        }
        else
        {
            --position.chars_read_current_line;
        }

        if (JSON_HEDLEY_LIKELY(current != char_traits<char_type>::eof()))
        {
            JSON_ASSERT(!token_string.empty());
            token_string.pop_back();
        }
    }

    /// add a character to token_buffer
    void add(char_int_type c)
    {
        token_buffer.push_back(static_cast<typename string_t::value_type>(c));
    }

  public:
    /////////////////////
    // value getters
    /////////////////////

    /// return integer value
    constexpr number_integer_t get_number_integer() const noexcept
    {
        return value_integer;
    }

    /// return unsigned integer value
    constexpr number_unsigned_t get_number_unsigned() const noexcept
    {
        return value_unsigned;
    }

    /// return floating-point value
    constexpr number_float_t get_number_float() const noexcept
    {
        return value_float;
    }

    /// return current string value (implicitly resets the token; useful only once)
    string_t& get_string()
    {
        // translate decimal points from locale back to '.' (#4084)
        if (decimal_point_char != '.' && decimal_point_position != std::string::npos)
        {
            token_buffer[decimal_point_position] = '.';
        }
        return token_buffer;
    }

    /////////////////////
    // diagnostics
    /////////////////////

    /// return position of last read token
    constexpr position_t get_position() const noexcept
    {
        return position;
    }

    /// return the last read token (for errors only).  Will never contain EOF
    /// (an arbitrary value that is not a valid char value, often -1), because
    /// 255 may legitimately occur.  May contain NUL, which should be escaped.
    std::string get_token_string() const
    {
        // escape control characters
        std::string result;
        for (const auto c : token_string)
        {
            if (static_cast<unsigned char>(c) <= '\x1F')
            {
                // escape control characters
                std::array<char, 9> cs{{}};
                static_cast<void>((std::snprintf)(cs.data(), cs.size(), "<U+%.4X>", static_cast<unsigned char>(c))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                result += cs.data();
            }
            else
            {
                // add character as is
                result.push_back(static_cast<std::string::value_type>(c));
            }
        }

        return result;
    }

    /// return syntax error message
    JSON_HEDLEY_RETURNS_NON_NULL
    constexpr const char* get_error_message() const noexcept
    {
        return error_message;
    }

    /////////////////////
    // actual scanner
    /////////////////////

    /*!
    @brief skip the UTF-8 byte order mark
    @return true iff there is no BOM or the correct BOM has been skipped
    */
    bool skip_bom()
    {
        if (get() == 0xEF)
        {
            // check if we completely parse the BOM
            return get() == 0xBB && get() == 0xBF;
        }

        // the first character is not the beginning of the BOM; unget it to
        // process is later
        unget();
        return true;
    }

    void skip_whitespace()
    {
        do
        {
            get();
        }
        while (current == ' ' || current == '\t' || current == '\n' || current == '\r');
    }

    token_type scan()
    {
        // initially, skip the BOM
        if (position.chars_read_total == 0 && !skip_bom())
        {
            error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
            return token_type::parse_error;
        }

        // read the next character and ignore whitespace
        skip_whitespace();

        // ignore comments
        while (ignore_comments && current == '/')
        {
            if (!scan_comment())
            {
                return token_type::parse_error;
            }

            // skip following whitespace
            skip_whitespace();
        }

        switch (current)
        {
            // structural characters
            case '[':
                return token_type::begin_array;
            case ']':
                return token_type::end_array;
            case '{':
                return token_type::begin_object;
            case '}':
                return token_type::end_object;
            case ':':
                return token_type::name_separator;
            case ',':
                return token_type::value_separator;

            // literals
            case 't':
            {
                std::array<char_type, 4> true_literal = {{static_cast<char_type>('t'), static_cast<char_type>('r'), static_cast<char_type>('u'), static_cast<char_type>('e')}};
                return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
            }
            case 'f':
            {
                std::array<char_type, 5> false_literal = {{static_cast<char_type>('f'), static_cast<char_type>('a'), static_cast<char_type>('l'), static_cast<char_type>('s'), static_cast<char_type>('e')}};
                return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
            }
            case 'n':
            {
                std::array<char_type, 4> null_literal = {{static_cast<char_type>('n'), static_cast<char_type>('u'), static_cast<char_type>('l'), static_cast<char_type>('l')}};
                return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
            }

            // string
            case '\"':
                return scan_string();

            // number
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                return scan_number();

            // end of input (the null byte is needed when parsing from
            // string literals)
            case '\0':
            case char_traits<char_type>::eof():
                return token_type::end_of_input;

            // error
            default:
                error_message = "invalid literal";
                return token_type::parse_error;
        }
    }

  private:
    /// input adapter
    InputAdapterType ia;

    /// whether comments should be ignored (true) or signaled as errors (false)
    const bool ignore_comments = false;

    /// the current character
    char_int_type current = char_traits<char_type>::eof();

    /// whether the next get() call should just return current
    bool next_unget = false;

    /// the start position of the current token
    position_t position {};

    /// raw input token string (for error messages)
    std::vector<char_type> token_string {};

    /// buffer for variable-length tokens (numbers, strings)
    string_t token_buffer {};

    /// a description of occurred lexer errors
    const char* error_message = "";

    // number values
    number_integer_t value_integer = 0;
    number_unsigned_t value_unsigned = 0;
    number_float_t value_float = 0;

    /// the decimal point
    const char_int_type decimal_point_char = '.';
    /// the position of the decimal point in the input
    std::size_t decimal_point_position = std::string::npos;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/string_concat.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN

/*!
@brief SAX interface

This class describes the SAX interface used by @ref nlohmann::json::sax_parse.
Each function is called in different situations while the input is parsed. The
boolean return value informs the parser whether to continue processing the
input.
*/
template<typename BasicJsonType>
struct json_sax
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    /*!
    @brief a null value was read
    @return whether parsing should proceed
    */
    virtual bool null() = 0;

    /*!
    @brief a boolean value was read
    @param[in] val  boolean value
    @return whether parsing should proceed
    */
    virtual bool boolean(bool val) = 0;

    /*!
    @brief an integer number was read
    @param[in] val  integer value
    @return whether parsing should proceed
    */
    virtual bool number_integer(number_integer_t val) = 0;

    /*!
    @brief an unsigned integer number was read
    @param[in] val  unsigned integer value
    @return whether parsing should proceed
    */
    virtual bool number_unsigned(number_unsigned_t val) = 0;

    /*!
    @brief a floating-point number was read
    @param[in] val  floating-point value
    @param[in] s    raw token value
    @return whether parsing should proceed
    */
    virtual bool number_float(number_float_t val, const string_t& s) = 0;

    /*!
    @brief a string value was read
    @param[in] val  string value
    @return whether parsing should proceed
    @note It is safe to move the passed string value.
    */
    virtual bool string(string_t& val) = 0;

    /*!
    @brief a binary value was read
    @param[in] val  binary value
    @return whether parsing should proceed
    @note It is safe to move the passed binary value.
    */
    virtual bool binary(binary_t& val) = 0;

    /*!
    @brief the beginning of an object was read
    @param[in] elements  number of object elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_object(std::size_t elements) = 0;

    /*!
    @brief an object key was read
    @param[in] val  object key
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool key(string_t& val) = 0;

    /*!
    @brief the end of an object was read
    @return whether parsing should proceed
    */
    virtual bool end_object() = 0;

    /*!
    @brief the beginning of an array was read
    @param[in] elements  number of array elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_array(std::size_t elements) = 0;

    /*!
    @brief the end of an array was read
    @return whether parsing should proceed
    */
    virtual bool end_array() = 0;

    /*!
    @brief a parse error occurred
    @param[in] position    the position in the input where the error occurs
    @param[in] last_token  the last read token
    @param[in] ex          an exception object describing the error
    @return whether parsing should proceed (must return false)
    */
    virtual bool parse_error(std::size_t position,
                             const std::string& last_token,
                             const detail::exception& ex) = 0;

    json_sax() = default;
    json_sax(const json_sax&) = default;
    json_sax(json_sax&&) noexcept = default;
    json_sax& operator=(const json_sax&) = default;
    json_sax& operator=(json_sax&&) noexcept = default;
    virtual ~json_sax() = default;
};

namespace detail
{
constexpr std::size_t unknown_size()
{
    return (std::numeric_limits<std::size_t>::max)();
}

/*!
@brief SAX implementation to create a JSON value from SAX events

This class implements the @ref json_sax interface and processes the SAX events
to create a JSON value which makes it basically a DOM parser. The structure or
hierarchy of the JSON value is managed by the stack `ref_stack` which contains
a pointer to the respective array or object for each recursion depth.

After successful parsing, the value that is passed by reference to the
constructor contains the parsed value.

@tparam BasicJsonType  the JSON type
*/
template<typename BasicJsonType, typename InputAdapterType>
class json_sax_dom_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using lexer_t = lexer<BasicJsonType, InputAdapterType>;

    /*!
    @param[in,out] r  reference to a JSON value that is manipulated while
                       parsing
    @param[in] allow_exceptions_  whether parse errors yield exceptions
    */
    explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true, lexer_t* lexer_ = nullptr)
        : root(r), allow_exceptions(allow_exceptions_), m_lexer_ref(lexer_)
    {}

    // make class move-only
    json_sax_dom_parser(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser(json_sax_dom_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~json_sax_dom_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool binary(binary_t& val)
    {
        handle_value(std::move(val));
        return true;
    }

    bool start_object(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));

#if JSON_DIAGNOSTIC_POSITIONS
        // Manually set the start position of the object here.
        // Ensure this is after the call to handle_value to ensure correct start position.
        if (m_lexer_ref)
        {
            // Lexer has read the first character of the object, so
            // subtract 1 from the position to get the correct start position.
            ref_stack.back()->start_position = m_lexer_ref->get_position() - 1;
        }
#endif

        if (JSON_HEDLEY_UNLIKELY(len != detail::unknown_size() && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, concat("excessive object size: ", std::to_string(len)), ref_stack.back()));
        }

        return true;
    }

    bool key(string_t& val)
    {
        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(ref_stack.back()->is_object());

        // add null at the given key and store the reference for later
        object_element = &(ref_stack.back()->m_data.m_value.object->operator[](val));
        return true;
    }

    bool end_object()
    {
        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(ref_stack.back()->is_object());

#if JSON_DIAGNOSTIC_POSITIONS
        if (m_lexer_ref)
        {
            // Lexer's position is past the closing brace, so set that as the end position.
            ref_stack.back()->end_position = m_lexer_ref->get_position();
        }
#endif

        ref_stack.back()->set_parents();
        ref_stack.pop_back();
        return true;
    }

    bool start_array(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::array));

#if JSON_DIAGNOSTIC_POSITIONS
        // Manually set the start position of the array here.
        // Ensure this is after the call to handle_value to ensure correct start position.
        if (m_lexer_ref)
        {
            ref_stack.back()->start_position = m_lexer_ref->get_position() - 1;
        }
#endif

        if (JSON_HEDLEY_UNLIKELY(len != detail::unknown_size() && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, concat("excessive array size: ", std::to_string(len)), ref_stack.back()));
        }

        return true;
    }

    bool end_array()
    {
        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(ref_stack.back()->is_array());

#if JSON_DIAGNOSTIC_POSITIONS
        if (m_lexer_ref)
        {
            // Lexer's position is past the closing bracket, so set that as the end position.
            ref_stack.back()->end_position = m_lexer_ref->get_position();
        }
#endif

        ref_stack.back()->set_parents();
        ref_stack.pop_back();
        return true;
    }

    template<class Exception>
    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const Exception& ex)
    {
        errored = true;
        static_cast<void>(ex);
        if (allow_exceptions)
        {
            JSON_THROW(ex);
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:

#if JSON_DIAGNOSTIC_POSITIONS
    void handle_diagnostic_positions_for_json_value(BasicJsonType& v)
    {
        if (m_lexer_ref)
        {
            // Lexer has read past the current field value, so set the end position to the current position.
            // The start position will be set below based on the length of the string representation
            // of the value.
            v.end_position = m_lexer_ref->get_position();

            switch (v.type())
            {
                case value_t::boolean:
                {
                    // 4 and 5 are the string length of "true" and "false"
                    v.start_position = v.end_position - (v.m_data.m_value.boolean ? 4 : 5);
                    break;
                }

                case value_t::null:
                {
                    // 4 is the string length of "null"
                    v.start_position = v.end_position - 4;
                    break;
                }

                case value_t::string:
                {
                    // include the length of the quotes, which is 2
                    v.start_position = v.end_position - v.m_data.m_value.string->size() - 2;
                    break;
                }

                // As we handle the start and end positions for values created during parsing,
                // we do not expect the following value type to be called. Regardless, set the positions
                // in case this is created manually or through a different constructor. Exclude from lcov
                // since the exact condition of this switch is esoteric.
                // LCOV_EXCL_START
                case value_t::discarded:
                {
                    v.end_position = std::string::npos;
                    v.start_position = v.end_position;
                    break;
                }
                // LCOV_EXCL_STOP
                case value_t::binary:
                case value_t::number_integer:
                case value_t::number_unsigned:
                case value_t::number_float:
                {
                    v.start_position = v.end_position - m_lexer_ref->get_string().size();
                    break;
                }
                case value_t::object:
                case value_t::array:
                {
                    // object and array are handled in start_object() and start_array() handlers
                    // skip setting the values here.
                    break;
                }
                default: // LCOV_EXCL_LINE
                    // Handle all possible types discretely, default handler should never be reached.
                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert,-warnings-as-errors) LCOV_EXCL_LINE
            }
        }
    }
#endif

    /*!
    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements
    */
    template<typename Value>
    JSON_HEDLEY_RETURNS_NON_NULL
    BasicJsonType* handle_value(Value&& v)
    {
        if (ref_stack.empty())
        {
            root = BasicJsonType(std::forward<Value>(v));

#if JSON_DIAGNOSTIC_POSITIONS
            handle_diagnostic_positions_for_json_value(root);
#endif

            return &root;
        }

        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());

        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_data.m_value.array->emplace_back(std::forward<Value>(v));

#if JSON_DIAGNOSTIC_POSITIONS
            handle_diagnostic_positions_for_json_value(ref_stack.back()->m_data.m_value.array->back());
#endif

            return &(ref_stack.back()->m_data.m_value.array->back());
        }

        JSON_ASSERT(ref_stack.back()->is_object());
        JSON_ASSERT(object_element);
        *object_element = BasicJsonType(std::forward<Value>(v));

#if JSON_DIAGNOSTIC_POSITIONS
        handle_diagnostic_positions_for_json_value(*object_element);
#endif

        return object_element;
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
    /// the lexer reference to obtain the current position
    lexer_t* m_lexer_ref = nullptr;
};

template<typename BasicJsonType, typename InputAdapterType>
class json_sax_dom_callback_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using parser_callback_t = typename BasicJsonType::parser_callback_t;
    using parse_event_t = typename BasicJsonType::parse_event_t;
    using lexer_t = lexer<BasicJsonType, InputAdapterType>;

    json_sax_dom_callback_parser(BasicJsonType& r,
                                 parser_callback_t cb,
                                 const bool allow_exceptions_ = true,
                                 lexer_t* lexer_ = nullptr)
        : root(r), callback(std::move(cb)), allow_exceptions(allow_exceptions_), m_lexer_ref(lexer_)
    {
        keep_stack.push_back(true);
    }

    // make class move-only
    json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~json_sax_dom_callback_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool binary(binary_t& val)
    {
        handle_value(std::move(val));
        return true;
    }

    bool start_object(std::size_t len)
    {
        // check callback for object start
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::object, true);
        ref_stack.push_back(val.second);

        if (ref_stack.back())
        {

#if JSON_DIAGNOSTIC_POSITIONS
            // Manually set the start position of the object here.
            // Ensure this is after the call to handle_value to ensure correct start position.
            if (m_lexer_ref)
            {
                // Lexer has read the first character of the object, so
                // subtract 1 from the position to get the correct start position.
                ref_stack.back()->start_position = m_lexer_ref->get_position() - 1;
            }
#endif

            // check object limit
            if (JSON_HEDLEY_UNLIKELY(len != detail::unknown_size() && len > ref_stack.back()->max_size()))
            {
                JSON_THROW(out_of_range::create(408, concat("excessive object size: ", std::to_string(len)), ref_stack.back()));
            }
        }
        return true;
    }

    bool key(string_t& val)
    {
        BasicJsonType k = BasicJsonType(val);

        // check callback for the key
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
        key_keep_stack.push_back(keep);

        // add discarded value at the given key and store the reference for later
        if (keep && ref_stack.back())
        {
            object_element = &(ref_stack.back()->m_data.m_value.object->operator[](val) = discarded);
        }

        return true;
    }

    bool end_object()
    {
        if (ref_stack.back())
        {
            if (!callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
            {
                // discard object
                *ref_stack.back() = discarded;

#if JSON_DIAGNOSTIC_POSITIONS
                // Set start/end positions for discarded object.
                handle_diagnostic_positions_for_json_value(*ref_stack.back());
#endif
            }
            else
            {

#if JSON_DIAGNOSTIC_POSITIONS
                if (m_lexer_ref)
                {
                    // Lexer's position is past the closing brace, so set that as the end position.
                    ref_stack.back()->end_position = m_lexer_ref->get_position();
                }
#endif

                ref_stack.back()->set_parents();
            }
        }

        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(!keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        if (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())
        {
            // remove discarded value
            for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
            {
                if (it->is_discarded())
                {
                    ref_stack.back()->erase(it);
                    break;
                }
            }
        }

        return true;
    }

    bool start_array(std::size_t len)
    {
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::array, true);
        ref_stack.push_back(val.second);

        if (ref_stack.back())
        {

#if JSON_DIAGNOSTIC_POSITIONS
            // Manually set the start position of the array here.
            // Ensure this is after the call to handle_value to ensure correct start position.
            if (m_lexer_ref)
            {
                // Lexer has read the first character of the array, so
                // subtract 1 from the position to get the correct start position.
                ref_stack.back()->start_position = m_lexer_ref->get_position() - 1;
            }
#endif

            // check array limit
            if (JSON_HEDLEY_UNLIKELY(len != detail::unknown_size() && len > ref_stack.back()->max_size()))
            {
                JSON_THROW(out_of_range::create(408, concat("excessive array size: ", std::to_string(len)), ref_stack.back()));
            }
        }

        return true;
    }

    bool end_array()
    {
        bool keep = true;

        if (ref_stack.back())
        {
            keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
            if (keep)
            {

#if JSON_DIAGNOSTIC_POSITIONS
                if (m_lexer_ref)
                {
                    // Lexer's position is past the closing bracket, so set that as the end position.
                    ref_stack.back()->end_position = m_lexer_ref->get_position();
                }
#endif

                ref_stack.back()->set_parents();
            }
            else
            {
                // discard array
                *ref_stack.back() = discarded;

#if JSON_DIAGNOSTIC_POSITIONS
                // Set start/end positions for discarded array.
                handle_diagnostic_positions_for_json_value(*ref_stack.back());
#endif
            }
        }

        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(!keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        // remove discarded value
        if (!keep && !ref_stack.empty() && ref_stack.back()->is_array())
        {
            ref_stack.back()->m_data.m_value.array->pop_back();
        }

        return true;
    }

    template<class Exception>
    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const Exception& ex)
    {
        errored = true;
        static_cast<void>(ex);
        if (allow_exceptions)
        {
            JSON_THROW(ex);
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:

#if JSON_DIAGNOSTIC_POSITIONS
    void handle_diagnostic_positions_for_json_value(BasicJsonType& v)
    {
        if (m_lexer_ref)
        {
            // Lexer has read past the current field value, so set the end position to the current position.
            // The start position will be set below based on the length of the string representation
            // of the value.
            v.end_position = m_lexer_ref->get_position();

            switch (v.type())
            {
                case value_t::boolean:
                {
                    // 4 and 5 are the string length of "true" and "false"
                    v.start_position = v.end_position - (v.m_data.m_value.boolean ? 4 : 5);
                    break;
                }

                case value_t::null:
                {
                    // 4 is the string length of "null"
                    v.start_position = v.end_position - 4;
                    break;
                }

                case value_t::string:
                {
                    // include the length of the quotes, which is 2
                    v.start_position = v.end_position - v.m_data.m_value.string->size() - 2;
                    break;
                }

                case value_t::discarded:
                {
                    v.end_position = std::string::npos;
                    v.start_position = v.end_position;
                    break;
                }

                case value_t::binary:
                case value_t::number_integer:
                case value_t::number_unsigned:
                case value_t::number_float:
                {
                    v.start_position = v.end_position - m_lexer_ref->get_string().size();
                    break;
                }

                case value_t::object:
                case value_t::array:
                {
                    // object and array are handled in start_object() and start_array() handlers
                    // skip setting the values here.
                    break;
                }
                default: // LCOV_EXCL_LINE
                    // Handle all possible types discretely, default handler should never be reached.
                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert,-warnings-as-errors) LCOV_EXCL_LINE
            }
        }
    }
#endif

    /*!
    @param[in] v  value to add to the JSON value we build during parsing
    @param[in] skip_callback  whether we should skip calling the callback
               function; this is required after start_array() and
               start_object() SAX events, because otherwise we would call the
               callback function with an empty array or object, respectively.

    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements

    @return pair of boolean (whether value should be kept) and pointer (to the
            passed value in the ref_stack hierarchy; nullptr if not kept)
    */
    template<typename Value>
    std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
    {
        JSON_ASSERT(!keep_stack.empty());

        // do not handle this value if we know it would be added to a discarded
        // container
        if (!keep_stack.back())
        {
            return {false, nullptr};
        }

        // create value
        auto value = BasicJsonType(std::forward<Value>(v));

#if JSON_DIAGNOSTIC_POSITIONS
        handle_diagnostic_positions_for_json_value(value);
#endif

        // check callback
        const bool keep = skip_callback || callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);

        // do not handle this value if we just learnt it shall be discarded
        if (!keep)
        {
            return {false, nullptr};
        }

        if (ref_stack.empty())
        {
            root = std::move(value);
            return {true, & root};
        }

        // skip this value if we already decided to skip the parent
        // (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)
        if (!ref_stack.back())
        {
            return {false, nullptr};
        }

        // we now only expect arrays and objects
        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());

        // array
        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_data.m_value.array->emplace_back(std::move(value));
            return {true, & (ref_stack.back()->m_data.m_value.array->back())};
        }

        // object
        JSON_ASSERT(ref_stack.back()->is_object());
        // check if we should store an element for the current key
        JSON_ASSERT(!key_keep_stack.empty());
        const bool store_element = key_keep_stack.back();
        key_keep_stack.pop_back();

        if (!store_element)
        {
            return {false, nullptr};
        }

        JSON_ASSERT(object_element);
        *object_element = std::move(value);
        return {true, object_element};
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// stack to manage which values to keep
    std::vector<bool> keep_stack {}; // NOLINT(readability-redundant-member-init)
    /// stack to manage which object keys to keep
    std::vector<bool> key_keep_stack {}; // NOLINT(readability-redundant-member-init)
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// callback function
    const parser_callback_t callback = nullptr;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
    /// a discarded value for the callback
    BasicJsonType discarded = BasicJsonType::value_t::discarded;
    /// the lexer reference to obtain the current position
    lexer_t* m_lexer_ref = nullptr;
};

template<typename BasicJsonType>
class json_sax_acceptor
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    bool null()
    {
        return true;
    }

    bool boolean(bool /*unused*/)
    {
        return true;
    }

    bool number_integer(number_integer_t /*unused*/)
    {
        return true;
    }

    bool number_unsigned(number_unsigned_t /*unused*/)
    {
        return true;
    }

    bool number_float(number_float_t /*unused*/, const string_t& /*unused*/)
    {
        return true;
    }

    bool string(string_t& /*unused*/)
    {
        return true;
    }

    bool binary(binary_t& /*unused*/)
    {
        return true;
    }

    bool start_object(std::size_t /*unused*/ = detail::unknown_size())
    {
        return true;
    }

    bool key(string_t& /*unused*/)
    {
        return true;
    }

    bool end_object()
    {
        return true;
    }

    bool start_array(std::size_t /*unused*/ = detail::unknown_size())
    {
        return true;
    }

    bool end_array()
    {
        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/, const detail::exception& /*unused*/)
    {
        return false;
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstdint> // size_t
#include <utility> // declval
#include <string> // string

// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/meta/detected.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename T>
using null_function_t = decltype(std::declval<T&>().null());

template<typename T>
using boolean_function_t =
    decltype(std::declval<T&>().boolean(std::declval<bool>()));

template<typename T, typename Integer>
using number_integer_function_t =
    decltype(std::declval<T&>().number_integer(std::declval<Integer>()));

template<typename T, typename Unsigned>
using number_unsigned_function_t =
    decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));

template<typename T, typename Float, typename String>
using number_float_function_t = decltype(std::declval<T&>().number_float(
                                    std::declval<Float>(), std::declval<const String&>()));

template<typename T, typename String>
using string_function_t =
    decltype(std::declval<T&>().string(std::declval<String&>()));

template<typename T, typename Binary>
using binary_function_t =
    decltype(std::declval<T&>().binary(std::declval<Binary&>()));

template<typename T>
using start_object_function_t =
    decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));

template<typename T, typename String>
using key_function_t =
    decltype(std::declval<T&>().key(std::declval<String&>()));

template<typename T>
using end_object_function_t = decltype(std::declval<T&>().end_object());

template<typename T>
using start_array_function_t =
    decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));

template<typename T>
using end_array_function_t = decltype(std::declval<T&>().end_array());

template<typename T, typename Exception>
using parse_error_function_t = decltype(std::declval<T&>().parse_error(
        std::declval<std::size_t>(), std::declval<const std::string&>(),
        std::declval<const Exception&>()));

template<typename SAX, typename BasicJsonType>
struct is_sax
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static constexpr bool value =
        is_detected_exact<bool, null_function_t, SAX>::value &&
        is_detected_exact<bool, boolean_function_t, SAX>::value &&
        is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&
        is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&
        is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&
        is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&
        is_detected_exact<bool, start_object_function_t, SAX>::value &&
        is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, end_object_function_t, SAX>::value &&
        is_detected_exact<bool, start_array_function_t, SAX>::value &&
        is_detected_exact<bool, end_array_function_t, SAX>::value &&
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
};

template<typename SAX, typename BasicJsonType>
struct is_sax_static_asserts
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
                  "Missing/invalid function: bool null()");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(
        is_detected_exact<bool, number_integer_function_t, SAX,
        number_integer_t>::value,
        "Missing/invalid function: bool number_integer(number_integer_t)");
    static_assert(
        is_detected_exact<bool, number_unsigned_function_t, SAX,
        number_unsigned_t>::value,
        "Missing/invalid function: bool number_unsigned(number_unsigned_t)");
    static_assert(is_detected_exact<bool, number_float_function_t, SAX,
                  number_float_t, string_t>::value,
                  "Missing/invalid function: bool number_float(number_float_t, const string_t&)");
    static_assert(
        is_detected_exact<bool, string_function_t, SAX, string_t>::value,
        "Missing/invalid function: bool string(string_t&)");
    static_assert(
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value,
        "Missing/invalid function: bool binary(binary_t&)");
    static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
                  "Missing/invalid function: bool start_object(std::size_t)");
    static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
                  "Missing/invalid function: bool key(string_t&)");
    static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
                  "Missing/invalid function: bool end_object()");
    static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
                  "Missing/invalid function: bool start_array(std::size_t)");
    static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
                  "Missing/invalid function: bool end_array()");
    static_assert(
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
        "Missing/invalid function: bool parse_error(std::size_t, const "
        "std::string&, const exception&)");
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// how to treat CBOR tags
enum class cbor_tag_handler_t
{
    error,   ///< throw a parse_error exception in case of a tag
    ignore,  ///< ignore tags
    store    ///< store tags as binary type
};

/*!
@brief determine system byte order

@return true if and only if system's byte order is little endian

@note from https://stackoverflow.com/a/1001328/266378
*/
inline bool little_endianness(int num = 1) noexcept
{
    return *reinterpret_cast<char*>(&num) == 1;
}

///////////////////
// binary reader //
///////////////////

/*!
@brief deserialization of CBOR, MessagePack, and UBJSON values
*/
template<typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser<BasicJsonType, InputAdapterType>>
class binary_reader
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using json_sax_t = SAX;
    using char_type = typename InputAdapterType::char_type;
    using char_int_type = typename char_traits<char_type>::int_type;

  public:
    /*!
    @brief create a binary reader

    @param[in] adapter  input adapter to read from
    */
    explicit binary_reader(InputAdapterType&& adapter, const input_format_t format = input_format_t::json) noexcept : ia(std::move(adapter)), input_format(format)
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
    }

    // make class move-only
    binary_reader(const binary_reader&) = delete;
    binary_reader(binary_reader&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    binary_reader& operator=(const binary_reader&) = delete;
    binary_reader& operator=(binary_reader&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~binary_reader() = default;

    /*!
    @param[in] format  the binary format to parse
    @param[in] sax_    a SAX event processor
    @param[in] strict  whether to expect the input to be consumed completed
    @param[in] tag_handler  how to treat CBOR tags

    @return whether parsing was successful
    */
    JSON_HEDLEY_NON_NULL(3)
    bool sax_parse(const input_format_t format,
                   json_sax_t* sax_,
                   const bool strict = true,
                   const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        sax = sax_;
        bool result = false;

        switch (format)
        {
            case input_format_t::bson:
                result = parse_bson_internal();
                break;

            case input_format_t::cbor:
                result = parse_cbor_internal(true, tag_handler);
                break;

            case input_format_t::msgpack:
                result = parse_msgpack_internal();
                break;

            case input_format_t::ubjson:
            case input_format_t::bjdata:
                result = parse_ubjson_internal();
                break;

            case input_format_t::json: // LCOV_EXCL_LINE
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }

        // strict mode: next byte must be EOF
        if (result && strict)
        {
            if (input_format == input_format_t::ubjson || input_format == input_format_t::bjdata)
            {
                get_ignore_noop();
            }
            else
            {
                get();
            }

            if (JSON_HEDLEY_UNLIKELY(current != char_traits<char_type>::eof()))
            {
                return sax->parse_error(chars_read, get_token_string(), parse_error::create(110, chars_read,
                                        exception_message(input_format, concat("expected end of input; last byte: 0x", get_token_string()), "value"), nullptr));
            }
        }

        return result;
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @brief Reads in a BSON-object and passes it to the SAX-parser.
    @return whether a valid BSON-value was passed to the SAX parser
    */
    bool parse_bson_internal()
    {
        std::int32_t document_size{};
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(detail::unknown_size())))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/false)))
        {
            return false;
        }

        return sax->end_object();
    }

    /*!
    @brief Parses a C-style string from the BSON input.
    @param[in,out] result  A reference to the string variable where the read
                            string is to be stored.
    @return `true` if the \x00-byte indicating the end of the string was
             encountered before the EOF; false` indicates an unexpected EOF.
    */
    bool get_bson_cstr(string_t& result)
    {
        auto out = std::back_inserter(result);
        while (true)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "cstring")))
            {
                return false;
            }
            if (current == 0x00)
            {
                return true;
            }
            *out++ = static_cast<typename string_t::value_type>(current);
        }
    }

    /*!
    @brief Parses a zero-terminated string of length @a len from the BSON
           input.
    @param[in] len  The length (including the zero-byte at the end) of the
                    string to be read.
    @param[in,out] result  A reference to the string variable where the read
                            string is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 1
    @return `true` if the string was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_string(const NumberType len, string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 1))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                    exception_message(input_format_t::bson, concat("string length must be at least 1, is ", std::to_string(len)), "string"), nullptr));
        }

        return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) && get() != char_traits<char_type>::eof();
    }

    /*!
    @brief Parses a byte array input of length @a len from the BSON input.
    @param[in] len  The length of the byte array to be read.
    @param[in,out] result  A reference to the binary variable where the read
                            array is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 0
    @return `true` if the byte array was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_binary(const NumberType len, binary_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 0))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                    exception_message(input_format_t::bson, concat("byte array length cannot be negative, is ", std::to_string(len)), "binary"), nullptr));
        }

        // All BSON binary values have a subtype
        std::uint8_t subtype{};
        get_number<std::uint8_t>(input_format_t::bson, subtype);
        result.set_subtype(subtype);

        return get_binary(input_format_t::bson, len, result);
    }

    /*!
    @brief Read a BSON document element of the given @a element_type.
    @param[in] element_type The BSON element type, c.f. http://bsonspec.org/spec.html
    @param[in] element_type_parse_position The position in the input stream,
               where the `element_type` was read.
    @warning Not all BSON element types are supported yet. An unsupported
             @a element_type will give rise to a parse_error.114:
             Unsupported BSON record type 0x...
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_internal(const char_int_type element_type,
                                     const std::size_t element_type_parse_position)
    {
        switch (element_type)
        {
            case 0x01: // double
            {
                double number{};
                return get_number<double, true>(input_format_t::bson, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0x02: // string
            {
                std::int32_t len{};
                string_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_string(len, value) && sax->string(value);
            }

            case 0x03: // object
            {
                return parse_bson_internal();
            }

            case 0x04: // array
            {
                return parse_bson_array();
            }

            case 0x05: // binary
            {
                std::int32_t len{};
                binary_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_binary(len, value) && sax->binary(value);
            }

            case 0x08: // boolean
            {
                return sax->boolean(get() != 0);
            }

            case 0x0A: // null
            {
                return sax->null();
            }

            case 0x10: // int32
            {
                std::int32_t value{};
                return get_number<std::int32_t, true>(input_format_t::bson, value) && sax->number_integer(value);
            }

            case 0x12: // int64
            {
                std::int64_t value{};
                return get_number<std::int64_t, true>(input_format_t::bson, value) && sax->number_integer(value);
            }

            case 0x11: // uint64
            {
                std::uint64_t value{};
                return get_number<std::uint64_t, true>(input_format_t::bson, value) && sax->number_unsigned(value);
            }

            default: // anything else is not supported (yet)
            {
                std::array<char, 3> cr{{}};
                static_cast<void>((std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(element_type))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                const std::string cr_str{cr.data()};
                return sax->parse_error(element_type_parse_position, cr_str,
                                        parse_error::create(114, element_type_parse_position, concat("Unsupported BSON record type 0x", cr_str), nullptr));
            }
        }
    }

    /*!
    @brief Read a BSON element list (as specified in the BSON-spec)

    The same binary layout is used for objects and arrays, hence it must be
    indicated with the argument @a is_array which one is expected
    (true --> array, false --> object).

    @param[in] is_array Determines if the element list being read is to be
                        treated as an object (@a is_array == false), or as an
                        array (@a is_array == true).
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_list(const bool is_array)
    {
        string_t key;

        while (auto element_type = get())
        {
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "element list")))
            {
                return false;
            }

            const std::size_t element_type_parse_position = chars_read;
            if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))
            {
                return false;
            }

            if (!is_array && !sax->key(key))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))
            {
                return false;
            }

            // get_bson_cstr only appends
            key.clear();
        }

        return true;
    }

    /*!
    @brief Reads an array from the BSON input and passes it to the SAX-parser.
    @return whether a valid BSON-array was passed to the SAX parser
    */
    bool parse_bson_array()
    {
        std::int32_t document_size{};
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(detail::unknown_size())))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/true)))
        {
            return false;
        }

        return sax->end_array();
    }

    //////////
    // CBOR //
    //////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true) or whether the last read character should
                         be considered instead (false)
    @param[in] tag_handler how CBOR tags should be treated

    @return whether a valid CBOR value was passed to the SAX parser
    */
    bool parse_cbor_internal(const bool get_char,
                             const cbor_tag_handler_t tag_handler)
    {
        switch (get_char ? get() : current)
        {
            // EOF
            case char_traits<char_type>::eof():
                return unexpect_eof(input_format_t::cbor, "value");

            // Integer 0x00..0x17 (0..23)
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            case 0x18: // Unsigned integer (one-byte uint8_t follows)
            {
                std::uint8_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x19: // Unsigned integer (two-byte uint16_t follows)
            {
                std::uint16_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x1A: // Unsigned integer (four-byte uint32_t follows)
            {
                std::uint32_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
            {
                std::uint64_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            // Negative integer -1-0x00..-1-0x17 (-1..-24)
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
                return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));

            case 0x38: // Negative integer (one-byte uint8_t follows)
            {
                std::uint8_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
            {
                std::uint16_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
            {
                std::uint32_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1) - number);
            }

            case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
            {
                std::uint64_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_integer(static_cast<number_integer_t>(-1)
                        - static_cast<number_integer_t>(number));
            }

            // Binary data (0x00..0x17 bytes follow)
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58: // Binary data (one-byte uint8_t for n follows)
            case 0x59: // Binary data (two-byte uint16_t for n follow)
            case 0x5A: // Binary data (four-byte uint32_t for n follow)
            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
            case 0x5F: // Binary data (indefinite length)
            {
                binary_t b;
                return get_cbor_binary(b) && sax->binary(b);
            }

            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            case 0x7F: // UTF-8 string (indefinite length)
            {
                string_t s;
                return get_cbor_string(s) && sax->string(s);
            }

            // array (0x00..0x17 data items follow)
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
                return get_cbor_array(
                           conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);

            case 0x98: // array (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x99: // array (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9A: // array (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9B: // array (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9F: // array (indefinite length)
                return get_cbor_array(detail::unknown_size(), tag_handler);

            // map (0x00..0x17 pairs of data items follow)
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
                return get_cbor_object(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);

            case 0xB8: // map (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xB9: // map (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBA: // map (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBB: // map (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBF: // map (indefinite length)
                return get_cbor_object(detail::unknown_size(), tag_handler);

            case 0xC6: // tagged item
            case 0xC7:
            case 0xC8:
            case 0xC9:
            case 0xCA:
            case 0xCB:
            case 0xCC:
            case 0xCD:
            case 0xCE:
            case 0xCF:
            case 0xD0:
            case 0xD1:
            case 0xD2:
            case 0xD3:
            case 0xD4:
            case 0xD8: // tagged item (1 byte follows)
            case 0xD9: // tagged item (2 bytes follow)
            case 0xDA: // tagged item (4 bytes follow)
            case 0xDB: // tagged item (8 bytes follow)
            {
                switch (tag_handler)
                {
                    case cbor_tag_handler_t::error:
                    {
                        auto last_token = get_token_string();
                        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                                exception_message(input_format_t::cbor, concat("invalid byte: 0x", last_token), "value"), nullptr));
                    }

                    case cbor_tag_handler_t::ignore:
                    {
                        // ignore binary subtype
                        switch (current)
                        {
                            case 0xD8:
                            {
                                std::uint8_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            case 0xD9:
                            {
                                std::uint16_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            case 0xDA:
                            {
                                std::uint32_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            case 0xDB:
                            {
                                std::uint64_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            default:
                                break;
                        }
                        return parse_cbor_internal(true, tag_handler);
                    }

                    case cbor_tag_handler_t::store:
                    {
                        binary_t b;
                        // use binary subtype and store in a binary container
                        switch (current)
                        {
                            case 0xD8:
                            {
                                std::uint8_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            case 0xD9:
                            {
                                std::uint16_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            case 0xDA:
                            {
                                std::uint32_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            case 0xDB:
                            {
                                std::uint64_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            default:
                                return parse_cbor_internal(true, tag_handler);
                        }
                        get();
                        return get_cbor_binary(b) && sax->binary(b);
                    }

                    default:                 // LCOV_EXCL_LINE
                        JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
                        return false;        // LCOV_EXCL_LINE
                }
            }

            case 0xF4: // false
                return sax->boolean(false);

            case 0xF5: // true
                return sax->boolean(true);

            case 0xF6: // null
                return sax->null();

            case 0xF9: // Half-Precision Float (two-byte IEEE 754)
            {
                const auto byte1_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }
                const auto byte2_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }

                const auto byte1 = static_cast<unsigned char>(byte1_raw);
                const auto byte2 = static_cast<unsigned char>(byte2_raw);

                // Code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);
                const double val = [&half]
                {
                    const int exp = (half >> 10u) & 0x1Fu;
                    const unsigned int mant = half & 0x3FFu;
                    JSON_ASSERT(0 <= exp&& exp <= 32);
                    JSON_ASSERT(mant <= 1024);
                    switch (exp)
                    {
                        case 0:
                            return std::ldexp(mant, -24);
                        case 31:
                            return (mant == 0)
                            ? std::numeric_limits<double>::infinity()
                            : std::numeric_limits<double>::quiet_NaN();
                        default:
                            return std::ldexp(mant + 1024, exp - 25);
                    }
                }();
                return sax->number_float((half & 0x8000u) != 0
                                         ? static_cast<number_float_t>(-val)
                                         : static_cast<number_float_t>(val), "");
            }

            case 0xFA: // Single-Precision Float (four-byte IEEE 754)
            {
                float number{};
                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
            {
                double number{};
                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            default: // anything else (0xFF is handled inside the other types)
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format_t::cbor, concat("invalid byte: 0x", last_token), "value"), nullptr));
            }
        }
    }

    /*!
    @brief reads a CBOR string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.
    Additionally, CBOR's strings with indefinite lengths are supported.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_cbor_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "string")))
        {
            return false;
        }

        switch (current)
        {
            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            {
                return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7F: // UTF-8 string (indefinite length)
            {
                while (get() != 0xFF)
                {
                    string_t chunk;
                    if (!get_cbor_string(chunk))
                    {
                        return false;
                    }
                    result.append(chunk);
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                        exception_message(input_format_t::cbor, concat("expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x", last_token), "string"), nullptr));
            }
        }
    }

    /*!
    @brief reads a CBOR byte array

    This function first reads starting bytes to determine the expected
    byte array length and then copies this number of bytes into the byte array.
    Additionally, CBOR's byte arrays with indefinite lengths are supported.

    @param[out] result  created byte array

    @return whether byte array creation completed
    */
    bool get_cbor_binary(binary_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "binary")))
        {
            return false;
        }

        switch (current)
        {
            // Binary data (0x00..0x17 bytes follow)
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            {
                return get_binary(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x58: // Binary data (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x59: // Binary data (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5A: // Binary data (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5F: // Binary data (indefinite length)
            {
                while (get() != 0xFF)
                {
                    binary_t chunk;
                    if (!get_cbor_binary(chunk))
                    {
                        return false;
                    }
                    result.insert(result.end(), chunk.begin(), chunk.end());
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                        exception_message(input_format_t::cbor, concat("expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x", last_token), "binary"), nullptr));
            }
        }
    }

    /*!
    @param[in] len  the length of the array or detail::unknown_size() for an
                    array of indefinite size
    @param[in] tag_handler how CBOR tags should be treated
    @return whether array creation completed
    */
    bool get_cbor_array(const std::size_t len,
                        const cbor_tag_handler_t tag_handler)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
        {
            return false;
        }

        if (len != detail::unknown_size())
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                {
                    return false;
                }
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))
                {
                    return false;
                }
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object or detail::unknown_size() for an
                    object of indefinite size
    @param[in] tag_handler how CBOR tags should be treated
    @return whether object creation completed
    */
    bool get_cbor_object(const std::size_t len,
                         const cbor_tag_handler_t tag_handler)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
        {
            return false;
        }

        if (len != 0)
        {
            string_t key;
            if (len != detail::unknown_size())
            {
                for (std::size_t i = 0; i < len; ++i)
                {
                    get();
                    if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
                    {
                        return false;
                    }

                    if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
            else
            {
                while (get() != 0xFF)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
                    {
                        return false;
                    }

                    if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
        }

        return sax->end_object();
    }

    /////////////
    // MsgPack //
    /////////////

    /*!
    @return whether a valid MessagePack value was passed to the SAX parser
    */
    bool parse_msgpack_internal()
    {
        switch (get())
        {
            // EOF
            case char_traits<char_type>::eof():
                return unexpect_eof(input_format_t::msgpack, "value");

            // positive fixint
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            // fixmap
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
                return get_msgpack_object(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixarray
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
            case 0x98:
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0x9F:
                return get_msgpack_array(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            case 0xD9: // str 8
            case 0xDA: // str 16
            case 0xDB: // str 32
            {
                string_t s;
                return get_msgpack_string(s) && sax->string(s);
            }

            case 0xC0: // nil
                return sax->null();

            case 0xC2: // false
                return sax->boolean(false);

            case 0xC3: // true
                return sax->boolean(true);

            case 0xC4: // bin 8
            case 0xC5: // bin 16
            case 0xC6: // bin 32
            case 0xC7: // ext 8
            case 0xC8: // ext 16
            case 0xC9: // ext 32
            case 0xD4: // fixext 1
            case 0xD5: // fixext 2
            case 0xD6: // fixext 4
            case 0xD7: // fixext 8
            case 0xD8: // fixext 16
            {
                binary_t b;
                return get_msgpack_binary(b) && sax->binary(b);
            }

            case 0xCA: // float 32
            {
                float number{};
                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCB: // float 64
            {
                double number{};
                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCC: // uint 8
            {
                std::uint8_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCD: // uint 16
            {
                std::uint16_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCE: // uint 32
            {
                std::uint32_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCF: // uint 64
            {
                std::uint64_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xD0: // int 8
            {
                std::int8_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD1: // int 16
            {
                std::int16_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD2: // int 32
            {
                std::int32_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD3: // int 64
            {
                std::int64_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xDC: // array 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDD: // array 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_array(conditional_static_cast<std::size_t>(len));
            }

            case 0xDE: // map 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
            }

            case 0xDF: // map 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_object(conditional_static_cast<std::size_t>(len));
            }

            // negative fixint
            case 0xE0:
            case 0xE1:
            case 0xE2:
            case 0xE3:
            case 0xE4:
            case 0xE5:
            case 0xE6:
            case 0xE7:
            case 0xE8:
            case 0xE9:
            case 0xEA:
            case 0xEB:
            case 0xEC:
            case 0xED:
            case 0xEE:
            case 0xEF:
            case 0xF0:
            case 0xF1:
            case 0xF2:
            case 0xF3:
            case 0xF4:
            case 0xF5:
            case 0xF6:
            case 0xF7:
            case 0xF8:
            case 0xF9:
            case 0xFA:
            case 0xFB:
            case 0xFC:
            case 0xFD:
            case 0xFE:
            case 0xFF:
                return sax->number_integer(static_cast<std::int8_t>(current));

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format_t::msgpack, concat("invalid byte: 0x", last_token), "value"), nullptr));
            }
        }
    }

    /*!
    @brief reads a MessagePack string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_msgpack_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, "string")))
        {
            return false;
        }

        switch (current)
        {
            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            {
                return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0xD9: // str 8
            {
                std::uint8_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            case 0xDA: // str 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            case 0xDB: // str 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                        exception_message(input_format_t::msgpack, concat("expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x", last_token), "string"), nullptr));
            }
        }
    }

    /*!
    @brief reads a MessagePack byte array

    This function first reads starting bytes to determine the expected
    byte array length and then copies this number of bytes into a byte array.

    @param[out] result  created byte array

    @return whether byte array creation completed
    */
    bool get_msgpack_binary(binary_t& result)
    {
        // helper function to set the subtype
        auto assign_and_return_true = [&result](std::int8_t subtype)
        {
            result.set_subtype(static_cast<std::uint8_t>(subtype));
            return true;
        };

        switch (current)
        {
            case 0xC4: // bin 8
            {
                std::uint8_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC5: // bin 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC6: // bin 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC7: // ext 8
            {
                std::uint8_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xC8: // ext 16
            {
                std::uint16_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xC9: // ext 32
            {
                std::uint32_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD4: // fixext 1
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 1, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD5: // fixext 2
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 2, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD6: // fixext 4
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 4, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD7: // fixext 8
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 8, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD8: // fixext 16
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 16, result) &&
                       assign_and_return_true(subtype);
            }

            default:           // LCOV_EXCL_LINE
                return false;  // LCOV_EXCL_LINE
        }
    }

    /*!
    @param[in] len  the length of the array
    @return whether array creation completed
    */
    bool get_msgpack_array(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
        {
            return false;
        }

        for (std::size_t i = 0; i < len; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
            {
                return false;
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object
    @return whether object creation completed
    */
    bool get_msgpack_object(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        for (std::size_t i = 0; i < len; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax->key(key)))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
            {
                return false;
            }
            key.clear();
        }

        return sax->end_object();
    }

    ////////////
    // UBJSON //
    ////////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether a valid UBJSON value was passed to the SAX parser
    */
    bool parse_ubjson_internal(const bool get_char = true)
    {
        return get_ubjson_value(get_char ? get_ignore_noop() : current);
    }

    /*!
    @brief reads a UBJSON string

    This function is either called after reading the 'S' byte explicitly
    indicating a string, or in case of an object key where the 'S' byte can be
    left out.

    @param[out] result   created string
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether string creation completed
    */
    bool get_ubjson_string(string_t& result, const bool get_char = true)
    {
        if (get_char)
        {
            get();  // TODO(niels): may we ignore N here?
        }

        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "value")))
        {
            return false;
        }

        switch (current)
        {
            case 'U':
            {
                std::uint8_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'i':
            {
                std::int8_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'I':
            {
                std::int16_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'l':
            {
                std::int32_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'L':
            {
                std::int64_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'u':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint16_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'm':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint32_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'M':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint64_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            default:
                break;
        }
        auto last_token = get_token_string();
        std::string message;

        if (input_format != input_format_t::bjdata)
        {
            message = "expected length type specification (U, i, I, l, L); last byte: 0x" + last_token;
        }
        else
        {
            message = "expected length type specification (U, i, u, I, m, l, M, L); last byte: 0x" + last_token;
        }
        return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, "string"), nullptr));
    }

    /*!
    @param[out] dim  an integer vector storing the ND array dimensions
    @return whether reading ND array size vector is successful
    */
    bool get_ubjson_ndarray_size(std::vector<size_t>& dim)
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        size_t dimlen = 0;
        bool no_ndarray = true;

        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type, no_ndarray)))
        {
            return false;
        }

        if (size_and_type.first != npos)
        {
            if (size_and_type.second != 0)
            {
                if (size_and_type.second != 'N')
                {
                    for (std::size_t i = 0; i < size_and_type.first; ++i)
                    {
                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, size_and_type.second)))
                        {
                            return false;
                        }
                        dim.push_back(dimlen);
                    }
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray)))
                    {
                        return false;
                    }
                    dim.push_back(dimlen);
                }
            }
        }
        else
        {
            while (current != ']')
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, current)))
                {
                    return false;
                }
                dim.push_back(dimlen);
                get_ignore_noop();
            }
        }
        return true;
    }

    /*!
    @param[out] result  determined size
    @param[in,out] is_ndarray  for input, `true` means already inside an ndarray vector
                               or ndarray dimension is not allowed; `false` means ndarray
                               is allowed; for output, `true` means an ndarray is found;
                               is_ndarray can only return `true` when its initial value
                               is `false`
    @param[in] prefix  type marker if already read, otherwise set to 0

    @return whether size determination completed
    */
    bool get_ubjson_size_value(std::size_t& result, bool& is_ndarray, char_int_type prefix = 0)
    {
        if (prefix == 0)
        {
            prefix = get_ignore_noop();
        }

        switch (prefix)
        {
            case 'U':
            {
                std::uint8_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'i':
            {
                std::int8_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number); // NOLINT(bugprone-signed-char-misuse,cert-str34-c): number is not a char
                return true;
            }

            case 'I':
            {
                std::int16_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'l':
            {
                std::int32_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'L':
            {
                std::int64_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                if (!value_in_range_of<std::size_t>(number))
                {
                    return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408,
                                            exception_message(input_format, "integer value overflow", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'u':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint16_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'm':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint32_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                result = conditional_static_cast<std::size_t>(number);
                return true;
            }

            case 'M':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint64_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (!value_in_range_of<std::size_t>(number))
                {
                    return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408,
                                            exception_message(input_format, "integer value overflow", "size"), nullptr));
                }
                result = detail::conditional_static_cast<std::size_t>(number);
                return true;
            }

            case '[':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                if (is_ndarray) // ndarray dimensional vector can only contain integers and cannot embed another array
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read, exception_message(input_format, "ndarray dimensional vector is not allowed", "size"), nullptr));
                }
                std::vector<size_t> dim;
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_ndarray_size(dim)))
                {
                    return false;
                }
                if (dim.size() == 1 || (dim.size() == 2 && dim.at(0) == 1)) // return normal array size if 1D row vector
                {
                    result = dim.at(dim.size() - 1);
                    return true;
                }
                if (!dim.empty())  // if ndarray, convert to an object in JData annotated array format
                {
                    for (auto i : dim) // test if any dimension in an ndarray is 0, if so, return a 1D empty container
                    {
                        if ( i == 0 )
                        {
                            result = 0;
                            return true;
                        }
                    }

                    string_t key = "_ArraySize_";
                    if (JSON_HEDLEY_UNLIKELY(!sax->start_object(3) || !sax->key(key) || !sax->start_array(dim.size())))
                    {
                        return false;
                    }
                    result = 1;
                    for (auto i : dim)
                    {
                        // Pre-multiplication overflow check: if i > 0 and result > SIZE_MAX/i, then result*i would overflow.
                        // This check must happen before multiplication since overflow detection after the fact is unreliable
                        // as modular arithmetic can produce any value, not just 0 or SIZE_MAX.
                        if (JSON_HEDLEY_UNLIKELY(i > 0 && result > (std::numeric_limits<std::size_t>::max)() / i))
                        {
                            return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408, exception_message(input_format, "excessive ndarray size caused overflow", "size"), nullptr));
                        }
                        result *= i;
                        // Additional post-multiplication check to catch any edge cases the pre-check might miss
                        if (result == 0 || result == npos)
                        {
                            return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408, exception_message(input_format, "excessive ndarray size caused overflow", "size"), nullptr));
                        }
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(static_cast<number_unsigned_t>(i))))
                        {
                            return false;
                        }
                    }
                    is_ndarray = true;
                    return sax->end_array();
                }
                result = 0;
                return true;
            }

            default:
                break;
        }
        auto last_token = get_token_string();
        std::string message;

        if (input_format != input_format_t::bjdata)
        {
            message = "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x" + last_token;
        }
        else
        {
            message = "expected length type specification (U, i, u, I, m, l, M, L) after '#'; last byte: 0x" + last_token;
        }
        return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, "size"), nullptr));
    }

    /*!
    @brief determine the type and size for a container

    In the optimized UBJSON format, a type and a size can be provided to allow
    for a more compact representation.

    @param[out] result  pair of the size and the type
    @param[in] inside_ndarray  whether the parser is parsing an ND array dimensional vector

    @return whether pair creation completed
    */
    bool get_ubjson_size_type(std::pair<std::size_t, char_int_type>& result, bool inside_ndarray = false)
    {
        result.first = npos; // size
        result.second = 0; // type
        bool is_ndarray = false;

        get_ignore_noop();

        if (current == '$')
        {
            result.second = get();  // must not ignore 'N', because 'N' maybe the type
            if (input_format == input_format_t::bjdata
                    && JSON_HEDLEY_UNLIKELY(std::binary_search(bjd_optimized_type_markers.begin(), bjd_optimized_type_markers.end(), result.second)))
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format, concat("marker 0x", last_token, " is not a permitted optimized array type"), "type"), nullptr));
            }

            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "type")))
            {
                return false;
            }

            get_ignore_noop();
            if (JSON_HEDLEY_UNLIKELY(current != '#'))
            {
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "value")))
                {
                    return false;
                }
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format, concat("expected '#' after type information; last byte: 0x", last_token), "size"), nullptr));
            }

            const bool is_error = get_ubjson_size_value(result.first, is_ndarray);
            if (input_format == input_format_t::bjdata && is_ndarray)
            {
                if (inside_ndarray)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
                                            exception_message(input_format, "ndarray can not be recursive", "size"), nullptr));
                }
                result.second |= (1 << 8); // use bit 8 to indicate ndarray, all UBJSON and BJData markers should be ASCII letters
            }
            return is_error;
        }

        if (current == '#')
        {
            const bool is_error = get_ubjson_size_value(result.first, is_ndarray);
            if (input_format == input_format_t::bjdata && is_ndarray)
            {
                return sax->parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
                                        exception_message(input_format, "ndarray requires both type and size", "size"), nullptr));
            }
            return is_error;
        }

        return true;
    }

    /*!
    @param prefix  the previously read or set type prefix
    @return whether value creation completed
    */
    bool get_ubjson_value(const char_int_type prefix)
    {
        switch (prefix)
        {
            case char_traits<char_type>::eof():  // EOF
                return unexpect_eof(input_format, "value");

            case 'T':  // true
                return sax->boolean(true);
            case 'F':  // false
                return sax->boolean(false);

            case 'Z':  // null
                return sax->null();

            case 'B':  // byte
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint8_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'U':
            {
                std::uint8_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'i':
            {
                std::int8_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'I':
            {
                std::int16_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'l':
            {
                std::int32_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'L':
            {
                std::int64_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'u':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint16_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'm':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint32_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'M':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint64_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'h':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                const auto byte1_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
                {
                    return false;
                }
                const auto byte2_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
                {
                    return false;
                }

                const auto byte1 = static_cast<unsigned char>(byte1_raw);
                const auto byte2 = static_cast<unsigned char>(byte2_raw);

                // Code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const auto half = static_cast<unsigned int>((byte2 << 8u) + byte1);
                const double val = [&half]
                {
                    const int exp = (half >> 10u) & 0x1Fu;
                    const unsigned int mant = half & 0x3FFu;
                    JSON_ASSERT(0 <= exp&& exp <= 32);
                    JSON_ASSERT(mant <= 1024);
                    switch (exp)
                    {
                        case 0:
                            return std::ldexp(mant, -24);
                        case 31:
                            return (mant == 0)
                            ? std::numeric_limits<double>::infinity()
                            : std::numeric_limits<double>::quiet_NaN();
                        default:
                            return std::ldexp(mant + 1024, exp - 25);
                    }
                }();
                return sax->number_float((half & 0x8000u) != 0
                                         ? static_cast<number_float_t>(-val)
                                         : static_cast<number_float_t>(val), "");
            }

            case 'd':
            {
                float number{};
                return get_number(input_format, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'D':
            {
                double number{};
                return get_number(input_format, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'H':
            {
                return get_ubjson_high_precision_number();
            }

            case 'C':  // char
            {
                get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "char")))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(current > 127))
                {
                    auto last_token = get_token_string();
                    return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                            exception_message(input_format, concat("byte after 'C' must be in range 0x00..0x7F; last byte: 0x", last_token), "char"), nullptr));
                }
                string_t s(1, static_cast<typename string_t::value_type>(current));
                return sax->string(s);
            }

            case 'S':  // string
            {
                string_t s;
                return get_ubjson_string(s) && sax->string(s);
            }

            case '[':  // array
                return get_ubjson_array();

            case '{':  // object
                return get_ubjson_object();

            default: // anything else
                break;
        }
        auto last_token = get_token_string();
        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format, "invalid byte: 0x" + last_token, "value"), nullptr));
    }

    /*!
    @return whether array creation completed
    */
    bool get_ubjson_array()
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        // if bit-8 of size_and_type.second is set to 1, encode bjdata ndarray as an object in JData annotated array format (https://github.com/NeuroJSON/jdata):
        // {"_ArrayType_" : "typeid", "_ArraySize_" : [n1, n2, ...], "_ArrayData_" : [v1, v2, ...]}

        if (input_format == input_format_t::bjdata && size_and_type.first != npos && (size_and_type.second & (1 << 8)) != 0)
        {
            size_and_type.second &= ~(static_cast<char_int_type>(1) << 8);  // use bit 8 to indicate ndarray, here we remove the bit to restore the type marker
            auto it = std::lower_bound(bjd_types_map.begin(), bjd_types_map.end(), size_and_type.second, [](const bjd_type & p, char_int_type t)
            {
                return p.first < t;
            });
            string_t key = "_ArrayType_";
            if (JSON_HEDLEY_UNLIKELY(it == bjd_types_map.end() || it->first != size_and_type.second))
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format, "invalid byte: 0x" + last_token, "type"), nullptr));
            }

            string_t type = it->second; // sax->string() takes a reference
            if (JSON_HEDLEY_UNLIKELY(!sax->key(key) || !sax->string(type)))
            {
                return false;
            }

            if (size_and_type.second == 'C' || size_and_type.second == 'B')
            {
                size_and_type.second = 'U';
            }

            key = "_ArrayData_";
            if (JSON_HEDLEY_UNLIKELY(!sax->key(key) || !sax->start_array(size_and_type.first) ))
            {
                return false;
            }

            for (std::size_t i = 0; i < size_and_type.first; ++i)
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                {
                    return false;
                }
            }

            return (sax->end_array() && sax->end_object());
        }

        // If BJData type marker is 'B' decode as binary
        if (input_format == input_format_t::bjdata && size_and_type.first != npos && size_and_type.second == 'B')
        {
            binary_t result;
            return get_binary(input_format, size_and_type.first, result) && sax->binary(result);
        }

        if (size_and_type.first != npos)
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                if (size_and_type.second != 'N')
                {
                    for (std::size_t i = 0; i < size_and_type.first; ++i)
                    {
                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                    {
                        return false;
                    }
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(detail::unknown_size())))
            {
                return false;
            }

            while (current != ']')
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))
                {
                    return false;
                }
                get_ignore_noop();
            }
        }

        return sax->end_array();
    }

    /*!
    @return whether object creation completed
    */
    bool get_ubjson_object()
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        // do not accept ND-array size in objects in BJData
        if (input_format == input_format_t::bjdata && size_and_type.first != npos && (size_and_type.second & (1 << 8)) != 0)
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                    exception_message(input_format, "BJData object does not support ND-array size in optimized format", "object"), nullptr));
        }

        string_t key;
        if (size_and_type.first != npos)
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(detail::unknown_size())))
            {
                return false;
            }

            while (current != '}')
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax->key(key)))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                {
                    return false;
                }
                get_ignore_noop();
                key.clear();
            }
        }

        return sax->end_object();
    }

    // Note, no reader for UBJSON binary types is implemented because they do
    // not exist

    bool get_ubjson_high_precision_number()
    {
        // get the size of the following number string
        std::size_t size{};
        bool no_ndarray = true;
        auto res = get_ubjson_size_value(size, no_ndarray);
        if (JSON_HEDLEY_UNLIKELY(!res))
        {
            return res;
        }

        // get number string
        std::vector<char> number_vector;
        for (std::size_t i = 0; i < size; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
            {
                return false;
            }
            number_vector.push_back(static_cast<char>(current));
        }

        // parse number string
        using ia_type = decltype(detail::input_adapter(number_vector));
        auto number_lexer = detail::lexer<BasicJsonType, ia_type>(detail::input_adapter(number_vector), false);
        const auto result_number = number_lexer.scan();
        const auto number_string = number_lexer.get_token_string();
        const auto result_remainder = number_lexer.scan();

        using token_type = typename detail::lexer_base<BasicJsonType>::token_type;

        if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))
        {
            return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read,
                                    exception_message(input_format, concat("invalid number text: ", number_lexer.get_token_string()), "high-precision number"), nullptr));
        }

        switch (result_number)
        {
            case token_type::value_integer:
                return sax->number_integer(number_lexer.get_number_integer());
            case token_type::value_unsigned:
                return sax->number_unsigned(number_lexer.get_number_unsigned());
            case token_type::value_float:
                return sax->number_float(number_lexer.get_number_float(), std::move(number_string));
            case token_type::uninitialized:
            case token_type::literal_true:
            case token_type::literal_false:
            case token_type::literal_null:
            case token_type::value_string:
            case token_type::begin_array:
            case token_type::begin_object:
            case token_type::end_array:
            case token_type::end_object:
            case token_type::name_separator:
            case token_type::value_separator:
            case token_type::parse_error:
            case token_type::end_of_input:
            case token_type::literal_or_value:
            default:
                return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read,
                                        exception_message(input_format, concat("invalid number text: ", number_lexer.get_token_string()), "high-precision number"), nullptr));
        }
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*!
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a -'ve valued
    `char_traits<char_type>::eof()` in that case.

    @return character read from the input
    */
    char_int_type get()
    {
        ++chars_read;
        return current = ia.get_character();
    }

    /*!
    @brief get_to read into a primitive type

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns false instead

    @return bool, whether the read was successful
    */
    template<class T>
    bool get_to(T& dest, const input_format_t format, const char* context)
    {
        auto new_chars_read = ia.get_elements(&dest);
        chars_read += new_chars_read;
        if (JSON_HEDLEY_UNLIKELY(new_chars_read < sizeof(T)))
        {
            // in case of failure, advance position by 1 to report the failing location
            ++chars_read;
            sax->parse_error(chars_read, "<end of file>", parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context), nullptr));
            return false;
        }
        return true;
    }

    /*!
    @return character read from the input after ignoring all 'N' entries
    */
    char_int_type get_ignore_noop()
    {
        do
        {
            get();
        }
        while (current == 'N');

        return current;
    }

    template<class NumberType>
    static void byte_swap(NumberType& number)
    {
        constexpr std::size_t sz = sizeof(number);
#ifdef __cpp_lib_byteswap
        if constexpr (sz == 1)
        {
            return;
        }
        else if constexpr(std::is_integral_v<NumberType>)
        {
            number = std::byteswap(number);
            return;
        }
        else
        {
#endif
            auto* ptr = reinterpret_cast<std::uint8_t*>(&number);
            for (std::size_t i = 0; i < sz / 2; ++i)
            {
                std::swap(ptr[i], ptr[sz - i - 1]);
            }
#ifdef __cpp_lib_byteswap
        }
#endif
    }

    /*
    @brief read a number from the input

    @tparam NumberType the type of the number
    @param[in] format   the current format (for diagnostics)
    @param[out] result  number of type @a NumberType

    @return whether conversion completed

    @note This function needs to respect the system's endianness, because
          bytes in CBOR, MessagePack, and UBJSON are stored in network order
          (big endian) and therefore need reordering on little endian systems.
          On the other hand, BSON and BJData use little endian and should reorder
          on big endian systems.
    */
    template<typename NumberType, bool InputIsLittleEndian = false>
    bool get_number(const input_format_t format, NumberType& result)
    {
        // read in the original format

        if (JSON_HEDLEY_UNLIKELY(!get_to(result, format, "number")))
        {
            return false;
        }
        if (is_little_endian != (InputIsLittleEndian || format == input_format_t::bjdata))
        {
            byte_swap(result);
        }
        return true;
    }

    /*!
    @brief create a string by reading characters from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of characters to read
    @param[out] result string created by reading @a len bytes

    @return whether string creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of string memory.
    */
    template<typename NumberType>
    bool get_string(const input_format_t format,
                    const NumberType len,
                    string_t& result)
    {
        bool success = true;
        for (NumberType i = 0; i < len; i++)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "string")))
            {
                success = false;
                break;
            }
            result.push_back(static_cast<typename string_t::value_type>(current));
        }
        return success;
    }

    /*!
    @brief create a byte array by reading bytes from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of bytes to read
    @param[out] result byte array created by reading @a len bytes

    @return whether byte array creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of memory.
    */
    template<typename NumberType>
    bool get_binary(const input_format_t format,
                    const NumberType len,
                    binary_t& result)
    {
        bool success = true;
        for (NumberType i = 0; i < len; i++)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "binary")))
            {
                success = false;
                break;
            }
            result.push_back(static_cast<std::uint8_t>(current));
        }
        return success;
    }

    /*!
    @param[in] format   the current format (for diagnostics)
    @param[in] context  further context information (for diagnostics)
    @return whether the last read character is not EOF
    */
    JSON_HEDLEY_NON_NULL(3)
    bool unexpect_eof(const input_format_t format, const char* context) const
    {
        if (JSON_HEDLEY_UNLIKELY(current == char_traits<char_type>::eof()))
        {
            return sax->parse_error(chars_read, "<end of file>",
                                    parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context), nullptr));
        }
        return true;
    }

    /*!
    @return a string representation of the last read byte
    */
    std::string get_token_string() const
    {
        std::array<char, 3> cr{{}};
        static_cast<void>((std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(current))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
        return std::string{cr.data()};
    }

    /*!
    @param[in] format   the current format
    @param[in] detail   a detailed error message
    @param[in] context  further context information
    @return a message string to use in the parse_error exceptions
    */
    std::string exception_message(const input_format_t format,
                                  const std::string& detail,
                                  const std::string& context) const
    {
        std::string error_msg = "syntax error while parsing ";

        switch (format)
        {
            case input_format_t::cbor:
                error_msg += "CBOR";
                break;

            case input_format_t::msgpack:
                error_msg += "MessagePack";
                break;

            case input_format_t::ubjson:
                error_msg += "UBJSON";
                break;

            case input_format_t::bson:
                error_msg += "BSON";
                break;

            case input_format_t::bjdata:
                error_msg += "BJData";
                break;

            case input_format_t::json: // LCOV_EXCL_LINE
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }

        return concat(error_msg, ' ', context, ": ", detail);
    }

  private:
    static JSON_INLINE_VARIABLE constexpr std::size_t npos = detail::unknown_size();

    /// input adapter
    InputAdapterType ia;

    /// the current character
    char_int_type current = char_traits<char_type>::eof();

    /// the number of characters read
    std::size_t chars_read = 0;

    /// whether we can assume little endianness
    const bool is_little_endian = little_endianness();

    /// input format
    const input_format_t input_format = input_format_t::json;

    /// the SAX parser
    json_sax_t* sax = nullptr;

    // excluded markers in bjdata optimized type
#define JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_ \
    make_array<char_int_type>('F', 'H', 'N', 'S', 'T', 'Z', '[', '{')

#define JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_ \
    make_array<bjd_type>(                      \
    bjd_type{'B', "byte"},                     \
    bjd_type{'C', "char"},                     \
    bjd_type{'D', "double"},                   \
    bjd_type{'I', "int16"},                    \
    bjd_type{'L', "int64"},                    \
    bjd_type{'M', "uint64"},                   \
    bjd_type{'U', "uint8"},                    \
    bjd_type{'d', "single"},                   \
    bjd_type{'i', "int8"},                     \
    bjd_type{'l', "int32"},                    \
    bjd_type{'m', "uint32"},                   \
    bjd_type{'u', "uint16"})

  JSON_PRIVATE_UNLESS_TESTED:
    // lookup tables
    // NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)
    const decltype(JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_) bjd_optimized_type_markers =
        JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_;

    using bjd_type = std::pair<char_int_type, string_t>;
    // NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)
    const decltype(JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_) bjd_types_map =
        JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_;

#undef JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_
#undef JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_
};

#ifndef JSON_HAS_CPP_17
    template<typename BasicJsonType, typename InputAdapterType, typename SAX>
    constexpr std::size_t binary_reader<BasicJsonType, InputAdapterType, SAX>::npos;
#endif

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/input/parser.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cmath> // isfinite
#include <cstdint> // uint8_t
#include <functional> // function
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/json_sax.hpp>

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{
////////////
// parser //
////////////

enum class parse_event_t : std::uint8_t
{
    /// the parser read `{` and started to process a JSON object
    object_start,
    /// the parser read `}` and finished processing a JSON object
    object_end,
    /// the parser read `[` and started to process a JSON array
    array_start,
    /// the parser read `]` and finished processing a JSON array
    array_end,
    /// the parser read a key of a value in an object
    key,
    /// the parser finished reading a JSON value
    value
};

template<typename BasicJsonType>
using parser_callback_t =
    std::function<bool(int /*depth*/, parse_event_t /*event*/, BasicJsonType& /*parsed*/)>;

/*!
@brief syntax analysis

This class implements a recursive descent parser.
*/
template<typename BasicJsonType, typename InputAdapterType>
class parser
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using lexer_t = lexer<BasicJsonType, InputAdapterType>;
    using token_type = typename lexer_t::token_type;

  public:
    /// a parser reading from an input adapter
    explicit parser(InputAdapterType&& adapter,
                    parser_callback_t<BasicJsonType> cb = nullptr,
                    const bool allow_exceptions_ = true,
                    const bool skip_comments = false)
        : callback(std::move(cb))
        , m_lexer(std::move(adapter), skip_comments)
        , allow_exceptions(allow_exceptions_)
    {
        // read first token
        get_token();
    }

    /*!
    @brief public parser interface

    @param[in] strict      whether to expect the last token to be EOF
    @param[in,out] result  parsed JSON value

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    void parse(const bool strict, BasicJsonType& result)
    {
        if (callback)
        {
            json_sax_dom_callback_parser<BasicJsonType, InputAdapterType> sdp(result, callback, allow_exceptions, &m_lexer);
            sax_parse_internal(&sdp);

            // in strict mode, input must be completely read
            if (strict && (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value"), nullptr));
            }

            // in case of an error, return a discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }

            // set top-level value to null if it was discarded by the callback
            // function
            if (result.is_discarded())
            {
                result = nullptr;
            }
        }
        else
        {
            json_sax_dom_parser<BasicJsonType, InputAdapterType> sdp(result, allow_exceptions, &m_lexer);
            sax_parse_internal(&sdp);

            // in strict mode, input must be completely read
            if (strict && (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
            }

            // in case of an error, return a discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }
        }

        result.assert_invariant();
    }

    /*!
    @brief public accept interface

    @param[in] strict  whether to expect the last token to be EOF
    @return whether the input is a proper JSON text
    */
    bool accept(const bool strict = true)
    {
        json_sax_acceptor<BasicJsonType> sax_acceptor;
        return sax_parse(&sax_acceptor, strict);
    }

    template<typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse(SAX* sax, const bool strict = true)
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
        const bool result = sax_parse_internal(sax);

        // strict mode: next byte must be EOF
        if (result && strict && (get_token() != token_type::end_of_input))
        {
            return sax->parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
        }

        return result;
    }

  private:
    template<typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse_internal(SAX* sax)
    {
        // stack to remember the hierarchy of structured values we are parsing
        // true = array; false = object
        std::vector<bool> states;
        // value to avoid a goto (see comment where set to true)
        bool skip_to_state_evaluation = false;

        while (true)
        {
            if (!skip_to_state_evaluation)
            {
                // invariant: get_token() was called before each iteration
                switch (last_token)
                {
                    case token_type::begin_object:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(detail::unknown_size())))
                        {
                            return false;
                        }

                        // closing } -> we are done
                        if (get_token() == token_type::end_object)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
                            {
                                return false;
                            }
                            break;
                        }

                        // parse key
                        if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
                        }
                        if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
                        {
                            return false;
                        }

                        // parse separator (:)
                        if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
                        }

                        // remember we are now inside an object
                        states.push_back(false);

                        // parse values
                        get_token();
                        continue;
                    }

                    case token_type::begin_array:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(detail::unknown_size())))
                        {
                            return false;
                        }

                        // closing ] -> we are done
                        if (get_token() == token_type::end_array)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
                            {
                                return false;
                            }
                            break;
                        }

                        // remember we are now inside an array
                        states.push_back(true);

                        // parse values (no need to call get_token)
                        continue;
                    }

                    case token_type::value_float:
                    {
                        const auto res = m_lexer.get_number_float();

                        if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    out_of_range::create(406, concat("number overflow parsing '", m_lexer.get_token_string(), '\''), nullptr));
                        }

                        if (JSON_HEDLEY_UNLIKELY(!sax->number_float(res, m_lexer.get_string())))
                        {
                            return false;
                        }

                        break;
                    }

                    case token_type::literal_false:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(false)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_null:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->null()))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_true:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(true)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_integer:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_integer(m_lexer.get_number_integer())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_string:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->string(m_lexer.get_string())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_unsigned:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(m_lexer.get_number_unsigned())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::parse_error:
                    {
                        // using "uninitialized" to avoid an "expected" message
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, "value"), nullptr));
                    }
                    case token_type::end_of_input:
                    {
                        if (JSON_HEDLEY_UNLIKELY(m_lexer.get_position().chars_read_total == 1))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            "attempting to parse an empty input; check that your input string or stream contains the expected JSON", nullptr));
                        }

                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
                    }
                    case token_type::uninitialized:
                    case token_type::end_array:
                    case token_type::end_object:
                    case token_type::name_separator:
                    case token_type::value_separator:
                    case token_type::literal_or_value:
                    default: // the last token was unexpected
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
                    }
                }
            }
            else
            {
                skip_to_state_evaluation = false;
            }

            // we reached this line after we successfully parsed a value
            if (states.empty())
            {
                // empty stack: we reached the end of the hierarchy: done
                return true;
            }

            if (states.back())  // array
            {
                // comma -> next value
                if (get_token() == token_type::value_separator)
                {
                    // parse a new value
                    get_token();
                    continue;
                }

                // closing ]
                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
                    {
                        return false;
                    }

                    // We are done with this array. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    JSON_ASSERT(!states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, "array"), nullptr));
            }

            // states.back() is false -> object

            // comma -> next value
            if (get_token() == token_type::value_separator)
            {
                // parse key
                if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
                {
                    return sax->parse_error(m_lexer.get_position(),
                                            m_lexer.get_token_string(),
                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
                }

                if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
                {
                    return false;
                }

                // parse separator (:)
                if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                {
                    return sax->parse_error(m_lexer.get_position(),
                                            m_lexer.get_token_string(),
                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
                }

                // parse values
                get_token();
                continue;
            }

            // closing }
            if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
            {
                if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
                {
                    return false;
                }

                // We are done with this object. Before we can parse a
                // new value, we need to evaluate the new state first.
                // By setting skip_to_state_evaluation to false, we
                // are effectively jumping to the beginning of this if.
                JSON_ASSERT(!states.empty());
                states.pop_back();
                skip_to_state_evaluation = true;
                continue;
            }

            return sax->parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, "object"), nullptr));
        }
    }

    /// get next token from lexer
    token_type get_token()
    {
        return last_token = m_lexer.scan();
    }

    std::string exception_message(const token_type expected, const std::string& context)
    {
        std::string error_msg = "syntax error ";

        if (!context.empty())
        {
            error_msg += concat("while parsing ", context, ' ');
        }

        error_msg += "- ";

        if (last_token == token_type::parse_error)
        {
            error_msg += concat(m_lexer.get_error_message(), "; last read: '",
                                m_lexer.get_token_string(), '\'');
        }
        else
        {
            error_msg += concat("unexpected ", lexer_t::token_type_name(last_token));
        }

        if (expected != token_type::uninitialized)
        {
            error_msg += concat("; expected ", lexer_t::token_type_name(expected));
        }

        return error_msg;
    }

  private:
    /// callback function
    const parser_callback_t<BasicJsonType> callback = nullptr;
    /// the type of the last read token
    token_type last_token = token_type::uninitialized;
    /// the lexer
    lexer_t m_lexer;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/iterators/internal_iterator.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // ptrdiff_t
#include <limits>  // numeric_limits

// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*
@brief an iterator for primitive JSON types

This class models an iterator for primitive JSON types (boolean, number,
string). Its only purpose is to allow the iterator/const_iterator classes
to "iterate" over primitive values. Internally, the iterator is modeled by
a `difference_type` variable. Value begin_value (`0`) models the begin and
end_value (`1`) models past the end.
*/
class primitive_iterator_t
{
  private:
    using difference_type = std::ptrdiff_t;
    static constexpr difference_type begin_value = 0;
    static constexpr difference_type end_value = begin_value + 1;

  JSON_PRIVATE_UNLESS_TESTED:
    /// iterator as signed integer type
    difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();

  public:
    constexpr difference_type get_value() const noexcept
    {
        return m_it;
    }

    /// set iterator to a defined beginning
    void set_begin() noexcept
    {
        m_it = begin_value;
    }

    /// set iterator to a defined past the end
    void set_end() noexcept
    {
        m_it = end_value;
    }

    /// return whether the iterator can be dereferenced
    constexpr bool is_begin() const noexcept
    {
        return m_it == begin_value;
    }

    /// return whether the iterator is at end
    constexpr bool is_end() const noexcept
    {
        return m_it == end_value;
    }

    friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it == rhs.m_it;
    }

    friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it < rhs.m_it;
    }

    primitive_iterator_t operator+(difference_type n) noexcept
    {
        auto result = *this;
        result += n;
        return result;
    }

    friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it - rhs.m_it;
    }

    primitive_iterator_t& operator++() noexcept
    {
        ++m_it;
        return *this;
    }

    primitive_iterator_t operator++(int)& noexcept // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        ++m_it;
        return result;
    }

    primitive_iterator_t& operator--() noexcept
    {
        --m_it;
        return *this;
    }

    primitive_iterator_t operator--(int)& noexcept // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        --m_it;
        return result;
    }

    primitive_iterator_t& operator+=(difference_type n) noexcept
    {
        m_it += n;
        return *this;
    }

    primitive_iterator_t& operator-=(difference_type n) noexcept
    {
        m_it -= n;
        return *this;
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief an iterator value

@note This structure could easily be a union, but MSVC currently does not allow
unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
*/
template<typename BasicJsonType> struct internal_iterator
{
    /// iterator for JSON objects
    typename BasicJsonType::object_t::iterator object_iterator {};
    /// iterator for JSON arrays
    typename BasicJsonType::array_t::iterator array_iterator {};
    /// generic iterator for all other types
    primitive_iterator_t primitive_iterator {};
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/iterators/iter_impl.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
#include <type_traits> // conditional, is_const, remove_const

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/iterators/internal_iterator.hpp>

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// forward declare to be able to friend it later on
template<typename IteratorType> class iteration_proxy;
template<typename IteratorType> class iteration_proxy_value;

/*!
@brief a template for a bidirectional iterator for the @ref basic_json class
This class implements a both iterators (iterator and const_iterator) for the
@ref basic_json class.
@note An iterator is called *initialized* when a pointer to a JSON value has
      been set (e.g., by a constructor or a copy assignment). If the iterator is
      default-constructed, it is *uninitialized* and most methods are undefined.
      **The library uses assertions to detect calls on uninitialized iterators.**
@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
       iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
*/
template<typename BasicJsonType>
class iter_impl // NOLINT(cppcoreguidelines-special-member-functions,hicpp-special-member-functions)
{
    /// the iterator with BasicJsonType of different const-ness
    using other_iter_impl = iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
    /// allow basic_json to access private members
    friend other_iter_impl;
    friend BasicJsonType;
    friend iteration_proxy<iter_impl>;
    friend iteration_proxy_value<iter_impl>;

    using object_t = typename BasicJsonType::object_t;
    using array_t = typename BasicJsonType::array_t;
    // make sure BasicJsonType is basic_json or const basic_json
    static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
                  "iter_impl only accepts (const) basic_json");
    // superficial check for the LegacyBidirectionalIterator named requirement
    static_assert(std::is_base_of<std::bidirectional_iterator_tag, std::bidirectional_iterator_tag>::value
                  &&  std::is_base_of<std::bidirectional_iterator_tag, typename std::iterator_traits<typename array_t::iterator>::iterator_category>::value,
                  "basic_json iterator assumes array and object type iterators satisfy the LegacyBidirectionalIterator named requirement.");

  public:
    /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
    /// The C++ Standard has never required user-defined iterators to derive from std::iterator.
    /// A user-defined iterator should provide publicly accessible typedefs named
    /// iterator_category, value_type, difference_type, pointer, and reference.
    /// Note that value_type is required to be non-const, even for constant iterators.
    using iterator_category = std::bidirectional_iterator_tag;

    /// the type of the values when the iterator is dereferenced
    using value_type = typename BasicJsonType::value_type;
    /// a type to represent differences between iterators
    using difference_type = typename BasicJsonType::difference_type;
    /// defines a pointer to the type iterated over (value_type)
    using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
          typename BasicJsonType::const_pointer,
          typename BasicJsonType::pointer>::type;
    /// defines a reference to the type iterated over (value_type)
    using reference =
        typename std::conditional<std::is_const<BasicJsonType>::value,
        typename BasicJsonType::const_reference,
        typename BasicJsonType::reference>::type;

    iter_impl() = default;
    ~iter_impl() = default;
    iter_impl(iter_impl&&) noexcept = default;
    iter_impl& operator=(iter_impl&&) noexcept = default;

    /*!
    @brief constructor for a given JSON instance
    @param[in] object  pointer to a JSON object for this iterator
    @pre object != nullptr
    @post The iterator is initialized; i.e. `m_object != nullptr`.
    */
    explicit iter_impl(pointer object) noexcept : m_object(object)
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = typename object_t::iterator();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = typename array_t::iterator();
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator = primitive_iterator_t();
                break;
            }
        }
    }

    /*!
    @note The conventional copy constructor and copy assignment are implicitly
          defined. Combined with the following converting constructor and
          assignment, they support: (1) copy from iterator to iterator, (2)
          copy from const iterator to const iterator, and (3) conversion from
          iterator to const iterator. However conversion from const iterator
          to iterator is not defined.
    */

    /*!
    @brief const copy constructor
    @param[in] other const iterator to copy from
    @note This copy constructor had to be defined explicitly to circumvent a bug
          occurring on msvc v19.0 compiler (VS 2015) debug build. For more
          information refer to: https://github.com/nlohmann/json/issues/1608
    */
    iter_impl(const iter_impl<const BasicJsonType>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<const BasicJsonType>& other) noexcept
    {
        if (&other != this)
        {
            m_object = other.m_object;
            m_it = other.m_it;
        }
        return *this;
    }

    /*!
    @brief converting constructor
    @param[in] other  non-const iterator to copy from
    @note It is not checked whether @a other is initialized.
    */
    iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other  non-const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept // NOLINT(cert-oop54-cpp)
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

  JSON_PRIVATE_UNLESS_TESTED:
    /*!
    @brief set the iterator to the first value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_begin() noexcept
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_data.m_value.object->begin();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_data.m_value.array->begin();
                break;
            }

            case value_t::null:
            {
                // set to end so begin()==end() is true: null is empty
                m_it.primitive_iterator.set_end();
                break;
            }

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator.set_begin();
                break;
            }
        }
    }

    /*!
    @brief set the iterator past the last value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_end() noexcept
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_data.m_value.object->end();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_data.m_value.array->end();
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator.set_end();
                break;
            }
        }
    }

  public:
    /*!
    @brief return a reference to the value pointed to by the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator*() const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                JSON_ASSERT(m_it.object_iterator != m_object->m_data.m_value.object->end());
                return m_it.object_iterator->second;
            }

            case value_t::array:
            {
                JSON_ASSERT(m_it.array_iterator != m_object->m_data.m_value.array->end());
                return *m_it.array_iterator;
            }

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
            }
        }
    }

    /*!
    @brief dereference the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    pointer operator->() const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                JSON_ASSERT(m_it.object_iterator != m_object->m_data.m_value.object->end());
                return &(m_it.object_iterator->second);
            }

            case value_t::array:
            {
                JSON_ASSERT(m_it.array_iterator != m_object->m_data.m_value.array->end());
                return &*m_it.array_iterator;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
            }
        }
    }

    /*!
    @brief post-increment (it++)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator++(int)& // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        ++(*this);
        return result;
    }

    /*!
    @brief pre-increment (++it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator++()
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, 1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, 1);
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                ++m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief post-decrement (it--)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator--(int)& // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        --(*this);
        return result;
    }

    /*!
    @brief pre-decrement (--it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator--()
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, -1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, -1);
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                --m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief comparison: equal
    @pre (1) Both iterators are initialized to point to the same object, or (2) both iterators are value-initialized.
    */
    template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
    bool operator==(const IterImpl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", m_object));
        }

        // value-initialized forward iterators can be compared, and must compare equal to other value-initialized iterators of the same type #4493
        if (m_object == nullptr)
        {
            return true;
        }

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                return (m_it.object_iterator == other.m_it.object_iterator);

            case value_t::array:
                return (m_it.array_iterator == other.m_it.array_iterator);

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return (m_it.primitive_iterator == other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief comparison: not equal
    @pre (1) Both iterators are initialized to point to the same object, or (2) both iterators are value-initialized.
    */
    template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
    bool operator!=(const IterImpl& other) const
    {
        return !operator==(other);
    }

    /*!
    @brief comparison: smaller
    @pre (1) Both iterators are initialized to point to the same object, or (2) both iterators are value-initialized.
    */
    bool operator<(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", m_object));
        }

        // value-initialized forward iterators can be compared, and must compare equal to other value-initialized iterators of the same type #4493
        if (m_object == nullptr)
        {
            // the iterators are both value-initialized and are to be considered equal, but this function checks for smaller, so we return false
            return false;
        }

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators", m_object));

            case value_t::array:
                return (m_it.array_iterator < other.m_it.array_iterator);

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return (m_it.primitive_iterator < other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief comparison: less than or equal
    @pre (1) Both iterators are initialized to point to the same object, or (2) both iterators are value-initialized.
    */
    bool operator<=(const iter_impl& other) const
    {
        return !other.operator < (*this);
    }

    /*!
    @brief comparison: greater than
    @pre (1) Both iterators are initialized to point to the same object, or (2) both iterators are value-initialized.
    */
    bool operator>(const iter_impl& other) const
    {
        return !operator<=(other);
    }

    /*!
    @brief comparison: greater than or equal
    @pre (1) The iterator is initialized; i.e. `m_object != nullptr`, or (2) both iterators are value-initialized.
    */
    bool operator>=(const iter_impl& other) const
    {
        return !operator<(other);
    }

    /*!
    @brief add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator+=(difference_type i)
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", m_object));

            case value_t::array:
            {
                std::advance(m_it.array_iterator, i);
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator += i;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator-=(difference_type i)
    {
        return operator+=(-i);
    }

    /*!
    @brief add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator+(difference_type i) const
    {
        auto result = *this;
        result += i;
        return result;
    }

    /*!
    @brief addition of distance and iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    friend iter_impl operator+(difference_type i, const iter_impl& it)
    {
        auto result = it;
        result += i;
        return result;
    }

    /*!
    @brief subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator-(difference_type i) const
    {
        auto result = *this;
        result -= i;
        return result;
    }

    /*!
    @brief return difference
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    difference_type operator-(const iter_impl& other) const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", m_object));

            case value_t::array:
                return m_it.array_iterator - other.m_it.array_iterator;

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return m_it.primitive_iterator - other.m_it.primitive_iterator;
        }
    }

    /*!
    @brief access to successor
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator[](difference_type n) const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators", m_object));

            case value_t::array:
                return *std::next(m_it.array_iterator, n);

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
            }
        }
    }

    /*!
    @brief return the key of an object iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    const typename object_t::key_type& key() const
    {
        JSON_ASSERT(m_object != nullptr);

        if (JSON_HEDLEY_LIKELY(m_object->is_object()))
        {
            return m_it.object_iterator->first;
        }

        JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators", m_object));
    }

    /*!
    @brief return the value of an iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference value() const
    {
        return operator*();
    }

  JSON_PRIVATE_UNLESS_TESTED:
    /// associated JSON instance
    pointer m_object = nullptr;
    /// the actual iterator of the associated instance
    internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>

// #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // ptrdiff_t
#include <iterator> // reverse_iterator
#include <utility> // declval

// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

//////////////////////
// reverse_iterator //
//////////////////////

/*!
@brief a template for a reverse iterator class

@tparam Base the base iterator type to reverse. Valid types are @ref
iterator (to create @ref reverse_iterator) and @ref const_iterator (to
create @ref const_reverse_iterator).

@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
  It is possible to write to the pointed-to element (only if @a Base is
  @ref iterator).

@since version 1.0.0
*/
template<typename Base>
class json_reverse_iterator : public std::reverse_iterator<Base>
{
  public:
    using difference_type = std::ptrdiff_t;
    /// shortcut to the reverse iterator adapter
    using base_iterator = std::reverse_iterator<Base>;
    /// the reference type for the pointed-to element
    using reference = typename Base::reference;

    /// create reverse iterator from iterator
    explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
        : base_iterator(it) {}

    /// create reverse iterator from base class
    explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}

    /// post-increment (it++)
    json_reverse_iterator operator++(int)& // NOLINT(cert-dcl21-cpp)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
    }

    /// pre-increment (++it)
    json_reverse_iterator& operator++()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator++());
    }

    /// post-decrement (it--)
    json_reverse_iterator operator--(int)& // NOLINT(cert-dcl21-cpp)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
    }

    /// pre-decrement (--it)
    json_reverse_iterator& operator--()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator--());
    }

    /// add to iterator
    json_reverse_iterator& operator+=(difference_type i)
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
    }

    /// add to iterator
    json_reverse_iterator operator+(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
    }

    /// subtract from iterator
    json_reverse_iterator operator-(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
    }

    /// return difference
    difference_type operator-(const json_reverse_iterator& other) const
    {
        return base_iterator(*this) - base_iterator(other);
    }

    /// access to successor
    reference operator[](difference_type n) const
    {
        return *(this->operator+(n));
    }

    /// return the key of an object iterator
    auto key() const -> decltype(std::declval<Base>().key())
    {
        auto it = --this->base();
        return it.key();
    }

    /// return the value of an iterator
    reference value() const
    {
        auto it = --this->base();
        return it.operator * ();
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/json_custom_base_class.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <type_traits> // conditional, is_same

// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief Default base class of the @ref basic_json class.

So that the correct implementations of the copy / move ctors / assign operators
of @ref basic_json do not require complex case distinctions
(no base class / custom base class used as customization point),
@ref basic_json always has a base class.
By default, this class is used because it is empty and thus has no effect
on the behavior of @ref basic_json.
*/
struct json_default_base {};

template<class T>
using json_base_class = typename std::conditional <
                        std::is_same<T, void>::value,
                        json_default_base,
                        T
                        >::type;

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/json_pointer.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // all_of
#include <cctype> // isdigit
#include <cerrno> // errno, ERANGE
#include <cstdlib> // strtoull
#ifndef JSON_NO_IO
    #include <iosfwd> // ostream
#endif  // JSON_NO_IO
#include <limits> // max
#include <numeric> // accumulate
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/string_escape.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

/// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document
/// @sa https://json.nlohmann.me/api/json_pointer/
template<typename RefStringType>
class json_pointer
{
    // allow basic_json to access private members
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    friend class basic_json;

    template<typename>
    friend class json_pointer;

    template<typename T>
    struct string_t_helper
    {
        using type = T;
    };

    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    struct string_t_helper<NLOHMANN_BASIC_JSON_TPL>
    {
        using type = StringType;
    };

  public:
    // for backwards compatibility accept BasicJsonType
    using string_t = typename string_t_helper<RefStringType>::type;

    /// @brief create JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/json_pointer/
    explicit json_pointer(const string_t& s = "")
        : reference_tokens(split(s))
    {}

    /// @brief return a string representation of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/to_string/
    string_t to_string() const
    {
        return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
                               string_t{},
                               [](const string_t& a, const string_t& b)
        {
            return detail::concat(a, '/', detail::escape(b));
        });
    }

    /// @brief return a string representation of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_string/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, to_string())
    operator string_t() const
    {
        return to_string();
    }

#ifndef JSON_NO_IO
    /// @brief write string representation of the JSON pointer to stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
    friend std::ostream& operator<<(std::ostream& o, const json_pointer& ptr)
    {
        o << ptr.to_string();
        return o;
    }
#endif

    /// @brief append another JSON pointer at the end of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
    json_pointer& operator/=(const json_pointer& ptr)
    {
        reference_tokens.insert(reference_tokens.end(),
                                ptr.reference_tokens.begin(),
                                ptr.reference_tokens.end());
        return *this;
    }

    /// @brief append an unescaped reference token at the end of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
    json_pointer& operator/=(string_t token)
    {
        push_back(std::move(token));
        return *this;
    }

    /// @brief append an array index at the end of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
    json_pointer& operator/=(std::size_t array_idx)
    {
        return *this /= std::to_string(array_idx);
    }

    /// @brief create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
    friend json_pointer operator/(const json_pointer& lhs,
                                  const json_pointer& rhs)
    {
        return json_pointer(lhs) /= rhs;
    }

    /// @brief create a new JSON pointer by appending the unescaped token at the end of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
    friend json_pointer operator/(const json_pointer& lhs, string_t token) // NOLINT(performance-unnecessary-value-param)
    {
        return json_pointer(lhs) /= std::move(token);
    }

    /// @brief create a new JSON pointer by appending the array-index-token at the end of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
    friend json_pointer operator/(const json_pointer& lhs, std::size_t array_idx)
    {
        return json_pointer(lhs) /= array_idx;
    }

    /// @brief returns the parent of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/parent_pointer/
    json_pointer parent_pointer() const
    {
        if (empty())
        {
            return *this;
        }

        json_pointer res = *this;
        res.pop_back();
        return res;
    }

    /// @brief remove last reference token
    /// @sa https://json.nlohmann.me/api/json_pointer/pop_back/
    void pop_back()
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
        }

        reference_tokens.pop_back();
    }

    /// @brief return last reference token
    /// @sa https://json.nlohmann.me/api/json_pointer/back/
    const string_t& back() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
        }

        return reference_tokens.back();
    }

    /// @brief append an unescaped token at the end of the reference pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/push_back/
    void push_back(const string_t& token)
    {
        reference_tokens.push_back(token);
    }

    /// @brief append an unescaped token at the end of the reference pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/push_back/
    void push_back(string_t&& token)
    {
        reference_tokens.push_back(std::move(token));
    }

    /// @brief return whether pointer points to the root document
    /// @sa https://json.nlohmann.me/api/json_pointer/empty/
    bool empty() const noexcept
    {
        return reference_tokens.empty();
    }

  private:
    /*!
    @param[in] s  reference token to be converted into an array index

    @return integer representation of @a s

    @throw parse_error.106  if an array index begins with '0'
    @throw parse_error.109  if an array index begins not with a digit
    @throw out_of_range.404 if string @a s could not be converted to an integer
    @throw out_of_range.410 if an array index exceeds size_type
    */
    template<typename BasicJsonType>
    static typename BasicJsonType::size_type array_index(const string_t& s)
    {
        using size_type = typename BasicJsonType::size_type;

        // error condition (cf. RFC 6901, Sect. 4)
        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))
        {
            JSON_THROW(detail::parse_error::create(106, 0, detail::concat("array index '", s, "' must not begin with '0'"), nullptr));
        }

        // error condition (cf. RFC 6901, Sect. 4)
        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))
        {
            JSON_THROW(detail::parse_error::create(109, 0, detail::concat("array index '", s, "' is not a number"), nullptr));
        }

        const char* p = s.c_str();
        char* p_end = nullptr; // NOLINT(misc-const-correctness)
        errno = 0; // strtoull doesn't reset errno
        const unsigned long long res = std::strtoull(p, &p_end, 10); // NOLINT(runtime/int)
        if (p == p_end // invalid input or empty string
                || errno == ERANGE // out of range
                || JSON_HEDLEY_UNLIKELY(static_cast<std::size_t>(p_end - p) != s.size())) // incomplete read
        {
            JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", s, "'"), nullptr));
        }

        // only triggered on special platforms (like 32bit), see also
        // https://github.com/nlohmann/json/pull/2203
        if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))  // NOLINT(runtime/int)
        {
            JSON_THROW(detail::out_of_range::create(410, detail::concat("array index ", s, " exceeds size_type"), nullptr));   // LCOV_EXCL_LINE
        }

        return static_cast<size_type>(res);
    }

  JSON_PRIVATE_UNLESS_TESTED:
    json_pointer top() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
        }

        json_pointer result = *this;
        result.reference_tokens = {reference_tokens[0]};
        return result;
    }

  private:
    /*!
    @brief create and return a reference to the pointed to value

    @complexity Linear in the number of reference tokens.

    @throw parse_error.109 if array index is not a number
    @throw type_error.313 if value cannot be unflattened
    */
    template<typename BasicJsonType>
    BasicJsonType& get_and_create(BasicJsonType& j) const
    {
        auto* result = &j;

        // in case no reference tokens exist, return a reference to the JSON value
        // j which will be overwritten by a primitive value
        for (const auto& reference_token : reference_tokens)
        {
            switch (result->type())
            {
                case detail::value_t::null:
                {
                    if (reference_token == "0")
                    {
                        // start a new array if the reference token is 0
                        result = &result->operator[](0);
                    }
                    else
                    {
                        // start a new object otherwise
                        result = &result->operator[](reference_token);
                    }
                    break;
                }

                case detail::value_t::object:
                {
                    // create an entry in the object
                    result = &result->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    // create an entry in the array
                    result = &result->operator[](array_index<BasicJsonType>(reference_token));
                    break;
                }

                /*
                The following code is only reached if there exists a reference
                token _and_ the current value is primitive. In this case, we have
                an error situation, because primitive values may only occur as
                a single value; that is, with an empty list of reference tokens.
                */
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::type_error::create(313, "invalid value to unflatten", &j));
            }
        }

        return *result;
    }

    /*!
    @brief return a reference to the pointed to value

    @note This version does not throw if a value is not present, but tries to
          create nested values instead. For instance, calling this function
          with pointer `"/this/that"` on a null value is equivalent to calling
          `operator[]("this").operator[]("that")` on that value, effectively
          changing the null value to an object.

    @param[in] ptr  a JSON value

    @return reference to the JSON value pointed to by the JSON pointer

    @complexity Linear in the length of the JSON pointer.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    BasicJsonType& get_unchecked(BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            // convert null values to arrays or objects before continuing
            if (ptr->is_null())
            {
                // check if the reference token is a number
                const bool nums =
                    std::all_of(reference_token.begin(), reference_token.end(),
                                [](const unsigned char x)
                {
                    return std::isdigit(x);
                });

                // change value to an array for numbers or "-" or to object otherwise
                *ptr = (nums || reference_token == "-")
                       ? detail::value_t::array
                       : detail::value_t::object;
            }

            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (reference_token == "-")
                    {
                        // explicitly treat "-" as index beyond the end
                        ptr = &ptr->operator[](ptr->m_data.m_value.array->size());
                    }
                    else
                    {
                        // convert array index to number; unchecked access
                        ptr = &ptr->operator[](array_index<BasicJsonType>(reference_token));
                    }
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    BasicJsonType& get_checked(BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402, detail::concat(
                                "array index '-' (", std::to_string(ptr->m_data.m_value.array->size()),
                                ") is out of range"), ptr));
                    }

                    // note: at performs range check
                    ptr = &ptr->at(array_index<BasicJsonType>(reference_token));
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @brief return a const reference to the pointed to value

    @param[in] ptr  a JSON value

    @return const reference to the JSON value pointed to by the JSON
    pointer

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" cannot be used for const access
                        JSON_THROW(detail::out_of_range::create(402, detail::concat("array index '-' (", std::to_string(ptr->m_data.m_value.array->size()), ") is out of range"), ptr));
                    }

                    // use unchecked array access
                    ptr = &ptr->operator[](array_index<BasicJsonType>(reference_token));
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    const BasicJsonType& get_checked(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402, detail::concat(
                                "array index '-' (", std::to_string(ptr->m_data.m_value.array->size()),
                                ") is out of range"), ptr));
                    }

                    // note: at performs range check
                    ptr = &ptr->at(array_index<BasicJsonType>(reference_token));
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    */
    template<typename BasicJsonType>
    bool contains(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    if (!ptr->contains(reference_token))
                    {
                        // we did not find the key in the object
                        return false;
                    }

                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 && !("0" <= reference_token && reference_token <= "9")))
                    {
                        // invalid char
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1))
                    {
                        if (JSON_HEDLEY_UNLIKELY(!('1' <= reference_token[0] && reference_token[0] <= '9')))
                        {
                            // the first char should be between '1' and '9'
                            return false;
                        }
                        for (std::size_t i = 1; i < reference_token.size(); i++)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!('0' <= reference_token[i] && reference_token[i] <= '9')))
                            {
                                // other char should be between '0' and '9'
                                return false;
                            }
                        }
                    }

                    const auto idx = array_index<BasicJsonType>(reference_token);
                    if (idx >= ptr->size())
                    {
                        // index out of range
                        return false;
                    }

                    ptr = &ptr->operator[](idx);
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                {
                    // we do not expect primitive values if there is still a
                    // reference token to process
                    return false;
                }
            }
        }

        // no reference token left means we found a primitive value
        return true;
    }

    /*!
    @brief split the string input to reference tokens

    @note This function is only called by the json_pointer constructor.
          All exceptions below are documented there.

    @throw parse_error.107  if the pointer is not empty or begins with '/'
    @throw parse_error.108  if character '~' is not followed by '0' or '1'
    */
    static std::vector<string_t> split(const string_t& reference_string)
    {
        std::vector<string_t> result;

        // special case: empty reference string -> no reference tokens
        if (reference_string.empty())
        {
            return result;
        }

        // check if a nonempty reference string begins with slash
        if (JSON_HEDLEY_UNLIKELY(reference_string[0] != '/'))
        {
            JSON_THROW(detail::parse_error::create(107, 1, detail::concat("JSON pointer must be empty or begin with '/' - was: '", reference_string, "'"), nullptr));
        }

        // extract the reference tokens:
        // - slash: position of the last read slash (or end of string)
        // - start: position after the previous slash
        for (
            // search for the first slash after the first character
            std::size_t slash = reference_string.find_first_of('/', 1),
            // set the beginning of the first reference token
            start = 1;
            // we can stop if start == 0 (if slash == string_t::npos)
            start != 0;
            // set the beginning of the next reference token
            // (will eventually be 0 if slash == string_t::npos)
            start = (slash == string_t::npos) ? 0 : slash + 1,
            // find next slash
            slash = reference_string.find_first_of('/', start))
        {
            // use the text between the beginning of the reference token
            // (start) and the last slash (slash).
            auto reference_token = reference_string.substr(start, slash - start);

            // check reference tokens are properly escaped
            for (std::size_t pos = reference_token.find_first_of('~');
                    pos != string_t::npos;
                    pos = reference_token.find_first_of('~', pos + 1))
            {
                JSON_ASSERT(reference_token[pos] == '~');

                // ~ must be followed by 0 or 1
                if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
                                         (reference_token[pos + 1] != '0' &&
                                          reference_token[pos + 1] != '1')))
                {
                    JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'", nullptr));
                }
            }

            // finally, store the reference token
            detail::unescape(reference_token);
            result.push_back(reference_token);
        }

        return result;
    }

  private:
    /*!
    @param[in] reference_string  the reference string to the current value
    @param[in] value             the value to consider
    @param[in,out] result        the result object to insert values to

    @note Empty objects or arrays are flattened to `null`.
    */
    template<typename BasicJsonType>
    static void flatten(const string_t& reference_string,
                        const BasicJsonType& value,
                        BasicJsonType& result)
    {
        switch (value.type())
        {
            case detail::value_t::array:
            {
                if (value.m_data.m_value.array->empty())
                {
                    // flatten empty array as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate array and use index as a reference string
                    for (std::size_t i = 0; i < value.m_data.m_value.array->size(); ++i)
                    {
                        flatten(detail::concat<string_t>(reference_string, '/', std::to_string(i)),
                                value.m_data.m_value.array->operator[](i), result);
                    }
                }
                break;
            }

            case detail::value_t::object:
            {
                if (value.m_data.m_value.object->empty())
                {
                    // flatten empty object as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate object and use keys as reference string
                    for (const auto& element : *value.m_data.m_value.object)
                    {
                        flatten(detail::concat<string_t>(reference_string, '/', detail::escape(element.first)), element.second, result);
                    }
                }
                break;
            }

            case detail::value_t::null:
            case detail::value_t::string:
            case detail::value_t::boolean:
            case detail::value_t::number_integer:
            case detail::value_t::number_unsigned:
            case detail::value_t::number_float:
            case detail::value_t::binary:
            case detail::value_t::discarded:
            default:
            {
                // add a primitive value with its reference string
                result[reference_string] = value;
                break;
            }
        }
    }

    /*!
    @param[in] value  flattened JSON

    @return unflattened JSON

    @throw parse_error.109 if array index is not a number
    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive
    @throw type_error.313  if value cannot be unflattened
    */
    template<typename BasicJsonType>
    static BasicJsonType
    unflatten(const BasicJsonType& value)
    {
        if (JSON_HEDLEY_UNLIKELY(!value.is_object()))
        {
            JSON_THROW(detail::type_error::create(314, "only objects can be unflattened", &value));
        }

        BasicJsonType result;

        // iterate the JSON object values
        for (const auto& element : *value.m_data.m_value.object)
        {
            if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))
            {
                JSON_THROW(detail::type_error::create(315, "values in object must be primitive", &element.second));
            }

            // Assign the value to the reference pointed to by JSON pointer. Note
            // that if the JSON pointer is "" (i.e., points to the whole value),
            // function get_and_create returns a reference to the result itself.
            // An assignment will then create a primitive value.
            json_pointer(element.first).get_and_create(result) = element.second;
        }

        return result;
    }

    // can't use the conversion operator because of ambiguity
    json_pointer<string_t> convert() const&
    {
        json_pointer<string_t> result;
        result.reference_tokens = reference_tokens;
        return result;
    }

    json_pointer<string_t> convert()&&
    {
        json_pointer<string_t> result;
        result.reference_tokens = std::move(reference_tokens);
        return result;
    }

  public:
#if JSON_HAS_THREE_WAY_COMPARISON
    /// @brief compares two JSON pointers for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeRhs>
    bool operator==(const json_pointer<RefStringTypeRhs>& rhs) const noexcept
    {
        return reference_tokens == rhs.reference_tokens;
    }

    /// @brief compares JSON pointer and string for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer))
    bool operator==(const string_t& rhs) const
    {
        return *this == json_pointer(rhs);
    }

    /// @brief 3-way compares two JSON pointers
    template<typename RefStringTypeRhs>
    std::strong_ordering operator<=>(const json_pointer<RefStringTypeRhs>& rhs) const noexcept // *NOPAD*
    {
        return  reference_tokens <=> rhs.reference_tokens; // *NOPAD*
    }
#else
    /// @brief compares two JSON pointers for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs) noexcept;

    /// @brief compares JSON pointer and string for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeLhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                           const StringType& rhs);

    /// @brief compares string and JSON pointer for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeRhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator==(const StringType& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs);

    /// @brief compares two JSON pointers for inequality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs) noexcept;

    /// @brief compares JSON pointer and string for inequality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
    template<typename RefStringTypeLhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                           const StringType& rhs);

    /// @brief compares string and JSON pointer for inequality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
    template<typename RefStringTypeRhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator!=(const StringType& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs);

    /// @brief compares two JSON pointer for less-than
    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator<(const json_pointer<RefStringTypeLhs>& lhs,
                          const json_pointer<RefStringTypeRhs>& rhs) noexcept;
#endif

  private:
    /// the reference tokens
    std::vector<string_t> reference_tokens;
};

#if !JSON_HAS_THREE_WAY_COMPARISON
// functions cannot be defined inside the class due to ODR violations
template<typename RefStringTypeLhs, typename RefStringTypeRhs>
inline bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs) noexcept
{
    return lhs.reference_tokens == rhs.reference_tokens;
}

template<typename RefStringTypeLhs,
         typename StringType = typename json_pointer<RefStringTypeLhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
inline bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                       const StringType& rhs)
{
    return lhs == json_pointer<RefStringTypeLhs>(rhs);
}

template<typename RefStringTypeRhs,
         typename StringType = typename json_pointer<RefStringTypeRhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
inline bool operator==(const StringType& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs)
{
    return json_pointer<RefStringTypeRhs>(lhs) == rhs;
}

template<typename RefStringTypeLhs, typename RefStringTypeRhs>
inline bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs) noexcept
{
    return !(lhs == rhs);
}

template<typename RefStringTypeLhs,
         typename StringType = typename json_pointer<RefStringTypeLhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
inline bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                       const StringType& rhs)
{
    return !(lhs == rhs);
}

template<typename RefStringTypeRhs,
         typename StringType = typename json_pointer<RefStringTypeRhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
inline bool operator!=(const StringType& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs)
{
    return !(lhs == rhs);
}

template<typename RefStringTypeLhs, typename RefStringTypeRhs>
inline bool operator<(const json_pointer<RefStringTypeLhs>& lhs,
                      const json_pointer<RefStringTypeRhs>& rhs) noexcept
{
    return lhs.reference_tokens < rhs.reference_tokens;
}
#endif

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/json_ref.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <initializer_list>
#include <utility>

// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename BasicJsonType>
class json_ref
{
  public:
    using value_type = BasicJsonType;

    json_ref(value_type&& value)
        : owned_value(std::move(value))
    {}

    json_ref(const value_type& value)
        : value_ref(&value)
    {}

    json_ref(std::initializer_list<json_ref> init)
        : owned_value(init)
    {}

    template <
        class... Args,
        enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >
    json_ref(Args && ... args)
        : owned_value(std::forward<Args>(args)...)
    {}

    // class should be movable only
    json_ref(json_ref&&) noexcept = default;
    json_ref(const json_ref&) = delete;
    json_ref& operator=(const json_ref&) = delete;
    json_ref& operator=(json_ref&&) = delete;
    ~json_ref() = default;

    value_type moved_or_copied() const
    {
        if (value_ref == nullptr)
        {
            return std::move(owned_value);
        }
        return *value_ref;
    }

    value_type const& operator*() const
    {
        return value_ref ? *value_ref : owned_value;
    }

    value_type const* operator->() const
    {
        return &** this;
    }

  private:
    mutable value_type owned_value = nullptr;
    value_type const* value_ref = nullptr;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/string_escape.hpp>

// #include <nlohmann/detail/string_utils.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // reverse
#include <array> // array
#include <map> // map
#include <cmath> // isnan, isinf
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstring> // memcpy
#include <limits> // numeric_limits
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/input/binary_reader.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // copy
#include <cstddef> // size_t
#include <iterator> // back_inserter
#include <memory> // shared_ptr, make_shared
#include <string> // basic_string
#include <vector> // vector

#ifndef JSON_NO_IO
    #include <ios>      // streamsize
    #include <ostream>  // basic_ostream
#endif  // JSON_NO_IO

// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// abstract output adapter interface
template<typename CharType> struct output_adapter_protocol
{
    virtual void write_character(CharType c) = 0;
    virtual void write_characters(const CharType* s, std::size_t length) = 0;
    virtual ~output_adapter_protocol() = default;

    output_adapter_protocol() = default;
    output_adapter_protocol(const output_adapter_protocol&) = default;
    output_adapter_protocol(output_adapter_protocol&&) noexcept = default;
    output_adapter_protocol& operator=(const output_adapter_protocol&) = default;
    output_adapter_protocol& operator=(output_adapter_protocol&&) noexcept = default;
};

/// a type to simplify interfaces
template<typename CharType>
using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;

/// output adapter for byte vectors
template<typename CharType, typename AllocatorType = std::allocator<CharType>>
class output_vector_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_vector_adapter(std::vector<CharType, AllocatorType>& vec) noexcept
        : v(vec)
    {}

    void write_character(CharType c) override
    {
        v.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        v.insert(v.end(), s, s + length);
    }

  private:
    std::vector<CharType, AllocatorType>& v;
};

#ifndef JSON_NO_IO
/// output adapter for output streams
template<typename CharType>
class output_stream_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept
        : stream(s)
    {}

    void write_character(CharType c) override
    {
        stream.put(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        stream.write(s, static_cast<std::streamsize>(length));
    }

  private:
    std::basic_ostream<CharType>& stream;
};
#endif  // JSON_NO_IO

/// output adapter for basic_string
template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_string_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_string_adapter(StringType& s) noexcept
        : str(s)
    {}

    void write_character(CharType c) override
    {
        str.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        str.append(s, length);
    }

  private:
    StringType& str;
};

template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_adapter
{
  public:
    template<typename AllocatorType = std::allocator<CharType>>
    output_adapter(std::vector<CharType, AllocatorType>& vec)
        : oa(std::make_shared<output_vector_adapter<CharType, AllocatorType>>(vec)) {}

#ifndef JSON_NO_IO
    output_adapter(std::basic_ostream<CharType>& s)
        : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}
#endif  // JSON_NO_IO

    output_adapter(StringType& s)
        : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}

    operator output_adapter_t<CharType>()
    {
        return oa;
    }

  private:
    output_adapter_t<CharType> oa = nullptr;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/string_concat.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// how to encode BJData
enum class bjdata_version_t
{
    draft2,
    draft3,
};

///////////////////
// binary writer //
///////////////////

/*!
@brief serialization to CBOR and MessagePack values
*/
template<typename BasicJsonType, typename CharType>
class binary_writer
{
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using number_float_t = typename BasicJsonType::number_float_t;

  public:
    /*!
    @brief create a binary writer

    @param[in] adapter  output adapter to write to
    */
    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(std::move(adapter))
    {
        JSON_ASSERT(oa);
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
            {
                write_bson_object(*j.m_data.m_value.object);
                break;
            }

            case value_t::null:
            case value_t::array:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                JSON_THROW(type_error::create(317, concat("to serialize to BSON, top-level type must be object, but is ", j.type_name()), &j));
            }
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_cbor(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                oa->write_character(to_char_type(0xF6));
                break;
            }

            case value_t::boolean:
            {
                oa->write_character(j.m_data.m_value.boolean
                                    ? to_char_type(0xF5)
                                    : to_char_type(0xF4));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_data.m_value.number_integer >= 0)
                {
                    // CBOR does not differentiate between positive signed
                    // integers and unsigned integers. Therefore, we used the
                    // code from the value_t::number_unsigned case here.
                    if (j.m_data.m_value.number_integer <= 0x17)
                    {
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x18));
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x19));
                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x1A));
                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x1B));
                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
                    }
                }
                else
                {
                    // The conversions below encode the sign in the first
                    // byte, and the value is converted to a positive number.
                    const auto positive_number = -1 - j.m_data.m_value.number_integer;
                    if (j.m_data.m_value.number_integer >= -24)
                    {
                        write_number(static_cast<std::uint8_t>(0x20 + positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x38));
                        write_number(static_cast<std::uint8_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x39));
                        write_number(static_cast<std::uint16_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x3A));
                        write_number(static_cast<std::uint32_t>(positive_number));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x3B));
                        write_number(static_cast<std::uint64_t>(positive_number));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_data.m_value.number_unsigned <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_unsigned));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x18));
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_unsigned));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x19));
                    write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_unsigned));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x1A));
                    write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_unsigned));
                }
                else
                {
                    oa->write_character(to_char_type(0x1B));
                    write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_unsigned));
                }
                break;
            }

            case value_t::number_float:
            {
                if (std::isnan(j.m_data.m_value.number_float))
                {
                    // NaN is 0xf97e00 in CBOR
                    oa->write_character(to_char_type(0xF9));
                    oa->write_character(to_char_type(0x7E));
                    oa->write_character(to_char_type(0x00));
                }
                else if (std::isinf(j.m_data.m_value.number_float))
                {
                    // Infinity is 0xf97c00, -Infinity is 0xf9fc00
                    oa->write_character(to_char_type(0xf9));
                    oa->write_character(j.m_data.m_value.number_float > 0 ? to_char_type(0x7C) : to_char_type(0xFC));
                    oa->write_character(to_char_type(0x00));
                }
                else
                {
                    write_compact_float(j.m_data.m_value.number_float, detail::input_format_t::cbor);
                }
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_data.m_value.string->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x60 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x78));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x79));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x7A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x7B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
                    j.m_data.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_data.m_value.array->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x80 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x98));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x99));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x9A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x9B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.array)
                {
                    write_cbor(el);
                }
                break;
            }

            case value_t::binary:
            {
                if (j.m_data.m_value.binary->has_subtype())
                {
                    if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xd8));
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.binary->subtype()));
                    }
                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xd9));
                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.binary->subtype()));
                    }
                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xda));
                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.binary->subtype()));
                    }
                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint64_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xdb));
                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.binary->subtype()));
                    }
                }

                // step 1: write control byte and the binary array size
                const auto N = j.m_data.m_value.binary->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x40 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x58));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x59));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x5A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x5B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
                    N);

                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_data.m_value.object->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0xA0 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0xB8));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0xB9));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0xBA));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0xBB));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.object)
                {
                    write_cbor(el.first);
                    write_cbor(el.second);
                }
                break;
            }

            case value_t::discarded:
            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_msgpack(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null: // nil
            {
                oa->write_character(to_char_type(0xC0));
                break;
            }

            case value_t::boolean: // true and false
            {
                oa->write_character(j.m_data.m_value.boolean
                                    ? to_char_type(0xC3)
                                    : to_char_type(0xC2));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_data.m_value.number_integer >= 0)
                {
                    // MessagePack does not differentiate between positive
                    // signed integers and unsigned integers. Therefore, we used
                    // the code from the value_t::number_unsigned case here.
                    if (j.m_data.m_value.number_unsigned < 128)
                    {
                        // positive fixnum
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        // uint 8
                        oa->write_character(to_char_type(0xCC));
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        // uint 16
                        oa->write_character(to_char_type(0xCD));
                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        // uint 32
                        oa->write_character(to_char_type(0xCE));
                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                    {
                        // uint 64
                        oa->write_character(to_char_type(0xCF));
                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
                    }
                }
                else
                {
                    if (j.m_data.m_value.number_integer >= -32)
                    {
                        // negative fixnum
                        write_number(static_cast<std::int8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                    {
                        // int 8
                        oa->write_character(to_char_type(0xD0));
                        write_number(static_cast<std::int8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                    {
                        // int 16
                        oa->write_character(to_char_type(0xD1));
                        write_number(static_cast<std::int16_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                    {
                        // int 32
                        oa->write_character(to_char_type(0xD2));
                        write_number(static_cast<std::int32_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                    {
                        // int 64
                        oa->write_character(to_char_type(0xD3));
                        write_number(static_cast<std::int64_t>(j.m_data.m_value.number_integer));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_data.m_value.number_unsigned < 128)
                {
                    // positive fixnum
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // uint 8
                    oa->write_character(to_char_type(0xCC));
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // uint 16
                    oa->write_character(to_char_type(0xCD));
                    write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // uint 32
                    oa->write_character(to_char_type(0xCE));
                    write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    // uint 64
                    oa->write_character(to_char_type(0xCF));
                    write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
                }
                break;
            }

            case value_t::number_float:
            {
                write_compact_float(j.m_data.m_value.number_float, detail::input_format_t::msgpack);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_data.m_value.string->size();
                if (N <= 31)
                {
                    // fixstr
                    write_number(static_cast<std::uint8_t>(0xA0 | N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // str 8
                    oa->write_character(to_char_type(0xD9));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // str 16
                    oa->write_character(to_char_type(0xDA));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // str 32
                    oa->write_character(to_char_type(0xDB));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
                    j.m_data.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_data.m_value.array->size();
                if (N <= 15)
                {
                    // fixarray
                    write_number(static_cast<std::uint8_t>(0x90 | N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // array 16
                    oa->write_character(to_char_type(0xDC));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // array 32
                    oa->write_character(to_char_type(0xDD));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.array)
                {
                    write_msgpack(el);
                }
                break;
            }

            case value_t::binary:
            {
                // step 0: determine if the binary type has a set subtype to
                // determine whether to use the ext or fixext types
                const bool use_ext = j.m_data.m_value.binary->has_subtype();

                // step 1: write control byte and the byte string length
                const auto N = j.m_data.m_value.binary->size();
                if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    std::uint8_t output_type{};
                    bool fixed = true;
                    if (use_ext)
                    {
                        switch (N)
                        {
                            case 1:
                                output_type = 0xD4; // fixext 1
                                break;
                            case 2:
                                output_type = 0xD5; // fixext 2
                                break;
                            case 4:
                                output_type = 0xD6; // fixext 4
                                break;
                            case 8:
                                output_type = 0xD7; // fixext 8
                                break;
                            case 16:
                                output_type = 0xD8; // fixext 16
                                break;
                            default:
                                output_type = 0xC7; // ext 8
                                fixed = false;
                                break;
                        }

                    }
                    else
                    {
                        output_type = 0xC4; // bin 8
                        fixed = false;
                    }

                    oa->write_character(to_char_type(output_type));
                    if (!fixed)
                    {
                        write_number(static_cast<std::uint8_t>(N));
                    }
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    const std::uint8_t output_type = use_ext
                                                     ? 0xC8 // ext 16
                                                     : 0xC5; // bin 16

                    oa->write_character(to_char_type(output_type));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    const std::uint8_t output_type = use_ext
                                                     ? 0xC9 // ext 32
                                                     : 0xC6; // bin 32

                    oa->write_character(to_char_type(output_type));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 1.5: if this is an ext type, write the subtype
                if (use_ext)
                {
                    write_number(static_cast<std::int8_t>(j.m_data.m_value.binary->subtype()));
                }

                // step 2: write the byte string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
                    N);

                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_data.m_value.object->size();
                if (N <= 15)
                {
                    // fixmap
                    write_number(static_cast<std::uint8_t>(0x80 | (N & 0xF)));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // map 16
                    oa->write_character(to_char_type(0xDE));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // map 32
                    oa->write_character(to_char_type(0xDF));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.object)
                {
                    write_msgpack(el.first);
                    write_msgpack(el.second);
                }
                break;
            }

            case value_t::discarded:
            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    @param[in] use_count   whether to use '#' prefixes (optimized format)
    @param[in] use_type    whether to use '$' prefixes (optimized format)
    @param[in] add_prefix  whether prefixes need to be used for this value
    @param[in] use_bjdata  whether write in BJData format, default is false
    @param[in] bjdata_version  which BJData version to use, default is draft2
    */
    void write_ubjson(const BasicJsonType& j, const bool use_count,
                      const bool use_type, const bool add_prefix = true,
                      const bool use_bjdata = false, const bjdata_version_t bjdata_version = bjdata_version_t::draft2)
    {
        const bool bjdata_draft3 = use_bjdata && bjdata_version == bjdata_version_t::draft3;

        switch (j.type())
        {
            case value_t::null:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('Z'));
                }
                break;
            }

            case value_t::boolean:
            {
                if (add_prefix)
                {
                    oa->write_character(j.m_data.m_value.boolean
                                        ? to_char_type('T')
                                        : to_char_type('F'));
                }
                break;
            }

            case value_t::number_integer:
            {
                write_number_with_ubjson_prefix(j.m_data.m_value.number_integer, add_prefix, use_bjdata);
                break;
            }

            case value_t::number_unsigned:
            {
                write_number_with_ubjson_prefix(j.m_data.m_value.number_unsigned, add_prefix, use_bjdata);
                break;
            }

            case value_t::number_float:
            {
                write_number_with_ubjson_prefix(j.m_data.m_value.number_float, add_prefix, use_bjdata);
                break;
            }

            case value_t::string:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('S'));
                }
                write_number_with_ubjson_prefix(j.m_data.m_value.string->size(), true, use_bjdata);
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
                    j.m_data.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                bool prefix_required = true;
                if (use_type && !j.m_data.m_value.array->empty())
                {
                    JSON_ASSERT(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
                    const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
                                                         [this, first_prefix, use_bjdata](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v, use_bjdata) == first_prefix;
                    });

                    std::vector<CharType> bjdx = {'[', '{', 'S', 'H', 'T', 'F', 'N', 'Z'}; // excluded markers in bjdata optimized type

                    if (same_prefix && !(use_bjdata && std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_data.m_value.array->size(), true, use_bjdata);
                }

                for (const auto& el : *j.m_data.m_value.array)
                {
                    write_ubjson(el, use_count, use_type, prefix_required, use_bjdata, bjdata_version);
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::binary:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                if (use_type && (bjdata_draft3 || !j.m_data.m_value.binary->empty()))
                {
                    JSON_ASSERT(use_count);
                    oa->write_character(to_char_type('$'));
                    oa->write_character(bjdata_draft3 ? 'B' : 'U');
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_data.m_value.binary->size(), true, use_bjdata);
                }

                if (use_type)
                {
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
                        j.m_data.m_value.binary->size());
                }
                else
                {
                    for (size_t i = 0; i < j.m_data.m_value.binary->size(); ++i)
                    {
                        oa->write_character(to_char_type(bjdata_draft3 ? 'B' : 'U'));
                        oa->write_character(j.m_data.m_value.binary->data()[i]);
                    }
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::object:
            {
                if (use_bjdata && j.m_data.m_value.object->size() == 3 && j.m_data.m_value.object->find("_ArrayType_") != j.m_data.m_value.object->end() && j.m_data.m_value.object->find("_ArraySize_") != j.m_data.m_value.object->end() && j.m_data.m_value.object->find("_ArrayData_") != j.m_data.m_value.object->end())
                {
                    if (!write_bjdata_ndarray(*j.m_data.m_value.object, use_count, use_type, bjdata_version))  // decode bjdata ndarray in the JData format (https://github.com/NeuroJSON/jdata)
                    {
                        break;
                    }
                }

                if (add_prefix)
                {
                    oa->write_character(to_char_type('{'));
                }

                bool prefix_required = true;
                if (use_type && !j.m_data.m_value.object->empty())
                {
                    JSON_ASSERT(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
                    const bool same_prefix = std::all_of(j.begin(), j.end(),
                                                         [this, first_prefix, use_bjdata](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v, use_bjdata) == first_prefix;
                    });

                    std::vector<CharType> bjdx = {'[', '{', 'S', 'H', 'T', 'F', 'N', 'Z'}; // excluded markers in bjdata optimized type

                    if (same_prefix && !(use_bjdata && std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_data.m_value.object->size(), true, use_bjdata);
                }

                for (const auto& el : *j.m_data.m_value.object)
                {
                    write_number_with_ubjson_prefix(el.first.size(), true, use_bjdata);
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(el.first.c_str()),
                        el.first.size());
                    write_ubjson(el.second, use_count, use_type, prefix_required, use_bjdata, bjdata_version);
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type('}'));
                }

                break;
            }

            case value_t::discarded:
            default:
                break;
        }
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @return The size of a BSON document entry header, including the id marker
            and the entry name size (and its null-terminator).
    */
    static std::size_t calc_bson_entry_header_size(const string_t& name, const BasicJsonType& j)
    {
        const auto it = name.find(static_cast<typename string_t::value_type>(0));
        if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
        {
            JSON_THROW(out_of_range::create(409, concat("BSON key cannot contain code point U+0000 (at byte ", std::to_string(it), ")"), &j));
        }

        static_cast<void>(j);
        return /*id*/ 1ul + name.size() + /*zero-terminator*/1u;
    }

    /*!
    @brief Writes the given @a element_type and @a name to the output adapter
    */
    void write_bson_entry_header(const string_t& name,
                                 const std::uint8_t element_type)
    {
        oa->write_character(to_char_type(element_type)); // boolean
        oa->write_characters(
            reinterpret_cast<const CharType*>(name.c_str()),
            name.size() + 1u);
    }

    /*!
    @brief Writes a BSON element with key @a name and boolean value @a value
    */
    void write_bson_boolean(const string_t& name,
                            const bool value)
    {
        write_bson_entry_header(name, 0x08);
        oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and double value @a value
    */
    void write_bson_double(const string_t& name,
                           const double value)
    {
        write_bson_entry_header(name, 0x01);
        write_number<double>(value, true);
    }

    /*!
    @return The size of the BSON-encoded string in @a value
    */
    static std::size_t calc_bson_string_size(const string_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and string value @a value
    */
    void write_bson_string(const string_t& name,
                           const string_t& value)
    {
        write_bson_entry_header(name, 0x02);

        write_number<std::int32_t>(static_cast<std::int32_t>(value.size() + 1ul), true);
        oa->write_characters(
            reinterpret_cast<const CharType*>(value.c_str()),
            value.size() + 1);
    }

    /*!
    @brief Writes a BSON element with key @a name and null value
    */
    void write_bson_null(const string_t& name)
    {
        write_bson_entry_header(name, 0x0A);
    }

    /*!
    @return The size of the BSON-encoded integer @a value
    */
    static std::size_t calc_bson_integer_size(const std::int64_t value)
    {
        return (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and integer @a value
    */
    void write_bson_integer(const string_t& name,
                            const std::int64_t value)
    {
        if ((std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)())
        {
            write_bson_entry_header(name, 0x10); // int32
            write_number<std::int32_t>(static_cast<std::int32_t>(value), true);
        }
        else
        {
            write_bson_entry_header(name, 0x12); // int64
            write_number<std::int64_t>(static_cast<std::int64_t>(value), true);
        }
    }

    /*!
    @return The size of the BSON-encoded unsigned integer in @a j
    */
    static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
    {
        return (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and unsigned @a value
    */
    void write_bson_unsigned(const string_t& name,
                             const BasicJsonType& j)
    {
        if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            write_bson_entry_header(name, 0x10 /* int32 */);
            write_number<std::int32_t>(static_cast<std::int32_t>(j.m_data.m_value.number_unsigned), true);
        }
        else if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            write_bson_entry_header(name, 0x12 /* int64 */);
            write_number<std::int64_t>(static_cast<std::int64_t>(j.m_data.m_value.number_unsigned), true);
        }
        else
        {
            write_bson_entry_header(name, 0x11 /* uint64 */);
            write_number<std::uint64_t>(static_cast<std::uint64_t>(j.m_data.m_value.number_unsigned), true);
        }
    }

    /*!
    @brief Writes a BSON element with key @a name and object @a value
    */
    void write_bson_object_entry(const string_t& name,
                                 const typename BasicJsonType::object_t& value)
    {
        write_bson_entry_header(name, 0x03); // object
        write_bson_object(value);
    }

    /*!
    @return The size of the BSON-encoded array @a value
    */
    static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t& value)
    {
        std::size_t array_index = 0ul;

        const std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), static_cast<std::size_t>(0), [&array_index](std::size_t result, const typename BasicJsonType::array_t::value_type & el)
        {
            return result + calc_bson_element_size(std::to_string(array_index++), el);
        });

        return sizeof(std::int32_t) + embedded_document_size + 1ul;
    }

    /*!
    @return The size of the BSON-encoded binary array @a value
    */
    static std::size_t calc_bson_binary_size(const typename BasicJsonType::binary_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and array @a value
    */
    void write_bson_array(const string_t& name,
                          const typename BasicJsonType::array_t& value)
    {
        write_bson_entry_header(name, 0x04); // array
        write_number<std::int32_t>(static_cast<std::int32_t>(calc_bson_array_size(value)), true);

        std::size_t array_index = 0ul;

        for (const auto& el : value)
        {
            write_bson_element(std::to_string(array_index++), el);
        }

        oa->write_character(to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and binary value @a value
    */
    void write_bson_binary(const string_t& name,
                           const binary_t& value)
    {
        write_bson_entry_header(name, 0x05);

        write_number<std::int32_t>(static_cast<std::int32_t>(value.size()), true);
        write_number(value.has_subtype() ? static_cast<std::uint8_t>(value.subtype()) : static_cast<std::uint8_t>(0x00));

        oa->write_characters(reinterpret_cast<const CharType*>(value.data()), value.size());
    }

    /*!
    @brief Calculates the size necessary to serialize the JSON value @a j with its @a name
    @return The calculated size for the BSON document entry for @a j with the given @a name.
    */
    static std::size_t calc_bson_element_size(const string_t& name,
            const BasicJsonType& j)
    {
        const auto header_size = calc_bson_entry_header_size(name, j);
        switch (j.type())
        {
            case value_t::object:
                return header_size + calc_bson_object_size(*j.m_data.m_value.object);

            case value_t::array:
                return header_size + calc_bson_array_size(*j.m_data.m_value.array);

            case value_t::binary:
                return header_size + calc_bson_binary_size(*j.m_data.m_value.binary);

            case value_t::boolean:
                return header_size + 1ul;

            case value_t::number_float:
                return header_size + 8ul;

            case value_t::number_integer:
                return header_size + calc_bson_integer_size(j.m_data.m_value.number_integer);

            case value_t::number_unsigned:
                return header_size + calc_bson_unsigned_size(j.m_data.m_value.number_unsigned);

            case value_t::string:
                return header_size + calc_bson_string_size(*j.m_data.m_value.string);

            case value_t::null:
                return header_size + 0ul;

            // LCOV_EXCL_START
            case value_t::discarded:
            default:
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert)
                return 0ul;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Serializes the JSON value @a j to BSON and associates it with the
           key @a name.
    @param name The name to associate with the JSON entity @a j within the
                current BSON document
    */
    void write_bson_element(const string_t& name,
                            const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
                return write_bson_object_entry(name, *j.m_data.m_value.object);

            case value_t::array:
                return write_bson_array(name, *j.m_data.m_value.array);

            case value_t::binary:
                return write_bson_binary(name, *j.m_data.m_value.binary);

            case value_t::boolean:
                return write_bson_boolean(name, j.m_data.m_value.boolean);

            case value_t::number_float:
                return write_bson_double(name, j.m_data.m_value.number_float);

            case value_t::number_integer:
                return write_bson_integer(name, j.m_data.m_value.number_integer);

            case value_t::number_unsigned:
                return write_bson_unsigned(name, j);

            case value_t::string:
                return write_bson_string(name, *j.m_data.m_value.string);

            case value_t::null:
                return write_bson_null(name);

            // LCOV_EXCL_START
            case value_t::discarded:
            default:
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert)
                return;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Calculates the size of the BSON serialization of the given
           JSON-object @a j.
    @param[in] value  JSON value to serialize
    @pre       value.type() == value_t::object
    */
    static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)
    {
        const std::size_t document_size = std::accumulate(value.begin(), value.end(), static_cast<std::size_t>(0),
                                          [](size_t result, const typename BasicJsonType::object_t::value_type & el)
        {
            return result += calc_bson_element_size(el.first, el.second);
        });

        return sizeof(std::int32_t) + document_size + 1ul;
    }

    /*!
    @param[in] value  JSON value to serialize
    @pre       value.type() == value_t::object
    */
    void write_bson_object(const typename BasicJsonType::object_t& value)
    {
        write_number<std::int32_t>(static_cast<std::int32_t>(calc_bson_object_size(value)), true);

        for (const auto& el : value)
        {
            write_bson_element(el.first, el.second);
        }

        oa->write_character(to_char_type(0x00));
    }

    //////////
    // CBOR //
    //////////

    static constexpr CharType get_cbor_float_prefix(float /*unused*/)
    {
        return to_char_type(0xFA);  // Single-Precision Float
    }

    static constexpr CharType get_cbor_float_prefix(double /*unused*/)
    {
        return to_char_type(0xFB);  // Double-Precision Float
    }

    /////////////
    // MsgPack //
    /////////////

    static constexpr CharType get_msgpack_float_prefix(float /*unused*/)
    {
        return to_char_type(0xCA);  // float 32
    }

    static constexpr CharType get_msgpack_float_prefix(double /*unused*/)
    {
        return to_char_type(0xCB);  // float 64
    }

    ////////////
    // UBJSON //
    ////////////

    // UBJSON: write number (floating point)
    template<typename NumberType, typename std::enable_if<
                 std::is_floating_point<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix,
                                         const bool use_bjdata)
    {
        if (add_prefix)
        {
            oa->write_character(get_ubjson_float_prefix(n));
        }
        write_number(n, use_bjdata);
    }

    // UBJSON: write number (unsigned integer)
    template<typename NumberType, typename std::enable_if<
                 std::is_unsigned<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix,
                                         const bool use_bjdata)
    {
        if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::uint8_t>(n), use_bjdata);
        }
        else if (n <= (std::numeric_limits<std::uint8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n), use_bjdata);
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n), use_bjdata);
        }
        else if (use_bjdata && n <= static_cast<uint64_t>((std::numeric_limits<uint16_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('u'));  // uint16 - bjdata only
            }
            write_number(static_cast<std::uint16_t>(n), use_bjdata);
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n), use_bjdata);
        }
        else if (use_bjdata && n <= static_cast<uint64_t>((std::numeric_limits<uint32_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('m'));  // uint32 - bjdata only
            }
            write_number(static_cast<std::uint32_t>(n), use_bjdata);
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n), use_bjdata);
        }
        else if (use_bjdata && n <= (std::numeric_limits<uint64_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('M'));  // uint64 - bjdata only
            }
            write_number(static_cast<std::uint64_t>(n), use_bjdata);
        }
        else
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('H'));  // high-precision number
            }

            const auto number = BasicJsonType(n).dump();
            write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
            for (std::size_t i = 0; i < number.size(); ++i)
            {
                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
            }
        }
    }

    // UBJSON: write number (signed integer)
    template < typename NumberType, typename std::enable_if <
                   std::is_signed<NumberType>::value&&
                   !std::is_floating_point<NumberType>::value, int >::type = 0 >
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix,
                                         const bool use_bjdata)
    {
        if ((std::numeric_limits<std::int8_t>::min)() <= n && n <= (std::numeric_limits<std::int8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::int8_t>(n), use_bjdata);
        }
        else if (static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n), use_bjdata);
        }
        else if ((std::numeric_limits<std::int16_t>::min)() <= n && n <= (std::numeric_limits<std::int16_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n), use_bjdata);
        }
        else if (use_bjdata && (static_cast<std::int64_t>((std::numeric_limits<std::uint16_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint16_t>::max)())))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('u'));  // uint16 - bjdata only
            }
            write_number(static_cast<uint16_t>(n), use_bjdata);
        }
        else if ((std::numeric_limits<std::int32_t>::min)() <= n && n <= (std::numeric_limits<std::int32_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n), use_bjdata);
        }
        else if (use_bjdata && (static_cast<std::int64_t>((std::numeric_limits<std::uint32_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint32_t>::max)())))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('m'));  // uint32 - bjdata only
            }
            write_number(static_cast<uint32_t>(n), use_bjdata);
        }
        else if ((std::numeric_limits<std::int64_t>::min)() <= n && n <= (std::numeric_limits<std::int64_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n), use_bjdata);
        }
        // LCOV_EXCL_START
        else
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('H'));  // high-precision number
            }

            const auto number = BasicJsonType(n).dump();
            write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
            for (std::size_t i = 0; i < number.size(); ++i)
            {
                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
            }
        }
        // LCOV_EXCL_STOP
    }

    /*!
    @brief determine the type prefix of container values
    */
    CharType ubjson_prefix(const BasicJsonType& j, const bool use_bjdata) const noexcept
    {
        switch (j.type())
        {
            case value_t::null:
                return 'Z';

            case value_t::boolean:
                return j.m_data.m_value.boolean ? 'T' : 'F';

            case value_t::number_integer:
            {
                if ((std::numeric_limits<std::int8_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                {
                    return 'i';
                }
                if ((std::numeric_limits<std::uint8_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    return 'U';
                }
                if ((std::numeric_limits<std::int16_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                {
                    return 'I';
                }
                if (use_bjdata && ((std::numeric_limits<std::uint16_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)()))
                {
                    return 'u';
                }
                if ((std::numeric_limits<std::int32_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                {
                    return 'l';
                }
                if (use_bjdata && ((std::numeric_limits<std::uint32_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)()))
                {
                    return 'm';
                }
                if ((std::numeric_limits<std::int64_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                {
                    return 'L';
                }
                // anything else is treated as a high-precision number
                return 'H'; // LCOV_EXCL_LINE
            }

            case value_t::number_unsigned:
            {
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
                {
                    return 'i';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint8_t>::max)()))
                {
                    return 'U';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
                {
                    return 'I';
                }
                if (use_bjdata && j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint16_t>::max)()))
                {
                    return 'u';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
                {
                    return 'l';
                }
                if (use_bjdata && j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint32_t>::max)()))
                {
                    return 'm';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
                {
                    return 'L';
                }
                if (use_bjdata && j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    return 'M';
                }
                // anything else is treated as a high-precision number
                return 'H'; // LCOV_EXCL_LINE
            }

            case value_t::number_float:
                return get_ubjson_float_prefix(j.m_data.m_value.number_float);

            case value_t::string:
                return 'S';

            case value_t::array: // fallthrough
            case value_t::binary:
                return '[';

            case value_t::object:
                return '{';

            case value_t::discarded:
            default:  // discarded values
                return 'N';
        }
    }

    static constexpr CharType get_ubjson_float_prefix(float /*unused*/)
    {
        return 'd';  // float 32
    }

    static constexpr CharType get_ubjson_float_prefix(double /*unused*/)
    {
        return 'D';  // float 64
    }

    /*!
    @return false if the object is successfully converted to a bjdata ndarray, true if the type or size is invalid
    */
    bool write_bjdata_ndarray(const typename BasicJsonType::object_t& value, const bool use_count, const bool use_type, const bjdata_version_t bjdata_version)
    {
        std::map<string_t, CharType> bjdtype = {{"uint8", 'U'},  {"int8", 'i'},  {"uint16", 'u'}, {"int16", 'I'},
            {"uint32", 'm'}, {"int32", 'l'}, {"uint64", 'M'}, {"int64", 'L'}, {"single", 'd'}, {"double", 'D'},
            {"char", 'C'}, {"byte", 'B'}
        };

        string_t key = "_ArrayType_";
        auto it = bjdtype.find(static_cast<string_t>(value.at(key)));
        if (it == bjdtype.end())
        {
            return true;
        }
        CharType dtype = it->second;

        key = "_ArraySize_";
        std::size_t len = (value.at(key).empty() ? 0 : 1);
        for (const auto& el : value.at(key))
        {
            len *= static_cast<std::size_t>(el.m_data.m_value.number_unsigned);
        }

        key = "_ArrayData_";
        if (value.at(key).size() != len)
        {
            return true;
        }

        oa->write_character('[');
        oa->write_character('$');
        oa->write_character(dtype);
        oa->write_character('#');

        key = "_ArraySize_";
        write_ubjson(value.at(key), use_count, use_type, true,  true, bjdata_version);

        key = "_ArrayData_";
        if (dtype == 'U' || dtype == 'C' || dtype == 'B')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint8_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'i')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int8_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'u')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint16_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'I')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int16_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'm')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint32_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'l')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int32_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'M')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint64_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'L')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int64_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'd')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<float>(el.m_data.m_value.number_float), true);
            }
        }
        else if (dtype == 'D')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<double>(el.m_data.m_value.number_float), true);
            }
        }
        return false;
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*
    @brief write a number to output input
    @param[in] n number of type @a NumberType
    @param[in] OutputIsLittleEndian Set to true if output data is
                                 required to be little endian
    @tparam NumberType the type of the number

    @note This function needs to respect the system's endianness, because bytes
          in CBOR, MessagePack, and UBJSON are stored in network order (big
          endian) and therefore need reordering on little endian systems.
          On the other hand, BSON and BJData use little endian and should reorder
          on big endian systems.
    */
    template<typename NumberType>
    void write_number(const NumberType n, const bool OutputIsLittleEndian = false)
    {
        // step 1: write the number to an array of length NumberType
        std::array<CharType, sizeof(NumberType)> vec{};
        std::memcpy(vec.data(), &n, sizeof(NumberType));

        // step 2: write the array to output (with possible reordering)
        if (is_little_endian != OutputIsLittleEndian)
        {
            // reverse byte order prior to conversion if necessary
            std::reverse(vec.begin(), vec.end());
        }

        oa->write_characters(vec.data(), sizeof(NumberType));
    }

    void write_compact_float(const number_float_t n, detail::input_format_t format)
    {
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
        if (static_cast<double>(n) >= static_cast<double>(std::numeric_limits<float>::lowest()) &&
                static_cast<double>(n) <= static_cast<double>((std::numeric_limits<float>::max)()) &&
                static_cast<double>(static_cast<float>(n)) == static_cast<double>(n))
        {
            oa->write_character(format == detail::input_format_t::cbor
                                ? get_cbor_float_prefix(static_cast<float>(n))
                                : get_msgpack_float_prefix(static_cast<float>(n)));
            write_number(static_cast<float>(n));
        }
        else
        {
            oa->write_character(format == detail::input_format_t::cbor
                                ? get_cbor_float_prefix(n)
                                : get_msgpack_float_prefix(n));
            write_number(n);
        }
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
    }

  public:
    // The following to_char_type functions are implement the conversion
    // between uint8_t and CharType. In case CharType is not unsigned,
    // such a conversion is required to allow values greater than 128.
    // See <https://github.com/nlohmann/json/issues/1286> for a discussion.
    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value && std::is_signed<char>::value > * = nullptr >
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return *reinterpret_cast<char*>(&x);
    }

    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value && std::is_unsigned<char>::value > * = nullptr >
    static CharType to_char_type(std::uint8_t x) noexcept
    {
        // The std::is_trivial trait is deprecated in C++26. The replacement is to use
        // std::is_trivially_copyable and std::is_trivially_default_constructible.
        // However, some older library implementations support std::is_trivial
        // but not all the std::is_trivially_* traits.
        // Since detecting full support across all libraries is difficult,
        // we use std::is_trivial unless we are using a standard where it has been deprecated.
        // For more details, see: https://github.com/nlohmann/json/pull/4775#issuecomment-2884361627
#ifdef JSON_HAS_CPP_26
        static_assert(std::is_trivially_copyable<CharType>::value, "CharType must be trivially copyable");
        static_assert(std::is_trivially_default_constructible<CharType>::value, "CharType must be trivially default constructible");
#else
        static_assert(std::is_trivial<CharType>::value, "CharType must be trivial");
#endif

        static_assert(sizeof(std::uint8_t) == sizeof(CharType), "size of CharType must be equal to std::uint8_t");
        CharType result;
        std::memcpy(&result, &x, sizeof(x));
        return result;
    }

    template<typename C = CharType,
             enable_if_t<std::is_unsigned<C>::value>* = nullptr>
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return x;
    }

    template < typename InputCharType, typename C = CharType,
               enable_if_t <
                   std::is_signed<C>::value &&
                   std::is_signed<char>::value &&
                   std::is_same<char, typename std::remove_cv<InputCharType>::type>::value
                   > * = nullptr >
    static constexpr CharType to_char_type(InputCharType x) noexcept
    {
        return x;
    }

  private:
    /// whether we can assume little endianness
    const bool is_little_endian = little_endianness();

    /// the output
    output_adapter_t<CharType> oa = nullptr;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/output/serializer.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2008 - 2009 BjÃ¶rn Hoehrmann <bjoern@hoehrmann.de>
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // reverse, remove, fill, find, none_of
#include <array> // array
#include <clocale> // localeconv, lconv
#include <cmath> // labs, isfinite, isnan, signbit
#include <cstddef> // size_t, ptrdiff_t
#include <cstdint> // uint8_t
#include <cstdio> // snprintf
#include <limits> // numeric_limits
#include <string> // string, char_traits
#include <iomanip> // setfill, setw
#include <type_traits> // is_same
#include <utility> // move

// #include <nlohmann/detail/conversions/to_chars.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2009 Florian Loitsch <https://florian.loitsch.com/>
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <array> // array
#include <cmath>   // signbit, isfinite
#include <cstdint> // intN_t, uintN_t
#include <cstring> // memcpy, memmove
#include <limits> // numeric_limits
#include <type_traits> // conditional

// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief implements the Grisu2 algorithm for binary to decimal floating-point
conversion.

This implementation is a slightly modified version of the reference
implementation which may be obtained from
http://florian.loitsch.com/publications (bench.tar.gz).

The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.

For a detailed description of the algorithm see:

[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
    Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming
    Language Design and Implementation, PLDI 2010
[2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately",
    Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
    Design and Implementation, PLDI 1996
*/
namespace dtoa_impl
{

template<typename Target, typename Source>
Target reinterpret_bits(const Source source)
{
    static_assert(sizeof(Target) == sizeof(Source), "size mismatch");

    Target target;
    std::memcpy(&target, &source, sizeof(Source));
    return target;
}

struct diyfp // f * 2^e
{
    static constexpr int kPrecision = 64; // = q

    std::uint64_t f = 0;
    int e = 0;

    constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}

    /*!
    @brief returns x - y
    @pre x.e == y.e and x.f >= y.f
    */
    static diyfp sub(const diyfp& x, const diyfp& y) noexcept
    {
        JSON_ASSERT(x.e == y.e);
        JSON_ASSERT(x.f >= y.f);

        return {x.f - y.f, x.e};
    }

    /*!
    @brief returns x * y
    @note The result is rounded. (Only the upper q bits are returned.)
    */
    static diyfp mul(const diyfp& x, const diyfp& y) noexcept
    {
        static_assert(kPrecision == 64, "internal error");

        // Computes:
        //  f = round((x.f * y.f) / 2^q)
        //  e = x.e + y.e + q

        // Emulate the 64-bit * 64-bit multiplication:
        //
        // p = u * v
        //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
        //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
        //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
        //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
        //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
        //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
        //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
        //
        // (Since Q might be larger than 2^32 - 1)
        //
        //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
        //
        // (Q_hi + H does not overflow a 64-bit int)
        //
        //   = p_lo + 2^64 p_hi

        const std::uint64_t u_lo = x.f & 0xFFFFFFFFu;
        const std::uint64_t u_hi = x.f >> 32u;
        const std::uint64_t v_lo = y.f & 0xFFFFFFFFu;
        const std::uint64_t v_hi = y.f >> 32u;

        const std::uint64_t p0 = u_lo * v_lo;
        const std::uint64_t p1 = u_lo * v_hi;
        const std::uint64_t p2 = u_hi * v_lo;
        const std::uint64_t p3 = u_hi * v_hi;

        const std::uint64_t p0_hi = p0 >> 32u;
        const std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;
        const std::uint64_t p1_hi = p1 >> 32u;
        const std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;
        const std::uint64_t p2_hi = p2 >> 32u;

        std::uint64_t Q = p0_hi + p1_lo + p2_lo;

        // The full product might now be computed as
        //
        // p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
        // p_lo = p0_lo + (Q << 32)
        //
        // But in this particular case here, the full p_lo is not required.
        // Effectively, we only need to add the highest bit in p_lo to p_hi (and
        // Q_hi + 1 does not overflow).

        Q += std::uint64_t{1} << (64u - 32u - 1u); // round, ties up

        const std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);

        return {h, x.e + y.e + 64};
    }

    /*!
    @brief normalize x such that the significand is >= 2^(q-1)
    @pre x.f != 0
    */
    static diyfp normalize(diyfp x) noexcept
    {
        JSON_ASSERT(x.f != 0);

        while ((x.f >> 63u) == 0)
        {
            x.f <<= 1u;
            x.e--;
        }

        return x;
    }

    /*!
    @brief normalize x such that the result has the exponent E
    @pre e >= x.e and the upper e - x.e bits of x.f must be zero.
    */
    static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
    {
        const int delta = x.e - target_exponent;

        JSON_ASSERT(delta >= 0);
        JSON_ASSERT(((x.f << delta) >> delta) == x.f);

        return {x.f << delta, target_exponent};
    }
};

struct boundaries
{
    diyfp w;
    diyfp minus;
    diyfp plus;
};

/*!
Compute the (normalized) diyfp representing the input number 'value' and its
boundaries.

@pre value must be finite and positive
*/
template<typename FloatType>
boundaries compute_boundaries(FloatType value)
{
    JSON_ASSERT(std::isfinite(value));
    JSON_ASSERT(value > 0);

    // Convert the IEEE representation into a diyfp.
    //
    // If v is denormal:
    //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
    // If v is normalized:
    //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))

    static_assert(std::numeric_limits<FloatType>::is_iec559,
                  "internal error: dtoa_short requires an IEEE-754 floating-point implementation");

    constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; // = p (includes the hidden bit)
    constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
    constexpr int      kMinExp    = 1 - kBias;
    constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); // = 2^(p-1)

    using bits_type = typename std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;

    const auto bits = static_cast<std::uint64_t>(reinterpret_bits<bits_type>(value));
    const std::uint64_t E = bits >> (kPrecision - 1);
    const std::uint64_t F = bits & (kHiddenBit - 1);

    const bool is_denormal = E == 0;
    const diyfp v = is_denormal
                    ? diyfp(F, kMinExp)
                    : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);

    // Compute the boundaries m- and m+ of the floating-point value
    // v = f * 2^e.
    //
    // Determine v- and v+, the floating-point predecessor and successor of v,
    // respectively.
    //
    //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
    //         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
    //
    //      v+ = v + 2^e
    //
    // Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
    // between m- and m+ round to v, regardless of how the input rounding
    // algorithm breaks ties.
    //
    //      ---+-------------+-------------+-------------+-------------+---  (A)
    //         v-            m-            v             m+            v+
    //
    //      -----------------+------+------+-------------+-------------+---  (B)
    //                       v-     m-     v             m+            v+

    const bool lower_boundary_is_closer = F == 0 && E > 1;
    const diyfp m_plus = diyfp((2 * v.f) + 1, v.e - 1);
    const diyfp m_minus = lower_boundary_is_closer
                          ? diyfp((4 * v.f) - 1, v.e - 2)  // (B)
                          : diyfp((2 * v.f) - 1, v.e - 1); // (A)

    // Determine the normalized w+ = m+.
    const diyfp w_plus = diyfp::normalize(m_plus);

    // Determine w- = m- such that e_(w-) = e_(w+).
    const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);

    return {diyfp::normalize(v), w_minus, w_plus};
}

// Given normalized diyfp w, Grisu needs to find a (normalized) cached
// power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
// within a certain range [alpha, gamma] (Definition 3.2 from [1])
//
//      alpha <= e = e_c + e_w + q <= gamma
//
// or
//
//      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
//                          <= f_c * f_w * 2^gamma
//
// Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies
//
//      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma
//
// or
//
//      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
//
// The choice of (alpha,gamma) determines the size of the table and the form of
// the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
// in practice:
//
// The idea is to cut the number c * w = f * 2^e into two parts, which can be
// processed independently: An integral part p1, and a fractional part p2:
//
//      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
//              = (f div 2^-e) + (f mod 2^-e) * 2^e
//              = p1 + p2 * 2^e
//
// The conversion of p1 into decimal form requires a series of divisions and
// modulos by (a power of) 10. These operations are faster for 32-bit than for
// 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
// achieved by choosing
//
//      -e >= 32   or   e <= -32 := gamma
//
// In order to convert the fractional part
//
//      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
//
// into decimal form, the fraction is repeatedly multiplied by 10 and the digits
// d[-i] are extracted in order:
//
//      (10 * p2) div 2^-e = d[-1]
//      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
//
// The multiplication by 10 must not overflow. It is sufficient to choose
//
//      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.
//
// Since p2 = f mod 2^-e < 2^-e,
//
//      -e <= 60   or   e >= -60 := alpha

constexpr int kAlpha = -60;
constexpr int kGamma = -32;

struct cached_power // c = f * 2^e ~= 10^k
{
    std::uint64_t f;
    int e;
    int k;
};

/*!
For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
satisfies (Definition 3.2 from [1])

     alpha <= e_c + e + q <= gamma.
*/
inline cached_power get_cached_power_for_binary_exponent(int e)
{
    // Now
    //
    //      alpha <= e_c + e + q <= gamma                                    (1)
    //      ==> f_c * 2^alpha <= c * 2^e * 2^q
    //
    // and since the c's are normalized, 2^(q-1) <= f_c,
    //
    //      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
    //      ==> 2^(alpha - e - 1) <= c
    //
    // If c were an exact power of ten, i.e. c = 10^k, one may determine k as
    //
    //      k = ceil( log_10( 2^(alpha - e - 1) ) )
    //        = ceil( (alpha - e - 1) * log_10(2) )
    //
    // From the paper:
    // "In theory the result of the procedure could be wrong since c is rounded,
    //  and the computation itself is approximated [...]. In practice, however,
    //  this simple function is sufficient."
    //
    // For IEEE double precision floating-point numbers converted into
    // normalized diyfp's w = f * 2^e, with q = 64,
    //
    //      e >= -1022      (min IEEE exponent)
    //           -52        (p - 1)
    //           -52        (p - 1, possibly normalize denormal IEEE numbers)
    //           -11        (normalize the diyfp)
    //         = -1137
    //
    // and
    //
    //      e <= +1023      (max IEEE exponent)
    //           -52        (p - 1)
    //           -11        (normalize the diyfp)
    //         = 960
    //
    // This binary exponent range [-1137,960] results in a decimal exponent
    // range [-307,324]. One does not need to store a cached power for each
    // k in this range. For each such k it suffices to find a cached power
    // such that the exponent of the product lies in [alpha,gamma].
    // This implies that the difference of the decimal exponents of adjacent
    // table entries must be less than or equal to
    //
    //      floor( (gamma - alpha) * log_10(2) ) = 8.
    //
    // (A smaller distance gamma-alpha would require a larger table.)

    // NB:
    // Actually, this function returns c, such that -60 <= e_c + e + 64 <= -34.

    constexpr int kCachedPowersMinDecExp = -300;
    constexpr int kCachedPowersDecStep = 8;

    static constexpr std::array<cached_power, 79> kCachedPowers =
    {
        {
            { 0xAB70FE17C79AC6CA, -1060, -300 },
            { 0xFF77B1FCBEBCDC4F, -1034, -292 },
            { 0xBE5691EF416BD60C, -1007, -284 },
            { 0x8DD01FAD907FFC3C,  -980, -276 },
            { 0xD3515C2831559A83,  -954, -268 },
            { 0x9D71AC8FADA6C9B5,  -927, -260 },
            { 0xEA9C227723EE8BCB,  -901, -252 },
            { 0xAECC49914078536D,  -874, -244 },
            { 0x823C12795DB6CE57,  -847, -236 },
            { 0xC21094364DFB5637,  -821, -228 },
            { 0x9096EA6F3848984F,  -794, -220 },
            { 0xD77485CB25823AC7,  -768, -212 },
            { 0xA086CFCD97BF97F4,  -741, -204 },
            { 0xEF340A98172AACE5,  -715, -196 },
            { 0xB23867FB2A35B28E,  -688, -188 },
            { 0x84C8D4DFD2C63F3B,  -661, -180 },
            { 0xC5DD44271AD3CDBA,  -635, -172 },
            { 0x936B9FCEBB25C996,  -608, -164 },
            { 0xDBAC6C247D62A584,  -582, -156 },
            { 0xA3AB66580D5FDAF6,  -555, -148 },
            { 0xF3E2F893DEC3F126,  -529, -140 },
            { 0xB5B5ADA8AAFF80B8,  -502, -132 },
            { 0x87625F056C7C4A8B,  -475, -124 },
            { 0xC9BCFF6034C13053,  -449, -116 },
            { 0x964E858C91BA2655,  -422, -108 },
            { 0xDFF9772470297EBD,  -396, -100 },
            { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
            { 0xF8A95FCF88747D94,  -343,  -84 },
            { 0xB94470938FA89BCF,  -316,  -76 },
            { 0x8A08F0F8BF0F156B,  -289,  -68 },
            { 0xCDB02555653131B6,  -263,  -60 },
            { 0x993FE2C6D07B7FAC,  -236,  -52 },
            { 0xE45C10C42A2B3B06,  -210,  -44 },
            { 0xAA242499697392D3,  -183,  -36 },
            { 0xFD87B5F28300CA0E,  -157,  -28 },
            { 0xBCE5086492111AEB,  -130,  -20 },
            { 0x8CBCCC096F5088CC,  -103,  -12 },
            { 0xD1B71758E219652C,   -77,   -4 },
            { 0x9C40000000000000,   -50,    4 },
            { 0xE8D4A51000000000,   -24,   12 },
            { 0xAD78EBC5AC620000,     3,   20 },
            { 0x813F3978F8940984,    30,   28 },
            { 0xC097CE7BC90715B3,    56,   36 },
            { 0x8F7E32CE7BEA5C70,    83,   44 },
            { 0xD5D238A4ABE98068,   109,   52 },
            { 0x9F4F2726179A2245,   136,   60 },
            { 0xED63A231D4C4FB27,   162,   68 },
            { 0xB0DE65388CC8ADA8,   189,   76 },
            { 0x83C7088E1AAB65DB,   216,   84 },
            { 0xC45D1DF942711D9A,   242,   92 },
            { 0x924D692CA61BE758,   269,  100 },
            { 0xDA01EE641A708DEA,   295,  108 },
            { 0xA26DA3999AEF774A,   322,  116 },
            { 0xF209787BB47D6B85,   348,  124 },
            { 0xB454E4A179DD1877,   375,  132 },
            { 0x865B86925B9BC5C2,   402,  140 },
            { 0xC83553C5C8965D3D,   428,  148 },
            { 0x952AB45CFA97A0B3,   455,  156 },
            { 0xDE469FBD99A05FE3,   481,  164 },
            { 0xA59BC234DB398C25,   508,  172 },
            { 0xF6C69A72A3989F5C,   534,  180 },
            { 0xB7DCBF5354E9BECE,   561,  188 },
            { 0x88FCF317F22241E2,   588,  196 },
            { 0xCC20CE9BD35C78A5,   614,  204 },
            { 0x98165AF37B2153DF,   641,  212 },
            { 0xE2A0B5DC971F303A,   667,  220 },
            { 0xA8D9D1535CE3B396,   694,  228 },
            { 0xFB9B7CD9A4A7443C,   720,  236 },
            { 0xBB764C4CA7A44410,   747,  244 },
            { 0x8BAB8EEFB6409C1A,   774,  252 },
            { 0xD01FEF10A657842C,   800,  260 },
            { 0x9B10A4E5E9913129,   827,  268 },
            { 0xE7109BFBA19C0C9D,   853,  276 },
            { 0xAC2820D9623BF429,   880,  284 },
            { 0x80444B5E7AA7CF85,   907,  292 },
            { 0xBF21E44003ACDD2D,   933,  300 },
            { 0x8E679C2F5E44FF8F,   960,  308 },
            { 0xD433179D9C8CB841,   986,  316 },
            { 0x9E19DB92B4E31BA9,  1013,  324 },
        }
    };

    // This computation gives exactly the same results for k as
    //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
    // for |e| <= 1500, but doesn't require floating-point operations.
    // NB: log_10(2) ~= 78913 / 2^18
    JSON_ASSERT(e >= -1500);
    JSON_ASSERT(e <=  1500);
    const int f = kAlpha - e - 1;
    const int k = ((f * 78913) / (1 << 18)) + static_cast<int>(f > 0);

    const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
    JSON_ASSERT(index >= 0);
    JSON_ASSERT(static_cast<std::size_t>(index) < kCachedPowers.size());

    const cached_power cached = kCachedPowers[static_cast<std::size_t>(index)];
    JSON_ASSERT(kAlpha <= cached.e + e + 64);
    JSON_ASSERT(kGamma >= cached.e + e + 64);

    return cached;
}

/*!
For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k.
For n == 0, returns 1 and sets pow10 := 1.
*/
inline int find_largest_pow10(const std::uint32_t n, std::uint32_t& pow10)
{
    // LCOV_EXCL_START
    if (n >= 1000000000)
    {
        pow10 = 1000000000;
        return 10;
    }
    // LCOV_EXCL_STOP
    if (n >= 100000000)
    {
        pow10 = 100000000;
        return  9;
    }
    if (n >= 10000000)
    {
        pow10 = 10000000;
        return  8;
    }
    if (n >= 1000000)
    {
        pow10 = 1000000;
        return  7;
    }
    if (n >= 100000)
    {
        pow10 = 100000;
        return  6;
    }
    if (n >= 10000)
    {
        pow10 = 10000;
        return  5;
    }
    if (n >= 1000)
    {
        pow10 = 1000;
        return  4;
    }
    if (n >= 100)
    {
        pow10 = 100;
        return  3;
    }
    if (n >= 10)
    {
        pow10 = 10;
        return  2;
    }

    pow10 = 1;
    return 1;
}

inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
                         std::uint64_t rest, std::uint64_t ten_k)
{
    JSON_ASSERT(len >= 1);
    JSON_ASSERT(dist <= delta);
    JSON_ASSERT(rest <= delta);
    JSON_ASSERT(ten_k > 0);

    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    //                                  ten_k
    //                                <------>
    //                                       <---- rest ---->
    // --------------[------------------+----+--------------]--------------
    //                                  w    V
    //                                       = buf * 10^k
    //
    // ten_k represents a unit-in-the-last-place in the decimal representation
    // stored in buf.
    // Decrement buf by ten_k while this takes buf closer to w.

    // The tests are written in this order to avoid overflow in unsigned
    // integer arithmetic.

    while (rest < dist
            && delta - rest >= ten_k
            && (rest + ten_k < dist || dist - rest > rest + ten_k - dist))
    {
        JSON_ASSERT(buf[len - 1] != '0');
        buf[len - 1]--;
        rest += ten_k;
    }
}

/*!
Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+.
M- and M+ must be normalized and share the same exponent -60 <= e <= -32.
*/
inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
                             diyfp M_minus, diyfp w, diyfp M_plus)
{
    static_assert(kAlpha >= -60, "internal error");
    static_assert(kGamma <= -32, "internal error");

    // Generates the digits (and the exponent) of a decimal floating-point
    // number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
    // w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.
    //
    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    // Grisu2 generates the digits of M+ from left to right and stops as soon as
    // V is in [M-,M+].

    JSON_ASSERT(M_plus.e >= kAlpha);
    JSON_ASSERT(M_plus.e <= kGamma);

    std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
    std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; // (significand of (M+ - w ), implicit exponent is e)

    // Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):
    //
    //      M+ = f * 2^e
    //         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
    //         = ((p1        ) * 2^-e + (p2        )) * 2^e
    //         = p1 + p2 * 2^e

    const diyfp one(std::uint64_t{1} << -M_plus.e, M_plus.e);

    auto p1 = static_cast<std::uint32_t>(M_plus.f >> -one.e); // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)
    std::uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e

    // 1)
    //
    // Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]

    JSON_ASSERT(p1 > 0);

    std::uint32_t pow10{};
    const int k = find_largest_pow10(p1, pow10);

    //      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)
    //
    //      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
    //         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
    //
    //      M+ = p1                                             + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
    //         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
    //
    // Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
    //
    //      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
    //
    // but stop as soon as
    //
    //      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e

    int n = k;
    while (n > 0)
    {
        // Invariants:
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
        //      pow10 = 10^(n-1) <= p1 < 10^n
        //
        const std::uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)
        const std::uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)
        //
        //      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
        //         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
        //
        JSON_ASSERT(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
        //
        p1 = r;
        n--;
        //
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)
        //      pow10 = 10^n
        //

        // Now check if enough digits have been generated.
        // Compute
        //
        //      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
        //
        // Note:
        // Since rest and delta share the same exponent e, it suffices to
        // compare the significands.
        const std::uint64_t rest = (std::uint64_t{p1} << -one.e) + p2;
        if (rest <= delta)
        {
            // V = buffer * 10^n, with M- <= V <= M+.

            decimal_exponent += n;

            // We may now just stop. But instead, it looks as if the buffer
            // could be decremented to bring V closer to w.
            //
            // pow10 = 10^n is now 1 ulp in the decimal representation V.
            // The rounding procedure works with diyfp's with an implicit
            // exponent of e.
            //
            //      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
            //
            const std::uint64_t ten_n = std::uint64_t{pow10} << -one.e;
            grisu2_round(buffer, length, dist, delta, rest, ten_n);

            return;
        }

        pow10 /= 10;
        //
        //      pow10 = 10^(n-1) <= p1 < 10^n
        // Invariants restored.
    }

    // 2)
    //
    // The digits of the integral part have been generated:
    //
    //      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
    //         = buffer            + p2 * 2^e
    //
    // Now generate the digits of the fractional part p2 * 2^e.
    //
    // Note:
    // No decimal point is generated: the exponent is adjusted instead.
    //
    // p2 actually represents the fraction
    //
    //      p2 * 2^e
    //          = p2 / 2^-e
    //          = d[-1] / 10^1 + d[-2] / 10^2 + ...
    //
    // Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
    //
    //      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
    //                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
    //
    // using
    //
    //      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
    //                = (                   d) * 2^-e + (                   r)
    //
    // or
    //      10^m * p2 * 2^e = d + r * 2^e
    //
    // i.e.
    //
    //      M+ = buffer + p2 * 2^e
    //         = buffer + 10^-m * (d + r * 2^e)
    //         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
    //
    // and stop as soon as 10^-m * r * 2^e <= delta * 2^e

    JSON_ASSERT(p2 > delta);

    int m = 0;
    for (;;)
    {
        // Invariant:
        //      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
        //         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
        //
        JSON_ASSERT(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);
        p2 *= 10;
        const std::uint64_t d = p2 >> -one.e;     // d = (10 * p2) div 2^-e
        const std::uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
        //
        //      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
        //         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        JSON_ASSERT(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        p2 = r;
        m++;
        //
        //      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
        // Invariant restored.

        // Check if enough digits have been generated.
        //
        //      10^-m * p2 * 2^e <= delta * 2^e
        //              p2 * 2^e <= 10^m * delta * 2^e
        //                    p2 <= 10^m * delta
        delta *= 10;
        dist  *= 10;
        if (p2 <= delta)
        {
            break;
        }
    }

    // V = buffer * 10^-m, with M- <= V <= M+.

    decimal_exponent -= m;

    // 1 ulp in the decimal representation is now 10^-m.
    // Since delta and dist are now scaled by 10^m, we need to do the
    // same with ulp in order to keep the units in sync.
    //
    //      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
    //
    const std::uint64_t ten_m = one.f;
    grisu2_round(buffer, length, dist, delta, p2, ten_m);

    // By construction this algorithm generates the shortest possible decimal
    // number (Loitsch, Theorem 6.2) which rounds back to w.
    // For an input number of precision p, at least
    //
    //      N = 1 + ceil(p * log_10(2))
    //
    // decimal digits are sufficient to identify all binary floating-point
    // numbers (Matula, "In-and-Out conversions").
    // This implies that the algorithm does not produce more than N decimal
    // digits.
    //
    //      N = 17 for p = 53 (IEEE double precision)
    //      N = 9  for p = 24 (IEEE single precision)
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
JSON_HEDLEY_NON_NULL(1)
inline void grisu2(char* buf, int& len, int& decimal_exponent,
                   diyfp m_minus, diyfp v, diyfp m_plus)
{
    JSON_ASSERT(m_plus.e == m_minus.e);
    JSON_ASSERT(m_plus.e == v.e);

    //  --------(-----------------------+-----------------------)--------    (A)
    //          m-                      v                       m+
    //
    //  --------------------(-----------+-----------------------)--------    (B)
    //                      m-          v                       m+
    //
    // First scale v (and m- and m+) such that the exponent is in the range
    // [alpha, gamma].

    const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);

    const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k

    // The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
    const diyfp w       = diyfp::mul(v,       c_minus_k);
    const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
    const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);

    //  ----(---+---)---------------(---+---)---------------(---+---)----
    //          w-                      w                       w+
    //          = c*m-                  = c*v                   = c*m+
    //
    // diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
    // w+ are now off by a small amount.
    // In fact:
    //
    //      w - v * 10^k < 1 ulp
    //
    // To account for this inaccuracy, add resp. subtract 1 ulp.
    //
    //  --------+---[---------------(---+---)---------------]---+--------
    //          w-  M-                  w                   M+  w+
    //
    // Now any number in [M-, M+] (bounds included) will round to w when input,
    // regardless of how the input rounding algorithm breaks ties.
    //
    // And digit_gen generates the shortest possible such number in [M-, M+].
    // Note that this does not mean that Grisu2 always generates the shortest
    // possible number in the interval (m-, m+).
    const diyfp M_minus(w_minus.f + 1, w_minus.e);
    const diyfp M_plus (w_plus.f  - 1, w_plus.e );

    decimal_exponent = -cached.k; // = -(-k) = k

    grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
template<typename FloatType>
JSON_HEDLEY_NON_NULL(1)
void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
{
    static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
                  "internal error: not enough precision");

    JSON_ASSERT(std::isfinite(value));
    JSON_ASSERT(value > 0);

    // If the neighbors (and boundaries) of 'value' are always computed for double-precision
    // numbers, all float's can be recovered using strtod (and strtof). However, the resulting
    // decimal representations are not exactly "short".
    //
    // The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)
    // says "value is converted to a string as if by std::sprintf in the default ("C") locale"
    // and since sprintf promotes floats to doubles, I think this is exactly what 'std::to_chars'
    // does.
    // On the other hand, the documentation for 'std::to_chars' requires that "parsing the
    // representation using the corresponding std::from_chars function recovers value exactly". That
    // indicates that single precision floating-point numbers should be recovered using
    // 'std::strtof'.
    //
    // NB: If the neighbors are computed for single-precision numbers, there is a single float
    //     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
    //     value is off by 1 ulp.
#if 0 // NOLINT(readability-avoid-unconditional-preprocessor-if)
    const boundaries w = compute_boundaries(static_cast<double>(value));
#else
    const boundaries w = compute_boundaries(value);
#endif

    grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
}

/*!
@brief appends a decimal representation of e to buf
@return a pointer to the element following the exponent.
@pre -1000 < e < 1000
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* append_exponent(char* buf, int e)
{
    JSON_ASSERT(e > -1000);
    JSON_ASSERT(e <  1000);

    if (e < 0)
    {
        e = -e;
        *buf++ = '-';
    }
    else
    {
        *buf++ = '+';
    }

    auto k = static_cast<std::uint32_t>(e);
    if (k < 10)
    {
        // Always print at least two digits in the exponent.
        // This is for compatibility with printf("%g").
        *buf++ = '0';
        *buf++ = static_cast<char>('0' + k);
    }
    else if (k < 100)
    {
        *buf++ = static_cast<char>('0' + (k / 10));
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }
    else
    {
        *buf++ = static_cast<char>('0' + (k / 100));
        k %= 100;
        *buf++ = static_cast<char>('0' + (k / 10));
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }

    return buf;
}

/*!
@brief prettify v = buf * 10^decimal_exponent

If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
notation. Otherwise it will be printed in exponential notation.

@pre min_exp < 0
@pre max_exp > 0
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* format_buffer(char* buf, int len, int decimal_exponent,
                           int min_exp, int max_exp)
{
    JSON_ASSERT(min_exp < 0);
    JSON_ASSERT(max_exp > 0);

    const int k = len;
    const int n = len + decimal_exponent;

    // v = buf * 10^(n-k)
    // k is the length of the buffer (number of decimal digits)
    // n is the position of the decimal point relative to the start of the buffer.

    if (k <= n && n <= max_exp)
    {
        // digits[000]
        // len <= max_exp + 2

        std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));
        // Make it look like a floating-point number (#362, #378)
        buf[n + 0] = '.';
        buf[n + 1] = '0';
        return buf + (static_cast<size_t>(n) + 2);
    }

    if (0 < n && n <= max_exp)
    {
        // dig.its
        // len <= max_digits10 + 1

        JSON_ASSERT(k > n);

        std::memmove(buf + (static_cast<size_t>(n) + 1), buf + n, static_cast<size_t>(k) - static_cast<size_t>(n));
        buf[n] = '.';
        return buf + (static_cast<size_t>(k) + 1U);
    }

    if (min_exp < n && n <= 0)
    {
        // 0.[000]digits
        // len <= 2 + (-min_exp - 1) + max_digits10

        std::memmove(buf + (2 + static_cast<size_t>(-n)), buf, static_cast<size_t>(k));
        buf[0] = '0';
        buf[1] = '.';
        std::memset(buf + 2, '0', static_cast<size_t>(-n));
        return buf + (2U + static_cast<size_t>(-n) + static_cast<size_t>(k));
    }

    if (k == 1)
    {
        // dE+123
        // len <= 1 + 5

        buf += 1;
    }
    else
    {
        // d.igitsE+123
        // len <= max_digits10 + 1 + 5

        std::memmove(buf + 2, buf + 1, static_cast<size_t>(k) - 1);
        buf[1] = '.';
        buf += 1 + static_cast<size_t>(k);
    }

    *buf++ = 'e';
    return append_exponent(buf, n - 1);
}

}  // namespace dtoa_impl

/*!
@brief generates a decimal representation of the floating-point number value in [first, last).

The format of the resulting decimal representation is similar to printf's %g
format. Returns an iterator pointing past-the-end of the decimal representation.

@note The input number must be finite, i.e. NaN's and Inf's are not supported.
@note The buffer must be large enough.
@note The result is NOT null-terminated.
*/
template<typename FloatType>
JSON_HEDLEY_NON_NULL(1, 2)
JSON_HEDLEY_RETURNS_NON_NULL
char* to_chars(char* first, const char* last, FloatType value)
{
    static_cast<void>(last); // maybe unused - fix warning
    JSON_ASSERT(std::isfinite(value));

    // Use signbit(value) instead of (value < 0) since signbit works for -0.
    if (std::signbit(value))
    {
        value = -value;
        *first++ = '-';
    }

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
    if (value == 0) // +-0
    {
        *first++ = '0';
        // Make it look like a floating-point number (#362, #378)
        *first++ = '.';
        *first++ = '0';
        return first;
    }
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10);

    // Compute v = buffer * 10^decimal_exponent.
    // The decimal digits are stored in the buffer, which needs to be interpreted
    // as an unsigned decimal integer.
    // len is the length of the buffer, i.e., the number of decimal digits.
    int len = 0;
    int decimal_exponent = 0;
    dtoa_impl::grisu2(first, len, decimal_exponent, value);

    JSON_ASSERT(len <= std::numeric_limits<FloatType>::max_digits10);

    // Format the buffer like printf("%.*g", prec, value)
    constexpr int kMinExp = -4;
    // Use digits10 here to increase compatibility with version 2.
    constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;

    JSON_ASSERT(last - first >= kMaxExp + 2);
    JSON_ASSERT(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);

    return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

///////////////////
// serialization //
///////////////////

/// how to treat decoding errors
enum class error_handler_t
{
    strict,  ///< throw a type_error exception in case of invalid UTF-8
    replace, ///< replace invalid UTF-8 sequences with U+FFFD
    ignore   ///< ignore invalid UTF-8 sequences
};

template<typename BasicJsonType>
class serializer
{
    using string_t = typename BasicJsonType::string_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using binary_char_t = typename BasicJsonType::binary_t::value_type;
    static constexpr std::uint8_t UTF8_ACCEPT = 0;
    static constexpr std::uint8_t UTF8_REJECT = 1;

  public:
    /*!
    @param[in] s  output stream to serialize to
    @param[in] ichar  indentation character to use
    @param[in] error_handler_  how to react on decoding errors
    */
    serializer(output_adapter_t<char> s, const char ichar,
               error_handler_t error_handler_ = error_handler_t::strict)
        : o(std::move(s))
        , loc(std::localeconv())
        , thousands_sep(loc->thousands_sep == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->thousands_sep)))
        , decimal_point(loc->decimal_point == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->decimal_point)))
        , indent_char(ichar)
        , indent_string(512, indent_char)
        , error_handler(error_handler_)
    {}

    // deleted because of pointer members
    serializer(const serializer&) = delete;
    serializer& operator=(const serializer&) = delete;
    serializer(serializer&&) = delete;
    serializer& operator=(serializer&&) = delete;
    ~serializer() = default;

    /*!
    @brief internal implementation of the serialization function

    This function is called by the public member function dump and organizes
    the serialization internally. The indentation level is propagated as
    additional parameter. In case of arrays and objects, the function is
    called recursively.

    - strings and object keys are escaped using `escape_string()`
    - integer numbers are converted implicitly via `operator<<`
    - floating-point numbers are converted to a string using `"%g"` format
    - binary values are serialized as objects containing the subtype and the
      byte array

    @param[in] val               value to serialize
    @param[in] pretty_print      whether the output shall be pretty-printed
    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
    in the output are escaped with `\uXXXX` sequences, and the result consists
    of ASCII characters only.
    @param[in] indent_step       the indent level
    @param[in] current_indent    the current indent level (only used internally)
    */
    void dump(const BasicJsonType& val,
              const bool pretty_print,
              const bool ensure_ascii,
              const unsigned int indent_step,
              const unsigned int current_indent = 0)
    {
        switch (val.m_data.m_type)
        {
            case value_t::object:
            {
                if (val.m_data.m_value.object->empty())
                {
                    o->write_characters("{}", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    auto i = val.m_data.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_data.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\": ", 3);
                        dump(i->second, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    JSON_ASSERT(i != val.m_data.m_value.object->cend());
                    JSON_ASSERT(std::next(i) == val.m_data.m_value.object->cend());
                    o->write_characters(indent_string.c_str(), new_indent);
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\": ", 3);
                    dump(i->second, true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_character('{');

                    // first n-1 elements
                    auto i = val.m_data.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_data.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\":", 2);
                        dump(i->second, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    JSON_ASSERT(i != val.m_data.m_value.object->cend());
                    JSON_ASSERT(std::next(i) == val.m_data.m_value.object->cend());
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\":", 2);
                    dump(i->second, false, ensure_ascii, indent_step, current_indent);

                    o->write_character('}');
                }

                return;
            }

            case value_t::array:
            {
                if (val.m_data.m_value.array->empty())
                {
                    o->write_characters("[]", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("[\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    for (auto i = val.m_data.m_value.array->cbegin();
                            i != val.m_data.m_value.array->cend() - 1; ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        dump(*i, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    JSON_ASSERT(!val.m_data.m_value.array->empty());
                    o->write_characters(indent_string.c_str(), new_indent);
                    dump(val.m_data.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character(']');
                }
                else
                {
                    o->write_character('[');

                    // first n-1 elements
                    for (auto i = val.m_data.m_value.array->cbegin();
                            i != val.m_data.m_value.array->cend() - 1; ++i)
                    {
                        dump(*i, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    JSON_ASSERT(!val.m_data.m_value.array->empty());
                    dump(val.m_data.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);

                    o->write_character(']');
                }

                return;
            }

            case value_t::string:
            {
                o->write_character('\"');
                dump_escaped(*val.m_data.m_value.string, ensure_ascii);
                o->write_character('\"');
                return;
            }

            case value_t::binary:
            {
                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    o->write_characters(indent_string.c_str(), new_indent);

                    o->write_characters("\"bytes\": [", 10);

                    if (!val.m_data.m_value.binary->empty())
                    {
                        for (auto i = val.m_data.m_value.binary->cbegin();
                                i != val.m_data.m_value.binary->cend() - 1; ++i)
                        {
                            dump_integer(*i);
                            o->write_characters(", ", 2);
                        }
                        dump_integer(val.m_data.m_value.binary->back());
                    }

                    o->write_characters("],\n", 3);
                    o->write_characters(indent_string.c_str(), new_indent);

                    o->write_characters("\"subtype\": ", 11);
                    if (val.m_data.m_value.binary->has_subtype())
                    {
                        dump_integer(val.m_data.m_value.binary->subtype());
                    }
                    else
                    {
                        o->write_characters("null", 4);
                    }
                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_characters("{\"bytes\":[", 10);

                    if (!val.m_data.m_value.binary->empty())
                    {
                        for (auto i = val.m_data.m_value.binary->cbegin();
                                i != val.m_data.m_value.binary->cend() - 1; ++i)
                        {
                            dump_integer(*i);
                            o->write_character(',');
                        }
                        dump_integer(val.m_data.m_value.binary->back());
                    }

                    o->write_characters("],\"subtype\":", 12);
                    if (val.m_data.m_value.binary->has_subtype())
                    {
                        dump_integer(val.m_data.m_value.binary->subtype());
                        o->write_character('}');
                    }
                    else
                    {
                        o->write_characters("null}", 5);
                    }
                }
                return;
            }

            case value_t::boolean:
            {
                if (val.m_data.m_value.boolean)
                {
                    o->write_characters("true", 4);
                }
                else
                {
                    o->write_characters("false", 5);
                }
                return;
            }

            case value_t::number_integer:
            {
                dump_integer(val.m_data.m_value.number_integer);
                return;
            }

            case value_t::number_unsigned:
            {
                dump_integer(val.m_data.m_value.number_unsigned);
                return;
            }

            case value_t::number_float:
            {
                dump_float(val.m_data.m_value.number_float);
                return;
            }

            case value_t::discarded:
            {
                o->write_characters("<discarded>", 11);
                return;
            }

            case value_t::null:
            {
                o->write_characters("null", 4);
                return;
            }

            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }
    }

  JSON_PRIVATE_UNLESS_TESTED:
    /*!
    @brief dump escaped string

    Escape a string by replacing certain special characters by a sequence of an
    escape character (backslash) and another character and other control
    characters by a sequence of "\u" followed by a four-digit hex
    representation. The escaped string is written to output stream @a o.

    @param[in] s  the string to escape
    @param[in] ensure_ascii  whether to escape non-ASCII characters with
                             \uXXXX sequences

    @complexity Linear in the length of string @a s.
    */
    void dump_escaped(const string_t& s, const bool ensure_ascii)
    {
        std::uint32_t codepoint{};
        std::uint8_t state = UTF8_ACCEPT;
        std::size_t bytes = 0;  // number of bytes written to string_buffer

        // number of bytes written at the point of the last valid byte
        std::size_t bytes_after_last_accept = 0;
        std::size_t undumped_chars = 0;

        for (std::size_t i = 0; i < s.size(); ++i)
        {
            const auto byte = static_cast<std::uint8_t>(s[i]);

            switch (decode(state, codepoint, byte))
            {
                case UTF8_ACCEPT:  // decode found a new code point
                {
                    switch (codepoint)
                    {
                        case 0x08: // backspace
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'b';
                            break;
                        }

                        case 0x09: // horizontal tab
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 't';
                            break;
                        }

                        case 0x0A: // newline
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'n';
                            break;
                        }

                        case 0x0C: // formfeed
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'f';
                            break;
                        }

                        case 0x0D: // carriage return
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'r';
                            break;
                        }

                        case 0x22: // quotation mark
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\"';
                            break;
                        }

                        case 0x5C: // reverse solidus
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\\';
                            break;
                        }

                        default:
                        {
                            // escape control characters (0x00..0x1F) or, if
                            // ensure_ascii parameter is used, non-ASCII characters
                            if ((codepoint <= 0x1F) || (ensure_ascii && (codepoint >= 0x7F)))
                            {
                                if (codepoint <= 0xFFFF)
                                {
                                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                                    static_cast<void>((std::snprintf)(string_buffer.data() + bytes, 7, "\\u%04x",
                                                                      static_cast<std::uint16_t>(codepoint)));
                                    bytes += 6;
                                }
                                else
                                {
                                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                                    static_cast<void>((std::snprintf)(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
                                                                      static_cast<std::uint16_t>(0xD7C0u + (codepoint >> 10u)),
                                                                      static_cast<std::uint16_t>(0xDC00u + (codepoint & 0x3FFu))));
                                    bytes += 12;
                                }
                            }
                            else
                            {
                                // copy byte to buffer (all previous bytes
                                // been copied have in default case above)
                                string_buffer[bytes++] = s[i];
                            }
                            break;
                        }
                    }

                    // write buffer and reset index; there must be 13 bytes
                    // left, as this is the maximal number of bytes to be
                    // written ("\uxxxx\uxxxx\0") for one code point
                    if (string_buffer.size() - bytes < 13)
                    {
                        o->write_characters(string_buffer.data(), bytes);
                        bytes = 0;
                    }

                    // remember the byte position of this accept
                    bytes_after_last_accept = bytes;
                    undumped_chars = 0;
                    break;
                }

                case UTF8_REJECT:  // decode found invalid UTF-8 byte
                {
                    switch (error_handler)
                    {
                        case error_handler_t::strict:
                        {
                            JSON_THROW(type_error::create(316, concat("invalid UTF-8 byte at index ", std::to_string(i), ": 0x", hex_bytes(byte | 0)), nullptr));
                        }

                        case error_handler_t::ignore:
                        case error_handler_t::replace:
                        {
                            // in case we saw this character the first time, we
                            // would like to read it again, because the byte
                            // may be OK for itself, but just not OK for the
                            // previous sequence
                            if (undumped_chars > 0)
                            {
                                --i;
                            }

                            // reset length buffer to the last accepted index;
                            // thus removing/ignoring the invalid characters
                            bytes = bytes_after_last_accept;

                            if (error_handler == error_handler_t::replace)
                            {
                                // add a replacement character
                                if (ensure_ascii)
                                {
                                    string_buffer[bytes++] = '\\';
                                    string_buffer[bytes++] = 'u';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'd';
                                }
                                else
                                {
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xEF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBD');
                                }

                                // write buffer and reset index; there must be 13 bytes
                                // left, as this is the maximal number of bytes to be
                                // written ("\uxxxx\uxxxx\0") for one code point
                                if (string_buffer.size() - bytes < 13)
                                {
                                    o->write_characters(string_buffer.data(), bytes);
                                    bytes = 0;
                                }

                                bytes_after_last_accept = bytes;
                            }

                            undumped_chars = 0;

                            // continue processing the string
                            state = UTF8_ACCEPT;
                            break;
                        }

                        default:            // LCOV_EXCL_LINE
                            JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
                    }
                    break;
                }

                default:  // decode found yet incomplete multibyte code point
                {
                    if (!ensure_ascii)
                    {
                        // code point will not be escaped - copy byte to buffer
                        string_buffer[bytes++] = s[i];
                    }
                    ++undumped_chars;
                    break;
                }
            }
        }

        // we finished processing the string
        if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
        {
            // write buffer
            if (bytes > 0)
            {
                o->write_characters(string_buffer.data(), bytes);
            }
        }
        else
        {
            // we finish reading, but do not accept: string was incomplete
            switch (error_handler)
            {
                case error_handler_t::strict:
                {
                    JSON_THROW(type_error::create(316, concat("incomplete UTF-8 string; last byte: 0x", hex_bytes(static_cast<std::uint8_t>(s.back() | 0))), nullptr));
                }

                case error_handler_t::ignore:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    break;
                }

                case error_handler_t::replace:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    // add a replacement character
                    if (ensure_ascii)
                    {
                        o->write_characters("\\ufffd", 6);
                    }
                    else
                    {
                        o->write_characters("\xEF\xBF\xBD", 3);
                    }
                    break;
                }

                default:            // LCOV_EXCL_LINE
                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
            }
        }
    }

  private:
    /*!
    @brief count digits

    Count the number of decimal (base 10) digits for an input unsigned integer.

    @param[in] x  unsigned integer number to count its digits
    @return    number of decimal digits
    */
    unsigned int count_digits(number_unsigned_t x) noexcept
    {
        unsigned int n_digits = 1;
        for (;;)
        {
            if (x < 10)
            {
                return n_digits;
            }
            if (x < 100)
            {
                return n_digits + 1;
            }
            if (x < 1000)
            {
                return n_digits + 2;
            }
            if (x < 10000)
            {
                return n_digits + 3;
            }
            x = x / 10000u;
            n_digits += 4;
        }
    }

    /*!
     * @brief convert a byte to a uppercase hex representation
     * @param[in] byte byte to represent
     * @return representation ("00".."FF")
     */
    static std::string hex_bytes(std::uint8_t byte)
    {
        std::string result = "FF";
        constexpr const char* nibble_to_hex = "0123456789ABCDEF";
        result[0] = nibble_to_hex[byte / 16];
        result[1] = nibble_to_hex[byte % 16];
        return result;
    }

    // templates to avoid warnings about useless casts
    template <typename NumberType, enable_if_t<std::is_signed<NumberType>::value, int> = 0>
    bool is_negative_number(NumberType x)
    {
        return x < 0;
    }

    template < typename NumberType, enable_if_t <std::is_unsigned<NumberType>::value, int > = 0 >
    bool is_negative_number(NumberType /*unused*/)
    {
        return false;
    }

    /*!
    @brief dump an integer

    Dump a given integer to output stream @a o. Works internally with
    @a number_buffer.

    @param[in] x  integer number (signed or unsigned) to dump
    @tparam NumberType either @a number_integer_t or @a number_unsigned_t
    */
    template < typename NumberType, detail::enable_if_t <
                   std::is_integral<NumberType>::value ||
                   std::is_same<NumberType, number_unsigned_t>::value ||
                   std::is_same<NumberType, number_integer_t>::value ||
                   std::is_same<NumberType, binary_char_t>::value,
                   int > = 0 >
    void dump_integer(NumberType x)
    {
        static constexpr std::array<std::array<char, 2>, 100> digits_to_99
        {
            {
                {{'0', '0'}}, {{'0', '1'}}, {{'0', '2'}}, {{'0', '3'}}, {{'0', '4'}}, {{'0', '5'}}, {{'0', '6'}}, {{'0', '7'}}, {{'0', '8'}}, {{'0', '9'}},
                {{'1', '0'}}, {{'1', '1'}}, {{'1', '2'}}, {{'1', '3'}}, {{'1', '4'}}, {{'1', '5'}}, {{'1', '6'}}, {{'1', '7'}}, {{'1', '8'}}, {{'1', '9'}},
                {{'2', '0'}}, {{'2', '1'}}, {{'2', '2'}}, {{'2', '3'}}, {{'2', '4'}}, {{'2', '5'}}, {{'2', '6'}}, {{'2', '7'}}, {{'2', '8'}}, {{'2', '9'}},
                {{'3', '0'}}, {{'3', '1'}}, {{'3', '2'}}, {{'3', '3'}}, {{'3', '4'}}, {{'3', '5'}}, {{'3', '6'}}, {{'3', '7'}}, {{'3', '8'}}, {{'3', '9'}},
                {{'4', '0'}}, {{'4', '1'}}, {{'4', '2'}}, {{'4', '3'}}, {{'4', '4'}}, {{'4', '5'}}, {{'4', '6'}}, {{'4', '7'}}, {{'4', '8'}}, {{'4', '9'}},
                {{'5', '0'}}, {{'5', '1'}}, {{'5', '2'}}, {{'5', '3'}}, {{'5', '4'}}, {{'5', '5'}}, {{'5', '6'}}, {{'5', '7'}}, {{'5', '8'}}, {{'5', '9'}},
                {{'6', '0'}}, {{'6', '1'}}, {{'6', '2'}}, {{'6', '3'}}, {{'6', '4'}}, {{'6', '5'}}, {{'6', '6'}}, {{'6', '7'}}, {{'6', '8'}}, {{'6', '9'}},
                {{'7', '0'}}, {{'7', '1'}}, {{'7', '2'}}, {{'7', '3'}}, {{'7', '4'}}, {{'7', '5'}}, {{'7', '6'}}, {{'7', '7'}}, {{'7', '8'}}, {{'7', '9'}},
                {{'8', '0'}}, {{'8', '1'}}, {{'8', '2'}}, {{'8', '3'}}, {{'8', '4'}}, {{'8', '5'}}, {{'8', '6'}}, {{'8', '7'}}, {{'8', '8'}}, {{'8', '9'}},
                {{'9', '0'}}, {{'9', '1'}}, {{'9', '2'}}, {{'9', '3'}}, {{'9', '4'}}, {{'9', '5'}}, {{'9', '6'}}, {{'9', '7'}}, {{'9', '8'}}, {{'9', '9'}},
            }
        };

        // special case for "0"
        if (x == 0)
        {
            o->write_character('0');
            return;
        }

        // use a pointer to fill the buffer
        auto buffer_ptr = number_buffer.begin(); // NOLINT(llvm-qualified-auto,readability-qualified-auto,cppcoreguidelines-pro-type-vararg,hicpp-vararg)

        number_unsigned_t abs_value;

        unsigned int n_chars{};

        if (is_negative_number(x))
        {
            *buffer_ptr = '-';
            abs_value = remove_sign(static_cast<number_integer_t>(x));

            // account one more byte for the minus sign
            n_chars = 1 + count_digits(abs_value);
        }
        else
        {
            abs_value = static_cast<number_unsigned_t>(x);
            n_chars = count_digits(abs_value);
        }

        // spare 1 byte for '\0'
        JSON_ASSERT(n_chars < number_buffer.size() - 1);

        // jump to the end to generate the string from backward,
        // so we later avoid reversing the result
        buffer_ptr += static_cast<typename decltype(number_buffer)::difference_type>(n_chars);

        // Fast int2ascii implementation inspired by "Fastware" talk by Andrei Alexandrescu
        // See: https://www.youtube.com/watch?v=o4-CwDo2zpg
        while (abs_value >= 100)
        {
            const auto digits_index = static_cast<unsigned>((abs_value % 100));
            abs_value /= 100;
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }

        if (abs_value >= 10)
        {
            const auto digits_index = static_cast<unsigned>(abs_value);
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }
        else
        {
            *(--buffer_ptr) = static_cast<char>('0' + abs_value);
        }

        o->write_characters(number_buffer.data(), n_chars);
    }

    /*!
    @brief dump a floating-point number

    Dump a given floating-point number to output stream @a o. Works internally
    with @a number_buffer.

    @param[in] x  floating-point number to dump
    */
    void dump_float(number_float_t x)
    {
        // NaN / inf
        if (!std::isfinite(x))
        {
            o->write_characters("null", 4);
            return;
        }

        // If number_float_t is an IEEE-754 single or double precision number,
        // use the Grisu2 algorithm to produce short numbers which are
        // guaranteed to round-trip, using strtof and strtod, resp.
        //
        // NB: The test below works if <long double> == <double>.
        static constexpr bool is_ieee_single_or_double
            = (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 24 && std::numeric_limits<number_float_t>::max_exponent == 128) ||
              (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 53 && std::numeric_limits<number_float_t>::max_exponent == 1024);

        dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
    }

    void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)
    {
        auto* begin = number_buffer.data();
        auto* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);

        o->write_characters(begin, static_cast<size_t>(end - begin));
    }

    void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
    {
        // get the number of digits for a float -> text -> float round-trip
        static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;

        // the actual conversion
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
        std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), "%.*g", d, x);

        // negative value indicates an error
        JSON_ASSERT(len > 0);
        // check if the buffer was large enough
        JSON_ASSERT(static_cast<std::size_t>(len) < number_buffer.size());

        // erase thousands separators
        if (thousands_sep != '\0')
        {
            // NOLINTNEXTLINE(readability-qualified-auto,llvm-qualified-auto): std::remove returns an iterator, see https://github.com/nlohmann/json/issues/3081
            const auto end = std::remove(number_buffer.begin(), number_buffer.begin() + len, thousands_sep);
            std::fill(end, number_buffer.end(), '\0');
            JSON_ASSERT((end - number_buffer.begin()) <= len);
            len = (end - number_buffer.begin());
        }

        // convert decimal point to '.'
        if (decimal_point != '\0' && decimal_point != '.')
        {
            // NOLINTNEXTLINE(readability-qualified-auto,llvm-qualified-auto): std::find returns an iterator, see https://github.com/nlohmann/json/issues/3081
            const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
            if (dec_pos != number_buffer.end())
            {
                *dec_pos = '.';
            }
        }

        o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));

        // determine if we need to append ".0"
        const bool value_is_int_like =
            std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
                         [](char c)
        {
            return c == '.' || c == 'e';
        });

        if (value_is_int_like)
        {
            o->write_characters(".0", 2);
        }
    }

    /*!
    @brief check whether a string is UTF-8 encoded

    The function checks each byte of a string whether it is UTF-8 encoded. The
    result of the check is stored in the @a state parameter. The function must
    be called initially with state 0 (accept). State 1 means the string must
    be rejected, because the current byte is not allowed. If the string is
    completely processed, but the state is non-zero, the string ended
    prematurely; that is, the last byte indicated more bytes should have
    followed.

    @param[in,out] state  the state of the decoding
    @param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
    @param[in] byte       next byte to decode
    @return               new state

    @note The function has been edited: a std::array is used.

    @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
    @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
    */
    static std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, const std::uint8_t byte) noexcept
    {
        static const std::array<std::uint8_t, 400> utf8d =
        {
            {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
                8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
                0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
                0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
                0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
                1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
                1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
                1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
            }
        };

        JSON_ASSERT(byte < utf8d.size());
        const std::uint8_t type = utf8d[byte];

        codep = (state != UTF8_ACCEPT)
                ? (byte & 0x3fu) | (codep << 6u)
                : (0xFFu >> type) & (byte);

        const std::size_t index = 256u + (static_cast<size_t>(state) * 16u) + static_cast<size_t>(type);
        JSON_ASSERT(index < utf8d.size());
        state = utf8d[index];
        return state;
    }

    /*
     * Overload to make the compiler happy while it is instantiating
     * dump_integer for number_unsigned_t.
     * Must never be called.
     */
    number_unsigned_t remove_sign(number_unsigned_t x)
    {
        JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        return x; // LCOV_EXCL_LINE
    }

    /*
     * Helper function for dump_integer
     *
     * This function takes a negative signed integer and returns its absolute
     * value as an unsigned integer. The plus/minus shuffling is necessary as we
     * cannot directly remove the sign of an arbitrary signed integer as the
     * absolute values of INT_MIN and INT_MAX are usually not the same. See
     * #1708 for details.
     */
    number_unsigned_t remove_sign(number_integer_t x) noexcept
    {
        JSON_ASSERT(x < 0 && x < (std::numeric_limits<number_integer_t>::max)()); // NOLINT(misc-redundant-expression)
        return static_cast<number_unsigned_t>(-(x + 1)) + 1;
    }

  private:
    /// the output of the serializer
    output_adapter_t<char> o = nullptr;

    /// a (hopefully) large enough character buffer
    std::array<char, 64> number_buffer{{}};

    /// the locale
    const std::lconv* loc = nullptr;
    /// the locale's thousand separator character
    const char thousands_sep = '\0';
    /// the locale's decimal point character
    const char decimal_point = '\0';

    /// string buffer
    std::array<char, 512> string_buffer{{}};

    /// the indentation character
    const char indent_char;
    /// the indentation string
    string_t indent_string;

    /// error_handler how to react on decoding errors
    const error_handler_t error_handler;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/value_t.hpp>

// #include <nlohmann/json_fwd.hpp>

// #include <nlohmann/ordered_map.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <functional> // equal_to, less
#include <initializer_list> // initializer_list
#include <iterator> // input_iterator_tag, iterator_traits
#include <memory> // allocator
#include <stdexcept> // for out_of_range
#include <type_traits> // enable_if, is_convertible
#include <utility> // pair
#include <vector> // vector

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

/// ordered_map: a minimal map-like container that preserves insertion order
/// for use within nlohmann::basic_json<ordered_map>
template <class Key, class T, class IgnoredLess = std::less<Key>,
          class Allocator = std::allocator<std::pair<const Key, T>>>
              struct ordered_map : std::vector<std::pair<const Key, T>, Allocator>
{
    using key_type = Key;
    using mapped_type = T;
    using Container = std::vector<std::pair<const Key, T>, Allocator>;
    using iterator = typename Container::iterator;
    using const_iterator = typename Container::const_iterator;
    using size_type = typename Container::size_type;
    using value_type = typename Container::value_type;
#ifdef JSON_HAS_CPP_14
    using key_compare = std::equal_to<>;
#else
    using key_compare = std::equal_to<Key>;
#endif

    // Explicit constructors instead of `using Container::Container`
    // otherwise older compilers choke on it (GCC <= 5.5, xcode <= 9.4)
    ordered_map() noexcept(noexcept(Container())) : Container{} {}
    explicit ordered_map(const Allocator& alloc) noexcept(noexcept(Container(alloc))) : Container{alloc} {}
    template <class It>
    ordered_map(It first, It last, const Allocator& alloc = Allocator())
        : Container{first, last, alloc} {}
    ordered_map(std::initializer_list<value_type> init, const Allocator& alloc = Allocator() )
        : Container{init, alloc} {}

    std::pair<iterator, bool> emplace(const key_type& key, T&& t)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return {it, false};
            }
        }
        Container::emplace_back(key, std::forward<T>(t));
        return {std::prev(this->end()), true};
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    std::pair<iterator, bool> emplace(KeyType && key, T && t)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return {it, false};
            }
        }
        Container::emplace_back(std::forward<KeyType>(key), std::forward<T>(t));
        return {std::prev(this->end()), true};
    }

    T& operator[](const key_type& key)
    {
        return emplace(key, T{}).first->second;
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    T & operator[](KeyType && key)
    {
        return emplace(std::forward<KeyType>(key), T{}).first->second;
    }

    const T& operator[](const key_type& key) const
    {
        return at(key);
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    const T & operator[](KeyType && key) const
    {
        return at(std::forward<KeyType>(key));
    }

    T& at(const key_type& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    T & at(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    const T& at(const key_type& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    const T & at(KeyType && key) const // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    size_type erase(const key_type& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                // Since we cannot move const Keys, re-construct them in place
                for (auto next = it; ++next != this->end(); ++it)
                {
                    it->~value_type(); // Destroy but keep allocation
                    new (&*it) value_type{std::move(*next)};
                }
                Container::pop_back();
                return 1;
            }
        }
        return 0;
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    size_type erase(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                // Since we cannot move const Keys, re-construct them in place
                for (auto next = it; ++next != this->end(); ++it)
                {
                    it->~value_type(); // Destroy but keep allocation
                    new (&*it) value_type{std::move(*next)};
                }
                Container::pop_back();
                return 1;
            }
        }
        return 0;
    }

    iterator erase(iterator pos)
    {
        return erase(pos, std::next(pos));
    }

    iterator erase(iterator first, iterator last)
    {
        if (first == last)
        {
            return first;
        }

        const auto elements_affected = std::distance(first, last);
        const auto offset = std::distance(Container::begin(), first);

        // This is the start situation. We need to delete elements_affected
        // elements (3 in this example: e, f, g), and need to return an
        // iterator past the last deleted element (h in this example).
        // Note that offset is the distance from the start of the vector
        // to first. We will need this later.

        // [ a, b, c, d, e, f, g, h, i, j ]
        //               ^        ^
        //             first    last

        // Since we cannot move const Keys, we re-construct them in place.
        // We start at first and re-construct (viz. copy) the elements from
        // the back of the vector. Example for the first iteration:

        //               ,--------.
        //               v        |   destroy e and re-construct with h
        // [ a, b, c, d, e, f, g, h, i, j ]
        //               ^        ^
        //               it       it + elements_affected

        for (auto it = first; std::next(it, elements_affected) != Container::end(); ++it)
        {
            it->~value_type(); // destroy but keep allocation
            new (&*it) value_type{std::move(*std::next(it, elements_affected))}; // "move" next element to it
        }

        // [ a, b, c, d, h, i, j, h, i, j ]
        //               ^        ^
        //             first    last

        // remove the unneeded elements at the end of the vector
        Container::resize(this->size() - static_cast<size_type>(elements_affected));

        // [ a, b, c, d, h, i, j ]
        //               ^        ^
        //             first    last

        // first is now pointing past the last deleted element, but we cannot
        // use this iterator, because it may have been invalidated by the
        // resize call. Instead, we can return begin() + offset.
        return Container::begin() + offset;
    }

    size_type count(const key_type& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return 1;
            }
        }
        return 0;
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    size_type count(KeyType && key) const // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return 1;
            }
        }
        return 0;
    }

    iterator find(const key_type& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it;
            }
        }
        return Container::end();
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    iterator find(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it;
            }
        }
        return Container::end();
    }

    const_iterator find(const key_type& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it;
            }
        }
        return Container::end();
    }

    std::pair<iterator, bool> insert( value_type&& value )
    {
        return emplace(value.first, std::move(value.second));
    }

    std::pair<iterator, bool> insert( const value_type& value )
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, value.first))
            {
                return {it, false};
            }
        }
        Container::push_back(value);
        return {--this->end(), true};
    }

    template<typename InputIt>
    using require_input_iter = typename std::enable_if<std::is_convertible<typename std::iterator_traits<InputIt>::iterator_category,
        std::input_iterator_tag>::value>::type;

    template<typename InputIt, typename = require_input_iter<InputIt>>
    void insert(InputIt first, InputIt last)
    {
        for (auto it = first; it != last; ++it)
        {
            insert(*it);
        }
    }

private:
    JSON_NO_UNIQUE_ADDRESS key_compare m_compare = key_compare();
};

NLOHMANN_JSON_NAMESPACE_END


#if defined(JSON_HAS_CPP_17)
    #if JSON_HAS_STATIC_RTTI
        #include <any>
    #endif
    #include <string_view>
#endif

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
NLOHMANN_JSON_NAMESPACE_BEGIN

/*!
@brief a class to store JSON values

@internal
@invariant The member variables @a m_value and @a m_type have the following
relationship:
- If `m_type == value_t::object`, then `m_value.object != nullptr`.
- If `m_type == value_t::array`, then `m_value.array != nullptr`.
- If `m_type == value_t::string`, then `m_value.string != nullptr`.
The invariants are checked by member function assert_invariant().

@note ObjectType trick from https://stackoverflow.com/a/9860911
@endinternal

@since version 1.0.0

@nosubgrouping
*/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
class basic_json // NOLINT(cppcoreguidelines-special-member-functions,hicpp-special-member-functions)
    : public ::nlohmann::detail::json_base_class<CustomBaseClass>
{
  private:
    template<detail::value_t> friend struct detail::external_constructor;

    template<typename>
    friend class ::nlohmann::json_pointer;
    // can be restored when json_pointer backwards compatibility is removed
    // friend ::nlohmann::json_pointer<StringType>;

    template<typename BasicJsonType, typename InputType>
    friend class ::nlohmann::detail::parser;
    friend ::nlohmann::detail::serializer<basic_json>;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::iter_impl;
    template<typename BasicJsonType, typename CharType>
    friend class ::nlohmann::detail::binary_writer;
    template<typename BasicJsonType, typename InputType, typename SAX>
    friend class ::nlohmann::detail::binary_reader;
    template<typename BasicJsonType, typename InputAdapterType>
    friend class ::nlohmann::detail::json_sax_dom_parser;
    template<typename BasicJsonType, typename InputAdapterType>
    friend class ::nlohmann::detail::json_sax_dom_callback_parser;
    friend class ::nlohmann::detail::exception;

    /// workaround type for MSVC
    using basic_json_t = NLOHMANN_BASIC_JSON_TPL;
    using json_base_class_t = ::nlohmann::detail::json_base_class<CustomBaseClass>;

  JSON_PRIVATE_UNLESS_TESTED:
    // convenience aliases for types residing in namespace detail;
    using lexer = ::nlohmann::detail::lexer_base<basic_json>;

    template<typename InputAdapterType>
    static ::nlohmann::detail::parser<basic_json, InputAdapterType> parser(
        InputAdapterType adapter,
        detail::parser_callback_t<basic_json>cb = nullptr,
        const bool allow_exceptions = true,
        const bool ignore_comments = false
                                 )
    {
        return ::nlohmann::detail::parser<basic_json, InputAdapterType>(std::move(adapter),
            std::move(cb), allow_exceptions, ignore_comments);
    }

  private:
    using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
    template<typename BasicJsonType>
    using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
    template<typename BasicJsonType>
    using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
    template<typename Iterator>
    using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
    template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;

    template<typename CharType>
    using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;

    template<typename InputType>
    using binary_reader = ::nlohmann::detail::binary_reader<basic_json, InputType>;
    template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;

  JSON_PRIVATE_UNLESS_TESTED:
    using serializer = ::nlohmann::detail::serializer<basic_json>;

  public:
    using value_t = detail::value_t;
    /// JSON Pointer, see @ref nlohmann::json_pointer
    using json_pointer = ::nlohmann::json_pointer<StringType>;
    template<typename T, typename SFINAE>
    using json_serializer = JSONSerializer<T, SFINAE>;
    /// how to treat decoding errors
    using error_handler_t = detail::error_handler_t;
    /// how to treat CBOR tags
    using cbor_tag_handler_t = detail::cbor_tag_handler_t;
    /// how to encode BJData
    using bjdata_version_t = detail::bjdata_version_t;
    /// helper type for initializer lists of basic_json values
    using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;

    using input_format_t = detail::input_format_t;
    /// SAX interface type, see @ref nlohmann::json_sax
    using json_sax_t = json_sax<basic_json>;

    ////////////////
    // exceptions //
    ////////////////

    /// @name exceptions
    /// Classes to implement user-defined exceptions.
    /// @{

    using exception = detail::exception;
    using parse_error = detail::parse_error;
    using invalid_iterator = detail::invalid_iterator;
    using type_error = detail::type_error;
    using out_of_range = detail::out_of_range;
    using other_error = detail::other_error;

    /// @}

    /////////////////////
    // container types //
    /////////////////////

    /// @name container types
    /// The canonic container types to use @ref basic_json like any other STL
    /// container.
    /// @{

    /// the type of elements in a basic_json container
    using value_type = basic_json;

    /// the type of an element reference
    using reference = value_type&;
    /// the type of an element const reference
    using const_reference = const value_type&;

    /// a type to represent differences between iterators
    using difference_type = std::ptrdiff_t;
    /// a type to represent container sizes
    using size_type = std::size_t;

    /// the allocator type
    using allocator_type = AllocatorType<basic_json>;

    /// the type of an element pointer
    using pointer = typename std::allocator_traits<allocator_type>::pointer;
    /// the type of an element const pointer
    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;

    /// an iterator for a basic_json container
    using iterator = iter_impl<basic_json>;
    /// a const iterator for a basic_json container
    using const_iterator = iter_impl<const basic_json>;
    /// a reverse iterator for a basic_json container
    using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
    /// a const reverse iterator for a basic_json container
    using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;

    /// @}

    /// @brief returns the allocator associated with the container
    /// @sa https://json.nlohmann.me/api/basic_json/get_allocator/
    static allocator_type get_allocator()
    {
        return allocator_type();
    }

    /// @brief returns version information on the library
    /// @sa https://json.nlohmann.me/api/basic_json/meta/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json meta()
    {
        basic_json result;

        result["copyright"] = "(C) 2013-2025 Niels Lohmann";
        result["name"] = "JSON for Modern C++";
        result["url"] = "https://github.com/nlohmann/json";
        result["version"]["string"] =
            detail::concat(std::to_string(NLOHMANN_JSON_VERSION_MAJOR), '.',
                           std::to_string(NLOHMANN_JSON_VERSION_MINOR), '.',
                           std::to_string(NLOHMANN_JSON_VERSION_PATCH));
        result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
        result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
        result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;

#ifdef _WIN32
        result["platform"] = "win32";
#elif defined __linux__
        result["platform"] = "linux";
#elif defined __APPLE__
        result["platform"] = "apple";
#elif defined __unix__
        result["platform"] = "unix";
#else
        result["platform"] = "unknown";
#endif

#if defined(__ICC) || defined(__INTEL_COMPILER)
        result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
#elif defined(__clang__)
        result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
#elif defined(__GNUC__) || defined(__GNUG__)
        result["compiler"] = {{"family", "gcc"}, {"version", detail::concat(
                    std::to_string(__GNUC__), '.',
                    std::to_string(__GNUC_MINOR__), '.',
                    std::to_string(__GNUC_PATCHLEVEL__))
            }
        };
#elif defined(__HP_cc) || defined(__HP_aCC)
        result["compiler"] = "hp"
#elif defined(__IBMCPP__)
        result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
#elif defined(_MSC_VER)
        result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
#elif defined(__PGI)
        result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
#elif defined(__SUNPRO_CC)
        result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
#else
        result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
#endif

#if defined(_MSVC_LANG)
        result["compiler"]["c++"] = std::to_string(_MSVC_LANG);
#elif defined(__cplusplus)
        result["compiler"]["c++"] = std::to_string(__cplusplus);
#else
        result["compiler"]["c++"] = "unknown";
#endif
        return result;
    }

    ///////////////////////////
    // JSON value data types //
    ///////////////////////////

    /// @name JSON value data types
    /// The data types to store a JSON value. These types are derived from
    /// the template arguments passed to class @ref basic_json.
    /// @{

    /// @brief default object key comparator type
    /// The actual object key comparator type (@ref object_comparator_t) may be
    /// different.
    /// @sa https://json.nlohmann.me/api/basic_json/default_object_comparator_t/
#if defined(JSON_HAS_CPP_14)
    // use of transparent comparator avoids unnecessary repeated construction of temporaries
    // in functions involving lookup by key with types other than object_t::key_type (aka. StringType)
    using default_object_comparator_t = std::less<>;
#else
    using default_object_comparator_t = std::less<StringType>;
#endif

    /// @brief a type for an object
    /// @sa https://json.nlohmann.me/api/basic_json/object_t/
    using object_t = ObjectType<StringType,
          basic_json,
          default_object_comparator_t,
          AllocatorType<std::pair<const StringType,
          basic_json>>>;

    /// @brief a type for an array
    /// @sa https://json.nlohmann.me/api/basic_json/array_t/
    using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;

    /// @brief a type for a string
    /// @sa https://json.nlohmann.me/api/basic_json/string_t/
    using string_t = StringType;

    /// @brief a type for a boolean
    /// @sa https://json.nlohmann.me/api/basic_json/boolean_t/
    using boolean_t = BooleanType;

    /// @brief a type for a number (integer)
    /// @sa https://json.nlohmann.me/api/basic_json/number_integer_t/
    using number_integer_t = NumberIntegerType;

    /// @brief a type for a number (unsigned)
    /// @sa https://json.nlohmann.me/api/basic_json/number_unsigned_t/
    using number_unsigned_t = NumberUnsignedType;

    /// @brief a type for a number (floating-point)
    /// @sa https://json.nlohmann.me/api/basic_json/number_float_t/
    using number_float_t = NumberFloatType;

    /// @brief a type for a packed binary type
    /// @sa https://json.nlohmann.me/api/basic_json/binary_t/
    using binary_t = nlohmann::byte_container_with_subtype<BinaryType>;

    /// @brief object key comparator type
    /// @sa https://json.nlohmann.me/api/basic_json/object_comparator_t/
    using object_comparator_t = detail::actual_object_comparator_t<basic_json>;

    /// @}

  private:

    /// helper for exception-safe object creation
    template<typename T, typename... Args>
    JSON_HEDLEY_RETURNS_NON_NULL
    static T* create(Args&& ... args)
    {
        AllocatorType<T> alloc;
        using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;

        auto deleter = [&](T * obj)
        {
            AllocatorTraits::deallocate(alloc, obj, 1);
        };
        std::unique_ptr<T, decltype(deleter)> obj(AllocatorTraits::allocate(alloc, 1), deleter);
        AllocatorTraits::construct(alloc, obj.get(), std::forward<Args>(args)...);
        JSON_ASSERT(obj != nullptr);
        return obj.release();
    }

    ////////////////////////
    // JSON value storage //
    ////////////////////////

  JSON_PRIVATE_UNLESS_TESTED:
    /*!
    @brief a JSON value

    The actual storage for a JSON value of the @ref basic_json class. This
    union combines the different storage types for the JSON value types
    defined in @ref value_t.

    JSON type | value_t type    | used type
    --------- | --------------- | ------------------------
    object    | object          | pointer to @ref object_t
    array     | array           | pointer to @ref array_t
    string    | string          | pointer to @ref string_t
    boolean   | boolean         | @ref boolean_t
    number    | number_integer  | @ref number_integer_t
    number    | number_unsigned | @ref number_unsigned_t
    number    | number_float    | @ref number_float_t
    binary    | binary          | pointer to @ref binary_t
    null      | null            | *no value is stored*

    @note Variable-length types (objects, arrays, and strings) are stored as
    pointers. The size of the union should not exceed 64 bits if the default
    value types are used.

    @since version 1.0.0
    */
    union json_value
    {
        /// object (stored with pointer to save storage)
        object_t* object;
        /// array (stored with pointer to save storage)
        array_t* array;
        /// string (stored with pointer to save storage)
        string_t* string;
        /// binary (stored with pointer to save storage)
        binary_t* binary;
        /// boolean
        boolean_t boolean;
        /// number (integer)
        number_integer_t number_integer;
        /// number (unsigned integer)
        number_unsigned_t number_unsigned;
        /// number (floating-point)
        number_float_t number_float;

        /// default constructor (for null values)
        json_value() = default;
        /// constructor for booleans
        json_value(boolean_t v) noexcept : boolean(v) {}
        /// constructor for numbers (integer)
        json_value(number_integer_t v) noexcept : number_integer(v) {}
        /// constructor for numbers (unsigned)
        json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
        /// constructor for numbers (floating-point)
        json_value(number_float_t v) noexcept : number_float(v) {}
        /// constructor for empty values of a given type
        json_value(value_t t)
        {
            switch (t)
            {
                case value_t::object:
                {
                    object = create<object_t>();
                    break;
                }

                case value_t::array:
                {
                    array = create<array_t>();
                    break;
                }

                case value_t::string:
                {
                    string = create<string_t>("");
                    break;
                }

                case value_t::binary:
                {
                    binary = create<binary_t>();
                    break;
                }

                case value_t::boolean:
                {
                    boolean = static_cast<boolean_t>(false);
                    break;
                }

                case value_t::number_integer:
                {
                    number_integer = static_cast<number_integer_t>(0);
                    break;
                }

                case value_t::number_unsigned:
                {
                    number_unsigned = static_cast<number_unsigned_t>(0);
                    break;
                }

                case value_t::number_float:
                {
                    number_float = static_cast<number_float_t>(0.0);
                    break;
                }

                case value_t::null:
                {
                    object = nullptr;  // silence warning, see #821
                    break;
                }

                case value_t::discarded:
                default:
                {
                    object = nullptr;  // silence warning, see #821
                    if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
                    {
                        JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.12.0", nullptr)); // LCOV_EXCL_LINE
                    }
                    break;
                }
            }
        }

        /// constructor for strings
        json_value(const string_t& value) : string(create<string_t>(value)) {}

        /// constructor for rvalue strings
        json_value(string_t&& value) : string(create<string_t>(std::move(value))) {}

        /// constructor for objects
        json_value(const object_t& value) : object(create<object_t>(value)) {}

        /// constructor for rvalue objects
        json_value(object_t&& value) : object(create<object_t>(std::move(value))) {}

        /// constructor for arrays
        json_value(const array_t& value) : array(create<array_t>(value)) {}

        /// constructor for rvalue arrays
        json_value(array_t&& value) : array(create<array_t>(std::move(value))) {}

        /// constructor for binary arrays
        json_value(const typename binary_t::container_type& value) : binary(create<binary_t>(value)) {}

        /// constructor for rvalue binary arrays
        json_value(typename binary_t::container_type&& value) : binary(create<binary_t>(std::move(value))) {}

        /// constructor for binary arrays (internal type)
        json_value(const binary_t& value) : binary(create<binary_t>(value)) {}

        /// constructor for rvalue binary arrays (internal type)
        json_value(binary_t&& value) : binary(create<binary_t>(std::move(value))) {}

        void destroy(value_t t)
        {
            if (
                (t == value_t::object && object == nullptr) ||
                (t == value_t::array && array == nullptr) ||
                (t == value_t::string && string == nullptr) ||
                (t == value_t::binary && binary == nullptr)
            )
            {
                // not initialized (e.g., due to exception in the ctor)
                return;
            }
            if (t == value_t::array || t == value_t::object)
            {
                // flatten the current json_value to a heap-allocated stack
                std::vector<basic_json> stack;

                // move the top-level items to stack
                if (t == value_t::array)
                {
                    stack.reserve(array->size());
                    std::move(array->begin(), array->end(), std::back_inserter(stack));
                }
                else
                {
                    stack.reserve(object->size());
                    for (auto&& it : *object)
                    {
                        stack.push_back(std::move(it.second));
                    }
                }

                while (!stack.empty())
                {
                    // move the last item to a local variable to be processed
                    basic_json current_item(std::move(stack.back()));
                    stack.pop_back();

                    // if current_item is array/object, move
                    // its children to the stack to be processed later
                    if (current_item.is_array())
                    {
                        std::move(current_item.m_data.m_value.array->begin(), current_item.m_data.m_value.array->end(), std::back_inserter(stack));

                        current_item.m_data.m_value.array->clear();
                    }
                    else if (current_item.is_object())
                    {
                        for (auto&& it : *current_item.m_data.m_value.object)
                        {
                            stack.push_back(std::move(it.second));
                        }

                        current_item.m_data.m_value.object->clear();
                    }

                    // it's now safe that current_item gets destructed
                    // since it doesn't have any children
                }
            }

            switch (t)
            {
                case value_t::object:
                {
                    AllocatorType<object_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
                    break;
                }

                case value_t::array:
                {
                    AllocatorType<array_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
                    break;
                }

                case value_t::string:
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
                    break;
                }

                case value_t::binary:
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, binary, 1);
                    break;
                }

                case value_t::null:
                case value_t::boolean:
                case value_t::number_integer:
                case value_t::number_unsigned:
                case value_t::number_float:
                case value_t::discarded:
                default:
                {
                    break;
                }
            }
        }
    };

  private:
    /*!
    @brief checks the class invariants

    This function asserts the class invariants. It needs to be called at the
    end of every constructor to make sure that created objects respect the
    invariant. Furthermore, it has to be called each time the type of a JSON
    value is changed, because the invariant expresses a relationship between
    @a m_type and @a m_value.

    Furthermore, the parent relation is checked for arrays and objects: If
    @a check_parents true and the value is an array or object, then the
    container's elements must have the current value as parent.

    @param[in] check_parents  whether the parent relation should be checked.
               The value is true by default and should only be set to false
               during destruction of objects when the invariant does not
               need to hold.
    */
    void assert_invariant(bool check_parents = true) const noexcept
    {
        JSON_ASSERT(m_data.m_type != value_t::object || m_data.m_value.object != nullptr);
        JSON_ASSERT(m_data.m_type != value_t::array || m_data.m_value.array != nullptr);
        JSON_ASSERT(m_data.m_type != value_t::string || m_data.m_value.string != nullptr);
        JSON_ASSERT(m_data.m_type != value_t::binary || m_data.m_value.binary != nullptr);

#if JSON_DIAGNOSTICS
        JSON_TRY
        {
            // cppcheck-suppress assertWithSideEffect
            JSON_ASSERT(!check_parents || !is_structured() || std::all_of(begin(), end(), [this](const basic_json & j)
            {
                return j.m_parent == this;
            }));
        }
        JSON_CATCH(...) {} // LCOV_EXCL_LINE
#endif
        static_cast<void>(check_parents);
    }

    void set_parents()
    {
#if JSON_DIAGNOSTICS
        switch (m_data.m_type)
        {
            case value_t::array:
            {
                for (auto& element : *m_data.m_value.array)
                {
                    element.m_parent = this;
                }
                break;
            }

            case value_t::object:
            {
                for (auto& element : *m_data.m_value.object)
                {
                    element.second.m_parent = this;
                }
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                break;
        }
#endif
    }

    iterator set_parents(iterator it, typename iterator::difference_type count_set_parents)
    {
#if JSON_DIAGNOSTICS
        for (typename iterator::difference_type i = 0; i < count_set_parents; ++i)
        {
            (it + i)->m_parent = this;
        }
#else
        static_cast<void>(count_set_parents);
#endif
        return it;
    }

    reference set_parent(reference j, std::size_t old_capacity = detail::unknown_size())
    {
#if JSON_DIAGNOSTICS
        if (old_capacity != detail::unknown_size())
        {
            // see https://github.com/nlohmann/json/issues/2838
            JSON_ASSERT(type() == value_t::array);
            if (JSON_HEDLEY_UNLIKELY(m_data.m_value.array->capacity() != old_capacity))
            {
                // capacity has changed: update all parents
                set_parents();
                return j;
            }
        }

        // ordered_json uses a vector internally, so pointers could have
        // been invalidated; see https://github.com/nlohmann/json/issues/2962
#ifdef JSON_HEDLEY_MSVC_VERSION
#pragma warning(push )
#pragma warning(disable : 4127) // ignore warning to replace if with if constexpr
#endif
        if (detail::is_ordered_map<object_t>::value)
        {
            set_parents();
            return j;
        }
#ifdef JSON_HEDLEY_MSVC_VERSION
#pragma warning( pop )
#endif

        j.m_parent = this;
#else
        static_cast<void>(j);
        static_cast<void>(old_capacity);
#endif
        return j;
    }

  public:
    //////////////////////////
    // JSON parser callback //
    //////////////////////////

    /// @brief parser event types
    /// @sa https://json.nlohmann.me/api/basic_json/parse_event_t/
    using parse_event_t = detail::parse_event_t;

    /// @brief per-element parser callback type
    /// @sa https://json.nlohmann.me/api/basic_json/parser_callback_t/
    using parser_callback_t = detail::parser_callback_t<basic_json>;

    //////////////////
    // constructors //
    //////////////////

    /// @name constructors and destructors
    /// Constructors of class @ref basic_json, copy/move constructor, copy
    /// assignment, static functions creating objects, and the destructor.
    /// @{

    /// @brief create an empty value with a given type
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(const value_t v)
        : m_data(v)
    {
        assert_invariant();
    }

    /// @brief create a null object
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(std::nullptr_t = nullptr) noexcept // NOLINT(bugprone-exception-escape)
        : basic_json(value_t::null)
    {
        assert_invariant();
    }

    /// @brief create a JSON value from compatible types
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    template < typename CompatibleType,
               typename U = detail::uncvref_t<CompatibleType>,
               detail::enable_if_t <
                   !detail::is_basic_json<U>::value && detail::is_compatible_type<basic_json_t, U>::value, int > = 0 >
    basic_json(CompatibleType && val) noexcept(noexcept( // NOLINT(bugprone-forwarding-reference-overload,bugprone-exception-escape)
            JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
                                       std::forward<CompatibleType>(val))))
    {
        JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
        set_parents();
        assert_invariant();
    }

    /// @brief create a JSON value from an existing one
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    template < typename BasicJsonType,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value&& !std::is_same<basic_json, BasicJsonType>::value, int > = 0 >
    basic_json(const BasicJsonType& val)
#if JSON_DIAGNOSTIC_POSITIONS
        : start_position(val.start_pos()),
          end_position(val.end_pos())
#endif
    {
        using other_boolean_t = typename BasicJsonType::boolean_t;
        using other_number_float_t = typename BasicJsonType::number_float_t;
        using other_number_integer_t = typename BasicJsonType::number_integer_t;
        using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
        using other_string_t = typename BasicJsonType::string_t;
        using other_object_t = typename BasicJsonType::object_t;
        using other_array_t = typename BasicJsonType::array_t;
        using other_binary_t = typename BasicJsonType::binary_t;

        switch (val.type())
        {
            case value_t::boolean:
                JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
                break;
            case value_t::number_float:
                JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
                break;
            case value_t::number_integer:
                JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
                break;
            case value_t::number_unsigned:
                JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
                break;
            case value_t::string:
                JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
                break;
            case value_t::object:
                JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
                break;
            case value_t::array:
                JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
                break;
            case value_t::binary:
                JSONSerializer<other_binary_t>::to_json(*this, val.template get_ref<const other_binary_t&>());
                break;
            case value_t::null:
                *this = nullptr;
                break;
            case value_t::discarded:
                m_data.m_type = value_t::discarded;
                break;
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }
        JSON_ASSERT(m_data.m_type == val.type());

        set_parents();
        assert_invariant();
    }

    /// @brief create a container (array or object) from an initializer list
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(initializer_list_t init,
               bool type_deduction = true,
               value_t manual_type = value_t::array)
    {
        // check if each element is an array with two elements whose first
        // element is a string
        bool is_an_object = std::all_of(init.begin(), init.end(),
                                        [](const detail::json_ref<basic_json>& element_ref)
        {
            // The cast is to ensure op[size_type] is called, bearing in mind size_type may not be int;
            // (many string types can be constructed from 0 via its null-pointer guise, so we get a
            // broken call to op[key_type], the wrong semantics, and a 4804 warning on Windows)
            return element_ref->is_array() && element_ref->size() == 2 && (*element_ref)[static_cast<size_type>(0)].is_string();
        });

        // adjust type if type deduction is not wanted
        if (!type_deduction)
        {
            // if an array is wanted, do not create an object though possible
            if (manual_type == value_t::array)
            {
                is_an_object = false;
            }

            // if an object is wanted but impossible, throw an exception
            if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object && !is_an_object))
            {
                JSON_THROW(type_error::create(301, "cannot create object from initializer list", nullptr));
            }
        }

        if (is_an_object)
        {
            // the initializer list is a list of pairs -> create an object
            m_data.m_type = value_t::object;
            m_data.m_value = value_t::object;

            for (auto& element_ref : init)
            {
                auto element = element_ref.moved_or_copied();
                m_data.m_value.object->emplace(
                    std::move(*((*element.m_data.m_value.array)[0].m_data.m_value.string)),
                    std::move((*element.m_data.m_value.array)[1]));
            }
        }
        else
        {
            // the initializer list describes an array -> create an array
            m_data.m_type = value_t::array;
            m_data.m_value.array = create<array_t>(init.begin(), init.end());
        }

        set_parents();
        assert_invariant();
    }

    /// @brief explicitly create a binary array (without subtype)
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(const typename binary_t::container_type& init)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = init;
        return res;
    }

    /// @brief explicitly create a binary array (with subtype)
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(const typename binary_t::container_type& init, typename binary_t::subtype_type subtype)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = binary_t(init, subtype);
        return res;
    }

    /// @brief explicitly create a binary array
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(typename binary_t::container_type&& init)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = std::move(init);
        return res;
    }

    /// @brief explicitly create a binary array (with subtype)
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(typename binary_t::container_type&& init, typename binary_t::subtype_type subtype)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = binary_t(std::move(init), subtype);
        return res;
    }

    /// @brief explicitly create an array from an initializer list
    /// @sa https://json.nlohmann.me/api/basic_json/array/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json array(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::array);
    }

    /// @brief explicitly create an object from an initializer list
    /// @sa https://json.nlohmann.me/api/basic_json/object/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json object(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::object);
    }

    /// @brief construct an array with count copies of given value
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(size_type cnt, const basic_json& val):
        m_data{cnt, val}
    {
        set_parents();
        assert_invariant();
    }

    /// @brief construct a JSON container given an iterator range
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    template < class InputIT, typename std::enable_if <
                   std::is_same<InputIT, typename basic_json_t::iterator>::value ||
                   std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int >::type = 0 >
    basic_json(InputIT first, InputIT last) // NOLINT(performance-unnecessary-value-param)
    {
        JSON_ASSERT(first.m_object != nullptr);
        JSON_ASSERT(last.m_object != nullptr);

        // make sure the iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(201, "iterators are not compatible", nullptr));
        }

        // copy type from the first iterator
        m_data.m_type = first.m_object->m_data.m_type;

        // check if the iterator range is complete for primitive values
        switch (m_data.m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()
                                         || !last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range", first.m_object));
                }
                break;
            }

            case value_t::null:
            case value_t::object:
            case value_t::array:
            case value_t::binary:
            case value_t::discarded:
            default:
                break;
        }

        switch (m_data.m_type)
        {
            case value_t::number_integer:
            {
                m_data.m_value.number_integer = first.m_object->m_data.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_data.m_value.number_unsigned = first.m_object->m_data.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_data.m_value.number_float = first.m_object->m_data.m_value.number_float;
                break;
            }

            case value_t::boolean:
            {
                m_data.m_value.boolean = first.m_object->m_data.m_value.boolean;
                break;
            }

            case value_t::string:
            {
                m_data.m_value = *first.m_object->m_data.m_value.string;
                break;
            }

            case value_t::object:
            {
                m_data.m_value.object = create<object_t>(first.m_it.object_iterator,
                                        last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                m_data.m_value.array = create<array_t>(first.m_it.array_iterator,
                                                       last.m_it.array_iterator);
                break;
            }

            case value_t::binary:
            {
                m_data.m_value = *first.m_object->m_data.m_value.binary;
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                JSON_THROW(invalid_iterator::create(206, detail::concat("cannot construct with iterators from ", first.m_object->type_name()), first.m_object));
        }

        set_parents();
        assert_invariant();
    }

    ///////////////////////////////////////
    // other constructors and destructor //
    ///////////////////////////////////////

    template<typename JsonRef,
             detail::enable_if_t<detail::conjunction<detail::is_json_ref<JsonRef>,
                                 std::is_same<typename JsonRef::value_type, basic_json>>::value, int> = 0 >
    basic_json(const JsonRef& ref) : basic_json(ref.moved_or_copied()) {}

    /// @brief copy constructor
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(const basic_json& other)
        : json_base_class_t(other)
#if JSON_DIAGNOSTIC_POSITIONS
        , start_position(other.start_position)
        , end_position(other.end_position)
#endif
    {
        m_data.m_type = other.m_data.m_type;
        // check of passed value is valid
        other.assert_invariant();

        switch (m_data.m_type)
        {
            case value_t::object:
            {
                m_data.m_value = *other.m_data.m_value.object;
                break;
            }

            case value_t::array:
            {
                m_data.m_value = *other.m_data.m_value.array;
                break;
            }

            case value_t::string:
            {
                m_data.m_value = *other.m_data.m_value.string;
                break;
            }

            case value_t::boolean:
            {
                m_data.m_value = other.m_data.m_value.boolean;
                break;
            }

            case value_t::number_integer:
            {
                m_data.m_value = other.m_data.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_data.m_value = other.m_data.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_data.m_value = other.m_data.m_value.number_float;
                break;
            }

            case value_t::binary:
            {
                m_data.m_value = *other.m_data.m_value.binary;
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                break;
        }

        set_parents();
        assert_invariant();
    }

    /// @brief move constructor
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(basic_json&& other) noexcept
        : json_base_class_t(std::forward<json_base_class_t>(other)),
          m_data(std::move(other.m_data)) // cppcheck-suppress[accessForwarded] TODO check
#if JSON_DIAGNOSTIC_POSITIONS
        , start_position(other.start_position) // cppcheck-suppress[accessForwarded] TODO check
        , end_position(other.end_position) // cppcheck-suppress[accessForwarded] TODO check
#endif
    {
        // check that the passed value is valid
        other.assert_invariant(false); // cppcheck-suppress[accessForwarded]

        // invalidate payload
        other.m_data.m_type = value_t::null;
        other.m_data.m_value = {};

#if JSON_DIAGNOSTIC_POSITIONS
        other.start_position = std::string::npos;
        other.end_position = std::string::npos;
#endif

        set_parents();
        assert_invariant();
    }

    /// @brief copy assignment
    /// @sa https://json.nlohmann.me/api/basic_json/operator=/
    basic_json& operator=(basic_json other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&&
        std::is_nothrow_move_assignable<json_value>::value&&
        std::is_nothrow_move_assignable<json_base_class_t>::value
    )
    {
        // check that the passed value is valid
        other.assert_invariant();

        using std::swap;
        swap(m_data.m_type, other.m_data.m_type);
        swap(m_data.m_value, other.m_data.m_value);

#if JSON_DIAGNOSTIC_POSITIONS
        swap(start_position, other.start_position);
        swap(end_position, other.end_position);
#endif

        json_base_class_t::operator=(std::move(other));

        set_parents();
        assert_invariant();
        return *this;
    }

    /// @brief destructor
    /// @sa https://json.nlohmann.me/api/basic_json/~basic_json/
    ~basic_json() noexcept
    {
        assert_invariant(false);
    }

    /// @}

  public:
    ///////////////////////
    // object inspection //
    ///////////////////////

    /// @name object inspection
    /// Functions to inspect the type of a JSON value.
    /// @{

    /// @brief serialization
    /// @sa https://json.nlohmann.me/api/basic_json/dump/
    string_t dump(const int indent = -1,
                  const char indent_char = ' ',
                  const bool ensure_ascii = false,
                  const error_handler_t error_handler = error_handler_t::strict) const
    {
        string_t result;
        serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);

        if (indent >= 0)
        {
            s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
        }
        else
        {
            s.dump(*this, false, ensure_ascii, 0);
        }

        return result;
    }

    /// @brief return the type of the JSON value (explicit)
    /// @sa https://json.nlohmann.me/api/basic_json/type/
    constexpr value_t type() const noexcept
    {
        return m_data.m_type;
    }

    /// @brief return whether type is primitive
    /// @sa https://json.nlohmann.me/api/basic_json/is_primitive/
    constexpr bool is_primitive() const noexcept
    {
        return is_null() || is_string() || is_boolean() || is_number() || is_binary();
    }

    /// @brief return whether type is structured
    /// @sa https://json.nlohmann.me/api/basic_json/is_structured/
    constexpr bool is_structured() const noexcept
    {
        return is_array() || is_object();
    }

    /// @brief return whether value is null
    /// @sa https://json.nlohmann.me/api/basic_json/is_null/
    constexpr bool is_null() const noexcept
    {
        return m_data.m_type == value_t::null;
    }

    /// @brief return whether value is a boolean
    /// @sa https://json.nlohmann.me/api/basic_json/is_boolean/
    constexpr bool is_boolean() const noexcept
    {
        return m_data.m_type == value_t::boolean;
    }

    /// @brief return whether value is a number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number/
    constexpr bool is_number() const noexcept
    {
        return is_number_integer() || is_number_float();
    }

    /// @brief return whether value is an integer number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number_integer/
    constexpr bool is_number_integer() const noexcept
    {
        return m_data.m_type == value_t::number_integer || m_data.m_type == value_t::number_unsigned;
    }

    /// @brief return whether value is an unsigned integer number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number_unsigned/
    constexpr bool is_number_unsigned() const noexcept
    {
        return m_data.m_type == value_t::number_unsigned;
    }

    /// @brief return whether value is a floating-point number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number_float/
    constexpr bool is_number_float() const noexcept
    {
        return m_data.m_type == value_t::number_float;
    }

    /// @brief return whether value is an object
    /// @sa https://json.nlohmann.me/api/basic_json/is_object/
    constexpr bool is_object() const noexcept
    {
        return m_data.m_type == value_t::object;
    }

    /// @brief return whether value is an array
    /// @sa https://json.nlohmann.me/api/basic_json/is_array/
    constexpr bool is_array() const noexcept
    {
        return m_data.m_type == value_t::array;
    }

    /// @brief return whether value is a string
    /// @sa https://json.nlohmann.me/api/basic_json/is_string/
    constexpr bool is_string() const noexcept
    {
        return m_data.m_type == value_t::string;
    }

    /// @brief return whether value is a binary array
    /// @sa https://json.nlohmann.me/api/basic_json/is_binary/
    constexpr bool is_binary() const noexcept
    {
        return m_data.m_type == value_t::binary;
    }

    /// @brief return whether value is discarded
    /// @sa https://json.nlohmann.me/api/basic_json/is_discarded/
    constexpr bool is_discarded() const noexcept
    {
        return m_data.m_type == value_t::discarded;
    }

    /// @brief return the type of the JSON value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/operator_value_t/
    constexpr operator value_t() const noexcept
    {
        return m_data.m_type;
    }

    /// @}

  private:
    //////////////////
    // value access //
    //////////////////

    /// get a boolean (explicit)
    boolean_t get_impl(boolean_t* /*unused*/) const
    {
        if (JSON_HEDLEY_LIKELY(is_boolean()))
        {
            return m_data.m_value.boolean;
        }

        JSON_THROW(type_error::create(302, detail::concat("type must be boolean, but is ", type_name()), this));
    }

    /// get a pointer to the value (object)
    object_t* get_impl_ptr(object_t* /*unused*/) noexcept
    {
        return is_object() ? m_data.m_value.object : nullptr;
    }

    /// get a pointer to the value (object)
    constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
    {
        return is_object() ? m_data.m_value.object : nullptr;
    }

    /// get a pointer to the value (array)
    array_t* get_impl_ptr(array_t* /*unused*/) noexcept
    {
        return is_array() ? m_data.m_value.array : nullptr;
    }

    /// get a pointer to the value (array)
    constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
    {
        return is_array() ? m_data.m_value.array : nullptr;
    }

    /// get a pointer to the value (string)
    string_t* get_impl_ptr(string_t* /*unused*/) noexcept
    {
        return is_string() ? m_data.m_value.string : nullptr;
    }

    /// get a pointer to the value (string)
    constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
    {
        return is_string() ? m_data.m_value.string : nullptr;
    }

    /// get a pointer to the value (boolean)
    boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
    {
        return is_boolean() ? &m_data.m_value.boolean : nullptr;
    }

    /// get a pointer to the value (boolean)
    constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
    {
        return is_boolean() ? &m_data.m_value.boolean : nullptr;
    }

    /// get a pointer to the value (integer number)
    number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
    {
        return m_data.m_type == value_t::number_integer ? &m_data.m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (integer number)
    constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
    {
        return m_data.m_type == value_t::number_integer ? &m_data.m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
    {
        return is_number_unsigned() ? &m_data.m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
    {
        return is_number_unsigned() ? &m_data.m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
    {
        return is_number_float() ? &m_data.m_value.number_float : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
    {
        return is_number_float() ? &m_data.m_value.number_float : nullptr;
    }

    /// get a pointer to the value (binary)
    binary_t* get_impl_ptr(binary_t* /*unused*/) noexcept
    {
        return is_binary() ? m_data.m_value.binary : nullptr;
    }

    /// get a pointer to the value (binary)
    constexpr const binary_t* get_impl_ptr(const binary_t* /*unused*/) const noexcept
    {
        return is_binary() ? m_data.m_value.binary : nullptr;
    }

    /*!
    @brief helper function to implement get_ref()

    This function helps to implement get_ref() without code duplication for
    const and non-const overloads

    @tparam ThisType will be deduced as `basic_json` or `const basic_json`

    @throw type_error.303 if ReferenceType does not match underlying value
    type of the current JSON
    */
    template<typename ReferenceType, typename ThisType>
    static ReferenceType get_ref_impl(ThisType& obj)
    {
        // delegate the call to get_ptr<>()
        auto* ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();

        if (JSON_HEDLEY_LIKELY(ptr != nullptr))
        {
            return *ptr;
        }

        JSON_THROW(type_error::create(303, detail::concat("incompatible ReferenceType for get_ref, actual type is ", obj.type_name()), &obj));
    }

  public:
    /// @name value access
    /// Direct access to the stored value of a JSON value.
    /// @{

    /// @brief get a pointer value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ptr/
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>()
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /// @brief get a pointer value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ptr/
    template < typename PointerType, typename std::enable_if <
                   std::is_pointer<PointerType>::value&&
                   std::is_const<typename std::remove_pointer<PointerType>::type>::value, int >::type = 0 >
    constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>() const
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

  private:
    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value
    which is [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType ret;
    JSONSerializer<ValueType>::from_json(*this, ret);
    return ret;
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and
    - @ref json_serializer<ValueType> does not have a `from_json()` method of
      the form `ValueType from_json(const basic_json&)`

    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get__ValueType_const}

    @since version 2.1.0
    */
    template < typename ValueType,
               detail::enable_if_t <
                   detail::is_default_constructible<ValueType>::value&&
                   detail::has_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType get_impl(detail::priority_tag<0> /*unused*/) const noexcept(noexcept(
            JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
    {
        auto ret = ValueType();
        JSONSerializer<ValueType>::from_json(*this, ret);
        return ret;
    }

    /*!
    @brief get a value (explicit); special case

    Explicit type conversion between the JSON value and a compatible value
    which is **not** [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and **not** [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    return JSONSerializer<ValueType>::from_json(*this);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json and
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `ValueType from_json(const basic_json&)`

    @note If @ref json_serializer<ValueType> has both overloads of
    `from_json()`, this one is chosen.

    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @since version 2.1.0
    */
    template < typename ValueType,
               detail::enable_if_t <
                   detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType get_impl(detail::priority_tag<1> /*unused*/) const noexcept(noexcept(
            JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>())))
    {
        return JSONSerializer<ValueType>::from_json(*this);
    }

    /*!
    @brief get special-case overload

    This overloads converts the current @ref basic_json in a different
    @ref basic_json type

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this, converted into @a BasicJsonType

    @complexity Depending on the implementation of the called `from_json()`
                method.

    @since version 3.2.0
    */
    template < typename BasicJsonType,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value,
                   int > = 0 >
    BasicJsonType get_impl(detail::priority_tag<2> /*unused*/) const
    {
        return *this;
    }

    /*!
    @brief get special-case overload

    This overloads avoids a lot of template boilerplate, it can be seen as the
    identity method

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this

    @complexity Constant.

    @since version 2.1.0
    */
    template<typename BasicJsonType,
             detail::enable_if_t<
                 std::is_same<BasicJsonType, basic_json_t>::value,
                 int> = 0>
    basic_json get_impl(detail::priority_tag<3> /*unused*/) const
    {
        return *this;
    }

    /*!
    @brief get a pointer value (explicit)
    @copydoc get()
    */
    template<typename PointerType,
             detail::enable_if_t<
                 std::is_pointer<PointerType>::value,
                 int> = 0>
    constexpr auto get_impl(detail::priority_tag<4> /*unused*/) const noexcept
    -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

  public:
    /*!
    @brief get a (pointer) value (explicit)

    Performs explicit type conversion between the JSON value and a compatible value if required.

    - If the requested type is a pointer to the internally stored JSON value that pointer is returned.
    No copies are made.

    - If the requested type is the current @ref basic_json, or a different @ref basic_json convertible
    from the current @ref basic_json.

    - Otherwise the value is converted by calling the @ref json_serializer<ValueType> `from_json()`
    method.

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @tparam ValueType if necessary

    @throw what @ref json_serializer<ValueType> `from_json()` method throws if conversion is required

    @since version 2.1.0
    */
    template < typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>>
#if defined(JSON_HAS_CPP_14)
    constexpr
#endif
    auto get() const noexcept(
    noexcept(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {})))
    -> decltype(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {}))
    {
        // we cannot static_assert on ValueTypeCV being non-const, because
        // there is support for get<const basic_json_t>(), which is why we
        // still need the uncvref
        static_assert(!std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        return get_impl<ValueType>(detail::priority_tag<4> {});
    }

    /*!
    @brief get a pointer value (explicit)

    Explicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning The pointer becomes invalid if the underlying JSON object
    changes.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get__PointerType}

    @sa see @ref get_ptr() for explicit pointer-member access

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /// @brief get a value (explicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_to/
    template < typename ValueType,
               detail::enable_if_t <
                   !detail::is_basic_json<ValueType>::value&&
                   detail::has_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType & get_to(ValueType& v) const noexcept(noexcept(
            JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<ValueType>::from_json(*this, v);
        return v;
    }

    // specialization to allow calling get_to with a basic_json value
    // see https://github.com/nlohmann/json/issues/2175
    template<typename ValueType,
             detail::enable_if_t <
                 detail::is_basic_json<ValueType>::value,
                 int> = 0>
    ValueType & get_to(ValueType& v) const
    {
        v = *this;
        return v;
    }

    template <
        typename T, std::size_t N,
        typename Array = T (&)[N], // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
        detail::enable_if_t <
            detail::has_from_json<basic_json_t, Array>::value, int > = 0 >
    Array get_to(T (&v)[N]) const // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
    noexcept(noexcept(JSONSerializer<Array>::from_json(
                          std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<Array>::from_json(*this, v);
        return v;
    }

    /// @brief get a reference value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ref/
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value, int>::type = 0>
    ReferenceType get_ref()
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /// @brief get a reference value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ref/
    template < typename ReferenceType, typename std::enable_if <
                   std::is_reference<ReferenceType>::value&&
                   std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int >::type = 0 >
    ReferenceType get_ref() const
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a value (implicit)

    Implicit type conversion between the JSON value and a compatible value.
    The call is realized by calling @ref get() const.

    @tparam ValueType non-pointer type compatible to the JSON value, for
    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
    `std::vector` types for JSON arrays. The character type of @ref string_t
    as well as an initializer list of this type is excluded to avoid
    ambiguities as these types implicitly convert to `std::string`.

    @return copy of the JSON value, converted to type @a ValueType

    @throw type_error.302 in case passed type @a ValueType is incompatible
    to the JSON value type (e.g., the JSON value is of type boolean, but a
    string is requested); see example below

    @complexity Linear in the size of the JSON value.

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,operator__ValueType}

    @since version 1.0.0
    */
    template < typename ValueType, typename std::enable_if <
                   detail::conjunction <
                       detail::negation<std::is_pointer<ValueType>>,
                       detail::negation<std::is_same<ValueType, std::nullptr_t>>,
                       detail::negation<std::is_same<ValueType, detail::json_ref<basic_json>>>,
                                        detail::negation<std::is_same<ValueType, typename string_t::value_type>>,
                                        detail::negation<detail::is_basic_json<ValueType>>,
                                        detail::negation<std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>>,
#if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER <= 1914))
                                                detail::negation<std::is_same<ValueType, std::string_view>>,
#endif
#if defined(JSON_HAS_CPP_17) && JSON_HAS_STATIC_RTTI
                                                detail::negation<std::is_same<ValueType, std::any>>,
#endif
                                                detail::is_detected_lazy<detail::get_template_function, const basic_json_t&, ValueType>
                                                >::value, int >::type = 0 >
                                        JSON_EXPLICIT operator ValueType() const
    {
        // delegate the call to get<>() const
        return get<ValueType>();
    }

    /// @brief get a binary value
    /// @sa https://json.nlohmann.me/api/basic_json/get_binary/
    binary_t& get_binary()
    {
        if (!is_binary())
        {
            JSON_THROW(type_error::create(302, detail::concat("type must be binary, but is ", type_name()), this));
        }

        return *get_ptr<binary_t*>();
    }

    /// @brief get a binary value
    /// @sa https://json.nlohmann.me/api/basic_json/get_binary/
    const binary_t& get_binary() const
    {
        if (!is_binary())
        {
            JSON_THROW(type_error::create(302, detail::concat("type must be binary, but is ", type_name()), this));
        }

        return *get_ptr<const binary_t*>();
    }

    /// @}

    ////////////////////
    // element access //
    ////////////////////

    /// @name element access
    /// Access to the JSON value.
    /// @{

    /// @brief access specified array element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    reference at(size_type idx)
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return set_parent(m_data.m_value.array->at(idx));
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create a better exception explanation
                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
            } // cppcheck-suppress[missingReturn]
        }
        else
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }
    }

    /// @brief access specified array element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    const_reference at(size_type idx) const
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_data.m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create a better exception explanation
                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
            } // cppcheck-suppress[missingReturn]
        }
        else
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    reference at(const typename object_t::key_type& key)
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(key);
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", key, "' not found"), this));
        }
        return set_parent(it->second);
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    reference at(KeyType && key)
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", string_t(std::forward<KeyType>(key)), "' not found"), this));
        }
        return set_parent(it->second);
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    const_reference at(const typename object_t::key_type& key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(key);
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", key, "' not found"), this));
        }
        return it->second;
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    const_reference at(KeyType && key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", string_t(std::forward<KeyType>(key)), "' not found"), this));
        }
        return it->second;
    }

    /// @brief access specified array element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    reference operator[](size_type idx)
    {
        // implicitly convert a null value to an empty array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value.array = create<array_t>();
            assert_invariant();
        }

        // operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // fill up the array with null values if given idx is outside the range
            if (idx >= m_data.m_value.array->size())
            {
#if JSON_DIAGNOSTICS
                // remember array size & capacity before resizing
                const auto old_size = m_data.m_value.array->size();
                const auto old_capacity = m_data.m_value.array->capacity();
#endif
                m_data.m_value.array->resize(idx + 1);

#if JSON_DIAGNOSTICS
                if (JSON_HEDLEY_UNLIKELY(m_data.m_value.array->capacity() != old_capacity))
                {
                    // capacity has changed: update all parents
                    set_parents();
                }
                else
                {
                    // set parent for values added above
                    set_parents(begin() + static_cast<typename iterator::difference_type>(old_size), static_cast<typename iterator::difference_type>(idx + 1 - old_size));
                }
#endif
                assert_invariant();
            }

            return m_data.m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a numeric argument with ", type_name()), this));
    }

    /// @brief access specified array element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    const_reference operator[](size_type idx) const
    {
        // const operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            return m_data.m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a numeric argument with ", type_name()), this));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    reference operator[](typename object_t::key_type key) // NOLINT(performance-unnecessary-value-param)
    {
        // implicitly convert a null value to an empty object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto result = m_data.m_value.object->emplace(std::move(key), nullptr);
            return set_parent(result.first->second);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    const_reference operator[](const typename object_t::key_type& key) const
    {
        // const operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto it = m_data.m_value.object->find(key);
            JSON_ASSERT(it != m_data.m_value.object->end());
            return it->second;
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

    // these two functions resolve a (const) char * ambiguity affecting Clang and MSVC
    // (they seemingly cannot be constrained to resolve the ambiguity)
    template<typename T>
    reference operator[](T* key)
    {
        return operator[](typename object_t::key_type(key));
    }

    template<typename T>
    const_reference operator[](T* key) const
    {
        return operator[](typename object_t::key_type(key));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int > = 0 >
    reference operator[](KeyType && key)
    {
        // implicitly convert a null value to an empty object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto result = m_data.m_value.object->emplace(std::forward<KeyType>(key), nullptr);
            return set_parent(result.first->second);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int > = 0 >
    const_reference operator[](KeyType && key) const
    {
        // const operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
            JSON_ASSERT(it != m_data.m_value.object->end());
            return it->second;
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

  private:
    template<typename KeyType>
    using is_comparable_with_object_key = detail::is_comparable <
        object_comparator_t, const typename object_t::key_type&, KeyType >;

    template<typename ValueType>
    using value_return_type = std::conditional <
        detail::is_c_string_uncvref<ValueType>::value,
        string_t, typename std::decay<ValueType>::type >;

  public:
    /// @brief access specified object element with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, detail::enable_if_t <
                   !detail::is_transparent<object_comparator_t>::value
                   && detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If 'key' is found, return its value. Otherwise, return `default_value'.
            const auto it = find(key);
            if (it != end())
            {
                return it->template get<ValueType>();
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   !detail::is_transparent<object_comparator_t>::value
                   && detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ReturnType value(const typename object_t::key_type& key, ValueType && default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If 'key' is found, return its value. Otherwise, return `default_value'.
            const auto it = find(key);
            if (it != end())
            {
                return it->template get<ReturnType>();
            }

            return std::forward<ValueType>(default_value);
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class KeyType, detail::enable_if_t <
                   detail::is_transparent<object_comparator_t>::value
                   && !detail::is_json_pointer<KeyType>::value
                   && is_comparable_with_object_key<KeyType>::value
                   && detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ValueType value(KeyType && key, const ValueType& default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If 'key' is found, return its value. Otherwise, return `default_value'.
            const auto it = find(std::forward<KeyType>(key));
            if (it != end())
            {
                return it->template get<ValueType>();
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element via JSON Pointer with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class KeyType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   detail::is_transparent<object_comparator_t>::value
                   && !detail::is_json_pointer<KeyType>::value
                   && is_comparable_with_object_key<KeyType>::value
                   && detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ReturnType value(KeyType && key, ValueType && default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If 'key' is found, return its value. Otherwise, return `default_value'.
            const auto it = find(std::forward<KeyType>(key));
            if (it != end())
            {
                return it->template get<ReturnType>();
            }

            return std::forward<ValueType>(default_value);
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element via JSON Pointer with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, detail::enable_if_t <
                   detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ValueType value(const json_pointer& ptr, const ValueType& default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If the pointer resolves to a value, return it. Otherwise, return
            // 'default_value'.
            JSON_TRY
            {
                return ptr.get_checked(this).template get<ValueType>();
            }
            JSON_INTERNAL_CATCH (out_of_range&)
            {
                return default_value;
            }
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element via JSON Pointer with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ReturnType value(const json_pointer& ptr, ValueType && default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If the pointer resolves to a value, return it. Otherwise, return
            // 'default_value'.
            JSON_TRY
            {
                return ptr.get_checked(this).template get<ReturnType>();
            }
            JSON_INTERNAL_CATCH (out_of_range&)
            {
                return std::forward<ValueType>(default_value);
            }
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    template < class ValueType, class BasicJsonType, detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value
                   && detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    ValueType value(const ::nlohmann::json_pointer<BasicJsonType>& ptr, const ValueType& default_value) const
    {
        return value(ptr.convert(), default_value);
    }

    template < class ValueType, class BasicJsonType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value
                   && detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    ReturnType value(const ::nlohmann::json_pointer<BasicJsonType>& ptr, ValueType && default_value) const
    {
        return value(ptr.convert(), std::forward<ValueType>(default_value));
    }

    /// @brief access the first element
    /// @sa https://json.nlohmann.me/api/basic_json/front/
    reference front()
    {
        return *begin();
    }

    /// @brief access the first element
    /// @sa https://json.nlohmann.me/api/basic_json/front/
    const_reference front() const
    {
        return *cbegin();
    }

    /// @brief access the last element
    /// @sa https://json.nlohmann.me/api/basic_json/back/
    reference back()
    {
        auto tmp = end();
        --tmp;
        return *tmp;
    }

    /// @brief access the last element
    /// @sa https://json.nlohmann.me/api/basic_json/back/
    const_reference back() const
    {
        auto tmp = cend();
        --tmp;
        return *tmp;
    }

    /// @brief remove element given an iterator
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    template < class IteratorType, detail::enable_if_t <
                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int > = 0 >
    IteratorType erase(IteratorType pos) // NOLINT(performance-unnecessary-value-param)
    {
        // make sure the iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
        }

        IteratorType result = end();

        switch (m_data.m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            case value_t::binary:
            {
                if (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))
                {
                    JSON_THROW(invalid_iterator::create(205, "iterator out of range", this));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.string, 1);
                    m_data.m_value.string = nullptr;
                }
                else if (is_binary())
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.binary, 1);
                    m_data.m_value.binary = nullptr;
                }

                m_data.m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_data.m_value.object->erase(pos.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_data.m_value.array->erase(pos.m_it.array_iterator);
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        return result;
    }

    /// @brief remove elements given an iterator range
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    template < class IteratorType, detail::enable_if_t <
                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int > = 0 >
    IteratorType erase(IteratorType first, IteratorType last) // NOLINT(performance-unnecessary-value-param)
    {
        // make sure the iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != first.m_object || this != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value", this));
        }

        IteratorType result = end();

        switch (m_data.m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            case value_t::binary:
            {
                if (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()
                                       || !last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range", this));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.string, 1);
                    m_data.m_value.string = nullptr;
                }
                else if (is_binary())
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.binary, 1);
                    m_data.m_value.binary = nullptr;
                }

                m_data.m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_data.m_value.object->erase(first.m_it.object_iterator,
                                              last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_data.m_value.array->erase(first.m_it.array_iterator,
                                             last.m_it.array_iterator);
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        return result;
    }

  private:
    template < typename KeyType, detail::enable_if_t <
                   detail::has_erase_with_key_type<basic_json_t, KeyType>::value, int > = 0 >
    size_type erase_internal(KeyType && key)
    {
        // this erase only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        return m_data.m_value.object->erase(std::forward<KeyType>(key));
    }

    template < typename KeyType, detail::enable_if_t <
                   !detail::has_erase_with_key_type<basic_json_t, KeyType>::value, int > = 0 >
    size_type erase_internal(KeyType && key)
    {
        // this erase only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        const auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
        if (it != m_data.m_value.object->end())
        {
            m_data.m_value.object->erase(it);
            return 1;
        }
        return 0;
    }

  public:

    /// @brief remove element from a JSON object given a key
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    size_type erase(const typename object_t::key_type& key)
    {
        // the indirection via erase_internal() is added to avoid making this
        // function a template and thus de-rank it during overload resolution
        return erase_internal(key);
    }

    /// @brief remove element from a JSON object given a key
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    size_type erase(KeyType && key)
    {
        return erase_internal(std::forward<KeyType>(key));
    }

    /// @brief remove element from a JSON array given an index
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    void erase(const size_type idx)
    {
        // this erase only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            if (JSON_HEDLEY_UNLIKELY(idx >= size()))
            {
                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
            }

            m_data.m_value.array->erase(m_data.m_value.array->begin() + static_cast<difference_type>(idx));
        }
        else
        {
            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }
    }

    /// @}

    ////////////
    // lookup //
    ////////////

    /// @name lookup
    /// @{

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    iterator find(const typename object_t::key_type& key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(key);
        }

        return result;
    }

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    const_iterator find(const typename object_t::key_type& key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(key);
        }

        return result;
    }

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    iterator find(KeyType && key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(std::forward<KeyType>(key));
        }

        return result;
    }

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    const_iterator find(KeyType && key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(std::forward<KeyType>(key));
        }

        return result;
    }

    /// @brief returns the number of occurrences of a key in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/count/
    size_type count(const typename object_t::key_type& key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_data.m_value.object->count(key) : 0;
    }

    /// @brief returns the number of occurrences of a key in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/count/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    size_type count(KeyType && key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_data.m_value.object->count(std::forward<KeyType>(key)) : 0;
    }

    /// @brief check the existence of an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/contains/
    bool contains(const typename object_t::key_type& key) const
    {
        return is_object() && m_data.m_value.object->find(key) != m_data.m_value.object->end();
    }

    /// @brief check the existence of an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/contains/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    bool contains(KeyType && key) const
    {
        return is_object() && m_data.m_value.object->find(std::forward<KeyType>(key)) != m_data.m_value.object->end();
    }

    /// @brief check the existence of an element in a JSON object given a JSON pointer
    /// @sa https://json.nlohmann.me/api/basic_json/contains/
    bool contains(const json_pointer& ptr) const
    {
        return ptr.contains(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    bool contains(const typename ::nlohmann::json_pointer<BasicJsonType>& ptr) const
    {
        return ptr.contains(this);
    }

    /// @}

    ///////////////
    // iterators //
    ///////////////

    /// @name iterators
    /// @{

    /// @brief returns an iterator to the first element
    /// @sa https://json.nlohmann.me/api/basic_json/begin/
    iterator begin() noexcept
    {
        iterator result(this);
        result.set_begin();
        return result;
    }

    /// @brief returns an iterator to the first element
    /// @sa https://json.nlohmann.me/api/basic_json/begin/
    const_iterator begin() const noexcept
    {
        return cbegin();
    }

    /// @brief returns a const iterator to the first element
    /// @sa https://json.nlohmann.me/api/basic_json/cbegin/
    const_iterator cbegin() const noexcept
    {
        const_iterator result(this);
        result.set_begin();
        return result;
    }

    /// @brief returns an iterator to one past the last element
    /// @sa https://json.nlohmann.me/api/basic_json/end/
    iterator end() noexcept
    {
        iterator result(this);
        result.set_end();
        return result;
    }

    /// @brief returns an iterator to one past the last element
    /// @sa https://json.nlohmann.me/api/basic_json/end/
    const_iterator end() const noexcept
    {
        return cend();
    }

    /// @brief returns an iterator to one past the last element
    /// @sa https://json.nlohmann.me/api/basic_json/cend/
    const_iterator cend() const noexcept
    {
        const_iterator result(this);
        result.set_end();
        return result;
    }

    /// @brief returns an iterator to the reverse-beginning
    /// @sa https://json.nlohmann.me/api/basic_json/rbegin/
    reverse_iterator rbegin() noexcept
    {
        return reverse_iterator(end());
    }

    /// @brief returns an iterator to the reverse-beginning
    /// @sa https://json.nlohmann.me/api/basic_json/rbegin/
    const_reverse_iterator rbegin() const noexcept
    {
        return crbegin();
    }

    /// @brief returns an iterator to the reverse-end
    /// @sa https://json.nlohmann.me/api/basic_json/rend/
    reverse_iterator rend() noexcept
    {
        return reverse_iterator(begin());
    }

    /// @brief returns an iterator to the reverse-end
    /// @sa https://json.nlohmann.me/api/basic_json/rend/
    const_reverse_iterator rend() const noexcept
    {
        return crend();
    }

    /// @brief returns a const reverse iterator to the last element
    /// @sa https://json.nlohmann.me/api/basic_json/crbegin/
    const_reverse_iterator crbegin() const noexcept
    {
        return const_reverse_iterator(cend());
    }

    /// @brief returns a const reverse iterator to one before the first
    /// @sa https://json.nlohmann.me/api/basic_json/crend/
    const_reverse_iterator crend() const noexcept
    {
        return const_reverse_iterator(cbegin());
    }

  public:
    /// @brief wrapper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    /// @deprecated This function is deprecated since 3.1.0 and will be removed in
    ///             version 4.0.0 of the library. Please use @ref items() instead;
    ///             that is, replace `json::iterator_wrapper(j)` with `j.items()`.
    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
    static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
    {
        return ref.items();
    }

    /// @brief wrapper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    /// @deprecated This function is deprecated since 3.1.0 and will be removed in
    ///         version 4.0.0 of the library. Please use @ref items() instead;
    ///         that is, replace `json::iterator_wrapper(j)` with `j.items()`.
    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
    static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
    {
        return ref.items();
    }

    /// @brief helper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    iteration_proxy<iterator> items() noexcept
    {
        return iteration_proxy<iterator>(*this);
    }

    /// @brief helper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    iteration_proxy<const_iterator> items() const noexcept
    {
        return iteration_proxy<const_iterator>(*this);
    }

    /// @}

    //////////////
    // capacity //
    //////////////

    /// @name capacity
    /// @{

    /// @brief checks whether the container is empty.
    /// @sa https://json.nlohmann.me/api/basic_json/empty/
    bool empty() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return true;
            }

            case value_t::array:
            {
                // delegate call to array_t::empty()
                return m_data.m_value.array->empty();
            }

            case value_t::object:
            {
                // delegate call to object_t::empty()
                return m_data.m_value.object->empty();
            }

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // all other types are nonempty
                return false;
            }
        }
    }

    /// @brief returns the number of elements
    /// @sa https://json.nlohmann.me/api/basic_json/size/
    size_type size() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return 0;
            }

            case value_t::array:
            {
                // delegate call to array_t::size()
                return m_data.m_value.array->size();
            }

            case value_t::object:
            {
                // delegate call to object_t::size()
                return m_data.m_value.object->size();
            }

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // all other types have size 1
                return 1;
            }
        }
    }

    /// @brief returns the maximum possible number of elements
    /// @sa https://json.nlohmann.me/api/basic_json/max_size/
    size_type max_size() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::array:
            {
                // delegate call to array_t::max_size()
                return m_data.m_value.array->max_size();
            }

            case value_t::object:
            {
                // delegate call to object_t::max_size()
                return m_data.m_value.object->max_size();
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // all other types have max_size() == size()
                return size();
            }
        }
    }

    /// @}

    ///////////////
    // modifiers //
    ///////////////

    /// @name modifiers
    /// @{

    /// @brief clears the contents
    /// @sa https://json.nlohmann.me/api/basic_json/clear/
    void clear() noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::number_integer:
            {
                m_data.m_value.number_integer = 0;
                break;
            }

            case value_t::number_unsigned:
            {
                m_data.m_value.number_unsigned = 0;
                break;
            }

            case value_t::number_float:
            {
                m_data.m_value.number_float = 0.0;
                break;
            }

            case value_t::boolean:
            {
                m_data.m_value.boolean = false;
                break;
            }

            case value_t::string:
            {
                m_data.m_value.string->clear();
                break;
            }

            case value_t::binary:
            {
                m_data.m_value.binary->clear();
                break;
            }

            case value_t::array:
            {
                m_data.m_value.array->clear();
                break;
            }

            case value_t::object:
            {
                m_data.m_value.object->clear();
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                break;
        }
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(basic_json&& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
        }

        // transform a null object into an array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value = value_t::array;
            assert_invariant();
        }

        // add the element to the array (move semantics)
        const auto old_capacity = m_data.m_value.array->capacity();
        m_data.m_value.array->push_back(std::move(val));
        set_parent(m_data.m_value.array->back(), old_capacity);
        // if val is moved from, basic_json move constructor marks it null, so we do not call the destructor
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(basic_json&& val)
    {
        push_back(std::move(val));
        return *this;
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(const basic_json& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
        }

        // transform a null object into an array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value = value_t::array;
            assert_invariant();
        }

        // add the element to the array
        const auto old_capacity = m_data.m_value.array->capacity();
        m_data.m_value.array->push_back(val);
        set_parent(m_data.m_value.array->back(), old_capacity);
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(const basic_json& val)
    {
        push_back(val);
        return *this;
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(const typename object_t::value_type& val)
    {
        // push_back only works for null objects or objects
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
        {
            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
        }

        // transform a null object into an object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value = value_t::object;
            assert_invariant();
        }

        // add the element to the object
        auto res = m_data.m_value.object->insert(val);
        set_parent(res.first->second);
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(const typename object_t::value_type& val)
    {
        push_back(val);
        return *this;
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(initializer_list_t init)
    {
        if (is_object() && init.size() == 2 && (*init.begin())->is_string())
        {
            basic_json&& key = init.begin()->moved_or_copied();
            push_back(typename object_t::value_type(
                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
        }
        else
        {
            push_back(basic_json(init));
        }
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(initializer_list_t init)
    {
        push_back(init);
        return *this;
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/emplace_back/
    template<class... Args>
    reference emplace_back(Args&& ... args)
    {
        // emplace_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(311, detail::concat("cannot use emplace_back() with ", type_name()), this));
        }

        // transform a null object into an array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value = value_t::array;
            assert_invariant();
        }

        // add the element to the array (perfect forwarding)
        const auto old_capacity = m_data.m_value.array->capacity();
        m_data.m_value.array->emplace_back(std::forward<Args>(args)...);
        return set_parent(m_data.m_value.array->back(), old_capacity);
    }

    /// @brief add an object to an object if key does not exist
    /// @sa https://json.nlohmann.me/api/basic_json/emplace/
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&& ... args)
    {
        // emplace only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
        {
            JSON_THROW(type_error::create(311, detail::concat("cannot use emplace() with ", type_name()), this));
        }

        // transform a null object into an object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value = value_t::object;
            assert_invariant();
        }

        // add the element to the array (perfect forwarding)
        auto res = m_data.m_value.object->emplace(std::forward<Args>(args)...);
        set_parent(res.first->second);

        // create a result iterator and set iterator to the result of emplace
        auto it = begin();
        it.m_it.object_iterator = res.first;

        // return pair of iterator and boolean
        return {it, res.second};
    }

    /// Helper for insertion of an iterator
    /// @note: This uses std::distance to support GCC 4.8,
    ///        see https://github.com/nlohmann/json/pull/1257
    template<typename... Args>
    iterator insert_iterator(const_iterator pos, Args&& ... args) // NOLINT(performance-unnecessary-value-param)
    {
        iterator result(this);
        JSON_ASSERT(m_data.m_value.array != nullptr);

        auto insert_pos = std::distance(m_data.m_value.array->begin(), pos.m_it.array_iterator);
        m_data.m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
        result.m_it.array_iterator = m_data.m_value.array->begin() + insert_pos;

        // This could have been written as:
        // result.m_it.array_iterator = m_data.m_value.array->insert(pos.m_it.array_iterator, cnt, val);
        // but the return value of insert is missing in GCC 4.8, so it is written this way instead.

        set_parents();
        return result;
    }

    /// @brief inserts element into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, const basic_json& val) // NOLINT(performance-unnecessary-value-param)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
            }

            // insert to array and return iterator
            return insert_iterator(pos, val);
        }

        JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
    }

    /// @brief inserts element into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, basic_json&& val) // NOLINT(performance-unnecessary-value-param)
    {
        return insert(pos, val);
    }

    /// @brief inserts copies of element into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, size_type cnt, const basic_json& val) // NOLINT(performance-unnecessary-value-param)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
            }

            // insert to array and return iterator
            return insert_iterator(pos, cnt, val);
        }

        JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
    }

    /// @brief inserts range of elements into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, const_iterator first, const_iterator last) // NOLINT(performance-unnecessary-value-param)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(!is_array()))
        {
            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
        }

        if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
        {
            JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container", this));
        }

        // insert to array and return iterator
        return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
    }

    /// @brief inserts elements from initializer list into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, initializer_list_t ilist) // NOLINT(performance-unnecessary-value-param)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(!is_array()))
        {
            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
        }

        // insert to array and return iterator
        return insert_iterator(pos, ilist.begin(), ilist.end());
    }

    /// @brief inserts range of elements into object
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    void insert(const_iterator first, const_iterator last) // NOLINT(performance-unnecessary-value-param)
    {
        // insert only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects", this));
        }

        m_data.m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
        set_parents();
    }

    /// @brief updates a JSON object from another object, overwriting existing keys
    /// @sa https://json.nlohmann.me/api/basic_json/update/
    void update(const_reference j, bool merge_objects = false)
    {
        update(j.begin(), j.end(), merge_objects);
    }

    /// @brief updates a JSON object from another object, overwriting existing keys
    /// @sa https://json.nlohmann.me/api/basic_json/update/
    void update(const_iterator first, const_iterator last, bool merge_objects = false) // NOLINT(performance-unnecessary-value-param)
    {
        // implicitly convert a null value to an empty object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(312, detail::concat("cannot use update() with ", type_name()), this));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
        {
            JSON_THROW(type_error::create(312, detail::concat("cannot use update() with ", first.m_object->type_name()), first.m_object));
        }

        for (auto it = first; it != last; ++it)
        {
            if (merge_objects && it.value().is_object())
            {
                auto it2 = m_data.m_value.object->find(it.key());
                if (it2 != m_data.m_value.object->end())
                {
                    it2->second.update(it.value(), true);
                    continue;
                }
            }
            m_data.m_value.object->operator[](it.key()) = it.value();
#if JSON_DIAGNOSTICS
            m_data.m_value.object->operator[](it.key()).m_parent = this;
#endif
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(reference other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&& // NOLINT(cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        std::swap(m_data.m_type, other.m_data.m_type);
        std::swap(m_data.m_value, other.m_data.m_value);

        set_parents();
        other.set_parents();
        assert_invariant();
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    friend void swap(reference left, reference right) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&& // NOLINT(cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        left.swap(right);
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(array_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            using std::swap;
            swap(*(m_data.m_value.array), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(array_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(object_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            using std::swap;
            swap(*(m_data.m_value.object), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(object_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(string_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_string()))
        {
            using std::swap;
            swap(*(m_data.m_value.string), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(string_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(binary_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_binary()))
        {
            using std::swap;
            swap(*(m_data.m_value.binary), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(binary_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(typename binary_t::container_type& other) // NOLINT(bugprone-exception-escape)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_binary()))
        {
            using std::swap;
            swap(*(m_data.m_value.binary), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(binary_t::container_type&) with ", type_name()), this));
        }
    }

    /// @}

    //////////////////////////////////////////
    // lexicographical comparison operators //
    //////////////////////////////////////////

    /// @name lexicographical comparison operators
    /// @{

    // note parentheses around operands are necessary; see
    // https://github.com/nlohmann/json/issues/1530
#define JSON_IMPLEMENT_OPERATOR(op, null_result, unordered_result, default_result)                       \
    const auto lhs_type = lhs.type();                                                                    \
    const auto rhs_type = rhs.type();                                                                    \
    \
    if (lhs_type == rhs_type) /* NOLINT(readability/braces) */                                           \
    {                                                                                                    \
        switch (lhs_type)                                                                                \
        {                                                                                                \
            case value_t::array:                                                                         \
                return (*lhs.m_data.m_value.array) op (*rhs.m_data.m_value.array);                                     \
                \
            case value_t::object:                                                                        \
                return (*lhs.m_data.m_value.object) op (*rhs.m_data.m_value.object);                                   \
                \
            case value_t::null:                                                                          \
                return (null_result);                                                                    \
                \
            case value_t::string:                                                                        \
                return (*lhs.m_data.m_value.string) op (*rhs.m_data.m_value.string);                                   \
                \
            case value_t::boolean:                                                                       \
                return (lhs.m_data.m_value.boolean) op (rhs.m_data.m_value.boolean);                                   \
                \
            case value_t::number_integer:                                                                \
                return (lhs.m_data.m_value.number_integer) op (rhs.m_data.m_value.number_integer);                     \
                \
            case value_t::number_unsigned:                                                               \
                return (lhs.m_data.m_value.number_unsigned) op (rhs.m_data.m_value.number_unsigned);                   \
                \
            case value_t::number_float:                                                                  \
                return (lhs.m_data.m_value.number_float) op (rhs.m_data.m_value.number_float);                         \
                \
            case value_t::binary:                                                                        \
                return (*lhs.m_data.m_value.binary) op (*rhs.m_data.m_value.binary);                                   \
                \
            case value_t::discarded:                                                                     \
            default:                                                                                     \
                return (unordered_result);                                                               \
        }                                                                                                \
    }                                                                                                    \
    else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)                   \
    {                                                                                                    \
        return static_cast<number_float_t>(lhs.m_data.m_value.number_integer) op rhs.m_data.m_value.number_float;      \
    }                                                                                                    \
    else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)                   \
    {                                                                                                    \
        return lhs.m_data.m_value.number_float op static_cast<number_float_t>(rhs.m_data.m_value.number_integer);      \
    }                                                                                                    \
    else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)                  \
    {                                                                                                    \
        return static_cast<number_float_t>(lhs.m_data.m_value.number_unsigned) op rhs.m_data.m_value.number_float;     \
    }                                                                                                    \
    else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)                  \
    {                                                                                                    \
        return lhs.m_data.m_value.number_float op static_cast<number_float_t>(rhs.m_data.m_value.number_unsigned);     \
    }                                                                                                    \
    else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)                \
    {                                                                                                    \
        return static_cast<number_integer_t>(lhs.m_data.m_value.number_unsigned) op rhs.m_data.m_value.number_integer; \
    }                                                                                                    \
    else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)                \
    {                                                                                                    \
        return lhs.m_data.m_value.number_integer op static_cast<number_integer_t>(rhs.m_data.m_value.number_unsigned); \
    }                                                                                                    \
    else if(compares_unordered(lhs, rhs))\
    {\
        return (unordered_result);\
    }\
    \
    return (default_result);

  JSON_PRIVATE_UNLESS_TESTED:
    // returns true if:
    // - any operand is NaN and the other operand is of number type
    // - any operand is discarded
    // in legacy mode, discarded values are considered ordered if
    // an operation is computed as an odd number of inverses of others
    static bool compares_unordered(const_reference lhs, const_reference rhs, bool inverse = false) noexcept
    {
        if ((lhs.is_number_float() && std::isnan(lhs.m_data.m_value.number_float) && rhs.is_number())
                || (rhs.is_number_float() && std::isnan(rhs.m_data.m_value.number_float) && lhs.is_number()))
        {
            return true;
        }
#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
        return (lhs.is_discarded() || rhs.is_discarded()) && !inverse;
#else
        static_cast<void>(inverse);
        return lhs.is_discarded() || rhs.is_discarded();
#endif
    }

  private:
    bool compares_unordered(const_reference rhs, bool inverse = false) const noexcept
    {
        return compares_unordered(*this, rhs, inverse);
    }

  public:
#if JSON_HAS_THREE_WAY_COMPARISON
    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    bool operator==(const_reference rhs) const noexcept
    {
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
        const_reference lhs = *this;
        JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
    }

    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    bool operator==(ScalarType rhs) const noexcept
    {
        return *this == basic_json(rhs);
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    bool operator!=(const_reference rhs) const noexcept
    {
        if (compares_unordered(rhs, true))
        {
            return false;
        }
        return !operator==(rhs);
    }

    /// @brief comparison: 3-way
    /// @sa https://json.nlohmann.me/api/basic_json/operator_spaceship/
    std::partial_ordering operator<=>(const_reference rhs) const noexcept // *NOPAD*
    {
        const_reference lhs = *this;
        // default_result is used if we cannot compare values. In that case,
        // we compare types.
        JSON_IMPLEMENT_OPERATOR(<=>, // *NOPAD*
                                std::partial_ordering::equivalent,
                                std::partial_ordering::unordered,
                                lhs_type <=> rhs_type) // *NOPAD*
    }

    /// @brief comparison: 3-way
    /// @sa https://json.nlohmann.me/api/basic_json/operator_spaceship/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    std::partial_ordering operator<=>(ScalarType rhs) const noexcept // *NOPAD*
    {
        return *this <=> basic_json(rhs); // *NOPAD*
    }

#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    // all operators that are computed as an odd number of inverses of others
    // need to be overloaded to emulate the legacy comparison behavior

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
    bool operator<=(const_reference rhs) const noexcept
    {
        if (compares_unordered(rhs, true))
        {
            return false;
        }
        return !(rhs < *this);
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    bool operator<=(ScalarType rhs) const noexcept
    {
        return *this <= basic_json(rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
    bool operator>=(const_reference rhs) const noexcept
    {
        if (compares_unordered(rhs, true))
        {
            return false;
        }
        return !(*this < rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    bool operator>=(ScalarType rhs) const noexcept
    {
        return *this >= basic_json(rhs);
    }
#endif
#else
    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    friend bool operator==(const_reference lhs, const_reference rhs) noexcept
    {
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
        JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
    }

    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs == basic_json(rhs);
    }

    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) == rhs;
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
    {
        if (compares_unordered(lhs, rhs, true))
        {
            return false;
        }
        return !(lhs == rhs);
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs != basic_json(rhs);
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) != rhs;
    }

    /// @brief comparison: less than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
    friend bool operator<(const_reference lhs, const_reference rhs) noexcept
    {
        // default_result is used if we cannot compare values. In that case,
        // we compare types. Note we have to call the operator explicitly,
        // because MSVC has problems otherwise.
        JSON_IMPLEMENT_OPERATOR( <, false, false, operator<(lhs_type, rhs_type))
    }

    /// @brief comparison: less than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs < basic_json(rhs);
    }

    /// @brief comparison: less than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) < rhs;
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
    {
        if (compares_unordered(lhs, rhs, true))
        {
            return false;
        }
        return !(rhs < lhs);
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs <= basic_json(rhs);
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) <= rhs;
    }

    /// @brief comparison: greater than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
    friend bool operator>(const_reference lhs, const_reference rhs) noexcept
    {
        // double inverse
        if (compares_unordered(lhs, rhs))
        {
            return false;
        }
        return !(lhs <= rhs);
    }

    /// @brief comparison: greater than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs > basic_json(rhs);
    }

    /// @brief comparison: greater than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) > rhs;
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
    {
        if (compares_unordered(lhs, rhs, true))
        {
            return false;
        }
        return !(lhs < rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs >= basic_json(rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) >= rhs;
    }
#endif

#undef JSON_IMPLEMENT_OPERATOR

    /// @}

    ///////////////////
    // serialization //
    ///////////////////

    /// @name serialization
    /// @{
#ifndef JSON_NO_IO
    /// @brief serialize to stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
    {
        // read width member and use it as the indentation parameter if nonzero
        const bool pretty_print = o.width() > 0;
        const auto indentation = pretty_print ? o.width() : 0;

        // reset width to 0 for subsequent calls to this stream
        o.width(0);

        // do the actual serialization
        serializer s(detail::output_adapter<char>(o), o.fill());
        s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
        return o;
    }

    /// @brief serialize to stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
    /// @deprecated This function is deprecated since 3.0.0 and will be removed in
    ///             version 4.0.0 of the library. Please use
    ///             operator<<(std::ostream&, const basic_json&) instead; that is,
    ///             replace calls like `j >> o;` with `o << j;`.
    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator<<(std::ostream&, const basic_json&))
    friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
    {
        return o << j;
    }
#endif  // JSON_NO_IO
    /// @}

    /////////////////////
    // deserialization //
    /////////////////////

    /// @name deserialization
    /// @{

    /// @brief deserialize from a compatible input
    /// @sa https://json.nlohmann.me/api/basic_json/parse/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(InputType&& i,
                            parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(detail::input_adapter(std::forward<InputType>(i)), std::move(cb), allow_exceptions, ignore_comments).parse(true, result); // cppcheck-suppress[accessMoved,accessForwarded]
        return result;
    }

    /// @brief deserialize from a pair of character iterators
    /// @sa https://json.nlohmann.me/api/basic_json/parse/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(IteratorType first,
                            IteratorType last,
                            parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(detail::input_adapter(std::move(first), std::move(last)), std::move(cb), allow_exceptions, ignore_comments).parse(true, result); // cppcheck-suppress[accessMoved]
        return result;
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))
    static basic_json parse(detail::span_input_adapter&& i,
                            parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false)
    {
        basic_json result;
        parser(i.get(), std::move(cb), allow_exceptions, ignore_comments).parse(true, result); // cppcheck-suppress[accessMoved]
        return result;
    }

    /// @brief check if the input is valid JSON
    /// @sa https://json.nlohmann.me/api/basic_json/accept/
    template<typename InputType>
    static bool accept(InputType&& i,
                       const bool ignore_comments = false)
    {
        return parser(detail::input_adapter(std::forward<InputType>(i)), nullptr, false, ignore_comments).accept(true);
    }

    /// @brief check if the input is valid JSON
    /// @sa https://json.nlohmann.me/api/basic_json/accept/
    template<typename IteratorType>
    static bool accept(IteratorType first, IteratorType last,
                       const bool ignore_comments = false)
    {
        return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments).accept(true);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
    static bool accept(detail::span_input_adapter&& i,
                       const bool ignore_comments = false)
    {
        return parser(i.get(), nullptr, false, ignore_comments).accept(true);
    }

    /// @brief generate SAX events
    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
    template <typename InputType, typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(InputType&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
    }

    /// @brief generate SAX events
    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
    template<class IteratorType, class SAX>
    JSON_HEDLEY_NON_NULL(3)
    static bool sax_parse(IteratorType first, IteratorType last, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
    }

    /// @brief generate SAX events
    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
    /// @deprecated This function is deprecated since 3.8.0 and will be removed in
    ///             version 4.0.0 of the library. Please use
    ///             sax_parse(ptr, ptr + len) instead.
    template <typename SAX>
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(detail::span_input_adapter&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false)
    {
        auto ia = i.get();
        return format == input_format_t::json
               // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
               ? parser(std::move(ia), nullptr, true, ignore_comments).sax_parse(sax, strict)
               // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
    }
#ifndef JSON_NO_IO
    /// @brief deserialize from stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gtgt/
    /// @deprecated This stream operator is deprecated since 3.0.0 and will be removed in
    ///             version 4.0.0 of the library. Please use
    ///             operator>>(std::istream&, basic_json&) instead; that is,
    ///             replace calls like `j << i;` with `i >> j;`.
    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator>>(std::istream&, basic_json&))
    friend std::istream& operator<<(basic_json& j, std::istream& i)
    {
        return operator>>(i, j);
    }

    /// @brief deserialize from stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gtgt/
    friend std::istream& operator>>(std::istream& i, basic_json& j)
    {
        parser(detail::input_adapter(i)).parse(false, j);
        return i;
    }
#endif  // JSON_NO_IO
    /// @}

    ///////////////////////////
    // convenience functions //
    ///////////////////////////

    /// @brief return the type as string
    /// @sa https://json.nlohmann.me/api/basic_json/type_name/
    JSON_HEDLEY_RETURNS_NON_NULL
    const char* type_name() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::null:
                return "null";
            case value_t::object:
                return "object";
            case value_t::array:
                return "array";
            case value_t::string:
                return "string";
            case value_t::boolean:
                return "boolean";
            case value_t::binary:
                return "binary";
            case value_t::discarded:
                return "discarded";
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
                return "number";
            default:
                return "invalid";
        }
    }

  JSON_PRIVATE_UNLESS_TESTED:
    //////////////////////
    // member variables //
    //////////////////////

    struct data
    {
        /// the type of the current element
        value_t m_type = value_t::null;

        /// the value of the current element
        json_value m_value = {};

        data(const value_t v)
            : m_type(v), m_value(v)
        {
        }

        data(size_type cnt, const basic_json& val)
            : m_type(value_t::array)
        {
            m_value.array = create<array_t>(cnt, val);
        }

        data() noexcept = default;
        data(data&&) noexcept = default;
        data(const data&) noexcept = delete;
        data& operator=(data&&) noexcept = delete;
        data& operator=(const data&) noexcept = delete;

        ~data() noexcept
        {
            m_value.destroy(m_type);
        }
    };

    data m_data = {};

#if JSON_DIAGNOSTICS
    /// a pointer to a parent value (for debugging purposes)
    basic_json* m_parent = nullptr;
#endif

#if JSON_DIAGNOSTIC_POSITIONS
    /// the start position of the value
    std::size_t start_position = std::string::npos;
    /// the end position of the value
    std::size_t end_position = std::string::npos;
  public:
    constexpr std::size_t start_pos() const noexcept
    {
        return start_position;
    }

    constexpr std::size_t end_pos() const noexcept
    {
        return end_position;
    }
#endif

    //////////////////////////////////////////
    // binary serialization/deserialization //
    //////////////////////////////////////////

    /// @name binary serialization/deserialization support
    /// @{

  public:
    /// @brief create a CBOR serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
    static std::vector<std::uint8_t> to_cbor(const basic_json& j)
    {
        std::vector<std::uint8_t> result;
        to_cbor(j, result);
        return result;
    }

    /// @brief create a CBOR serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
    static void to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o)
    {
        binary_writer<std::uint8_t>(o).write_cbor(j);
    }

    /// @brief create a CBOR serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
    static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_cbor(j);
    }

    /// @brief create a MessagePack serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
    static std::vector<std::uint8_t> to_msgpack(const basic_json& j)
    {
        std::vector<std::uint8_t> result;
        to_msgpack(j, result);
        return result;
    }

    /// @brief create a MessagePack serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
    static void to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o)
    {
        binary_writer<std::uint8_t>(o).write_msgpack(j);
    }

    /// @brief create a MessagePack serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
    static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_msgpack(j);
    }

    /// @brief create a UBJSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
    static std::vector<std::uint8_t> to_ubjson(const basic_json& j,
            const bool use_size = false,
            const bool use_type = false)
    {
        std::vector<std::uint8_t> result;
        to_ubjson(j, result, use_size, use_type);
        return result;
    }

    /// @brief create a UBJSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
    static void to_ubjson(const basic_json& j, detail::output_adapter<std::uint8_t> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type);
    }

    /// @brief create a UBJSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
    static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<char>(o).write_ubjson(j, use_size, use_type);
    }

    /// @brief create a BJData serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
    static std::vector<std::uint8_t> to_bjdata(const basic_json& j,
            const bool use_size = false,
            const bool use_type = false,
            const bjdata_version_t version = bjdata_version_t::draft2)
    {
        std::vector<std::uint8_t> result;
        to_bjdata(j, result, use_size, use_type, version);
        return result;
    }

    /// @brief create a BJData serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
    static void to_bjdata(const basic_json& j, detail::output_adapter<std::uint8_t> o,
                          const bool use_size = false, const bool use_type = false,
                          const bjdata_version_t version = bjdata_version_t::draft2)
    {
        binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type, true, true, version);
    }

    /// @brief create a BJData serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
    static void to_bjdata(const basic_json& j, detail::output_adapter<char> o,
                          const bool use_size = false, const bool use_type = false,
                          const bjdata_version_t version = bjdata_version_t::draft2)
    {
        binary_writer<char>(o).write_ubjson(j, use_size, use_type, true, true, version);
    }

    /// @brief create a BSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
    static std::vector<std::uint8_t> to_bson(const basic_json& j)
    {
        std::vector<std::uint8_t> result;
        to_bson(j, result);
        return result;
    }

    /// @brief create a BSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
    static void to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o)
    {
        binary_writer<std::uint8_t>(o).write_bson(j);
    }

    /// @brief create a BSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
    static void to_bson(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_bson(j);
    }

    /// @brief create a JSON value from an input in CBOR format
    /// @sa https://json.nlohmann.me/api/basic_json/from_cbor/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(InputType&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in CBOR format
    /// @sa https://json.nlohmann.me/api/basic_json/from_cbor/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(IteratorType first, IteratorType last,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
    static basic_json from_cbor(const T* ptr, std::size_t len,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        return from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
    static basic_json from_cbor(detail::span_input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        auto ia = i.get();
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in MessagePack format
    /// @sa https://json.nlohmann.me/api/basic_json/from_msgpack/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(InputType&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in MessagePack format
    /// @sa https://json.nlohmann.me/api/basic_json/from_msgpack/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(IteratorType first, IteratorType last,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
    static basic_json from_msgpack(const T* ptr, std::size_t len,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        return from_msgpack(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
    static basic_json from_msgpack(detail::span_input_adapter&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = i.get();
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in UBJSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_ubjson/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(InputType&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in UBJSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_ubjson/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(IteratorType first, IteratorType last,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
    static basic_json from_ubjson(const T* ptr, std::size_t len,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        return from_ubjson(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
    static basic_json from_ubjson(detail::span_input_adapter&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = i.get();
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BJData format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bjdata/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bjdata(InputType&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BJData format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bjdata/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bjdata(IteratorType first, IteratorType last,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bson/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(InputType&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bson/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(IteratorType first, IteratorType last,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
    static basic_json from_bson(const T* ptr, std::size_t len,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        return from_bson(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
    static basic_json from_bson(detail::span_input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = i.get();
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }
    /// @}

    //////////////////////////
    // JSON Pointer support //
    //////////////////////////

    /// @name JSON Pointer functions
    /// @{

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    reference operator[](const json_pointer& ptr)
    {
        return ptr.get_unchecked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    reference operator[](const ::nlohmann::json_pointer<BasicJsonType>& ptr)
    {
        return ptr.get_unchecked(this);
    }

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    const_reference operator[](const json_pointer& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    const_reference operator[](const ::nlohmann::json_pointer<BasicJsonType>& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    reference at(const json_pointer& ptr)
    {
        return ptr.get_checked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    reference at(const ::nlohmann::json_pointer<BasicJsonType>& ptr)
    {
        return ptr.get_checked(this);
    }

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    const_reference at(const json_pointer& ptr) const
    {
        return ptr.get_checked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    const_reference at(const ::nlohmann::json_pointer<BasicJsonType>& ptr) const
    {
        return ptr.get_checked(this);
    }

    /// @brief return flattened JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/flatten/
    basic_json flatten() const
    {
        basic_json result(value_t::object);
        json_pointer::flatten("", *this, result);
        return result;
    }

    /// @brief unflatten a previously flattened JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/unflatten/
    basic_json unflatten() const
    {
        return json_pointer::unflatten(*this);
    }

    /// @}

    //////////////////////////
    // JSON Patch functions //
    //////////////////////////

    /// @name JSON Patch functions
    /// @{

    /// @brief applies a JSON patch in-place without copying the object
    /// @sa https://json.nlohmann.me/api/basic_json/patch/
    void patch_inplace(const basic_json& json_patch)
    {
        basic_json& result = *this;
        // the valid JSON Patch operations
        enum class patch_operations {add, remove, replace, move, copy, test, invalid};

        const auto get_op = [](const string_t& op)
        {
            if (op == "add")
            {
                return patch_operations::add;
            }
            if (op == "remove")
            {
                return patch_operations::remove;
            }
            if (op == "replace")
            {
                return patch_operations::replace;
            }
            if (op == "move")
            {
                return patch_operations::move;
            }
            if (op == "copy")
            {
                return patch_operations::copy;
            }
            if (op == "test")
            {
                return patch_operations::test;
            }

            return patch_operations::invalid;
        };

        // wrapper for "add" operation; add value at ptr
        const auto operation_add = [&result](json_pointer & ptr, const basic_json & val)
        {
            // adding to the root of the target document means replacing it
            if (ptr.empty())
            {
                result = val;
                return;
            }

            // make sure the top element of the pointer exists
            json_pointer const top_pointer = ptr.top();
            if (top_pointer != ptr)
            {
                result.at(top_pointer);
            }

            // get reference to the parent of the JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            // parent must exist when performing patch add per RFC6902 specs
            basic_json& parent = result.at(ptr);

            switch (parent.m_data.m_type)
            {
                case value_t::null:
                case value_t::object:
                {
                    // use operator[] to add value
                    parent[last_path] = val;
                    break;
                }

                case value_t::array:
                {
                    if (last_path == "-")
                    {
                        // special case: append to back
                        parent.push_back(val);
                    }
                    else
                    {
                        const auto idx = json_pointer::template array_index<basic_json_t>(last_path);
                        if (JSON_HEDLEY_UNLIKELY(idx > parent.size()))
                        {
                            // avoid undefined behavior
                            JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), &parent));
                        }

                        // default case: insert add offset
                        parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
                    }
                    break;
                }

                // if there exists a parent, it cannot be primitive
                case value_t::string: // LCOV_EXCL_LINE
                case value_t::boolean: // LCOV_EXCL_LINE
                case value_t::number_integer: // LCOV_EXCL_LINE
                case value_t::number_unsigned: // LCOV_EXCL_LINE
                case value_t::number_float: // LCOV_EXCL_LINE
                case value_t::binary: // LCOV_EXCL_LINE
                case value_t::discarded: // LCOV_EXCL_LINE
                default:            // LCOV_EXCL_LINE
                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
            }
        };

        // wrapper for "remove" operation; remove value at ptr
        const auto operation_remove = [this, & result](json_pointer & ptr)
        {
            // get reference to the parent of the JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result.at(ptr);

            // remove child
            if (parent.is_object())
            {
                // perform range check
                auto it = parent.find(last_path);
                if (JSON_HEDLEY_LIKELY(it != parent.end()))
                {
                    parent.erase(it);
                }
                else
                {
                    JSON_THROW(out_of_range::create(403, detail::concat("key '", last_path, "' not found"), this));
                }
            }
            else if (parent.is_array())
            {
                // note erase performs range check
                parent.erase(json_pointer::template array_index<basic_json_t>(last_path));
            }
        };

        // type check: top level value must be an array
        if (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))
        {
            JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", &json_patch));
        }

        // iterate and apply the operations
        for (const auto& val : json_patch)
        {
            // wrapper to get a value for an operation
            const auto get_value = [&val](const string_t& op,
                                          const string_t& member,
                                          bool string_type) -> basic_json &
            {
                // find value
                auto it = val.m_data.m_value.object->find(member);

                // context-sensitive error message
                const auto error_msg = (op == "op") ? "operation" : detail::concat("operation '", op, '\''); // NOLINT(bugprone-unused-local-non-trivial-variable)

                // check if the desired value is present
                if (JSON_HEDLEY_UNLIKELY(it == val.m_data.m_value.object->end()))
                {
                    // NOLINTNEXTLINE(performance-inefficient-string-concatenation)
                    JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, " must have member '", member, "'"), &val));
                }

                // check if the result is of type string
                if (JSON_HEDLEY_UNLIKELY(string_type && !it->second.is_string()))
                {
                    // NOLINTNEXTLINE(performance-inefficient-string-concatenation)
                    JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, " must have string member '", member, "'"), &val));
                }

                // no error: return value
                return it->second;
            };

            // type check: every element of the array must be an object
            if (JSON_HEDLEY_UNLIKELY(!val.is_object()))
            {
                JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", &val));
            }

            // collect mandatory members
            const auto op = get_value("op", "op", true).template get<string_t>();
            const auto path = get_value(op, "path", true).template get<string_t>();
            json_pointer ptr(path);

            switch (get_op(op))
            {
                case patch_operations::add:
                {
                    operation_add(ptr, get_value("add", "value", false));
                    break;
                }

                case patch_operations::remove:
                {
                    operation_remove(ptr);
                    break;
                }

                case patch_operations::replace:
                {
                    // the "path" location must exist - use at()
                    result.at(ptr) = get_value("replace", "value", false);
                    break;
                }

                case patch_operations::move:
                {
                    const auto from_path = get_value("move", "from", true).template get<string_t>();
                    json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json const v = result.at(from_ptr);

                    // The move operation is functionally identical to a
                    // "remove" operation on the "from" location, followed
                    // immediately by an "add" operation at the target
                    // location with the value that was just removed.
                    operation_remove(from_ptr);
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::copy:
                {
                    const auto from_path = get_value("copy", "from", true).template get<string_t>();
                    const json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json const v = result.at(from_ptr);

                    // The copy is functionally identical to an "add"
                    // operation at the target location using the value
                    // specified in the "from" member.
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::test:
                {
                    bool success = false;
                    JSON_TRY
                    {
                        // check if "value" matches the one at "path"
                        // the "path" location must exist - use at()
                        success = (result.at(ptr) == get_value("test", "value", false));
                    }
                    JSON_INTERNAL_CATCH (out_of_range&)
                    {
                        // ignore out of range errors: success remains false
                    }

                    // throw an exception if the test fails
                    if (JSON_HEDLEY_UNLIKELY(!success))
                    {
                        JSON_THROW(other_error::create(501, detail::concat("unsuccessful: ", val.dump()), &val));
                    }

                    break;
                }

                case patch_operations::invalid:
                default:
                {
                    // op must be "add", "remove", "replace", "move", "copy", or
                    // "test"
                    JSON_THROW(parse_error::create(105, 0, detail::concat("operation value '", op, "' is invalid"), &val));
                }
            }
        }
    }

    /// @brief applies a JSON patch to a copy of the current object
    /// @sa https://json.nlohmann.me/api/basic_json/patch/
    basic_json patch(const basic_json& json_patch) const
    {
        basic_json result = *this;
        result.patch_inplace(json_patch);
        return result;
    }

    /// @brief creates a diff as a JSON patch
    /// @sa https://json.nlohmann.me/api/basic_json/diff/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json diff(const basic_json& source, const basic_json& target,
                           const string_t& path = "")
    {
        // the patch
        basic_json result(value_t::array);

        // if the values are the same, return an empty patch
        if (source == target)
        {
            return result;
        }

        if (source.type() != target.type())
        {
            // different types: replace value
            result.push_back(
            {
                {"op", "replace"}, {"path", path}, {"value", target}
            });
            return result;
        }

        switch (source.type())
        {
            case value_t::array:
            {
                // first pass: traverse common elements
                std::size_t i = 0;
                while (i < source.size() && i < target.size())
                {
                    // recursive call to compare array values at index i
                    auto temp_diff = diff(source[i], target[i], detail::concat<string_t>(path, '/', detail::to_string<string_t>(i)));
                    result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    ++i;
                }

                // We now reached the end of at least one array
                // in a second pass, traverse the remaining elements

                // remove my remaining elements
                const auto end_index = static_cast<difference_type>(result.size());
                while (i < source.size())
                {
                    // add operations in reverse order to avoid invalid
                    // indices
                    result.insert(result.begin() + end_index, object(
                    {
                        {"op", "remove"},
                        {"path", detail::concat<string_t>(path, '/', detail::to_string<string_t>(i))}
                    }));
                    ++i;
                }

                // add other remaining elements
                while (i < target.size())
                {
                    result.push_back(
                    {
                        {"op", "add"},
                        {"path", detail::concat<string_t>(path, "/-")},
                        {"value", target[i]}
                    });
                    ++i;
                }

                break;
            }

            case value_t::object:
            {
                // first pass: traverse this object's elements
                for (auto it = source.cbegin(); it != source.cend(); ++it)
                {
                    // escape the key name to be used in a JSON patch
                    const auto path_key = detail::concat<string_t>(path, '/', detail::escape(it.key()));

                    if (target.find(it.key()) != target.end())
                    {
                        // recursive call to compare object values at key it
                        auto temp_diff = diff(it.value(), target[it.key()], path_key);
                        result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    }
                    else
                    {
                        // found a key that is not in o -> remove it
                        result.push_back(object(
                        {
                            {"op", "remove"}, {"path", path_key}
                        }));
                    }
                }

                // second pass: traverse other object's elements
                for (auto it = target.cbegin(); it != target.cend(); ++it)
                {
                    if (source.find(it.key()) == source.end())
                    {
                        // found a key that is not in this -> add it
                        const auto path_key = detail::concat<string_t>(path, '/', detail::escape(it.key()));
                        result.push_back(
                        {
                            {"op", "add"}, {"path", path_key},
                            {"value", it.value()}
                        });
                    }
                }

                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // both primitive types: replace value
                result.push_back(
                {
                    {"op", "replace"}, {"path", path}, {"value", target}
                });
                break;
            }
        }

        return result;
    }
    /// @}

    ////////////////////////////////
    // JSON Merge Patch functions //
    ////////////////////////////////

    /// @name JSON Merge Patch functions
    /// @{

    /// @brief applies a JSON Merge Patch
    /// @sa https://json.nlohmann.me/api/basic_json/merge_patch/
    void merge_patch(const basic_json& apply_patch)
    {
        if (apply_patch.is_object())
        {
            if (!is_object())
            {
                *this = object();
            }
            for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
            {
                if (it.value().is_null())
                {
                    erase(it.key());
                }
                else
                {
                    operator[](it.key()).merge_patch(it.value());
                }
            }
        }
        else
        {
            *this = apply_patch;
        }
    }

    /// @}
};

/// @brief user-defined to_string function for JSON values
/// @sa https://json.nlohmann.me/api/basic_json/to_string/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
std::string to_string(const NLOHMANN_BASIC_JSON_TPL& j)
{
    return j.dump();
}

inline namespace literals
{
inline namespace json_literals
{

/// @brief user-defined string literal for JSON values
/// @sa https://json.nlohmann.me/api/basic_json/operator_literal_json/
JSON_HEDLEY_NON_NULL(1)
#if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
    inline nlohmann::json operator ""_json(const char* s, std::size_t n)
#else
    inline nlohmann::json operator "" _json(const char* s, std::size_t n)
#endif
{
    return nlohmann::json::parse(s, s + n);
}

/// @brief user-defined string literal for JSON pointer
/// @sa https://json.nlohmann.me/api/basic_json/operator_literal_json_pointer/
JSON_HEDLEY_NON_NULL(1)
#if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
    inline nlohmann::json::json_pointer operator ""_json_pointer(const char* s, std::size_t n)
#else
    inline nlohmann::json::json_pointer operator "" _json_pointer(const char* s, std::size_t n)
#endif
{
    return nlohmann::json::json_pointer(std::string(s, n));
}

}  // namespace json_literals
}  // namespace literals
NLOHMANN_JSON_NAMESPACE_END

///////////////////////
// nonmember support //
///////////////////////

namespace std // NOLINT(cert-dcl58-cpp)
{

/// @brief hash value for JSON objects
/// @sa https://json.nlohmann.me/api/basic_json/std_hash/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct hash<nlohmann::NLOHMANN_BASIC_JSON_TPL> // NOLINT(cert-dcl58-cpp)
{
    std::size_t operator()(const nlohmann::NLOHMANN_BASIC_JSON_TPL& j) const
    {
        return nlohmann::detail::hash(j);
    }
};

// specialization for std::less<value_t>
template<>
struct less< ::nlohmann::detail::value_t> // do not remove the space after '<', see https://github.com/nlohmann/json/pull/679
{
    /*!
    @brief compare two value_t enum values
    @since version 3.0.0
    */
    bool operator()(::nlohmann::detail::value_t lhs,
                    ::nlohmann::detail::value_t rhs) const noexcept
    {
#if JSON_HAS_THREE_WAY_COMPARISON
        return std::is_lt(lhs <=> rhs); // *NOPAD*
#else
        return ::nlohmann::detail::operator<(lhs, rhs);
#endif
    }
};

// C++20 prohibit function specialization in the std namespace.
#ifndef JSON_HAS_CPP_20

/// @brief exchanges the values of two JSON objects
/// @sa https://json.nlohmann.me/api/basic_json/std_swap/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
inline void swap(nlohmann::NLOHMANN_BASIC_JSON_TPL& j1, nlohmann::NLOHMANN_BASIC_JSON_TPL& j2) noexcept(  // NOLINT(readability-inconsistent-declaration-parameter-name, cert-dcl58-cpp)
    is_nothrow_move_constructible<nlohmann::NLOHMANN_BASIC_JSON_TPL>::value&&                          // NOLINT(misc-redundant-expression,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    is_nothrow_move_assignable<nlohmann::NLOHMANN_BASIC_JSON_TPL>::value)
{
    j1.swap(j2);
}

#endif

}  // namespace std

#if JSON_USE_GLOBAL_UDLS
    #if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
        using nlohmann::literals::json_literals::operator ""_json; // NOLINT(misc-unused-using-decls,google-global-names-in-headers)
        using nlohmann::literals::json_literals::operator ""_json_pointer; //NOLINT(misc-unused-using-decls,google-global-names-in-headers)
    #else
        using nlohmann::literals::json_literals::operator "" _json; // NOLINT(misc-unused-using-decls,google-global-names-in-headers)
        using nlohmann::literals::json_literals::operator "" _json_pointer; //NOLINT(misc-unused-using-decls,google-global-names-in-headers)
    #endif
#endif

// #include <nlohmann/detail/macro_unscope.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// restore clang diagnostic settings
#if defined(__clang__)
    #pragma clang diagnostic pop
#endif

// clean up
#undef JSON_ASSERT
#undef JSON_INTERNAL_CATCH
#undef JSON_THROW
#undef JSON_PRIVATE_UNLESS_TESTED
#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
#undef NLOHMANN_BASIC_JSON_TPL
#undef JSON_EXPLICIT
#undef NLOHMANN_CAN_CALL_STD_FUNC_IMPL
#undef JSON_INLINE_VARIABLE
#undef JSON_NO_UNIQUE_ADDRESS
#undef JSON_DISABLE_ENUM_SERIALIZATION
#undef JSON_USE_GLOBAL_UDLS

#ifndef JSON_TEST_KEEP_MACROS
    #undef JSON_CATCH
    #undef JSON_TRY
    #undef JSON_HAS_CPP_11
    #undef JSON_HAS_CPP_14
    #undef JSON_HAS_CPP_17
    #undef JSON_HAS_CPP_20
    #undef JSON_HAS_CPP_23
    #undef JSON_HAS_CPP_26
    #undef JSON_HAS_FILESYSTEM
    #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
    #undef JSON_HAS_THREE_WAY_COMPARISON
    #undef JSON_HAS_RANGES
    #undef JSON_HAS_STATIC_RTTI
    #undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
#endif

// #include <nlohmann/thirdparty/hedley/hedley_undef.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013 - 2025 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#undef JSON_HEDLEY_ALWAYS_INLINE
#undef JSON_HEDLEY_ARM_VERSION
#undef JSON_HEDLEY_ARM_VERSION_CHECK
#undef JSON_HEDLEY_ARRAY_PARAM
#undef JSON_HEDLEY_ASSUME
#undef JSON_HEDLEY_BEGIN_C_DECLS
#undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#undef JSON_HEDLEY_CLANG_HAS_FEATURE
#undef JSON_HEDLEY_CLANG_HAS_WARNING
#undef JSON_HEDLEY_COMPCERT_VERSION
#undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#undef JSON_HEDLEY_CONCAT
#undef JSON_HEDLEY_CONCAT3
#undef JSON_HEDLEY_CONCAT3_EX
#undef JSON_HEDLEY_CONCAT_EX
#undef JSON_HEDLEY_CONST
#undef JSON_HEDLEY_CONSTEXPR
#undef JSON_HEDLEY_CONST_CAST
#undef JSON_HEDLEY_CPP_CAST
#undef JSON_HEDLEY_CRAY_VERSION
#undef JSON_HEDLEY_CRAY_VERSION_CHECK
#undef JSON_HEDLEY_C_DECL
#undef JSON_HEDLEY_DEPRECATED
#undef JSON_HEDLEY_DEPRECATED_FOR
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
#undef JSON_HEDLEY_DIAGNOSTIC_POP
#undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#undef JSON_HEDLEY_DMC_VERSION
#undef JSON_HEDLEY_DMC_VERSION_CHECK
#undef JSON_HEDLEY_EMPTY_BASES
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#undef JSON_HEDLEY_END_C_DECLS
#undef JSON_HEDLEY_FLAGS
#undef JSON_HEDLEY_FLAGS_CAST
#undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_BUILTIN
#undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_EXTENSION
#undef JSON_HEDLEY_GCC_HAS_FEATURE
#undef JSON_HEDLEY_GCC_HAS_WARNING
#undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#undef JSON_HEDLEY_GCC_VERSION
#undef JSON_HEDLEY_GCC_VERSION_CHECK
#undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#undef JSON_HEDLEY_GNUC_HAS_FEATURE
#undef JSON_HEDLEY_GNUC_HAS_WARNING
#undef JSON_HEDLEY_GNUC_VERSION
#undef JSON_HEDLEY_GNUC_VERSION_CHECK
#undef JSON_HEDLEY_HAS_ATTRIBUTE
#undef JSON_HEDLEY_HAS_BUILTIN
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
#undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_HAS_EXTENSION
#undef JSON_HEDLEY_HAS_FEATURE
#undef JSON_HEDLEY_HAS_WARNING
#undef JSON_HEDLEY_IAR_VERSION
#undef JSON_HEDLEY_IAR_VERSION_CHECK
#undef JSON_HEDLEY_IBM_VERSION
#undef JSON_HEDLEY_IBM_VERSION_CHECK
#undef JSON_HEDLEY_IMPORT
#undef JSON_HEDLEY_INLINE
#undef JSON_HEDLEY_INTEL_CL_VERSION
#undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
#undef JSON_HEDLEY_INTEL_VERSION
#undef JSON_HEDLEY_INTEL_VERSION_CHECK
#undef JSON_HEDLEY_IS_CONSTANT
#undef JSON_HEDLEY_IS_CONSTEXPR_
#undef JSON_HEDLEY_LIKELY
#undef JSON_HEDLEY_MALLOC
#undef JSON_HEDLEY_MCST_LCC_VERSION
#undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
#undef JSON_HEDLEY_MESSAGE
#undef JSON_HEDLEY_MSVC_VERSION
#undef JSON_HEDLEY_MSVC_VERSION_CHECK
#undef JSON_HEDLEY_NEVER_INLINE
#undef JSON_HEDLEY_NON_NULL
#undef JSON_HEDLEY_NO_ESCAPE
#undef JSON_HEDLEY_NO_RETURN
#undef JSON_HEDLEY_NO_THROW
#undef JSON_HEDLEY_NULL
#undef JSON_HEDLEY_PELLES_VERSION
#undef JSON_HEDLEY_PELLES_VERSION_CHECK
#undef JSON_HEDLEY_PGI_VERSION
#undef JSON_HEDLEY_PGI_VERSION_CHECK
#undef JSON_HEDLEY_PREDICT
#undef JSON_HEDLEY_PRINTF_FORMAT
#undef JSON_HEDLEY_PRIVATE
#undef JSON_HEDLEY_PUBLIC
#undef JSON_HEDLEY_PURE
#undef JSON_HEDLEY_REINTERPRET_CAST
#undef JSON_HEDLEY_REQUIRE
#undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#undef JSON_HEDLEY_REQUIRE_MSG
#undef JSON_HEDLEY_RESTRICT
#undef JSON_HEDLEY_RETURNS_NON_NULL
#undef JSON_HEDLEY_SENTINEL
#undef JSON_HEDLEY_STATIC_ASSERT
#undef JSON_HEDLEY_STATIC_CAST
#undef JSON_HEDLEY_STRINGIFY
#undef JSON_HEDLEY_STRINGIFY_EX
#undef JSON_HEDLEY_SUNPRO_VERSION
#undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#undef JSON_HEDLEY_TINYC_VERSION
#undef JSON_HEDLEY_TINYC_VERSION_CHECK
#undef JSON_HEDLEY_TI_ARMCL_VERSION
#undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL2000_VERSION
#undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL430_VERSION
#undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL6X_VERSION
#undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL7X_VERSION
#undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
#undef JSON_HEDLEY_TI_CLPRU_VERSION
#undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
#undef JSON_HEDLEY_TI_VERSION
#undef JSON_HEDLEY_TI_VERSION_CHECK
#undef JSON_HEDLEY_UNAVAILABLE
#undef JSON_HEDLEY_UNLIKELY
#undef JSON_HEDLEY_UNPREDICTABLE
#undef JSON_HEDLEY_UNREACHABLE
#undef JSON_HEDLEY_UNREACHABLE_RETURN
#undef JSON_HEDLEY_VERSION
#undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#undef JSON_HEDLEY_VERSION_DECODE_MINOR
#undef JSON_HEDLEY_VERSION_DECODE_REVISION
#undef JSON_HEDLEY_VERSION_ENCODE
#undef JSON_HEDLEY_WARNING
#undef JSON_HEDLEY_WARN_UNUSED_RESULT
#undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
#undef JSON_HEDLEY_FALL_THROUGH



#endif  // INCLUDE_NLOHMANN_JSON_HPP_


============================================================
File Path: project/main.cpp
============================================================
#include "MyGame.h"

//Windowsã‚¢ãƒ—ãƒªã§ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ(mainé–¢æ•°)
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int) {
	Framework* game = new MyGame();

	game->Run();

	delete game;

	return 0;
}

